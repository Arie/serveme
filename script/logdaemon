#!/usr/bin/env ruby
# frozen_string_literal: true

require File.expand_path('../config/boot', __dir__)
require 'socket'
require 'sidekiq'
require 'active_support'
require 'active_support/core_ext'
require 'tf2_line_parser'
require File.expand_path('../app/helpers/log_line_helper', __dir__)
require File.expand_path('../app/workers/log_worker', __dir__)
require File.expand_path('../app/workers/log_batch_worker', __dir__)

STREAMING_LOG_DIR = File.expand_path('../log/streaming', __dir__)

class LogHandler
  include LogLineHelper

  def initialize(streaming_log_dir)
    @streaming_log_dir = streaming_log_dir
    @batch = []
    @batch_mutex = Mutex.new
    @last_flush = Time.now
    @listener_cache = {}
    @listener_cache_mutex = Mutex.new
    start_batch_flusher
  end

  def process_data(data)
    log_line = data.force_encoding('UTF-8').scrub[5..]
    matches = log_line.match(LogWorker::LOG_LINE_REGEX)
    secret = matches[:secret] if matches

    if interesting_line?(log_line)
      if actionable_line?(log_line) || has_listeners?(secret)
        @batch_mutex.synchronize do
          @batch << log_line.to_s
          flush_batch if @batch.size >= 20
        end
      end
    end

    # Write to log files immediately (unbatched)
    write_log(secret, matches[:line]) if matches && matches[:line] && secret.present?
  end

  def has_listeners?(secret)
    return false unless secret.present?

    @listener_cache_mutex.synchronize do
      cached = @listener_cache[secret]
      if cached && (Time.now - cached[:time]) < 2
        return cached[:value]
      end

      value = Sidekiq.redis { |r| r.call("EXISTS", "log_listeners:#{secret}") > 0 }
      @listener_cache[secret] = { value: value, time: Time.now }
      value
    end
  end

  def flush_batch
    return if @batch.empty?

    LogBatchWorker.perform_async(@batch.dup)

    @batch.clear
    @last_flush = Time.now
  end

  def start_batch_flusher
    # Background thread that flushes every 100ms even if batch isn't full
    Thread.new do
      loop do
        sleep 0.1
        @batch_mutex.synchronize { flush_batch }
      rescue => e
        warn "Batch flusher error: #{e.message}"
      end
    end
  end

  def write_log(secret, line)
    return unless secret =~ /^\d+$/

    File.open(File.join(@streaming_log_dir, "#{secret}.log"), 'a') do |f|
      f.puts line
    end
  end
end

FileUtils.mkdir_p(STREAMING_LOG_DIR)

# Check for systemd socket activation
listen_fds = ENV.fetch('LISTEN_FDS', 0).to_i
listen_pid = ENV.fetch('LISTEN_PID', 0).to_i

if listen_fds > 0 && listen_pid == Process.pid
  # Systemd socket activation: FD 3 is the first passed socket
  # EventMachine doesn't support attaching existing UDP sockets,
  # so we use plain Ruby sockets instead
  puts "Using systemd socket activation (#{listen_fds} socket(s) passed)"

  socket = UDPSocket.for_fd(3)
  handler = LogHandler.new(STREAMING_LOG_DIR)

  # Handle SIGTERM gracefully for systemd stop/restart
  running = true
  Signal.trap('TERM') { running = false }
  Signal.trap('INT') { running = false }

  while running
    begin
      # Use IO.select with timeout to allow signal handling
      ready = IO.select([ socket ], nil, nil, 1)
      next unless ready

      data, = socket.recvfrom_nonblock(65535)
      handler.process_data(data)
    rescue IO::WaitReadable
      # No data available, continue loop
    rescue => e
      warn "Error processing log line: #{e.message}"
      warn e.backtrace.first(5).join("\n")
    end
  end

  puts "Shutting down gracefully"
else
  # Fallback for development/manual usage - use EventMachine
  require 'eventmachine'
  require 'optparse'

  # Store handler in a constant so EMHandler can access it
  LOG_HANDLER = LogHandler.new(STREAMING_LOG_DIR)

  class EMHandler < EM::Connection
    def receive_data(data)
      LOG_HANDLER.process_data(data)
    end
  end

  options = { ip: '0.0.0.0', port: 40001 }
  OptionParser.new do |opts|
    opts.banner = "Usage: #{$PROGRAM_NAME} [options]"
    opts.on('-i', '--ip IP', 'IP to bind to') { |ip| options[:ip] = ip }
    opts.on('-p', '--port PORT', Integer, 'Port to bind to') { |port| options[:port] = port }
  end.parse!

  puts "Listening on #{options[:ip]}:#{options[:port]}..."

  EM.run do
    EM.open_datagram_socket(options[:ip], options[:port], EMHandler)
  end
end
