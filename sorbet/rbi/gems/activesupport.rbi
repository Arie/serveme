# This file is autogenerated. Do not edit it by hand. Regenerate it with:
#   srb rbi gems

# typed: false
#
# If you would like to make changes to this file, great! Please create the gem's shim here:
#
#   https://github.com/sorbet/sorbet-typed/new/master?filename=lib/activesupport/all/activesupport.rbi
#
# activesupport-7.2.0

module ActiveSupport
  def parse_json_times; end
  def parse_json_times=(val); end
  def self.cache_format_version; end
  def self.cache_format_version=(value); end
  def self.deprecator; end
  def self.eager_load!; end
  def self.error_reporter; end
  def self.error_reporter=(arg0); end
  def self.escape_html_entities_in_json(*, **, &); end
  def self.escape_html_entities_in_json=(arg); end
  def self.gem_version; end
  def self.json_encoder(*, **, &); end
  def self.json_encoder=(arg); end
  def self.parse_json_times; end
  def self.parse_json_times=(val); end
  def self.test_order; end
  def self.test_order=(val); end
  def self.test_parallelization_threshold; end
  def self.test_parallelization_threshold=(val); end
  def self.time_precision(*, **, &); end
  def self.time_precision=(arg); end
  def self.to_time_preserves_timezone; end
  def self.to_time_preserves_timezone=(value); end
  def self.use_standard_json_time_format(*, **, &); end
  def self.use_standard_json_time_format=(arg); end
  def self.utc_to_local_returns_utc_offset_times; end
  def self.utc_to_local_returns_utc_offset_times=(value); end
  def self.version; end
  def test_order; end
  def test_order=(val); end
  def test_parallelization_threshold; end
  def test_parallelization_threshold=(val); end
  extend ActiveSupport::Autoload
  extend ActiveSupport::LazyLoadHooks
end
module ActiveSupport::DeepMergeable
  def deep_merge!(other, &block); end
  def deep_merge(other, &block); end
  def deep_merge?(other); end
end
class Hash
  def _deep_transform_keys_in_object!(object, &block); end
  def _deep_transform_keys_in_object(object, &block); end
  def _deep_transform_values_in_object!(object, &block); end
  def _deep_transform_values_in_object(object, &block); end
  def as_json(options = nil); end
  def assert_valid_keys(*valid_keys); end
  def blank?; end
  def compact_blank!; end
  def compact_blank; end
  def deep_dup; end
  def deep_merge?(other); end
  def deep_stringify_keys!; end
  def deep_stringify_keys; end
  def deep_symbolize_keys!; end
  def deep_symbolize_keys; end
  def deep_transform_keys!(&block); end
  def deep_transform_keys(&block); end
  def deep_transform_values!(&block); end
  def deep_transform_values(&block); end
  def except!(*keys); end
  def extract!(*keys); end
  def extractable_options?; end
  def nested_under_indifferent_access; end
  def present?; end
  def reverse_merge!(other_hash); end
  def reverse_merge(other_hash); end
  def reverse_update(other_hash); end
  def self.[](*arg0); end
  def self.ruby2_keywords_hash?(arg0); end
  def slice!(*keys); end
  def stringify_keys!; end
  def stringify_keys; end
  def symbolize_keys!; end
  def symbolize_keys; end
  def to_options!; end
  def to_options; end
  def to_param(namespace = nil); end
  def to_query(namespace = nil); end
  def to_xml(options = nil); end
  def with_defaults!(other_hash); end
  def with_defaults(other_hash); end
  def with_indifferent_access; end
  include ActiveSupport::DeepMergeable
  include ActiveSupport::ToJsonWithActiveSupportEncoder
end
module ActiveSupport::LazyLoadHooks
  def execute_hook(name, base, options, block); end
  def on_load(name, options = nil, &block); end
  def run_load_hooks(name, base = nil); end
  def self.extended(base); end
  def with_execution_control(name, block, once); end
end
module ActiveSupport::Inflector
  def apply_inflections(word, rules, locale = nil); end
  def camelize(term, uppercase_first_letter = nil); end
  def classify(table_name); end
  def const_regexp(camel_cased_word); end
  def constantize(camel_cased_word); end
  def dasherize(underscored_word); end
  def deconstantize(path); end
  def demodulize(path); end
  def downcase_first(string); end
  def foreign_key(class_name, separate_class_name_and_id_with_underscore = nil); end
  def humanize(lower_case_and_underscored_word, capitalize: nil, keep_id_suffix: nil); end
  def inflections(locale = nil); end
  def ordinal(number); end
  def ordinalize(number); end
  def parameterize(string, separator: nil, preserve_case: nil, locale: nil); end
  def pluralize(word, locale = nil); end
  def safe_constantize(camel_cased_word); end
  def singularize(word, locale = nil); end
  def tableize(class_name); end
  def titleize(word, keep_id_suffix: nil); end
  def transliterate(string, replacement = nil, locale: nil); end
  def underscore(camel_cased_word); end
  def upcase_first(string); end
  extend ActiveSupport::Inflector
  extend ActiveSupport::Inflector
end
class ActiveSupport::Inflector::Inflections
  def acronym(word); end
  def acronyms; end
  def acronyms_camelize_regex; end
  def acronyms_underscore_regex; end
  def clear(scope = nil); end
  def define_acronym_regex_patterns; end
  def human(rule, replacement); end
  def humans; end
  def initialize; end
  def initialize_dup(orig); end
  def irregular(singular, plural); end
  def plural(rule, replacement); end
  def plurals; end
  def self.instance(locale = nil); end
  def self.instance_or_fallback(locale); end
  def singular(rule, replacement); end
  def singulars; end
  def uncountable(*words); end
  def uncountables; end
end
class ActiveSupport::Inflector::Inflections::Uncountables < Array
  def <<(*word); end
  def add(words); end
  def delete(entry); end
  def initialize; end
  def to_regex(string); end
  def uncountable?(str); end
end
module ActiveSupport::Autoload
  def autoload(const_name, path = nil); end
  def autoload_at(path); end
  def autoload_under(path); end
  def eager_autoload; end
  def eager_load!; end
end
module ActiveSupport::VERSION
end
module ActiveSupport::Concern
  def append_features(base); end
  def class_methods(&class_methods_module_definition); end
  def included(base = nil, &block); end
  def prepend_features(base); end
  def prepended(base = nil, &block); end
  def self.extended(base); end
end
class ActiveSupport::Concern::MultipleIncludedBlocks < StandardError
  def initialize; end
end
class ActiveSupport::Concern::MultiplePrependBlocks < StandardError
  def initialize; end
end
class Module
  def alias_attribute(new_name, old_name); end
  def anonymous?; end
  def as_json(options = nil); end
  def attr_internal(*attrs); end
  def attr_internal_accessor(*attrs); end
  def attr_internal_define(attr_name, type); end
  def attr_internal_reader(*attrs); end
  def attr_internal_writer(*attrs); end
  def cattr_accessor(*syms, instance_reader: nil, instance_writer: nil, instance_accessor: nil, default: nil, &blk); end
  def cattr_reader(*syms, instance_reader: nil, instance_accessor: nil, default: nil, location: nil); end
  def cattr_writer(*syms, instance_writer: nil, instance_accessor: nil, default: nil, location: nil); end
  def deep_dup; end
  def delegate(*methods, to: nil, prefix: nil, allow_nil: nil, private: nil); end
  def delegate_missing_to(target, allow_nil: nil); end
  def deprecate(*method_names, deprecator:, **options); end
  def mattr_accessor(*syms, instance_reader: nil, instance_writer: nil, instance_accessor: nil, default: nil, &blk); end
  def mattr_reader(*syms, instance_reader: nil, instance_accessor: nil, default: nil, location: nil); end
  def mattr_writer(*syms, instance_writer: nil, instance_accessor: nil, default: nil, location: nil); end
  def method_visibility(method); end
  def module_parent; end
  def module_parent_name; end
  def module_parents; end
  def redefine_method(method, &block); end
  def redefine_singleton_method(method, &block); end
  def remove_possible_method(method); end
  def remove_possible_singleton_method(method); end
  def self.attr_internal_naming_format; end
  def self.attr_internal_naming_format=(format); end
  def silence_redefinition_of_method(method); end
  def thread_cattr_accessor(*syms, instance_reader: nil, instance_writer: nil, instance_accessor: nil, default: nil); end
  def thread_cattr_reader(*syms, instance_reader: nil, instance_accessor: nil, default: nil); end
  def thread_cattr_writer(*syms, instance_writer: nil, instance_accessor: nil); end
  def thread_mattr_accessor(*syms, instance_reader: nil, instance_writer: nil, instance_accessor: nil, default: nil); end
  def thread_mattr_reader(*syms, instance_reader: nil, instance_accessor: nil, default: nil); end
  def thread_mattr_writer(*syms, instance_writer: nil, instance_accessor: nil); end
  include Module::Concerning
end
module ActiveSupport::LoggerThreadSafeLevel
  def level; end
  def local_level; end
  def local_level=(level); end
  def local_level_key; end
  def log_at(level); end
  extend ActiveSupport::Concern
end
module ActiveSupport::LoggerSilence
  def silence(severity = nil); end
  extend ActiveSupport::Concern
end
class ActiveSupport::Logger < Logger
  def initialize(*args, **kwargs); end
  def self.logger_outputs_to?(logger, *sources); end
  def self.normalize_sources(sources); end
  def self.silencer; end
  def self.silencer=(val); end
  def silencer; end
  def silencer=(val); end
  include ActiveSupport::LoggerSilence
  include ActiveSupport::LoggerThreadSafeLevel
end
class ActiveSupport::Logger::SimpleFormatter < Logger::Formatter
  def call(severity, time, _progname, msg); end
end
class ActiveSupport::BroadcastLogger
  def <<(message); end
  def add(*args, &block); end
  def broadcast_to(*loggers); end
  def broadcasts; end
  def close; end
  def debug!; end
  def debug(*args, &block); end
  def debug?; end
  def dispatch(&block); end
  def error!; end
  def error(*args, &block); end
  def error?; end
  def fatal!; end
  def fatal(*args, &block); end
  def fatal?; end
  def formatter; end
  def formatter=(formatter); end
  def info!; end
  def info(*args, &block); end
  def info?; end
  def initialize(*loggers); end
  def initialize_copy(other); end
  def level; end
  def level=(level); end
  def local_level=(level); end
  def log(*args, &block); end
  def method_missing(name, *, **, &); end
  def progname; end
  def progname=(arg0); end
  def respond_to_missing?(method, include_all); end
  def self.silencer; end
  def self.silencer=(val); end
  def sev_threshold=(level); end
  def silencer; end
  def silencer=(val); end
  def stop_broadcasting_to(logger); end
  def unknown(*args, &block); end
  def warn!; end
  def warn(*args, &block); end
  def warn?; end
  include ActiveSupport::LoggerSilence
  include ActiveSupport::LoggerThreadSafeLevel
end
module DateAndTime
end
module DateAndTime::Compatibility
  def preserve_timezone; end
  def self.preserve_timezone; end
  def self.preserve_timezone=(val); end
  def self.utc_to_local_returns_utc_offset_times; end
  def self.utc_to_local_returns_utc_offset_times=(val); end
  def utc_to_local_returns_utc_offset_times; end
end
class ActiveSupport::ErrorReporter
  def debug_mode; end
  def debug_mode=(arg0); end
  def disable(subscriber); end
  def handle(*error_classes, severity: nil, context: nil, fallback: nil, source: nil); end
  def initialize(*subscribers, logger: nil); end
  def logger; end
  def logger=(arg0); end
  def record(*error_classes, severity: nil, context: nil, source: nil); end
  def report(error, handled: nil, severity: nil, context: nil, source: nil); end
  def set_context(*, **, &); end
  def subscribe(subscriber); end
  def unexpected(error, severity: nil, context: nil, source: nil); end
  def unsubscribe(subscriber); end
end
class ActiveSupport::ErrorReporter::UnexpectedError < Exception
end
module Kernel
  def class_eval(*args, &block); end
  def concern(topic, &module_definition); end
  def enable_warnings(&block); end
  def self.concern(topic, &module_definition); end
  def self.enable_warnings(&block); end
  def self.silence_warnings(&block); end
  def self.suppress(*exception_classes); end
  def self.with_warnings(flag); end
  def silence_warnings(&block); end
  def suppress(*exception_classes); end
  def with_warnings(flag); end
end
class ActiveSupport::DelegationError < NoMethodError
  def self.nil_target(method_name, target); end
end
module ActiveSupport::Delegation
  def self.generate(owner, methods, location: nil, to: nil, prefix: nil, allow_nil: nil, nilable: nil, private: nil, as: nil, signature: nil); end
  def self.generate_method_missing(owner, target, allow_nil: nil); end
end
class Array
  def as_json(options = nil); end
  def blank?; end
  def compact_blank!; end
  def deep_dup; end
  def excluding(*elements); end
  def extract!; end
  def extract_options!; end
  def fifth; end
  def forty_two; end
  def fourth; end
  def from(position); end
  def in_groups(number, fill_with = nil, &block); end
  def in_groups_of(number, fill_with = nil, &block); end
  def including(*elements); end
  def inquiry; end
  def present?; end
  def second; end
  def second_to_last; end
  def self.[](*arg0); end
  def split(value = nil, &block); end
  def third; end
  def third_to_last; end
  def to(position); end
  def to_formatted_s(format = nil); end
  def to_fs(format = nil); end
  def to_param; end
  def to_query(key); end
  def to_sentence(options = nil); end
  def to_xml(options = nil); end
  def without(*elements); end
  include ActiveSupport::ToJsonWithActiveSupportEncoder
end
class Object < BasicObject
  def acts_like?(duck); end
  def as_json(options = nil); end
  def blank?; end
  def deep_dup; end
  def duplicable?; end
  def html_safe?; end
  def in?(another_object); end
  def instance_values; end
  def instance_variable_names; end
  def presence; end
  def presence_in(another_object); end
  def present?; end
  def to_param; end
  def to_query(key); end
  def with(**attributes); end
  def with_options(options, &block); end
  include ActiveSupport::ToJsonWithActiveSupportEncoder
  include ActiveSupport::Tryable
end
class NilClass
  def as_json(options = nil); end
  def blank?; end
  def present?; end
  def to_param; end
  def try!(*); end
  def try(*); end
  include ActiveSupport::ToJsonWithActiveSupportEncoder
end
class FalseClass
  def as_json(options = nil); end
  def blank?; end
  def present?; end
  def to_param; end
  include ActiveSupport::ToJsonWithActiveSupportEncoder
end
class TrueClass
  def as_json(options = nil); end
  def blank?; end
  def present?; end
  def to_param; end
  include ActiveSupport::ToJsonWithActiveSupportEncoder
end
class Symbol
  def as_json(options = nil); end
  def blank?; end
  def ends_with?(*arg0); end
  def present?; end
  def starts_with?(*arg0); end
end
class String
  def acts_like_string?; end
  def as_json(options = nil); end
  def at(position); end
  def blank?; end
  def camelcase(first_letter = nil); end
  def camelize(first_letter = nil); end
  def classify; end
  def constantize; end
  def dasherize; end
  def deconstantize; end
  def demodulize; end
  def downcase_first; end
  def ends_with?(*arg0); end
  def exclude?(string); end
  def first(limit = nil); end
  def foreign_key(separate_class_name_and_id_with_underscore = nil); end
  def from(position); end
  def html_safe; end
  def humanize(capitalize: nil, keep_id_suffix: nil); end
  def in_time_zone(zone = nil); end
  def indent!(amount, indent_string = nil, indent_empty_lines = nil); end
  def indent(amount, indent_string = nil, indent_empty_lines = nil); end
  def inquiry; end
  def is_utf8?; end
  def last(limit = nil); end
  def mb_chars; end
  def parameterize(separator: nil, preserve_case: nil, locale: nil); end
  def pluralize(count = nil, locale = nil); end
  def present?; end
  def remove!(*patterns); end
  def remove(*patterns); end
  def safe_constantize; end
  def singularize(locale = nil); end
  def squish!; end
  def squish; end
  def starts_with?(*arg0); end
  def strip_heredoc; end
  def tableize; end
  def titlecase(keep_id_suffix: nil); end
  def titleize(keep_id_suffix: nil); end
  def to(position); end
  def to_date; end
  def to_datetime; end
  def to_time(form = nil); end
  def truncate(truncate_to, options = nil); end
  def truncate_bytes(truncate_to, omission: nil); end
  def truncate_words(words_count, options = nil); end
  def underscore; end
  def upcase_first; end
  include ActiveSupport::ToJsonWithActiveSupportEncoder
end
class Numeric
  def as_json(options = nil); end
  def blank?; end
  def byte; end
  def bytes; end
  def day; end
  def days; end
  def exabyte; end
  def exabytes; end
  def fortnight; end
  def fortnights; end
  def gigabyte; end
  def gigabytes; end
  def hour; end
  def hours; end
  def html_safe?; end
  def in_milliseconds; end
  def kilobyte; end
  def kilobytes; end
  def megabyte; end
  def megabytes; end
  def minute; end
  def minutes; end
  def petabyte; end
  def petabytes; end
  def present?; end
  def second; end
  def seconds; end
  def terabyte; end
  def terabytes; end
  def week; end
  def weeks; end
  def zettabyte; end
  def zettabytes; end
end
class Time
  def active_support_local_zone; end
  def acts_like_time?; end
  def advance(options); end
  def ago(seconds); end
  def as_json(options = nil); end
  def at_beginning_of_day; end
  def at_beginning_of_hour; end
  def at_beginning_of_minute; end
  def at_end_of_day; end
  def at_end_of_hour; end
  def at_end_of_minute; end
  def at_midday; end
  def at_middle_of_day; end
  def at_midnight; end
  def at_noon; end
  def beginning_of_day; end
  def beginning_of_hour; end
  def beginning_of_minute; end
  def blank?; end
  def change(options); end
  def compare_with_coercion(other); end
  def compare_without_coercion(arg0); end
  def end_of_day; end
  def end_of_hour; end
  def end_of_minute; end
  def eql_with_coercion(other); end
  def eql_without_coercion(arg0); end
  def formatted_offset(colon = nil, alternate_utc_string = nil); end
  def in(seconds); end
  def midday; end
  def middle_of_day; end
  def midnight; end
  def minus_with_coercion(other); end
  def minus_with_duration(other); end
  def minus_without_coercion(other); end
  def minus_without_duration(arg0); end
  def next_day(days = nil); end
  def next_month(months = nil); end
  def next_year(years = nil); end
  def noon; end
  def plus_with_duration(other); end
  def plus_without_duration(arg0); end
  def present?; end
  def preserve_timezone; end
  def prev_day(days = nil); end
  def prev_month(months = nil); end
  def prev_year(years = nil); end
  def rfc3339(fraction_digits = nil); end
  def sec_fraction; end
  def seconds_since_midnight; end
  def seconds_until_end_of_day; end
  def self.===(other); end
  def self.at_with_coercion(time_or_number, *args, **); end
  def self.at_without_coercion(time, subsec = nil, unit = nil, in: nil); end
  def self.current; end
  def self.days_in_month(month, year = nil); end
  def self.days_in_year(year = nil); end
  def self.find_zone!(time_zone); end
  def self.find_zone(time_zone); end
  def self.rfc3339(str); end
  def self.use_zone(time_zone); end
  def self.zone; end
  def self.zone=(time_zone); end
  def self.zone_default; end
  def self.zone_default=(arg0); end
  def since(seconds); end
  def to_formatted_s(format = nil); end
  def to_fs(format = nil); end
  include DateAndTime::Calculations
  include DateAndTime::Compatibility
  include DateAndTime::Zones
end
class ActiveSupport::KeyGenerator
  def generate_key(salt, key_size = nil); end
  def initialize(secret, options = nil); end
  def inspect; end
  def self.hash_digest_class; end
  def self.hash_digest_class=(klass); end
end
class ActiveSupport::CachingKeyGenerator
  def generate_key(*args); end
  def initialize(key_generator); end
end
module ActiveSupport::Messages
end
class ActiveSupport::Messages::RotationCoordinator
  def [](salt); end
  def []=(salt, codec); end
  def build(salt, secret_generator:, secret_generator_options:, **options); end
  def build_with_rotations(salt); end
  def changing_configuration!; end
  def clear_rotations; end
  def initialize(&secret_generator); end
  def normalize_options(options); end
  def on_rotation(&callback); end
  def rotate(**options, &block); end
  def rotate_defaults; end
  def transitional; end
  def transitional=(arg0); end
end
class ActiveSupport::MessageVerifiers < ActiveSupport::Messages::RotationCoordinator
  def build(salt, secret_generator:, secret_generator_options:, **options); end
end
module ActiveSupport::Notifications
  def self.instrument(name, payload = nil); end
  def self.instrumenter; end
  def self.monotonic_subscribe(pattern = nil, callback = nil, &block); end
  def self.notifier; end
  def self.notifier=(arg0); end
  def self.publish(name, *args); end
  def self.publish_event(event); end
  def self.registry; end
  def self.subscribe(pattern = nil, callback = nil, &block); end
  def self.subscribed(callback, pattern = nil, monotonic: nil, &block); end
  def self.unsubscribe(subscriber_or_name); end
end
class ActiveSupport::Notifications::Instrumenter
  def build_handle(name, payload); end
  def finish(name, payload); end
  def finish_with_state(listeners_state, name, payload); end
  def id; end
  def initialize(notifier); end
  def instrument(name, payload = nil); end
  def new_event(name, payload = nil); end
  def start(name, payload); end
  def unique_id; end
end
class ActiveSupport::Notifications::Instrumenter::LegacyHandle
  def finish; end
  def initialize(notifier, name, id, payload); end
  def start; end
end
class ActiveSupport::Notifications::Instrumenter::LegacyHandle::Wrapper
  def build_handle(name, id, payload); end
  def finish(*, **, &); end
  def initialize(notifier); end
  def start(*, **, &); end
end
class ActiveSupport::Notifications::Event
  def allocations; end
  def cpu_time; end
  def duration; end
  def end; end
  def finish!; end
  def gc_time; end
  def idle_time; end
  def initialize(name, start, ending, transaction_id, payload); end
  def name; end
  def now; end
  def now_allocations; end
  def now_cpu; end
  def now_gc; end
  def payload; end
  def payload=(arg0); end
  def record; end
  def start!; end
  def time; end
  def transaction_id; end
end
module ActiveSupport::Tryable
  def try!(*args, **, &block); end
  def try(*args, **, &block); end
end
class Delegator < BasicObject
  include ActiveSupport::Tryable
end
class ActiveSupport::Notifications::InstrumentationSubscriberError < RuntimeError
  def exceptions; end
  def initialize(exceptions); end
end
module ActiveSupport::Notifications::FanoutIteration
  def iterate_guarding_exceptions(collection); end
end
class ActiveSupport::Notifications::Fanout
  def all_listeners_for(name); end
  def build_handle(name, id, payload); end
  def clear_cache(key = nil); end
  def finish(name, id, payload, listeners = nil); end
  def groups_for(name); end
  def initialize; end
  def inspect; end
  def listeners_for(name); end
  def listening?(name); end
  def publish(name, *args); end
  def publish_event(event); end
  def start(name, id, payload); end
  def subscribe(pattern = nil, callable = nil, monotonic: nil, &block); end
  def unsubscribe(subscriber_or_name); end
  def wait; end
  include ActiveSupport::Notifications::FanoutIteration
end
class ActiveSupport::Notifications::Fanout::BaseGroup
  def each(&block); end
  def initialize(listeners, name, id, payload); end
  include ActiveSupport::Notifications::FanoutIteration
end
class ActiveSupport::Notifications::Fanout::BaseTimeGroup < ActiveSupport::Notifications::Fanout::BaseGroup
  def finish(name, id, payload); end
  def start(name, id, payload); end
end
class ActiveSupport::Notifications::Fanout::MonotonicTimedGroup < ActiveSupport::Notifications::Fanout::BaseTimeGroup
  def now; end
end
class ActiveSupport::Notifications::Fanout::TimedGroup < ActiveSupport::Notifications::Fanout::BaseTimeGroup
  def now; end
end
class ActiveSupport::Notifications::Fanout::EventedGroup < ActiveSupport::Notifications::Fanout::BaseGroup
  def finish(name, id, payload); end
  def start(name, id, payload); end
end
class ActiveSupport::Notifications::Fanout::EventObjectGroup < ActiveSupport::Notifications::Fanout::BaseGroup
  def build_event(name, id, payload); end
  def finish(name, id, payload); end
  def start(name, id, payload); end
end
class ActiveSupport::Notifications::Fanout::Handle
  def ensure_state!(expected); end
  def finish; end
  def finish_with_values(name, id, payload); end
  def initialize(notifier, name, id, payload); end
  def start; end
  include ActiveSupport::Notifications::FanoutIteration
end
module ActiveSupport::Notifications::Fanout::Subscribers
  def self.new(pattern, listener, monotonic); end
end
class ActiveSupport::Notifications::Fanout::Subscribers::Matcher
  def ===(name); end
  def exclusions; end
  def initialize(pattern); end
  def pattern; end
  def self.wrap(pattern); end
  def unsubscribe!(name); end
end
class ActiveSupport::Notifications::Fanout::Subscribers::Matcher::AllMessages
  def ===(name); end
  def unsubscribe!(*); end
end
class ActiveSupport::Notifications::Fanout::Subscribers::Evented
  def delegate; end
  def group_class; end
  def initialize(pattern, delegate); end
  def pattern; end
  def publish(name, *args); end
  def publish_event(event); end
  def silenceable; end
  def silenced?(name); end
  def subscribed_to?(name); end
  def unsubscribe!(name); end
end
class ActiveSupport::Notifications::Fanout::Subscribers::Timed < ActiveSupport::Notifications::Fanout::Subscribers::Evented
  def group_class; end
  def publish(name, *args); end
end
class ActiveSupport::Notifications::Fanout::Subscribers::MonotonicTimed < ActiveSupport::Notifications::Fanout::Subscribers::Timed
  def group_class; end
end
class ActiveSupport::Notifications::Fanout::Subscribers::EventObject < ActiveSupport::Notifications::Fanout::Subscribers::Evented
  def group_class; end
  def publish_event(event); end
end
class ActiveSupport::DeprecationException < StandardError
end
class ActiveSupport::Deprecation
  def deprecation_horizon; end
  def deprecation_horizon=(arg0); end
  def initialize(deprecation_horizon = nil, gem_name = nil); end
  def self._instance; end
  include ActiveSupport::Deprecation::Behavior
  include ActiveSupport::Deprecation::Disallowed
  include ActiveSupport::Deprecation::MethodWrapper
  include ActiveSupport::Deprecation::Reporting
end
module ActiveSupport::Deprecation::Behavior
  def arity_coerce(behavior); end
  def arity_of_callable(callable); end
  def behavior; end
  def behavior=(behavior); end
  def debug; end
  def debug=(arg0); end
  def disallowed_behavior; end
  def disallowed_behavior=(behavior); end
end
module ActiveSupport::Deprecation::Reporting
  def _extract_callstack(callstack); end
  def allow(allowed_warnings = nil, if: nil, &block); end
  def begin_silence; end
  def deprecated_method_warning(method_name, message = nil); end
  def deprecation_caller_message(callstack); end
  def deprecation_message(callstack, message = nil); end
  def deprecation_warning(deprecated_method_name, message = nil, caller_backtrace = nil); end
  def end_silence; end
  def extract_callstack(callstack); end
  def gem_name; end
  def gem_name=(arg0); end
  def ignored_callstack?(path); end
  def silence(&block); end
  def silenced; end
  def silenced=(arg0); end
  def warn(message = nil, callstack = nil); end
end
module ActiveSupport::Deprecation::Disallowed
  def deprecation_disallowed?(message); end
  def disallowed_warnings; end
  def disallowed_warnings=(arg0); end
  def explicitly_allowed?(message); end
end
module ActiveSupport::Deprecation::DeprecatedConstantAccessor
  def self.included(base); end
end
module ActiveSupport::Deprecation::MethodWrapper
  def deprecate_methods(target_module, *method_names); end
end
class ActiveSupport::Deprecation::DeprecationProxy
  def inspect; end
  def method_missing(called, *args, &block); end
  def self.new(*args, **kwargs, &block); end
end
class ActiveSupport::Deprecation::DeprecatedObjectProxy < ActiveSupport::Deprecation::DeprecationProxy
  def initialize(object, message, deprecator); end
  def target; end
  def warn(callstack, called, args); end
end
class ActiveSupport::Deprecation::DeprecatedInstanceVariableProxy < ActiveSupport::Deprecation::DeprecationProxy
  def initialize(instance, method, var = nil, deprecator:); end
  def target; end
  def warn(callstack, called, args); end
end
class ActiveSupport::Deprecation::DeprecatedConstantProxy < Module
  def append_features(base); end
  def class; end
  def const_missing(name); end
  def extended(base); end
  def hash(*, **, &); end
  def initialize(old_const, new_const, deprecator, message: nil); end
  def inspect; end
  def instance_methods(*, **, &); end
  def method_missing(*, **, &); end
  def name(*, **, &); end
  def prepend_features(base); end
  def respond_to?(*, **, &); end
  def self.new(*args, **options, &block); end
  def target; end
end
class ActiveSupport::Deprecation::Deprecators
  def [](name); end
  def []=(name, deprecator); end
  def apply_options(deprecator); end
  def behavior=(behavior); end
  def debug=(debug); end
  def disallowed_behavior=(disallowed_behavior); end
  def disallowed_warnings=(disallowed_warnings); end
  def each(&block); end
  def initialize; end
  def set_option(name, value); end
  def silence(&block); end
  def silenced=(silenced); end
end
class Class < Module
  def class_attribute(*attrs, instance_accessor: nil, instance_reader: nil, instance_writer: nil, instance_predicate: nil, default: nil); end
  def descendants; end
end
module ActiveSupport::JSON
  def self.convert_dates_from(data); end
  def self.decode(json); end
  def self.dump(value, options = nil); end
  def self.encode(value, options = nil); end
  def self.load(json); end
  def self.parse_error; end
end
module ActiveSupport::BigDecimalWithDefaultFormat
  def to_s(format = nil); end
end
class ActiveSupport::TimeZone
  def <=>(zone); end
  def =~(re); end
  def at(*args); end
  def encode_with(coder); end
  def formatted_offset(colon = nil, alternate_utc_string = nil); end
  def init_with(coder); end
  def initialize(name, utc_offset = nil, tzinfo = nil); end
  def iso8601(str); end
  def local(*args); end
  def local_to_utc(time, dst = nil); end
  def match?(re); end
  def name; end
  def now; end
  def parse(str, now = nil); end
  def parts_to_time(parts, now); end
  def period_for_local(time, dst = nil); end
  def period_for_utc(time); end
  def periods_for_local(time); end
  def rfc3339(str); end
  def self.[](arg); end
  def self.all; end
  def self.clear; end
  def self.country_zones(country_code); end
  def self.create(*, **); end
  def self.find_tzinfo(name); end
  def self.load_country_zones(code); end
  def self.new(name); end
  def self.seconds_to_utc_offset(seconds, colon = nil); end
  def self.us_zones; end
  def self.zones_map; end
  def strptime(str, format, now = nil); end
  def time_now; end
  def to_s; end
  def today; end
  def tomorrow; end
  def tzinfo; end
  def utc_offset; end
  def utc_to_local(time); end
  def yesterday; end
  include Comparable
end
class DateTime < Date
  def <=>(other); end
  def acts_like_date?; end
  def acts_like_time?; end
  def advance(options); end
  def ago(seconds); end
  def as_json(options = nil); end
  def at_beginning_of_day; end
  def at_beginning_of_hour; end
  def at_beginning_of_minute; end
  def at_end_of_day; end
  def at_end_of_hour; end
  def at_end_of_minute; end
  def at_midday; end
  def at_middle_of_day; end
  def at_midnight; end
  def at_noon; end
  def beginning_of_day; end
  def beginning_of_hour; end
  def beginning_of_minute; end
  def blank?; end
  def change(options); end
  def default_inspect; end
  def end_of_day; end
  def end_of_hour; end
  def end_of_minute; end
  def formatted_offset(colon = nil, alternate_utc_string = nil); end
  def getgm; end
  def getlocal(utc_offset = nil); end
  def getutc; end
  def gmtime; end
  def in(seconds); end
  def inspect; end
  def localtime(utc_offset = nil); end
  def midday; end
  def middle_of_day; end
  def midnight; end
  def noon; end
  def nsec; end
  def offset_in_seconds; end
  def present?; end
  def readable_inspect; end
  def seconds_since_midnight; end
  def seconds_since_unix_epoch; end
  def seconds_until_end_of_day; end
  def self.civil_from_format(utc_or_local, year, month = nil, day = nil, hour = nil, min = nil, sec = nil); end
  def self.current; end
  def since(seconds); end
  def subsec; end
  def to_f; end
  def to_formatted_s(format = nil); end
  def to_fs(format = nil); end
  def to_i; end
  def usec; end
  def utc; end
  def utc?; end
  def utc_offset; end
  include DateAndTime::Compatibility
end
module DateAndTime::Zones
  def in_time_zone(zone = nil); end
  def time_with_zone(time, zone); end
end
class Date
  def acts_like_date?; end
  def advance(options); end
  def ago(seconds); end
  def as_json(options = nil); end
  def at_beginning_of_day; end
  def at_end_of_day; end
  def at_midday; end
  def at_middle_of_day; end
  def at_midnight; end
  def at_noon; end
  def beginning_of_day; end
  def blank?; end
  def change(options); end
  def compare_with_coercion(other); end
  def compare_without_coercion(arg0); end
  def default_inspect; end
  def end_of_day; end
  def in(seconds); end
  def midday; end
  def middle_of_day; end
  def midnight; end
  def minus_with_duration(other); end
  def minus_without_duration(arg0); end
  def noon; end
  def plus_with_duration(other); end
  def plus_without_duration(arg0); end
  def present?; end
  def readable_inspect; end
  def self.beginning_of_week; end
  def self.beginning_of_week=(week_start); end
  def self.beginning_of_week_default; end
  def self.beginning_of_week_default=(arg0); end
  def self.current; end
  def self.find_beginning_of_week!(week_start); end
  def self.tomorrow; end
  def self.yesterday; end
  def since(seconds); end
  def to_formatted_s(format = nil); end
  def to_fs(format = nil); end
  include DateAndTime::Calculations
  include DateAndTime::Zones
end
module ActiveSupport::ToJsonWithActiveSupportEncoder
  def to_json(options = nil); end
end
class Integer < Numeric
  def month; end
  def months; end
  def multiple_of?(number); end
  def ordinal; end
  def ordinalize; end
  def year; end
  def years; end
  include ActiveSupport::NumericWithFormat
  include ActiveSupport::ToJsonWithActiveSupportEncoder
end
class Float < Numeric
  def as_json(options = nil); end
  include ActiveSupport::NumericWithFormat
  include ActiveSupport::ToJsonWithActiveSupportEncoder
end
module Enumerable
  def as_json(options = nil); end
  def compact_blank; end
  def exclude?(object); end
  def excluding(*elements); end
  def in_order_of(key, series); end
  def including(*elements); end
  def index_by; end
  def index_with(default = nil); end
  def many?; end
  def maximum(key); end
  def minimum(key); end
  def pick(*keys); end
  def pluck(*keys); end
  def sole; end
  def without(*elements); end
  include ActiveSupport::ToJsonWithActiveSupportEncoder
end
class Data
  def as_json(options = nil); end
end
class Struct
  def as_json(options = nil); end
end
class BigDecimal < Numeric
  def as_json(options = nil); end
  include ActiveSupport::NumericWithFormat
end
class Regexp
  def as_json(options = nil); end
  def multiline?; end
end
class IO
  def as_json(options = nil); end
end
class Range
  def as_json(options = nil); end
  def overlaps?(arg0); end
  def sum(initial_value = nil); end
end
class URI::Generic
  def as_json(options = nil); end
end
class Pathname
  def as_json(options = nil); end
  def blank?; end
  def existence; end
  def present?; end
end
class IPAddr
  def as_json(options = nil); end
end
class Process::Status
  def as_json(options = nil); end
end
class Exception
  def as_json(options = nil); end
end
module ActiveSupport::JSON::Encoding
  def self.escape_html_entities_in_json; end
  def self.escape_html_entities_in_json=(arg0); end
  def self.json_encoder; end
  def self.json_encoder=(arg0); end
  def self.time_precision; end
  def self.time_precision=(arg0); end
  def self.use_standard_json_time_format; end
  def self.use_standard_json_time_format=(arg0); end
end
class ActiveSupport::JSON::Encoding::JSONGemEncoder
  def encode(value); end
  def initialize(options = nil); end
  def jsonify(value); end
  def options; end
  def stringify(jsonified); end
end
module ActiveSupport::Messages::SerializerWithFallback
  def detect_format(dumped); end
  def fallback?(format); end
  def load(dumped); end
  def self.[](format); end
end
module ActiveSupport::Messages::SerializerWithFallback::AllowMarshal
  def fallback?(format); end
end
module ActiveSupport::Messages::SerializerWithFallback::MarshalWithFallback
  def _load(dumped); end
  def dump(object); end
  def dumped?(dumped); end
  def format; end
  extend ActiveSupport::Messages::SerializerWithFallback::MarshalWithFallback
  include ActiveSupport::Messages::SerializerWithFallback
end
module ActiveSupport::Messages::SerializerWithFallback::JsonWithFallback
  def _load(dumped); end
  def detect_format(dumped); end
  def dump(object); end
  def dumped?(dumped); end
  def format; end
  extend ActiveSupport::Messages::SerializerWithFallback::JsonWithFallback
  include ActiveSupport::Messages::SerializerWithFallback
end
module ActiveSupport::Messages::SerializerWithFallback::JsonWithFallbackAllowMarshal
  extend ActiveSupport::Messages::SerializerWithFallback::JsonWithFallbackAllowMarshal
  include ActiveSupport::Messages::SerializerWithFallback::AllowMarshal
  include ActiveSupport::Messages::SerializerWithFallback::JsonWithFallback
end
module ActiveSupport::Messages::SerializerWithFallback::MessagePackWithFallback
  def _load(dumped); end
  def available?; end
  def dump(object); end
  def dumped?(dumped); end
  def format; end
  extend ActiveSupport::Messages::SerializerWithFallback::MessagePackWithFallback
  include ActiveSupport::Messages::SerializerWithFallback
end
module ActiveSupport::Messages::SerializerWithFallback::MessagePackWithFallbackAllowMarshal
  extend ActiveSupport::Messages::SerializerWithFallback::MessagePackWithFallbackAllowMarshal
  include ActiveSupport::Messages::SerializerWithFallback::AllowMarshal
  include ActiveSupport::Messages::SerializerWithFallback::MessagePackWithFallback
end
module ActiveSupport::Messages::Metadata
  def deserialize_from_json(serialized); end
  def deserialize_from_json_safe_string(string); end
  def deserialize_with_metadata(message, **expected_metadata); end
  def dual_serialized_metadata_envelope_json?(string); end
  def extract_from_metadata_envelope(envelope, purpose: nil); end
  def metadata_envelope?(object); end
  def parse_expiry(expires_at); end
  def pick_expiry(expires_at, expires_in); end
  def self.use_message_serializer_for_metadata; end
  def self.use_message_serializer_for_metadata=(arg0); end
  def serialize_to_json(data); end
  def serialize_to_json_safe_string(data); end
  def serialize_with_metadata(data, **metadata); end
  def use_message_serializer_for_metadata?; end
  def wrap_in_metadata_envelope(hash, expires_at: nil, expires_in: nil, purpose: nil); end
  def wrap_in_metadata_legacy_envelope(hash, expires_at: nil, expires_in: nil, purpose: nil); end
end
class ActiveSupport::Messages::Codec
  def catch_and_ignore(throwable, &block); end
  def catch_and_raise(throwable, as: nil, &block); end
  def decode(encoded, url_safe: nil); end
  def deserialize(serialized); end
  def encode(data, url_safe: nil); end
  def initialize(**options); end
  def self.default_serializer; end
  def self.default_serializer=(value); end
  def serialize(data); end
  def serializer; end
  def use_message_serializer_for_metadata?; end
  include ActiveSupport::Messages::Metadata
end
module ActiveSupport::Messages::Rotator
  def build_rotation(*args, **options); end
  def catch_rotation_error(&block); end
  def fall_back_to(fallback); end
  def initialize(*args, on_rotation: nil, **options); end
  def read_message(message, on_rotation: nil, **options); end
  def rotate(*args, **options); end
end
module ActiveSupport::SecurityUtils
  def fixed_length_secure_compare(a, b); end
  def secure_compare(a, b); end
  def self.fixed_length_secure_compare(a, b); end
  def self.secure_compare(a, b); end
end
class ActiveSupport::MessageVerifier < ActiveSupport::Messages::Codec
  def create_message(value, **options); end
  def digest_length_in_hex; end
  def digest_matches_data?(digest, data); end
  def extract_encoded(signed); end
  def generate(value, **options); end
  def generate_digest(data); end
  def initialize(*args, on_rotation: nil, **options); end
  def inspect; end
  def read_message(message, on_rotation: nil, **options); end
  def separator_at?(signed_message, index); end
  def separator_index_for(signed_message); end
  def sign_encoded(encoded); end
  def valid_message?(message); end
  def verified(message, **options); end
  def verify(message, **options); end
end
class ActiveSupport::MessageVerifier::InvalidSignature < StandardError
end
class ActiveSupport::MessageEncryptor < ActiveSupport::Messages::Codec
  def aead_mode; end
  def aead_mode?; end
  def create_message(value, **options); end
  def decrypt(encrypted_message); end
  def decrypt_and_verify(message, **options); end
  def encrypt(data); end
  def encrypt_and_sign(value, **options); end
  def extract_part(encrypted_message, rindex, length); end
  def extract_parts(encrypted_message); end
  def initialize(*args, on_rotation: nil, **options); end
  def inspect; end
  def join_parts(parts); end
  def length_after_encode(length_before_encode); end
  def length_of_encoded_auth_tag; end
  def length_of_encoded_iv; end
  def new_cipher; end
  def read_message(message, on_rotation: nil, **options); end
  def self.default_cipher; end
  def self.key_len(cipher = nil); end
  def self.use_authenticated_message_encryption; end
  def self.use_authenticated_message_encryption=(val); end
  def sign(data); end
  def verify(data); end
end
module ActiveSupport::MessageEncryptor::NullSerializer
  def self.dump(value); end
  def self.load(value); end
end
class ActiveSupport::MessageEncryptor::InvalidMessage < StandardError
end
class ActiveSupport::EncryptedFile
  def change(&block); end
  def check_key_length; end
  def content_path; end
  def decrypt(contents); end
  def encrypt(contents); end
  def encryptor; end
  def env_key; end
  def handle_missing_key; end
  def initialize(content_path:, key_path:, env_key:, raise_if_missing_key:); end
  def key; end
  def key?; end
  def key_path; end
  def raise_if_missing_key; end
  def read; end
  def read_env_key; end
  def read_key_file; end
  def self.expected_key_length; end
  def self.generate_key; end
  def write(contents); end
  def writing(contents); end
end
class ActiveSupport::EncryptedFile::MissingContentError < RuntimeError
  def initialize(content_path); end
end
class ActiveSupport::EncryptedFile::MissingKeyError < RuntimeError
  def initialize(key_path:, env_key:); end
end
class ActiveSupport::EncryptedFile::InvalidKeyLengthError < RuntimeError
  def initialize; end
end
class ActiveSupport::OrderedOptions < Hash
  def [](key); end
  def []=(key, value); end
  def _get(arg0); end
  def dig(key, *identifiers); end
  def extractable_options?; end
  def inspect; end
  def method_missing(method, *args); end
  def respond_to_missing?(name, include_private); end
end
class ActiveSupport::InheritableOptions < ActiveSupport::OrderedOptions
  def ==(other); end
  def each(&block); end
  def inheritable_copy; end
  def initialize(parent = nil); end
  def inspect; end
  def key?(key); end
  def overridden?(key); end
  def own_key?(arg0); end
  def pretty_print(pp); end
  def to_a; end
  def to_h; end
  def to_s; end
end
class ActiveSupport::EncryptedConfiguration < ActiveSupport::EncryptedFile
  def config; end
  def deep_transform(hash); end
  def deserialize(content); end
  def initialize(config_path:, key_path:, env_key:, raise_if_missing_key:); end
  def inspect; end
  def method_missing(method, *, **, &); end
  def options; end
  def read; end
  def respond_to_missing?(name, include_private = nil); end
  def validate!; end
end
class ActiveSupport::EncryptedConfiguration::InvalidContentError < RuntimeError
  def initialize(content_path); end
  def message; end
end
class ActiveSupport::HashWithIndifferentAccess < Hash
  def [](key); end
  def []=(key, value); end
  def assoc(key); end
  def compact; end
  def convert_key(key); end
  def convert_value(value, conversion: nil); end
  def deep_stringify_keys!; end
  def deep_stringify_keys; end
  def deep_symbolize_keys; end
  def default(key = nil); end
  def delete(key); end
  def dig(*args); end
  def dup; end
  def except(*keys); end
  def extractable_options?; end
  def fetch(key, *extras); end
  def fetch_values(*indices, &block); end
  def has_key?(key); end
  def include?(key); end
  def initialize(constructor = nil); end
  def key?(key); end
  def member?(key); end
  def merge!(*other_hashes, &block); end
  def merge(*hashes, &block); end
  def nested_under_indifferent_access; end
  def regular_update(*arg0); end
  def regular_writer(arg0, arg1); end
  def reject(*args, &block); end
  def replace(other_hash); end
  def reverse_merge!(other_hash); end
  def reverse_merge(other_hash); end
  def select(*args, &block); end
  def self.[](*args); end
  def set_defaults(target); end
  def slice!(*keys); end
  def slice(*keys); end
  def store(key, value); end
  def stringify_keys!; end
  def stringify_keys; end
  def symbolize_keys; end
  def to_hash; end
  def to_options!; end
  def to_options; end
  def to_proc; end
  def transform_keys!(hash = nil, &block); end
  def transform_keys(hash = nil, &block); end
  def transform_values(&block); end
  def update(*other_hashes, &block); end
  def update_with_single_argument(other_hash, block); end
  def values_at(*keys); end
  def with_defaults!(other_hash); end
  def with_defaults(other_hash); end
  def with_indifferent_access; end
  def without(*keys); end
end
class ActiveSupport::ConfigurationFile
  def initialize(content_path); end
  def parse(context: nil, **options); end
  def read(content_path); end
  def render(context); end
  def self.parse(content_path, **options); end
end
class ActiveSupport::ConfigurationFile::FormatError < StandardError
end
module ActiveSupport::DescendantsTracker
  def descendants; end
  def self.clear(classes); end
  def self.descendants(klass); end
  def self.disable_clear!; end
  def self.reject!(classes); end
  def self.subclasses(klass); end
end
class ActiveSupport::DescendantsTracker::WeakSet < ObjectSpace::WeakMap
  def <<(object); end
  def to_a; end
end
module ActiveSupport::DescendantsTracker::ReloadedClassesFiltering
  def descendants; end
  def subclasses; end
end
module ActiveSupport::Multibyte
  def self.proxy_class; end
  def self.proxy_class=(klass); end
end
module ActiveSupport::Callbacks
  def halted_callback_hook(filter, name); end
  def run_callbacks(kind, type = nil); end
  extend ActiveSupport::Concern
end
module ActiveSupport::Callbacks::Conditionals
end
class ActiveSupport::Callbacks::Conditionals::Value
  def call(target, value); end
  def initialize(&block); end
end
module ActiveSupport::Callbacks::Filters
end
class ActiveSupport::Callbacks::Filters::Environment < Struct
  def halted; end
  def halted=(_); end
  def self.[](*arg0); end
  def self.inspect; end
  def self.keyword_init?; end
  def self.members; end
  def self.new(*arg0); end
  def target; end
  def target=(_); end
  def value; end
  def value=(_); end
end
class ActiveSupport::Callbacks::Filters::Before
  def apply(callback_sequence); end
  def call(env); end
  def filter; end
  def halted_lambda; end
  def initialize(user_callback, user_conditions, chain_config, filter, name); end
  def name; end
  def user_callback; end
  def user_conditions; end
end
class ActiveSupport::Callbacks::Filters::After
  def apply(callback_sequence); end
  def call(env); end
  def halting; end
  def initialize(user_callback, user_conditions, chain_config); end
  def user_callback; end
  def user_conditions; end
end
class ActiveSupport::Callbacks::Filters::Around
  def apply(callback_sequence); end
  def initialize(user_callback, user_conditions); end
end
class ActiveSupport::Callbacks::Callback
  def apply(callback_sequence); end
  def chain_config; end
  def check_conditionals(conditionals); end
  def compiled; end
  def conditions_lambdas; end
  def current_scopes; end
  def duplicates?(other); end
  def filter; end
  def initialize(name, filter, kind, options, chain_config); end
  def kind; end
  def kind=(arg0); end
  def matches?(_kind, _filter); end
  def merge_conditional_options(chain, if_option:, unless_option:); end
  def name; end
  def name=(arg0); end
  def self.build(chain, filter, kind, options); end
end
module ActiveSupport::Callbacks::CallTemplate
  def self.build(filter, callback); end
end
class ActiveSupport::Callbacks::CallTemplate::MethodCall
  def expand(target, value, block); end
  def initialize(method); end
  def inverted_lambda; end
  def make_lambda; end
end
class ActiveSupport::Callbacks::CallTemplate::ObjectCall
  def expand(target, value, block); end
  def initialize(target, method); end
  def inverted_lambda; end
  def make_lambda; end
end
class ActiveSupport::Callbacks::CallTemplate::InstanceExec0
  def expand(target, value, block); end
  def initialize(block); end
  def inverted_lambda; end
  def make_lambda; end
end
class ActiveSupport::Callbacks::CallTemplate::InstanceExec1
  def expand(target, value, block); end
  def initialize(block); end
  def inverted_lambda; end
  def make_lambda; end
end
class ActiveSupport::Callbacks::CallTemplate::InstanceExec2
  def expand(target, value, block); end
  def initialize(block); end
  def inverted_lambda; end
  def make_lambda; end
end
class ActiveSupport::Callbacks::CallTemplate::ProcCall
  def expand(target, value, block); end
  def initialize(target); end
  def inverted_lambda; end
  def make_lambda; end
end
class ActiveSupport::Callbacks::CallbackSequence
  def after(after); end
  def around(call_template, user_conditions); end
  def before(before); end
  def expand_call_template(arg, block); end
  def final?; end
  def initialize(nested = nil, call_template = nil, user_conditions = nil); end
  def invoke_after(arg); end
  def invoke_before(arg); end
  def nested; end
  def skip?(arg); end
end
class ActiveSupport::Callbacks::CallbackChain
  def append(*callbacks); end
  def append_one(callback); end
  def chain; end
  def clear; end
  def compile(type); end
  def config; end
  def default_terminator; end
  def delete(o); end
  def each(&block); end
  def empty?; end
  def index(o); end
  def initialize(name, config); end
  def initialize_copy(other); end
  def insert(index, o); end
  def name; end
  def prepend(*callbacks); end
  def prepend_one(callback); end
  def remove_duplicates(callback); end
  include Enumerable
end
module ActiveSupport::Callbacks::ClassMethods
  def __update_callbacks(name); end
  def define_callbacks(*names); end
  def get_callbacks(name); end
  def normalize_callback_params(filters, block); end
  def reset_callbacks(name); end
  def set_callback(name, *filter_list, &block); end
  def set_callbacks(name, callbacks); end
  def skip_callback(name, *filter_list, &block); end
end
class ActiveSupport::BacktraceCleaner
  def add_core_silencer; end
  def add_filter(&block); end
  def add_gem_filter; end
  def add_gem_silencer; end
  def add_silencer(&block); end
  def add_stdlib_silencer; end
  def clean(backtrace, kind = nil); end
  def clean_frame(frame, kind = nil); end
  def filter(backtrace, kind = nil); end
  def filter_backtrace(backtrace); end
  def initialize; end
  def initialize_copy(_other); end
  def noise(backtrace); end
  def remove_filters!; end
  def remove_silencers!; end
  def silence(backtrace); end
end
module Singleton
  def duplicable?; end
end
class ActiveSupport::XMLConverter
  def become_array?(value); end
  def become_content?(value); end
  def become_empty_string?(value); end
  def become_hash?(value); end
  def deep_to_h(value); end
  def garbage?(value); end
  def initialize(xml, disallowed_types = nil); end
  def normalize_keys(params); end
  def nothing?(value); end
  def process_array(value); end
  def process_content(value); end
  def process_hash(value); end
  def to_h; end
end
class ActiveSupport::XMLConverter::DisallowedType < StandardError
  def initialize(type); end
end
class ActiveSupport::OptionMerger
  def initialize(context, options); end
  def method_missing(method, *arguments, &block); end
  def respond_to_missing?(*, **, &); end
end
module I18n
end
class I18n::Railtie < Rails::Railtie
  def self.include_fallbacks_module; end
  def self.init_fallbacks(fallbacks); end
  def self.initialize_i18n(app); end
  def self.setup_raise_on_missing_translations_config(app); end
  def self.validate_fallbacks(fallbacks); end
  def self.watched_dirs_with_extensions(paths); end
end
class ActiveSupport::Railtie < Rails::Railtie
end
module ActiveSupport::EnumerableCoreExt
end
module ActiveSupport::EnumerableCoreExt::Constants
  def const_missing(name); end
end
class Enumerable::SoleItemExpectedError < StandardError
end
class ActiveSupport::Subscriber
  def self.add_event_subscriber(event); end
  def self.attach_to(namespace, subscriber = nil, notifier = nil, inherit_all: nil); end
  def self.detach_from(namespace, notifier = nil); end
  def self.fetch_public_methods(subscriber, inherit_all); end
  def self.find_attached_subscriber; end
  def self.invalid_event?(event); end
  def self.method_added(event); end
  def self.namespace; end
  def self.notifier; end
  def self.pattern_subscribed?(pattern); end
  def self.prepare_pattern(event); end
  def self.remove_event_subscriber(event); end
  def self.subscriber; end
  def self.subscribers; end
end
class ActiveSupport::LogSubscriber < ActiveSupport::Subscriber
  def self.attach_to(*, **, &); end
  def self.colorize_logging; end
  def self.colorize_logging=(val); end
  def self.fetch_public_methods(subscriber, inherit_all); end
  def self.flush_all!; end
  def self.log_levels; end
  def self.log_levels=(value); end
  def self.log_levels?; end
  def self.log_subscribers; end
  def self.logger; end
  def self.logger=(arg0); end
  def self.set_event_levels; end
  def self.subscribe_log_level(method, level); end
end
class ActiveSupport::Messages::RotationConfiguration
  def encrypted; end
  def initialize; end
  def rotate(kind, *args, **options); end
  def signed; end
end
module Benchmark
  def self.ms(&block); end
end
module ActiveSupport::Benchmarkable
  def benchmark(message = nil, options = nil, &block); end
end
module ActiveSupport::ActionableError
  def self.actions(error); end
  def self.dispatch(error, name); end
  extend ActiveSupport::Concern
end
class ActiveSupport::ActionableError::NonActionable < StandardError
end
module ActiveSupport::ActionableError::ClassMethods
  def action(name, &block); end
end
class NameError < StandardError
  def missing_name; end
  def missing_name?(name); end
  def real_mod_name(mod); end
end
module ActiveSupport::CoreExt
end
module ActiveSupport::CoreExt::ERBUtil
  def h(s); end
  def html_escape(s); end
  def unwrapped_html_escape(s); end
end
module ActiveSupport::CoreExt::ERBUtilPrivate
  def h(s); end
  def html_escape(s); end
  def unwrapped_html_escape(s); end
  include ActiveSupport::CoreExt::ERBUtil
end
class ERB
end
module ERB::Util
  def html_escape_once(s); end
  def json_escape(s); end
  def self.html_escape_once(s); end
  def self.json_escape(s); end
  def self.tokenize(source); end
  def self.xml_name_escape(name); end
  def xml_name_escape(name); end
end
module ActiveSupport::Multibyte::Unicode
  def compose(codepoints); end
  def decompose(type, codepoints); end
  def recode_windows1252_chars(string); end
  def tidy_bytes(string, force = nil); end
  extend ActiveSupport::Multibyte::Unicode
end
class ActiveSupport::SafeBuffer < String
  def %(args); end
  def *(_); end
  def +(other); end
  def <<(value); end
  def [](*args); end
  def []=(arg1, arg2, arg3 = nil); end
  def bytesplice(*args, value); end
  def capitalize!(*args); end
  def capitalize(*args, &block); end
  def chomp!(*args); end
  def chomp(*args, &block); end
  def chop!(*args); end
  def chop(*args, &block); end
  def chr; end
  def concat(value); end
  def delete!(*args); end
  def delete(*args, &block); end
  def delete_prefix!(*args); end
  def delete_prefix(*args, &block); end
  def delete_suffix!(*args); end
  def delete_suffix(*args, &block); end
  def downcase!(*args); end
  def downcase(*args, &block); end
  def encode_with(coder); end
  def explicit_html_escape_interpolated_argument(arg); end
  def gsub!(*args, &block); end
  def gsub(*args, &block); end
  def html_safe; end
  def html_safe?; end
  def implicit_html_escape_interpolated_argument(arg); end
  def initialize(str = nil); end
  def initialize_copy(other); end
  def insert(index, value); end
  def lstrip!(*args); end
  def lstrip(*args, &block); end
  def next!(*args); end
  def next(*args, &block); end
  def original_concat(*arg0); end
  def prepend(value); end
  def replace(value); end
  def reverse!(*args); end
  def reverse(*args, &block); end
  def rstrip!(*args); end
  def rstrip(*args, &block); end
  def safe_concat(value); end
  def scrub!(*args); end
  def scrub(*args, &block); end
  def set_block_back_references(block, match_data); end
  def slice!(*args); end
  def slice(*args); end
  def squeeze!(*args); end
  def squeeze(*args, &block); end
  def string_into_safe_buffer(new_string, is_html_safe); end
  def strip!(*args); end
  def strip(*args, &block); end
  def sub!(*args, &block); end
  def sub(*args, &block); end
  def succ!(*args); end
  def succ(*args, &block); end
  def swapcase!(*args); end
  def swapcase(*args, &block); end
  def to_param; end
  def to_s; end
  def tr!(*args); end
  def tr(*args, &block); end
  def tr_s!(*args); end
  def tr_s(*args, &block); end
  def unicode_normalize!(*args); end
  def unicode_normalize(*args, &block); end
  def upcase!(*args); end
  def upcase(*args, &block); end
end
class ActiveSupport::SafeBuffer::SafeConcatError < StandardError
  def initialize; end
end
class ActiveSupport::Duration
  def %(other); end
  def *(other); end
  def +(other); end
  def +@; end
  def -(other); end
  def -@; end
  def /(other); end
  def <=>(other); end
  def ==(other); end
  def _parts; end
  def abs(&); end
  def after(time = nil); end
  def ago(time = nil); end
  def as_json(options = nil); end
  def before(time = nil); end
  def coerce(other); end
  def encode_with(coder); end
  def eql?(other); end
  def from_now(time = nil); end
  def hash; end
  def in_days; end
  def in_hours; end
  def in_minutes; end
  def in_months; end
  def in_seconds; end
  def in_weeks; end
  def in_years; end
  def init_with(coder); end
  def initialize(value, parts, variable = nil); end
  def inspect; end
  def instance_of?(klass); end
  def is_a?(klass); end
  def iso8601(precision: nil); end
  def kind_of?(klass); end
  def method_missing(*, **, &); end
  def negative?(&); end
  def parts; end
  def positive?(&); end
  def raise_type_error(other); end
  def respond_to_missing?(method, _); end
  def self.===(other); end
  def self.build(value); end
  def self.calculate_total_seconds(parts); end
  def self.days(value); end
  def self.hours(value); end
  def self.minutes(value); end
  def self.months(value); end
  def self.parse(iso8601duration); end
  def self.seconds(value); end
  def self.weeks(value); end
  def self.years(value); end
  def since(time = nil); end
  def sum(sign, time = nil); end
  def to_f(&); end
  def to_i; end
  def to_s; end
  def until(time = nil); end
  def value; end
  def variable?; end
  def zero?(&); end
end
class ActiveSupport::Duration::Scalar < Numeric
  def %(other); end
  def *(other); end
  def +(other); end
  def -(other); end
  def -@; end
  def /(other); end
  def <=>(other); end
  def calculate(op, other); end
  def coerce(other); end
  def initialize(value); end
  def raise_type_error(other); end
  def to_f(*, **, &); end
  def to_i(*, **, &); end
  def to_s(*, **, &); end
  def value; end
  def variable?; end
end
class ActiveSupport::TimeWithZone
  def +(other); end
  def -(other); end
  def <=>(other); end
  def acts_like_time?; end
  def advance(options); end
  def after?(arg0); end
  def ago(other); end
  def as_json(options = nil); end
  def before?(arg0); end
  def between?(min, max); end
  def blank?; end
  def change(options); end
  def comparable_time; end
  def day; end
  def dst?; end
  def duration_of_variable_length?(obj); end
  def encode_with(coder); end
  def eql?(other); end
  def formatted_offset(colon = nil, alternate_utc_string = nil); end
  def freeze; end
  def future?; end
  def get_period_and_ensure_valid_local_time(period); end
  def getgm; end
  def getlocal(utc_offset = nil); end
  def getutc; end
  def gmt?; end
  def gmt_offset; end
  def gmtime; end
  def gmtoff; end
  def hash; end
  def hour; end
  def httpdate; end
  def in(other); end
  def in_time_zone(new_zone = nil); end
  def incorporate_utc_offset(time, offset); end
  def init_with(coder); end
  def initialize(utc_time, time_zone, local_time = nil, period = nil); end
  def inspect; end
  def is_a?(klass); end
  def isdst; end
  def iso8601(fraction_digits = nil); end
  def kind_of?(klass); end
  def localtime(utc_offset = nil); end
  def marshal_dump; end
  def marshal_load(variables); end
  def mday; end
  def method_missing(*, **, &); end
  def min; end
  def mon; end
  def month; end
  def next_day?; end
  def nsec; end
  def past?; end
  def period; end
  def present?; end
  def prev_day?; end
  def respond_to?(sym, include_priv = nil); end
  def respond_to_missing?(sym, include_priv); end
  def rfc2822; end
  def rfc3339(fraction_digits = nil); end
  def rfc822; end
  def sec; end
  def since(other); end
  def strftime(format); end
  def time; end
  def time_zone; end
  def to_a; end
  def to_date; end
  def to_datetime; end
  def to_f; end
  def to_formatted_s(format = nil); end
  def to_fs(format = nil); end
  def to_i; end
  def to_r; end
  def to_s; end
  def to_time; end
  def today?; end
  def tomorrow?; end
  def transfer_time_values_to_utc_constructor(time); end
  def tv_sec; end
  def usec; end
  def utc; end
  def utc?; end
  def utc_offset; end
  def wday; end
  def wrap_with_time_zone(time); end
  def xmlschema(fraction_digits = nil); end
  def yday; end
  def year; end
  def yesterday?; end
  def zone; end
  include Comparable
end
module DateAndTime::Calculations
  def after?(date_or_time); end
  def all_day; end
  def all_month; end
  def all_quarter; end
  def all_week(start_day = nil); end
  def all_year; end
  def at_beginning_of_month; end
  def at_beginning_of_quarter; end
  def at_beginning_of_week(start_day = nil); end
  def at_beginning_of_year; end
  def at_end_of_month; end
  def at_end_of_quarter; end
  def at_end_of_week(start_day = nil); end
  def at_end_of_year; end
  def before?(date_or_time); end
  def beginning_of_month; end
  def beginning_of_quarter; end
  def beginning_of_week(start_day = nil); end
  def beginning_of_year; end
  def copy_time_to(other); end
  def days_ago(days); end
  def days_since(days); end
  def days_span(day); end
  def days_to_week_start(start_day = nil); end
  def end_of_month; end
  def end_of_quarter; end
  def end_of_week(start_day = nil); end
  def end_of_year; end
  def first_hour(date_or_time); end
  def future?; end
  def last_hour(date_or_time); end
  def last_month; end
  def last_quarter; end
  def last_week(start_day = nil, same_time: nil); end
  def last_weekday; end
  def last_year; end
  def monday; end
  def months_ago(months); end
  def months_since(months); end
  def next_day?; end
  def next_occurring(day_of_week); end
  def next_quarter; end
  def next_week(given_day_in_next_week = nil, same_time: nil); end
  def next_weekday; end
  def on_weekday?; end
  def on_weekend?; end
  def past?; end
  def prev_day?; end
  def prev_occurring(day_of_week); end
  def prev_quarter; end
  def prev_week(start_day = nil, same_time: nil); end
  def prev_weekday; end
  def quarter; end
  def sunday; end
  def today?; end
  def tomorrow; end
  def tomorrow?; end
  def weeks_ago(weeks); end
  def weeks_since(weeks); end
  def years_ago(years); end
  def years_since(years); end
  def yesterday; end
  def yesterday?; end
end
module ActiveSupport::RangeWithFormat
  def to_formatted_s(format = nil); end
  def to_fs(format = nil); end
end
module ActiveSupport::CompareWithRange
  def ===(value); end
  def include?(value); end
end
module ActiveSupport::EachTimeWithZone
  def each(&block); end
  def ensure_iteration_allowed; end
  def step(n = nil, &block); end
end
class ActiveSupport::StringInquirer < String
  def method_missing(method_name, *, **, &); end
  def respond_to_missing?(method_name, include_private = nil); end
end
class ActiveSupport::EnvironmentInquirer < ActiveSupport::StringInquirer
  def development?; end
  def initialize(env); end
  def local?; end
  def production?; end
  def test?; end
end
class ActiveSupport::CodeGenerator
  def define_cached_method(canonical_name, namespace:, as: nil, &block); end
  def execute; end
  def initialize(owner, path, line); end
  def self.batch(owner, path, line); end
end
class ActiveSupport::CodeGenerator::MethodSet
  def apply(owner, path, line); end
  def define_cached_method(canonical_name, as: nil); end
  def initialize(namespace); end
end
module Module::Concerning
  def concern(topic, &module_definition); end
  def concerning(topic, prepend: nil, &block); end
end
module ActiveSupport::NumberHelper
  def number_to_currency(number, options = nil); end
  def number_to_delimited(number, options = nil); end
  def number_to_human(number, options = nil); end
  def number_to_human_size(number, options = nil); end
  def number_to_percentage(number, options = nil); end
  def number_to_phone(number, options = nil); end
  def number_to_rounded(number, options = nil); end
  extend ActiveSupport::Autoload
  extend ActiveSupport::NumberHelper
end
module ActiveSupport::HtmlSafeTranslation
  def html_escape_translation_options(options); end
  def html_safe_translation(translation); end
  def html_safe_translation_key?(key); end
  def i18n_option?(name); end
  def translate(key, **options); end
  extend ActiveSupport::HtmlSafeTranslation
end
class ActiveSupport::FileUpdateChecker
  def compile_ext(array); end
  def compile_glob(hash); end
  def escape(key); end
  def execute; end
  def execute_if_updated; end
  def initialize(files, dirs = nil, &block); end
  def max_mtime(paths); end
  def updated?; end
  def updated_at(paths); end
  def watched; end
end
module ActiveSupport::Concurrency
end
class ActiveSupport::Concurrency::ShareLock
  def busy_for_exclusive?(purpose); end
  def busy_for_sharing?(purpose); end
  def eligible_waiters?(compatible); end
  def exclusive(purpose: nil, compatible: nil, after_compatible: nil, no_wait: nil); end
  def initialize; end
  def raw_state; end
  def sharing; end
  def start_exclusive(purpose: nil, compatible: nil, no_wait: nil); end
  def start_sharing; end
  def stop_exclusive(compatible: nil); end
  def stop_sharing; end
  def wait_for(method, &block); end
  def yield_shares(purpose: nil, compatible: nil, block_share: nil); end
  include MonitorMixin
end
module ActiveSupport::Dependencies
  def self._autoloaded_tracked_classes; end
  def self._autoloaded_tracked_classes=(arg0); end
  def self._eager_load_paths; end
  def self._eager_load_paths=(arg0); end
  def self.autoload_once_paths; end
  def self.autoload_once_paths=(arg0); end
  def self.autoload_paths; end
  def self.autoload_paths=(arg0); end
  def self.autoloader; end
  def self.autoloader=(arg0); end
  def self.clear; end
  def self.eager_load?(path); end
  def self.interlock; end
  def self.interlock=(arg0); end
  def self.load_interlock(&block); end
  def self.run_interlock(&block); end
  def self.search_for_file(relpath); end
  def self.unload_interlock(&block); end
end
class ActiveSupport::Dependencies::Interlock
  def done_running; end
  def done_unloading; end
  def initialize; end
  def loading(&block); end
  def permit_concurrent_loads(&block); end
  def raw_state(&block); end
  def running(&block); end
  def start_running; end
  def start_unloading; end
  def unloading(&block); end
end
module ActiveSupport::Dependencies::RequireDependency
  def require_dependency(filename); end
end
class ActiveSupport::ParameterFilter
  def call(params, full_parent_key = nil, original_params = nil); end
  def compile_filters!(filters); end
  def filter(params); end
  def filter_param(key, value); end
  def initialize(filters = nil, mask: nil); end
  def self.precompile_filters(filters); end
  def value_for_key(key, value, full_parent_key = nil, original_params = nil); end
end
class ActiveSupport::ArrayInquirer < Array
  def any?(*candidates); end
  def method_missing(name, *, **, &); end
  def respond_to_missing?(name, include_private = nil); end
end
module ActiveSupport::Cache
  def self.expand_cache_key(key, namespace = nil); end
  def self.format_version; end
  def self.format_version=(arg0); end
  def self.lookup_store(store = nil, *parameters); end
  def self.retrieve_cache_key(key); end
  def self.retrieve_store_class(store); end
end
class ActiveSupport::Cache::Entry
  def bytesize; end
  def compressed(compress_threshold); end
  def compressed?; end
  def dup_value!; end
  def expired?; end
  def expires_at; end
  def expires_at=(value); end
  def initialize(value, compressed: nil, version: nil, expires_in: nil, expires_at: nil, **); end
  def local?; end
  def marshal_load(payload); end
  def mismatched?(version); end
  def pack; end
  def self.unpack(members); end
  def uncompress(value); end
  def value; end
  def version; end
end
class ActiveSupport::Cache::Coder
  def dump(entry); end
  def dump_compressed(entry, threshold); end
  def dump_version(version); end
  def initialize(serializer, compressor, legacy_serializer: nil); end
  def load(dumped); end
  def load_version(dumped_version); end
  def signature?(dumped); end
  def try_compress(string, threshold); end
  def type_for_string(value); end
end
class ActiveSupport::Cache::Coder::StringDeserializer
  def initialize(encoding); end
  def load(payload); end
end
class ActiveSupport::Cache::Coder::LazyEntry < ActiveSupport::Cache::Entry
  def initialize(serializer, compressor, payload, **options); end
  def mismatched?(version); end
  def value; end
end
module ActiveSupport::Cache::SerializerWithFallback
  def load(dumped); end
  def marshal_load(payload); end
  def self.[](format); end
end
module ActiveSupport::Cache::SerializerWithFallback::PassthroughWithFallback
  def _load(entry); end
  def dump(entry); end
  def dump_compressed(entry, threshold); end
  def dumped?(dumped); end
  extend ActiveSupport::Cache::SerializerWithFallback::PassthroughWithFallback
  include ActiveSupport::Cache::SerializerWithFallback
end
module ActiveSupport::Cache::SerializerWithFallback::Marshal70WithFallback
  def _load(marked); end
  def dump(entry); end
  def dump_compressed(entry, threshold); end
  def dumped?(dumped); end
  extend ActiveSupport::Cache::SerializerWithFallback::Marshal70WithFallback
  include ActiveSupport::Cache::SerializerWithFallback
end
module ActiveSupport::Cache::SerializerWithFallback::Marshal71WithFallback
  def _load(dumped); end
  def dump(value); end
  def dumped?(dumped); end
  extend ActiveSupport::Cache::SerializerWithFallback::Marshal71WithFallback
  include ActiveSupport::Cache::SerializerWithFallback
end
module ActiveSupport::Cache::SerializerWithFallback::MessagePackWithFallback
  def _load(dumped); end
  def available?; end
  def dump(value); end
  def dumped?(dumped); end
  extend ActiveSupport::Cache::SerializerWithFallback::MessagePackWithFallback
  include ActiveSupport::Cache::SerializerWithFallback
end
class ActiveSupport::Cache::DeserializationError < StandardError
end
module ActiveSupport::Cache::Strategy
end
class ActiveSupport::Cache::Store
  def _instrument(operation, multi: nil, options: nil, **payload, &block); end
  def cleanup(options = nil); end
  def clear(options = nil); end
  def decrement(name, amount = nil, options = nil); end
  def default_serializer; end
  def delete(name, options = nil); end
  def delete_entry(key, **options); end
  def delete_matched(matcher, options = nil); end
  def delete_multi(names, options = nil); end
  def delete_multi_entries(entries, **options); end
  def deserialize_entry(payload, **); end
  def exist?(name, options = nil); end
  def expanded_key(key); end
  def expanded_version(key); end
  def fetch(name, options = nil, &block); end
  def fetch_multi(*names); end
  def get_entry_value(entry, name, options); end
  def handle_expired_entry(entry, key, options); end
  def handle_invalid_expires_in(message); end
  def increment(name, amount = nil, options = nil); end
  def initialize(options = nil); end
  def instrument(operation, key, options = nil, &block); end
  def instrument_multi(operation, keys, options = nil, &block); end
  def key_matcher(pattern, options); end
  def logger; end
  def logger=(val); end
  def merged_options(call_options); end
  def mute; end
  def namespace_key(key, options = nil); end
  def new_entry(value, options = nil); end
  def normalize_key(key, options = nil); end
  def normalize_options(options); end
  def normalize_version(key, options = nil); end
  def options; end
  def raise_on_invalid_cache_expiration_time; end
  def raise_on_invalid_cache_expiration_time=(val); end
  def read(name, options = nil); end
  def read_entry(key, **options); end
  def read_multi(*names); end
  def read_multi_entries(names, **options); end
  def save_block_result_to_cache(name, key, options); end
  def self.logger; end
  def self.logger=(val); end
  def self.raise_on_invalid_cache_expiration_time; end
  def self.raise_on_invalid_cache_expiration_time=(val); end
  def self.retrieve_pool_options(options); end
  def serialize_entry(entry, **options); end
  def silence!; end
  def silence; end
  def silence?; end
  def validate_options(options); end
  def write(name, value, options = nil); end
  def write_entry(key, entry, **options); end
  def write_multi(hash, options = nil); end
  def write_multi_entries(hash, **options); end
end
class ActiveSupport::Cache::WriteOptions
  def expires_at; end
  def expires_at=(expires_at); end
  def expires_in; end
  def expires_in=(expires_in); end
  def initialize(options); end
  def version; end
  def version=(version); end
end
class ActiveSupport::Cache::MemoryStore < ActiveSupport::Cache::Store
  def cached_size(key, payload); end
  def cleanup(options = nil); end
  def clear(options = nil); end
  def decrement(name, amount = nil, options = nil); end
  def delete_entry(key, **options); end
  def delete_matched(matcher, options = nil); end
  def increment(name, amount = nil, options = nil); end
  def initialize(options = nil); end
  def inspect; end
  def modify_value(name, amount, options); end
  def prune(target_size, max_time = nil); end
  def pruning?; end
  def read_entry(key, **options); end
  def self.supports_cache_versioning?; end
  def synchronize(&block); end
  def write_entry(key, entry, **options); end
end
module ActiveSupport::Cache::MemoryStore::DupCoder
  def dump(entry); end
  def dump_compressed(entry, threshold); end
  def dump_value(value); end
  def load(entry); end
  def load_value(string); end
  extend ActiveSupport::Cache::MemoryStore::DupCoder
end
module ActiveSupport::Configurable
  def config; end
  extend ActiveSupport::Concern
end
class ActiveSupport::Configurable::Configuration < ActiveSupport::InheritableOptions
  def compile_methods!; end
  def self.compile_methods!(keys); end
end
module ActiveSupport::Configurable::ClassMethods
  def config; end
  def config_accessor(*names, instance_reader: nil, instance_writer: nil, instance_accessor: nil, default: nil); end
  def configure; end
  def inherited(subclass); end
end
class ActiveSupport::Multibyte::Chars
  def <=>(*, **, &); end
  def =~(*, **, &); end
  def acts_like_string?(*, **, &); end
  def as_json(options = nil); end
  def chars(string); end
  def compose; end
  def decompose; end
  def grapheme_length; end
  def initialize(string); end
  def limit(limit); end
  def match?(*, **, &); end
  def method_missing(method, *, **, &); end
  def respond_to_missing?(method, include_private); end
  def reverse!(*args); end
  def reverse; end
  def slice!(*args); end
  def split(*args); end
  def tidy_bytes!(*args); end
  def tidy_bytes(force = nil); end
  def titlecase; end
  def titleize; end
  def to_s; end
  def to_str; end
  def wrapped_string; end
  include Comparable
end
class ActiveSupport::ExecutionWrapper
  def __callbacks; end
  def __callbacks?; end
  def _complete_callbacks; end
  def _run_callbacks; end
  def _run_complete_callbacks(&block); end
  def _run_run_callbacks(&block); end
  def complete!; end
  def complete; end
  def hook_state; end
  def run!; end
  def run; end
  def self.__callbacks; end
  def self.__callbacks=(value); end
  def self.__callbacks?; end
  def self._complete_callbacks; end
  def self._complete_callbacks=(value); end
  def self._run_callbacks; end
  def self._run_callbacks=(value); end
  def self.active?; end
  def self.active_key; end
  def self.error_reporter; end
  def self.perform; end
  def self.register_hook(hook, outer: nil); end
  def self.run!(reset: nil); end
  def self.to_complete(*args, &block); end
  def self.to_run(*args, &block); end
  def self.wrap(source: nil); end
  extend ActiveSupport::Callbacks::ClassMethods
  extend ActiveSupport::DescendantsTracker
  include ActiveSupport::Callbacks
end
class ActiveSupport::ExecutionWrapper::RunHook < Struct
  def before(target); end
  def hook; end
  def hook=(_); end
  def self.[](*arg0); end
  def self.inspect; end
  def self.keyword_init?; end
  def self.members; end
  def self.new(*arg0); end
end
class ActiveSupport::ExecutionWrapper::CompleteHook < Struct
  def after(target); end
  def before(target); end
  def hook; end
  def hook=(_); end
  def self.[](*arg0); end
  def self.inspect; end
  def self.keyword_init?; end
  def self.members; end
  def self.new(*arg0); end
end
class ActiveSupport::Executor < ActiveSupport::ExecutionWrapper
end
class ActiveSupport::Reloader < ActiveSupport::ExecutionWrapper
  def _class_unload_callbacks; end
  def _prepare_callbacks; end
  def _run_class_unload_callbacks(&block); end
  def _run_prepare_callbacks(&block); end
  def check; end
  def check=(arg0); end
  def check?; end
  def class_unload!(&block); end
  def complete!; end
  def executor; end
  def executor=(arg0); end
  def executor?; end
  def initialize; end
  def release_unload_lock!; end
  def require_unload_lock!; end
  def run!; end
  def self.__callbacks; end
  def self._class_unload_callbacks; end
  def self._class_unload_callbacks=(value); end
  def self._prepare_callbacks; end
  def self._prepare_callbacks=(value); end
  def self.after_class_unload(*args, &block); end
  def self.before_class_unload(*args, &block); end
  def self.check!; end
  def self.check; end
  def self.check=(value); end
  def self.check?; end
  def self.executor; end
  def self.executor=(value); end
  def self.executor?; end
  def self.prepare!; end
  def self.reload!; end
  def self.reloaded!; end
  def self.run!(reset: nil); end
  def self.to_prepare(*args, &block); end
  def self.wrap(**kwargs); end
end
module Digest
end
module Digest::UUID
  def self.nil_uuid; end
  def self.pack_uuid_namespace(namespace); end
  def self.uuid_from_hash(hash_class, namespace, name); end
  def self.uuid_v3(uuid_namespace, name); end
  def self.uuid_v4; end
  def self.uuid_v5(uuid_namespace, name); end
end
class File < IO
  def self.world_readable?(arg0); end
  def self.writable?(arg0); end
end
class LoadError < ScriptError
  def is_missing?(location); end
end
module ActiveSupport::NumericWithFormat
  def to_formatted_s(format = nil, options = nil); end
  def to_fs(format = nil, options = nil); end
end
module SecureRandom
  def self.base36(n = nil); end
  def self.base58(n = nil); end
end
module ActiveSupport::TaggedLogging
  def clear_tags!(*, **, &); end
  def flush; end
  def pop_tags(*, **, &); end
  def push_tags(*, **, &); end
  def self.new(logger); end
  def tagged(*tags); end
end
module ActiveSupport::TaggedLogging::Formatter
  def call(severity, timestamp, progname, msg); end
  def clear_tags!; end
  def current_tags; end
  def pop_tags(count = nil); end
  def push_tags(*tags); end
  def tag_stack; end
  def tagged(*tags); end
  def tags_text; end
end
class ActiveSupport::TaggedLogging::TagStack
  def clear; end
  def format_message(message); end
  def initialize; end
  def pop_tags(count); end
  def push_tags(tags); end
  def tags; end
end
module ActiveSupport::TaggedLogging::LocalTagStorage
  def self.extended(base); end
  def tag_stack; end
  def tag_stack=(arg0); end
end
class ActiveSupport::Digest
  def self.hash_digest_class; end
  def self.hash_digest_class=(klass); end
  def self.hexdigest(arg); end
end
module ActiveSupport::Cache::Strategy::LocalCache
  def bypass_local_cache(&block); end
  def cleanup(options = nil); end
  def clear(options = nil); end
  def decrement(name, amount = nil, options = nil); end
  def delete_entry(key, **); end
  def delete_matched(matcher, options = nil); end
  def increment(name, amount = nil, options = nil); end
  def local_cache; end
  def local_cache_key; end
  def middleware; end
  def read_multi_entries(names, **options); end
  def read_serialized_entry(key, raw: nil, **options); end
  def use_temporary_local_cache(temporary_cache); end
  def with_local_cache(&block); end
  def write_cache_value(name, value, **options); end
  def write_serialized_entry(key, payload, **); end
end
module ActiveSupport::Cache::Strategy::LocalCache::LocalCacheRegistry
  def cache_for(local_cache_key); end
  def set_cache_for(local_cache_key, value); end
  extend ActiveSupport::Cache::Strategy::LocalCache::LocalCacheRegistry
end
class ActiveSupport::Cache::Strategy::LocalCache::LocalStore
  def clear(options = nil); end
  def delete_entry(key); end
  def fetch_entry(key); end
  def initialize; end
  def read_entry(key); end
  def read_multi_entries(keys); end
  def write_entry(key, entry); end
end
class ActiveSupport::Cache::RedisCacheStore < ActiveSupport::Cache::Store
  def change_counter(key, amount, options); end
  def cleanup(options = nil); end
  def clear(options = nil); end
  def decrement(name, amount = nil, options = nil); end
  def delete_entry(key, **); end
  def delete_matched(matcher, options = nil); end
  def delete_multi_entries(entries, **_options); end
  def deserialize_entry(payload, raw: nil, **); end
  def failsafe(method, returning: nil); end
  def increment(name, amount = nil, options = nil); end
  def initialize(error_handler: nil, **redis_options); end
  def inspect; end
  def max_key_bytesize; end
  def normalize_key(key, options); end
  def pipeline_entries(entries, &block); end
  def read_entry(key, **options); end
  def read_multi(*names); end
  def read_multi_entries(names, **options); end
  def read_serialized_entry(key, raw: nil, **options); end
  def redis; end
  def self.build_redis(redis: nil, url: nil, **redis_options); end
  def self.build_redis_client(**redis_options); end
  def self.build_redis_distributed_client(urls:, **redis_options); end
  def self.supports_cache_versioning?; end
  def serialize_entries(entries, **options); end
  def serialize_entry(entry, raw: nil, **options); end
  def stats; end
  def supports_expire_nx?; end
  def truncate_key(key); end
  def write_entry(key, entry, raw: nil, **options); end
  def write_multi_entries(entries, **options); end
  def write_serialized_entry(key, payload, **); end
end
class ActiveSupport::Cache::Strategy::LocalCache::Middleware
  def call(env); end
  def initialize(name, local_cache_key); end
  def local_cache_key; end
  def name; end
  def new(app); end
end
class ActiveSupport::SyntaxErrorProxy < Anonymous_Delegator_1
  def backtrace; end
  def backtrace_locations; end
  def parse_message_for_trace; end
end
class Anonymous_Struct_2 < Struct
  def lineno; end
  def lineno=(_); end
  def path; end
  def path=(_); end
  def self.[](*arg0); end
  def self.inspect; end
  def self.keyword_init?; end
  def self.members; end
  def self.new(*arg0); end
  def to_s; end
  def to_s=(_); end
end
class ActiveSupport::SyntaxErrorProxy::BacktraceLocation < Anonymous_Struct_2
  def label; end
  def spot(_); end
end
class ActiveSupport::SyntaxErrorProxy::BacktraceLocationProxy < Anonymous_Delegator_3
  def initialize(loc, ex); end
  def spot(_); end
end
class Thread::Backtrace::Location
  def spot(ex); end
end
module ActiveSupport::IsolatedExecutionState
  def self.[](key); end
  def self.[]=(key, value); end
  def self.clear; end
  def self.context; end
  def self.delete(key); end
  def self.isolation_level; end
  def self.isolation_level=(level); end
  def self.key?(key); end
  def self.scope; end
  def self.share_with(other); end
  def self.state; end
  def self.unique_id; end
end
class Thread
  def active_support_execution_state; end
  def active_support_execution_state=(arg0); end
end
class Fiber
  def active_support_execution_state; end
  def active_support_execution_state=(arg0); end
end
module ActiveSupport::Rescuable
  def handler_for_rescue(exception); end
  def rescue_with_handler(exception); end
  extend ActiveSupport::Concern
end
module ActiveSupport::Rescuable::ClassMethods
  def constantize_rescue_handler_class(class_or_name); end
  def find_rescue_handler(exception); end
  def handler_for_rescue(exception, object: nil); end
  def rescue_from(*klasses, with: nil, &block); end
  def rescue_with_handler(exception, object: nil, visited_exceptions: nil); end
end
module ActiveSupport::Concurrency::NullLock
  def synchronize; end
  extend ActiveSupport::Concurrency::NullLock
end
module ActiveSupport::Concurrency::LoadInterlockAwareMonitorMixin
  def mon_enter; end
  def synchronize(&block); end
end
class ActiveSupport::Concurrency::LoadInterlockAwareMonitor < Monitor
  include ActiveSupport::Concurrency::LoadInterlockAwareMonitorMixin
end
class ActiveSupport::Concurrency::ThreadLoadInterlockAwareMonitor
  def initialize; end
  def mon_enter; end
  def mon_exit; end
  def mon_try_enter; end
end
module ActiveSupport::ForkTracker
  def self.after_fork(&block); end
  def self.after_fork_callback; end
  def self.hook!; end
  def self.unregister(callback); end
end
module ActiveSupport::ForkTracker::CoreExt
  def _fork; end
end
class ActiveSupport::CurrentAttributes
  def __callbacks; end
  def __callbacks?; end
  def _reset_callbacks; end
  def _run_reset_callbacks(&block); end
  def self.__callbacks; end
  def self.__callbacks=(value); end
  def self.__callbacks?; end
  def self._reset_callbacks; end
  def self._reset_callbacks=(value); end
  def self.after_reset(*methods, &block); end
  def self.attribute(*names, default: nil); end
  def self.before_reset(*methods, &block); end
  def self.clear_all; end
  def self.current_instances; end
  def self.current_instances_key; end
  def self.defaults; end
  def self.defaults=(value); end
  def self.defaults?; end
  def self.generated_attribute_methods; end
  def self.instance; end
  def self.method_added(name); end
  def self.method_missing(name, *, **, &); end
  def self.reset(*, **, &); end
  def self.reset_all; end
  def self.resets(*methods, &block); end
  def self.respond_to_missing?(name, _); end
  def self.set(*, **, &); end
  extend ActiveSupport::Callbacks::ClassMethods
  extend ActiveSupport::DescendantsTracker
  include ActiveSupport::Callbacks
end
module ActiveSupport::Testing
end
module ActiveSupport::Testing::TaggedLogging
  def before_setup; end
  def tagged_logger; end
  def tagged_logger=(arg0); end
end
module ActiveSupport::Testing::SetupAndTeardown
  def after_teardown; end
  def before_setup; end
  def self.prepended(klass); end
end
module ActiveSupport::Testing::SetupAndTeardown::ClassMethods
  def setup(*args, &block); end
  def teardown(*args, &block); end
end
module ActiveSupport::Testing::TestsWithoutAssertions
  def after_teardown; end
end
module ActiveSupport::Testing::Assertions
  def _assert_nothing_raised_or_warn(assertion, &block); end
  def assert_changes(expression, message = nil, from: nil, to: nil, &block); end
  def assert_difference(expression, *args, &block); end
  def assert_no_changes(expression, message = nil, from: nil, &block); end
  def assert_no_difference(expression, message = nil, &block); end
  def assert_not(object, message = nil); end
  def assert_nothing_raised; end
  def assert_raise(*exp, match: nil, &block); end
  def assert_raises(*exp, match: nil, &block); end
end
module ActiveSupport::Testing::ErrorReporterAssertions
  def assert_error_reported(error_class = nil, &block); end
  def assert_no_error_reported(&block); end
end
module ActiveSupport::Testing::ErrorReporterAssertions::ErrorCollector
  def self.record; end
  def self.report(error, **kwargs); end
  def self.subscribe; end
end
class ActiveSupport::Testing::ErrorReporterAssertions::ErrorCollector::Report < Struct
  def context; end
  def context=(_); end
  def error; end
  def error=(_); end
  def handled; end
  def handled=(_); end
  def handled?; end
  def self.[](*arg0); end
  def self.inspect; end
  def self.keyword_init?; end
  def self.members; end
  def self.new(*arg0); end
  def severity; end
  def severity=(_); end
  def source; end
  def source=(_); end
end
module ActiveSupport::Testing::Deprecation
  def assert_deprecated(match = nil, deprecator = nil, &block); end
  def assert_not_deprecated(deprecator, &block); end
  def collect_deprecations(deprecator); end
end
module ActiveSupport::Testing::Declarative
  def test(name, &block); end
end
module ActiveSupport::Testing::Isolation
  def run; end
  def self.forking_env?; end
  def self.included(klass); end
  include ActiveSupport::Testing::Isolation::Forking
end
class ActiveSupport::Testing::Isolation::SubprocessCrashed < StandardError
end
module ActiveSupport::Testing::Isolation::Forking
  def run_in_isolation(&blk); end
end
module ActiveSupport::Testing::Isolation::Subprocess
  def run_in_isolation(&blk); end
end
module ActiveSupport::Testing::ConstantLookup
  extend ActiveSupport::Concern
end
module ActiveSupport::Testing::ConstantLookup::ClassMethods
  def determine_constant_from_test_name(test_name); end
end
class ActiveSupport::Testing::SimpleStubs
  def initialize; end
  def stub_object(object, method_name, &block); end
  def stubbed?; end
  def stubbing(object, method_name); end
  def unstub_all!; end
  def unstub_object(stub); end
end
class ActiveSupport::Testing::SimpleStubs::Stub < Struct
  def method_name; end
  def method_name=(_); end
  def object; end
  def object=(_); end
  def original_method; end
  def original_method=(_); end
  def self.[](*arg0); end
  def self.inspect; end
  def self.keyword_init?; end
  def self.members; end
  def self.new(*arg0); end
end
module ActiveSupport::Testing::TimeHelpers
  def after_teardown; end
  def freeze_time(with_usec: nil, &block); end
  def in_block; end
  def in_block=(arg0); end
  def simple_stubs; end
  def travel(duration, with_usec: nil, &block); end
  def travel_back; end
  def travel_to(date_or_time, with_usec: nil); end
  def unfreeze_time; end
end
module ActiveSupport::Testing::ConstantStubbing
  def stub_const(mod, constant, new_value, exists: nil); end
end
module ActiveSupport::Testing::FileFixtures
  def file_fixture(fixture_name); end
  extend ActiveSupport::Concern
end
class ActiveSupport::Testing::Parallelization
  def <<(work); end
  def after_fork_hooks; end
  def initialize(worker_count); end
  def run_cleanup_hooks; end
  def self.after_fork_hook(&blk); end
  def self.after_fork_hooks; end
  def self.run_cleanup_hook(&blk); end
  def self.run_cleanup_hooks; end
  def shutdown; end
  def size; end
  def start; end
end
class ActiveSupport::Testing::Parallelization::Server
  def <<(o); end
  def active_workers?; end
  def initialize; end
  def interrupt; end
  def pop; end
  def record(reporter, result); end
  def shutdown; end
  def start_worker(worker_id); end
  def stop_worker(worker_id); end
  include DRb::DRbUndumped
end
class ActiveSupport::Testing::Parallelization::Worker
  def add_setup_exception(result); end
  def after_fork; end
  def initialize(number, url); end
  def perform_job(job); end
  def run_cleanup; end
  def safe_record(reporter, result); end
  def set_process_title(status); end
  def start; end
  def work_from_queue; end
end
class ActiveSupport::Testing::ParallelizeExecutor
  def <<(work); end
  def build_parallel_executor; end
  def execution_info; end
  def initialize(size:, with:, threshold: nil); end
  def many_workers?; end
  def parallel_executor; end
  def parallelize; end
  def parallelize_with; end
  def parallelized?; end
  def should_parallelize?; end
  def show_execution_info; end
  def shutdown; end
  def size; end
  def start; end
  def tests_count; end
  def threshold; end
end
module ActiveSupport::Executor::TestHelper
  def run(*, **, &); end
end
class ActiveSupport::TestCase < Minitest::Test
  def __callbacks; end
  def __callbacks?; end
  def _run_setup_callbacks(&block); end
  def _run_teardown_callbacks(&block); end
  def _setup_callbacks; end
  def _teardown_callbacks; end
  def assert_no_match(matcher, obj, msg = nil); end
  def assert_not_empty(obj, msg = nil); end
  def assert_not_equal(exp, act, msg = nil); end
  def assert_not_in_delta(exp, act, delta = nil, msg = nil); end
  def assert_not_in_epsilon(a, b, epsilon = nil, msg = nil); end
  def assert_not_includes(collection, obj, msg = nil); end
  def assert_not_instance_of(cls, obj, msg = nil); end
  def assert_not_kind_of(cls, obj, msg = nil); end
  def assert_not_nil(obj, msg = nil); end
  def assert_not_operator(o1, op, o2 = nil, msg = nil); end
  def assert_not_predicate(o1, op, msg = nil); end
  def assert_not_respond_to(obj, meth, msg = nil, include_all: nil); end
  def assert_not_same(exp, act, msg = nil); end
  def dom_class(*, **, &); end
  def dom_id(*, **, &); end
  def file_fixture_path; end
  def file_fixture_path?; end
  def inspect; end
  def method_name; end
  def self.__callbacks; end
  def self.__callbacks=(value); end
  def self.__callbacks?; end
  def self._setup_callbacks; end
  def self._setup_callbacks=(value); end
  def self._teardown_callbacks; end
  def self._teardown_callbacks=(value); end
  def self.file_fixture_path; end
  def self.file_fixture_path=(value); end
  def self.file_fixture_path?; end
  def self.parallelize(workers: nil, with: nil, threshold: nil); end
  def self.parallelize_setup(&block); end
  def self.parallelize_teardown(&block); end
  def self.test_order; end
  def self.test_order=(new_order); end
  extend ActiveSupport::Callbacks::ClassMethods
  extend ActiveSupport::DescendantsTracker
  extend ActiveSupport::Testing::Declarative
  extend ActiveSupport::Testing::SetupAndTeardown::ClassMethods
  extend Rails::LineFiltering
  include ActionCable::TestHelper
  include ActiveSupport::Callbacks
  include ActiveSupport::Executor::TestHelper
  include ActiveSupport::Testing::Assertions
  include ActiveSupport::Testing::ConstantStubbing
  include ActiveSupport::Testing::Deprecation
  include ActiveSupport::Testing::ErrorReporterAssertions
  include ActiveSupport::Testing::FileFixtures
  include ActiveSupport::Testing::TaggedLogging
  include ActiveSupport::Testing::TimeHelpers
  include Turbo::Broadcastable::TestHelper
  include Turbo::Streams::StreamName
  include Turbo::TestAssertions
end
module ActiveSupport::Testing::Stream
  def capture(stream); end
  def quietly(&block); end
  def silence_stream(stream); end
end
module ActiveSupport::CurrentAttributes::TestHelper
  def after_teardown; end
  def before_setup; end
end
module ActiveSupport::ExecutionContext
  def self.[]=(key, value); end
  def self.after_change(&block); end
  def self.clear; end
  def self.set(**options); end
  def self.store; end
  def self.to_h; end
end
module ActiveSupport::ExecutionContext::TestHelper
  def after_teardown; end
  def before_setup; end
end
