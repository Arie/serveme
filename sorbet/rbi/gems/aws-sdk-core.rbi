# This file is autogenerated. Do not edit it by hand. Regenerate it with:
#   srb rbi gems

# typed: true
#
# If you would like to make changes to this file, great! Please create the gem's shim here:
#
#   https://github.com/sorbet/sorbet-typed/new/master?filename=lib/aws-sdk-core/all/aws-sdk-core.rbi
#
# aws-sdk-core-3.201.5

module Seahorse
end
module Seahorse::Util
  def self.escape_header_list_string(s); end
  def self.host_label?(str); end
  def self.uri_escape(string); end
  def self.uri_path_escape(path); end
end
module Seahorse::Client
end
class Seahorse::Client::BlockIO
  def initialize(headers = nil, &block); end
  def read(bytes = nil, output_buffer = nil); end
  def size; end
  def write(chunk); end
end
class Seahorse::Client::Configuration
  def add_option(name, default = nil, &block); end
  def apply_defaults(struct, options); end
  def apply_options(struct, options); end
  def build!(options = nil); end
  def empty_struct; end
  def initialize; end
end
class Seahorse::Client::Configuration::Defaults < Array
  def each(&block); end
end
class Seahorse::Client::Configuration::DynamicDefault
  def block; end
  def block=(arg0); end
  def call(*args); end
  def initialize(block = nil); end
end
class Seahorse::Client::Configuration::DefaultResolver
  def initialize(struct); end
  def method_missing(method_name, *args); end
  def override_config(k, v); end
  def resolve; end
  def resolve_defaults(opt_name, defaults); end
  def respond_to?(method_name, *args); end
  def value_at(opt_name); end
end
class Seahorse::Client::Handler
  def call(context); end
  def handler; end
  def handler=(arg0); end
  def initialize(handler = nil); end
  def inspect; end
end
module Seahorse::Client::HandlerBuilder
  def handle(*args, &block); end
  def handle_request(*args, &block); end
  def handle_response(*args, &block); end
  def handler(*args, &block); end
  def handler_for(name = nil, &block); end
  def new_handler(block); end
end
class Seahorse::Client::HandlerList
  def add(handler_class, options = nil); end
  def add_entries(entries); end
  def add_entry(entry); end
  def copy_from(source_list, &block); end
  def each(&block); end
  def entries; end
  def filter(operation); end
  def for(operation); end
  def initialize(options = nil); end
  def next_index; end
  def remove(handler_class); end
  def to_stack; end
  include Enumerable
end
class Seahorse::Client::HandlerListEntry
  def <=>(other); end
  def compute_weight; end
  def copy(options = nil); end
  def handler_class; end
  def initialize(options); end
  def inserted; end
  def operations; end
  def option(name, options); end
  def priority; end
  def set_priority(priority); end
  def set_step(step); end
  def step; end
  def weight; end
end
class Seahorse::Client::ManagedFile < File
  def open?; end
end
class Seahorse::Client::NetworkingError < StandardError
  def initialize(error, msg = nil); end
  def original_error; end
end
class Seahorse::Client::Http2InitialRequestError < StandardError
  def initialize(error); end
  def original_error; end
end
class Seahorse::Client::Http2StreamInitializeError < StandardError
  def initialize(error); end
  def original_error; end
end
class Seahorse::Client::Http2ConnectionClosedError < StandardError
end
class Seahorse::Client::Plugin
  def add_handlers(handlers, config); end
  def add_options(config); end
  def after_initialize(client); end
  def before_initialize(client_class, options); end
  def self.after_initialize(&block); end
  def self.after_initialize_hooks; end
  def self.before_initialize(&block); end
  def self.before_initialize_hooks; end
  def self.handlers; end
  def self.literal(string); end
  def self.option(name, default = nil, options = nil, &block); end
  def self.options; end
  extend Seahorse::Client::HandlerBuilder
end
class InvalidName___Class_0x00___CodeLiteral_102 < String
  def inspect; end
end
class Seahorse::Client::Plugin::PluginOption
  def default; end
  def default=(arg0); end
  def default_block; end
  def default_block=(arg0); end
  def doc_default(options); end
  def doc_default=(arg0); end
  def doc_type; end
  def doc_type=(arg0); end
  def docstring; end
  def docstring=(arg0); end
  def documented?; end
  def initialize(name, options = nil); end
  def name; end
  def rbs_type; end
  def rbs_type=(arg0); end
  def required; end
  def required=(arg0); end
end
class Seahorse::Client::PluginList
  def _add(plugin); end
  def add(plugin); end
  def each(&block); end
  def each_plugin(&block); end
  def initialize(plugins = nil, options = nil); end
  def remove(plugin); end
  def set(plugins); end
  include Enumerable
end
class Seahorse::Client::PluginList::PluginWrapper
  def canonical_name; end
  def eql?(other); end
  def hash; end
  def initialize(plugin); end
  def plugin; end
  def require_plugin; end
  def self.new(plugin); end
end
class Seahorse::Client::Request
  def context; end
  def handlers; end
  def initialize(handlers, context); end
  def send_request(options = nil, &block); end
  include Seahorse::Client::HandlerBuilder
end
class Seahorse::Client::RequestContext
  def [](key); end
  def []=(key, value); end
  def authorizer; end
  def authorizer=(arg0); end
  def client; end
  def client=(arg0); end
  def config; end
  def config=(arg0); end
  def http_request; end
  def http_request=(arg0); end
  def http_response; end
  def http_response=(arg0); end
  def initialize(options = nil); end
  def metadata; end
  def operation; end
  def operation=(arg0); end
  def operation_name; end
  def operation_name=(arg0); end
  def params; end
  def params=(arg0); end
  def retries; end
  def retries=(arg0); end
end
class Seahorse::Client::Response < Delegator
  def __getobj__; end
  def __setobj__(obj); end
  def checksum_validated; end
  def context; end
  def data; end
  def data=(arg0); end
  def error; end
  def error=(arg0); end
  def initialize(options = nil); end
  def on(range, &_block); end
  def on_complete(&block); end
  def on_success(&block); end
  def successful?; end
end
class Seahorse::Client::AsyncResponse
  def context; end
  def error; end
  def initialize(options = nil); end
  def join!; end
  def on(range, &block); end
  def on_complete(&block); end
  def successful?; end
  def wait; end
end
module Seahorse::Client::Http
end
class Seahorse::Client::Http::Headers
  def [](key); end
  def []=(key, value); end
  def clear; end
  def delete(key); end
  def each(&block); end
  def each_pair(&block); end
  def has_key?(key); end
  def include?(key); end
  def initialize(headers = nil); end
  def inspect; end
  def key?(key); end
  def keys; end
  def to_h; end
  def to_hash; end
  def update(headers); end
  def values; end
  def values_at(*keys); end
  include Enumerable
end
class Seahorse::Client::Http::Request
  def body; end
  def body=(io); end
  def body_contents; end
  def endpoint; end
  def endpoint=(endpoint); end
  def headers; end
  def headers=(arg0); end
  def http_method; end
  def http_method=(arg0); end
  def initialize(options = nil); end
end
class Seahorse::Client::Http::Response
  def body; end
  def body=(io); end
  def body_contents; end
  def emit(event_name, *args); end
  def error; end
  def headers; end
  def headers=(arg0); end
  def initialize(options = nil); end
  def listener(range, callback); end
  def on_data(&callback); end
  def on_done(status_code_range = nil, &callback); end
  def on_error(&callback); end
  def on_headers(status_code_range = nil, &block); end
  def on_success(status_code_range = nil, &callback); end
  def reset; end
  def signal_data(chunk); end
  def signal_done(options = nil); end
  def signal_error(networking_error); end
  def signal_headers(status_code, headers); end
  def status_code; end
  def status_code=(arg0); end
end
class Seahorse::Client::Http::AsyncResponse < Seahorse::Client::Http::Response
  def initialize(options = nil); end
  def signal_done(options = nil); end
  def signal_headers(headers); end
end
module Seahorse::Client::Logging
end
class Seahorse::Client::Logging::Handler < Seahorse::Client::Handler
  def call(context); end
  def format(config, response); end
  def log(config, response); end
end
class Seahorse::Client::Logging::Formatter
  def ==(other); end
  def _client_class(response); end
  def _error_class(response); end
  def _error_message(response); end
  def _http_request_body(response); end
  def _http_request_endpoint(response); end
  def _http_request_headers(response); end
  def _http_request_host(response); end
  def _http_request_method(response); end
  def _http_request_port(response); end
  def _http_request_scheme(response); end
  def _http_response_body(response); end
  def _http_response_headers(response); end
  def _http_response_status_code(response); end
  def _operation(response); end
  def _request_params(response); end
  def _retries(response); end
  def _time(response); end
  def eql?(other); end
  def format(response); end
  def initialize(pattern, options = nil); end
  def max_string_size; end
  def method_missing(method_name, *args); end
  def pattern; end
  def self.colored; end
  def self.default; end
  def self.short; end
  def summarize_array(array); end
  def summarize_file(path); end
  def summarize_hash(hash); end
  def summarize_string(str); end
  def summarize_string_hash(hash); end
  def summarize_symbol_hash(hash); end
  def summarize_value(value); end
end
module Seahorse::Client::NetHttp
end
module Seahorse::Client::NetHttp::Patches
  def self.apply!; end
end
module Seahorse::Client::NetHttp::Patches::PatchDefaultContentType
  def supply_default_content_type; end
end
class Seahorse::Client::NetHttp::ConnectionPool
  def _clean; end
  def clean!; end
  def empty!; end
  def http_continue_timeout; end
  def http_idle_timeout; end
  def http_open_timeout; end
  def http_proxy; end
  def http_proxy_parts; end
  def http_read_timeout; end
  def http_wire_trace; end
  def http_wire_trace?; end
  def initialize(options = nil); end
  def logger; end
  def remove_path_and_query(endpoint); end
  def request(endpoint, request, &block); end
  def self.for(options = nil); end
  def self.pool_options(options); end
  def self.pools; end
  def session_for(endpoint, &block); end
  def size; end
  def ssl_ca_bundle; end
  def ssl_ca_directory; end
  def ssl_ca_store; end
  def ssl_timeout; end
  def ssl_verify_peer; end
  def ssl_verify_peer?; end
  def start_session(endpoint); end
end
class Seahorse::Client::NetHttp::ConnectionPool::ExtendedSession < Delegator
  def __getobj__; end
  def __setobj__(obj); end
  def finish; end
  def initialize(http); end
  def last_used; end
  def request(*args, &block); end
end
class Seahorse::Client::NetHttp::Handler < Seahorse::Client::Handler
  def build_net_request(request); end
  def call(context); end
  def complete_response(req, resp, bytes_received); end
  def error_message(req, error); end
  def extract_headers(response); end
  def headers(request); end
  def net_http_request_class(request); end
  def pool_for(config); end
  def pool_options(config); end
  def session(config, req, &block); end
  def should_verify_bytes?(req, resp); end
  def transmit(config, req, resp); end
  def verify_bytes_received(resp, bytes_received); end
end
class Seahorse::Client::NetHttp::Handler::TruncatedBodyError < IOError
  def initialize(bytes_expected, bytes_received); end
end
class Seahorse::Client::NetHttp::Handler::InvalidHttpVerbError < StandardError
end
module Seahorse::Client::H2
end
class Seahorse::Client::H2::Connection
  def _debug_entry(str); end
  def _default_ca_bundle; end
  def _default_ca_directory; end
  def _nonblocking_connect(tcp, addr); end
  def _register_h2_callbacks; end
  def _tcp_socket(endpoint); end
  def _tls_context; end
  def close!; end
  def closed?; end
  def connect(endpoint); end
  def connection_read_timeout; end
  def connection_timeout; end
  def debug_output(msg, type = nil); end
  def enable_alpn; end
  def errors; end
  def http_wire_trace; end
  def initialize(options = nil); end
  def input_signal_thread; end
  def input_signal_thread=(arg0); end
  def logger; end
  def max_concurrent_streams; end
  def new_stream; end
  def ssl_ca_bundle; end
  def ssl_ca_directory; end
  def ssl_ca_store; end
  def ssl_verify_peer; end
  def ssl_verify_peer?; end
  def start(stream); end
end
class Seahorse::Client::H2::Handler < Seahorse::Client::Handler
  def _h2_headers(req); end
  def _register_callbacks(resp, stream, stream_mutex, close_condition, sync_queue); end
  def _send_initial_data(req, stream); end
  def _send_initial_headers(req, stream); end
  def call(context); end
  def error_message(req, error); end
end
module Seahorse::Client::Plugins
end
class Seahorse::Client::Plugins::ContentLength < Seahorse::Client::Plugin
end
class Seahorse::Client::Plugins::ContentLength::Handler < Seahorse::Client::Handler
  def call(context); end
end
class Seahorse::Client::Plugins::Endpoint < Seahorse::Client::Plugin
  def add_handlers(handlers, config); end
  def after_initialize(client); end
end
class Seahorse::Client::Plugins::Endpoint::Handler < Seahorse::Client::Handler
  def call(context); end
end
class Seahorse::Client::Plugins::Logging < Seahorse::Client::Plugin
  def add_handlers(handlers, config); end
end
class Seahorse::Client::Plugins::NetHttp < Seahorse::Client::Plugin
  def self.resolve_http_open_timeout(cfg); end
  def self.resolve_http_read_timeout(cfg); end
  def self.resolve_ssl_timeout(cfg); end
end
class Seahorse::Client::Plugins::H2 < Seahorse::Client::Plugin
end
class Seahorse::Client::Plugins::RaiseResponseErrors < Seahorse::Client::Plugin
  def add_handlers(handlers, config); end
end
class Seahorse::Client::Plugins::RaiseResponseErrors::Handler < Seahorse::Client::Handler
  def call(context); end
end
class Seahorse::Client::Plugins::ResponseTarget < Seahorse::Client::Plugin
end
class Seahorse::Client::Plugins::ResponseTarget::Handler < Seahorse::Client::Handler
  def add_event_listeners(context, target); end
  def call(context); end
  def io(target, headers); end
end
class Seahorse::Client::Plugins::ReadCallbackIO
  def handle_chunk(chunk); end
  def initialize(io, on_read = nil); end
  def io; end
  def read(*args); end
  def size(*args, **, &block); end
  extend Forwardable
end
class Seahorse::Client::Plugins::RequestCallback < Seahorse::Client::Plugin
end
class Seahorse::Client::Plugins::RequestCallback::OptionHandler < Seahorse::Client::Handler
  def add_response_events(on_chunk_received, context); end
  def call(context); end
end
class Seahorse::Client::Plugins::RequestCallback::ReadCallbackHandler < Seahorse::Client::Handler
  def call(context); end
  def unwrap_callback_body(context); end
end
module Seahorse::Model
end
class Seahorse::Model::Api
  def add_authorizer(name, authorizer); end
  def add_operation(name, operation); end
  def async_operation_names; end
  def authorizer(name); end
  def authorizer_names; end
  def authorizers(&block); end
  def endpoint_operation; end
  def endpoint_operation=(arg0); end
  def initialize; end
  def inspect(*args); end
  def metadata; end
  def metadata=(arg0); end
  def operation(name); end
  def operation_names; end
  def operations(&block); end
  def require_endpoint_discovery; end
  def require_endpoint_discovery=(arg0); end
  def version; end
  def version=(arg0); end
end
class Seahorse::Model::Operation
  def [](key); end
  def []=(key, value); end
  def async; end
  def async=(arg0); end
  def authorizer; end
  def authorizer=(arg0); end
  def deprecated; end
  def deprecated=(arg0); end
  def documentation; end
  def documentation=(arg0); end
  def endpoint_discovery; end
  def endpoint_discovery=(arg0); end
  def endpoint_operation; end
  def endpoint_operation=(arg0); end
  def endpoint_pattern; end
  def endpoint_pattern=(arg0); end
  def errors; end
  def errors=(arg0); end
  def http_checksum; end
  def http_checksum=(arg0); end
  def http_checksum_required; end
  def http_checksum_required=(arg0); end
  def http_method; end
  def http_method=(arg0); end
  def http_request_uri; end
  def http_request_uri=(arg0); end
  def initialize; end
  def input; end
  def input=(arg0); end
  def name; end
  def name=(arg0); end
  def output; end
  def output=(arg0); end
  def request_compression; end
  def request_compression=(arg0); end
  def require_apikey; end
  def require_apikey=(arg0); end
end
class Seahorse::Model::Authorizer
  def initialize; end
  def name; end
  def name=(arg0); end
  def placement; end
  def placement=(arg0); end
  def type; end
  def type=(arg0); end
end
module Seahorse::Model::Shapes
end
class Seahorse::Model::Shapes::ShapeRef
  def [](key); end
  def []=(key, value); end
  def deprecated; end
  def deprecated=(arg0); end
  def document; end
  def document=(arg0); end
  def documentation; end
  def documentation=(arg0); end
  def event; end
  def event=(arg0); end
  def eventheader; end
  def eventheader=(arg0); end
  def eventheader_type; end
  def eventheader_type=(arg0); end
  def eventpayload; end
  def eventpayload=(arg0); end
  def eventpayload_type; end
  def eventpayload_type=(arg0); end
  def eventstream; end
  def eventstream=(arg0); end
  def initialize(options = nil); end
  def location; end
  def location=(location); end
  def location_name; end
  def location_name=(location_name); end
  def required; end
  def required=(arg0); end
  def shape; end
  def shape=(arg0); end
end
class Seahorse::Model::Shapes::Shape
  def [](key); end
  def []=(key, value); end
  def documentation; end
  def documentation=(arg0); end
  def initialize(options = nil); end
  def name; end
  def name=(arg0); end
  def union; end
  def union=(arg0); end
end
class Seahorse::Model::Shapes::BlobShape < Seahorse::Model::Shapes::Shape
  def max; end
  def max=(arg0); end
  def min; end
  def min=(arg0); end
end
class Seahorse::Model::Shapes::BooleanShape < Seahorse::Model::Shapes::Shape
end
class Seahorse::Model::Shapes::FloatShape < Seahorse::Model::Shapes::Shape
  def max; end
  def max=(arg0); end
  def min; end
  def min=(arg0); end
end
class Seahorse::Model::Shapes::IntegerShape < Seahorse::Model::Shapes::Shape
  def max; end
  def max=(arg0); end
  def min; end
  def min=(arg0); end
end
class Seahorse::Model::Shapes::ListShape < Seahorse::Model::Shapes::Shape
  def flattened; end
  def flattened=(arg0); end
  def max; end
  def max=(arg0); end
  def member; end
  def member=(arg0); end
  def min; end
  def min=(arg0); end
end
class Seahorse::Model::Shapes::MapShape < Seahorse::Model::Shapes::Shape
  def flattened; end
  def flattened=(arg0); end
  def key; end
  def key=(arg0); end
  def max; end
  def max=(arg0); end
  def min; end
  def min=(arg0); end
  def value; end
  def value=(arg0); end
end
class Seahorse::Model::Shapes::StringShape < Seahorse::Model::Shapes::Shape
  def enum; end
  def enum=(arg0); end
  def max; end
  def max=(arg0); end
  def min; end
  def min=(arg0); end
end
class Seahorse::Model::Shapes::StructureShape < Seahorse::Model::Shapes::Shape
  def add_member(name, shape_ref); end
  def initialize(options = nil); end
  def member(name); end
  def member?(member_name); end
  def member_by_location_name(location_name); end
  def member_names; end
  def members; end
  def required; end
  def required=(arg0); end
  def struct_class; end
  def struct_class=(arg0); end
end
class Seahorse::Model::Shapes::UnionShape < Seahorse::Model::Shapes::StructureShape
  def add_member_subclass(member, subclass); end
  def initialize(options = nil); end
  def member_subclass(member); end
end
class Seahorse::Model::Shapes::TimestampShape < Seahorse::Model::Shapes::Shape
end
class Seahorse::Model::Shapes::DocumentShape < Seahorse::Model::Shapes::Shape
end
class Seahorse::Client::Base
  def after_initialize(plugins); end
  def build_config(plugins, options); end
  def build_handler_list(plugins); end
  def build_request(operation_name, params = nil); end
  def config; end
  def context_for(operation_name, params); end
  def handlers; end
  def initialize(plugins, options); end
  def inspect; end
  def operation_names; end
  def self.add_plugin(plugin); end
  def self.api; end
  def self.before_initialize(plugins, options); end
  def self.build_plugins(plugins); end
  def self.clear_plugins; end
  def self.define(options = nil); end
  def self.define_operation_methods; end
  def self.extend(options = nil); end
  def self.inherited(subclass); end
  def self.new(options = nil); end
  def self.plugins; end
  def self.remove_plugin(plugin); end
  def self.set_api(api); end
  def self.set_plugins(plugins); end
  include Seahorse::Client::HandlerBuilder
end
class Seahorse::Client::AsyncBase < Seahorse::Client::Base
  def close_connection; end
  def connection; end
  def connection_errors; end
  def initialize(plugins, options); end
  def new_connection; end
  def operation_names; end
end
module Aws
  def self.config; end
  def self.config=(config); end
  def self.eager_autoload!(*args); end
  def self.empty_connection_pools!; end
  def self.partition(partition_name); end
  def self.partitions; end
  def self.shared_config; end
  def self.use_bundled_cert!; end
end
module Aws::Deprecations
  def deprecated(method, options = nil); end
end
module Aws::CredentialProvider
  def credentials; end
  def expiration; end
  def set?; end
end
module Aws::RefreshingCredentials
  def async_expiration_length; end
  def credentials; end
  def initialize(options = nil); end
  def near_expiration?(expiration_length); end
  def refresh!; end
  def refresh_if_near_expiration!; end
  def sync_expiration_length; end
end
class Aws::AssumeRoleCredentials
  def assume_role_params; end
  def client; end
  def initialize(options = nil); end
  def refresh; end
  def self.assume_role_options; end
  include Aws::CredentialProvider
  include Aws::RefreshingCredentials
end
class Aws::AssumeRoleWebIdentityCredentials
  def _session_name; end
  def _token_from_file(path); end
  def client; end
  def initialize(options = nil); end
  def refresh; end
  def self.assume_role_web_identity_options; end
  include Aws::CredentialProvider
  include Aws::RefreshingCredentials
end
class Aws::Credentials
  def access_key_id; end
  def credentials; end
  def initialize(access_key_id, secret_access_key, session_token = nil); end
  def inspect; end
  def secret_access_key; end
  def session_token; end
  def set?; end
end
class Aws::CredentialProviderChain
  def assume_role_credentials(options); end
  def assume_role_web_identity_credentials(options); end
  def assume_role_with_profile(options, profile_name); end
  def determine_profile_name(options); end
  def env_credentials(_options); end
  def envar(keys); end
  def initialize(config = nil); end
  def instance_profile_credentials(options); end
  def process_credentials(options); end
  def providers; end
  def resolve; end
  def shared_credentials(options); end
  def sso_credentials(options); end
  def static_credentials(options); end
  def static_profile_assume_role_credentials(options); end
  def static_profile_assume_role_web_identity_credentials(options); end
  def static_profile_credentials(options); end
  def static_profile_process_credentials(options); end
  def static_profile_sso_credentials(options); end
end
class Aws::ECSCredentials
  def backoff(backoff); end
  def ecs_or_eks_ip?(ip_address); end
  def fetch_authorization_token; end
  def fetch_authorization_token_file(path); end
  def get_credentials; end
  def http_get(connection, path); end
  def initialize(options = nil); end
  def initialize_full_uri(endpoint); end
  def initialize_relative_uri(options, path); end
  def initialize_uri(options, credential_path, endpoint); end
  def ip_loopback?(ip_address); end
  def open_connection; end
  def refresh; end
  def retries; end
  def retry_errors(error_classes, options = nil); end
  def set_authorization_token(request); end
  def valid_ip_address?(ip_address); end
  def validate_authorization_token!(token); end
  def validate_full_uri!(full_uri); end
  def validate_full_uri_scheme!(full_uri); end
  include Aws::CredentialProvider
  include Aws::RefreshingCredentials
end
class Aws::ECSCredentials::Non200Response < RuntimeError
end
class Aws::ECSCredentials::TokenFileReadError < RuntimeError
end
class Aws::ECSCredentials::InvalidTokenError < RuntimeError
end
class Aws::InstanceProfileCredentials
  def _get_credentials(conn, token); end
  def _metadata_disabled?; end
  def backoff(backoff); end
  def empty_credentials?(creds); end
  def fetch_token(conn); end
  def get_credentials; end
  def http_get(connection, path, token = nil); end
  def http_put(connection, path, ttl); end
  def initialize(options = nil); end
  def open_connection; end
  def refresh; end
  def refresh_offset; end
  def resolve_disable_v1(options); end
  def resolve_endpoint(options, endpoint_mode); end
  def resolve_endpoint_mode(options); end
  def retries; end
  def retry_errors(error_classes, options = nil, &_block); end
  def token_set?; end
  def warn_expired_credentials; end
  include Aws::CredentialProvider
  include Aws::RefreshingCredentials
end
class Aws::InstanceProfileCredentials::Non200Response < RuntimeError
end
class Aws::InstanceProfileCredentials::TokenRetrivalError < RuntimeError
end
class Aws::InstanceProfileCredentials::TokenExpiredError < RuntimeError
end
class Aws::InstanceProfileCredentials::Token
  def expired?; end
  def initialize(value, ttl, created_time = nil); end
  def value; end
end
class Aws::IniParser
  def self.ini_parse(raw); end
end
class Aws::SharedCredentials
  def credentials; end
  def initialize(options = nil); end
  def inspect; end
  def loadable?; end
  def path; end
  def profile_name; end
  include Aws::CredentialProvider
end
class Aws::ProcessCredentials
  def _parse_payload_format_v1(creds_json); end
  def credentials_from_process; end
  def initialize(process); end
  def near_expiration?(expiration_length); end
  def refresh; end
  include Aws::CredentialProvider
  include Aws::RefreshingCredentials
end
class Aws::SSOCredentials
  def client; end
  def initialize(options = nil); end
  def read_cached_token; end
  def refresh; end
  def sso_cache_file; end
  include Aws::CredentialProvider
  include Aws::RefreshingCredentials
end
class Aws::Token
  def expiration; end
  def initialize(token, expiration = nil); end
  def inspect; end
  def set?; end
  def token; end
end
module Aws::TokenProvider
  def set?; end
  def token; end
end
class Aws::StaticTokenProvider
  def initialize(token, expiration = nil); end
  include Aws::TokenProvider
end
module Aws::RefreshingToken
  def expiration; end
  def initialize(options = nil); end
  def near_expiration?; end
  def refresh!; end
  def refresh_if_near_expiration; end
  def token; end
end
class Aws::SSOTokenProvider
  def can_refresh_token?(token_json); end
  def client; end
  def initialize(options = nil); end
  def read_cached_token; end
  def refresh; end
  def sso_cache_file; end
  def update_token_cache(token_json); end
  include Aws::RefreshingToken
  include Aws::TokenProvider
end
class Aws::TokenProviderChain
  def determine_profile_name(options); end
  def initialize(config = nil); end
  def providers; end
  def resolve; end
  def sso_token(options); end
  def static_profile_sso_token(options); end
end
module Aws::Plugins
end
class Aws::Plugins::BearerAuthorization < Seahorse::Client::Plugin
  def add_handlers(handlers, cfg); end
end
class Aws::Plugins::BearerAuthorization::Handler < Seahorse::Client::Handler
  def call(context); end
end
module Aws::ClientStubs
  def api_requests(options = nil); end
  def apply_stubs(operation_name, stubs); end
  def convert_stub(operation_name, stub); end
  def data_to_http_resp(operation_name, data); end
  def default_stub(operation_name); end
  def hash_to_http_resp(data); end
  def http_response_stub(operation_name, data); end
  def next_stub(context); end
  def protocol_helper; end
  def service_error_stub(error_code); end
  def setup_stubbing; end
  def stub_data(operation_name, data = nil); end
  def stub_responses(operation_name, *stubs); end
end
module Aws::AsyncClientStubs
  def send_events; end
  def setup_stubbing; end
  include Aws::ClientStubs
end
class Aws::AsyncClientStubs::StubStream
  def close; end
  def closed?; end
  def data(bytes, options = nil); end
  def initialize; end
  def send_events; end
  def send_events=(arg0); end
  def state; end
end
class Aws::EagerLoader
  def initialize; end
  def load(klass_or_module); end
  def loaded; end
end
module Aws::Errors
end
class Aws::Errors::NonSupportedRubyVersionError < RuntimeError
end
class Aws::Errors::ServiceError < RuntimeError
  def code; end
  def context; end
  def data; end
  def data=(arg0); end
  def initialize(context, message, data = nil); end
  def retryable?; end
  def self.code; end
  def self.code=(arg0); end
  def throttling?; end
end
class Aws::Errors::MetadataParserError < RuntimeError
  def initialize(*args); end
end
class Aws::Errors::MissingContentLength < RuntimeError
  def initialize(*args); end
end
class Aws::Errors::EndpointDiscoveryError < RuntimeError
  def initialize(*args); end
end
class Aws::Errors::MissingEndpointHostLabelValue < RuntimeError
  def initialize(name); end
end
class Aws::Errors::SignalEventError < RuntimeError
end
class Aws::Errors::EventStreamParserError < RuntimeError
end
class Aws::Errors::EventStreamBuilderError < RuntimeError
end
class Aws::Errors::EventError < RuntimeError
  def error_code; end
  def error_message; end
  def event_type; end
  def initialize(event_type, code, message); end
end
class Aws::Errors::InvalidARNError < RuntimeError
end
class Aws::Errors::InvalidARNRegionError < RuntimeError
  def initialize(*args); end
end
class Aws::Errors::InvalidARNPartitionError < RuntimeError
  def initialize(*args); end
end
class Aws::Errors::ChecksumError < RuntimeError
end
class Aws::Errors::NoSuchProfileError < RuntimeError
end
class Aws::Errors::NoSourceProfileError < RuntimeError
end
class Aws::Errors::InvalidCredentialSourceError < RuntimeError
end
class Aws::Errors::CredentialSourceConflictError < RuntimeError
end
class Aws::Errors::NoSourceCredentialsError < RuntimeError
end
class Aws::Errors::MissingCredentialsError < RuntimeError
  def initialize(*args); end
end
class Aws::Errors::MissingWebIdentityTokenFile < RuntimeError
  def initialize(*args); end
end
class Aws::Errors::InvalidProcessCredentialsPayload < RuntimeError
end
class Aws::Errors::InvalidSSOCredentials < RuntimeError
end
class Aws::Errors::InvalidSSOToken < RuntimeError
end
class Aws::Errors::MissingBearerTokenError < RuntimeError
  def initialize(*args); end
end
class Aws::Errors::SourceProfileCircularReferenceError < RuntimeError
end
class Aws::Errors::MissingRegionError < ArgumentError
  def initialize(*args); end
end
class Aws::Errors::InvalidRegionSetError < ArgumentError
  def initialize(*args); end
end
class Aws::Errors::InvalidRegionError < ArgumentError
  def initialize(*args); end
  def possible_regions; end
end
class Aws::Errors::NoSuchEndpointError < RuntimeError
  def context; end
  def endpoint; end
  def initialize(options = nil); end
  def original_error; end
  def possible_regions; end
end
class Aws::Errors::RetryCapacityNotAvailableError < RuntimeError
  def initialize(*args); end
end
module Aws::Errors::DynamicErrors
  def const_missing(constant); end
  def error_class(error_code); end
  def error_class_constant(error_code); end
  def error_const_set?(constant); end
  def self.extended(submodule); end
  def set_error_constant(constant); end
end
module Aws::PageableResponse
  def each(&block); end
  def each_page(&block); end
  def last_page?; end
  def next_page(params = nil); end
  def next_page?; end
  def next_page_params(params); end
  def next_response(params); end
  def pager; end
  def pager=(arg0); end
  def self.apply(base); end
end
class Aws::PageableResponse::LastPageError < RuntimeError
  def initialize(response); end
  def response; end
end
module Aws::PageableResponse::UnsafeEnumerableMethods
  def as_json(_options = nil); end
  def count; end
  def respond_to?(method_name, *args); end
  def to_h; end
  def to_json(options = nil); end
end
module Aws::PageableResponse::Extension
  def each(&block); end
  def each_page(&block); end
  def last_page?; end
  def next_page(params = nil); end
  def next_page?; end
  def next_page_params(params); end
  def next_response(params); end
  def pager; end
  def pager=(arg0); end
  include Aws::PageableResponse::UnsafeEnumerableMethods
  include Enumerable
end
class Aws::Pager
  def empty_value?(value); end
  def initialize(options); end
  def limit_key; end
  def next_tokens(response); end
  def prev_tokens(response); end
  def tokens; end
  def truncated?(response); end
end
class Aws::Pager::NullPager
  def limit_key; end
  def next_tokens; end
  def prev_tokens; end
  def truncated?(response); end
end
class Aws::ParamConverter
  def c(ref, value); end
  def close_opened_files; end
  def convert(params); end
  def initialize(rules); end
  def list(ref, values); end
  def map(ref, values); end
  def member(ref, value); end
  def opened_files; end
  def self.add(shape_class, value_class, converter = nil, &block); end
  def self.c(shape, value, instance = nil); end
  def self.convert(shape, params); end
  def self.converter_for(shape_class, value); end
  def self.each_base_class(shape_class, &block); end
  def self.ensure_open(file, converter); end
  def self.find(shape_class, value); end
  def structure(ref, values); end
  include Seahorse::Model::Shapes
end
class Aws::ParamValidator
  def correct_type?(ref, value, errors, context); end
  def document(ref, value, errors, context); end
  def error_messages(errors); end
  def expected_got(context, expected, got); end
  def initialize(rules, options = nil); end
  def io_like?(value, require_size = nil); end
  def list(ref, values, errors, context); end
  def map(ref, values, errors, context); end
  def self.validate!(rules, params); end
  def shape(ref, value, errors, context); end
  def streaming_input?(ref); end
  def structure(ref, values, errors, context); end
  def validate!(params); end
  include Seahorse::Model::Shapes
end
class Aws::SharedConfig
  def adaptive_retry_wait_to_fill(opts = nil); end
  def assume_role_credentials_from_config(opts = nil); end
  def assume_role_from_profile(cfg, profile, opts, chain_config); end
  def assume_role_process_credentials_from_config(profile); end
  def assume_role_web_identity_credentials_from_config(opts = nil); end
  def ca_bundle(opts = nil); end
  def config_enabled?; end
  def config_path; end
  def configured_endpoint(opts = nil); end
  def correct_clock_skew(opts = nil); end
  def credential_process(opts = nil); end
  def credentials(opts = nil); end
  def credentials_from_config(profile, _opts); end
  def credentials_from_profile(prof_config); end
  def credentials_from_shared(profile, _opts); end
  def credentials_from_source(credential_source, config); end
  def credentials_path; end
  def csm_client_id(opts = nil); end
  def csm_enabled(opts = nil); end
  def csm_host(opts = nil); end
  def csm_port(opts = nil); end
  def default_shared_config_path(file); end
  def defaults_mode(opts = nil); end
  def determine_config_path; end
  def determine_credentials_path; end
  def determine_profile(options); end
  def disable_request_compression(opts = nil); end
  def ec2_metadata_service_endpoint(opts = nil); end
  def ec2_metadata_service_endpoint_mode(opts = nil); end
  def ec2_metadata_v1_disabled(opts = nil); end
  def endpoint_discovery_enabled(opts = nil); end
  def fresh(options = nil); end
  def get_config_value(key, opts); end
  def ignore_configured_endpoint_urls(opts = nil); end
  def initialize(options = nil); end
  def load_config_file; end
  def load_credentials_file; end
  def loadable?(path); end
  def max_attempts(opts = nil); end
  def profile_name; end
  def region(opts = nil); end
  def request_min_compression_size_bytes(opts = nil); end
  def resolve_source_profile(profile, opts = nil); end
  def retry_mode(opts = nil); end
  def s3_disable_express_session_auth(opts = nil); end
  def s3_disable_multiregion_access_points(opts = nil); end
  def s3_us_east_1_regional_endpoint(opts = nil); end
  def s3_use_arn_region(opts = nil); end
  def sdk_ua_app_id(opts = nil); end
  def self.config_reader(*attrs); end
  def sigv4a_signing_region_set(opts = nil); end
  def sso_credentials_from_config(opts = nil); end
  def sso_credentials_from_profile(cfg, profile); end
  def sso_session(cfg, profile, sso_session_name); end
  def sso_token_from_config(opts = nil); end
  def sso_token_from_profile(cfg, profile); end
  def sts_regional_endpoints(opts = nil); end
  def use_dualstack_endpoint(opts = nil); end
  def use_fips_endpoint(opts = nil); end
  def validate_profile_exists(profile); end
end
module Aws::Structure
  def empty?; end
  def initialize(values = nil); end
  def key?(member_name); end
  def self.new(*args); end
  def to_h(obj = nil, options = nil); end
  def to_hash(obj = nil, options = nil); end
  def to_s(obj = nil); end
end
module Aws::Structure::Union
  def member; end
  def value; end
end
class Struct::AwsEmptyStructure < Struct
  def self.[](*arg0); end
  def self.inspect; end
  def self.keyword_init?; end
  def self.members; end
  def self.new(*arg0); end
end
class Aws::EmptyStructure < Struct::AwsEmptyStructure
  include Aws::Structure
end
class Aws::TypeBuilder
  def build_type(shape, shapes); end
  def initialize(svc_module); end
end
module Aws::Util
  def self.copy_hash(hash); end
  def self.deep_copy(obj); end
  def self.deep_merge(left, right); end
  def self.deserialize_number(str); end
  def self.deserialize_time(value); end
  def self.monotonic_milliseconds; end
  def self.monotonic_seconds; end
  def self.serialize_number(input); end
  def self.str_2_bool(str); end
end
module Aws::Resources
end
class Aws::Resources::Collection
  def [](*args, &block); end
  def batch_enum; end
  def batches; end
  def each(&block); end
  def first(count = nil); end
  def initialize(batches, options = nil); end
  def length; end
  def limit(limit); end
  def limited_batches; end
  def non_empty_batches; end
  def size; end
  extend Aws::Deprecations
  include Enumerable
end
module Aws::Log
end
class Aws::Log::Formatter
  def _client_class(response); end
  def _error_class(response); end
  def _error_message(response); end
  def _http_request_body(response); end
  def _http_request_endpoint(response); end
  def _http_request_headers(response); end
  def _http_request_host(response); end
  def _http_request_method(response); end
  def _http_request_port(response); end
  def _http_request_scheme(response); end
  def _http_response_body(response); end
  def _http_response_headers(response); end
  def _http_response_status_code(response); end
  def _operation(response); end
  def _region(response); end
  def _request_params(response); end
  def _retries(response); end
  def _time(response); end
  def format(response); end
  def initialize(pattern, options = nil); end
  def method_missing(method_name, *args); end
  def pattern; end
  def self.colored(options = nil); end
  def self.default(options = nil); end
  def self.short(options = nil); end
end
class Aws::Log::ParamFilter
  def filter(values, type); end
  def filter_array(values, type); end
  def filter_hash(values, type); end
  def filter_struct(values, type); end
  def initialize(options = nil); end
end
class Aws::Log::ParamFormatter
  def initialize(options = nil); end
  def summarize(value); end
  def summarize_array(array); end
  def summarize_file(path); end
  def summarize_hash(hash); end
  def summarize_string(str); end
  def summarize_string_hash(hash); end
  def summarize_symbol_hash(hash); end
  def summarize_value(value); end
end
module Aws::Stubbing
end
class Aws::Stubbing::EmptyStub
  def initialize(rules); end
  def stub; end
  def stub_ref(ref, visited = nil); end
  def stub_scalar(ref); end
  def stub_structure(ref, visited); end
  include Seahorse::Model::Shapes
end
class Aws::Stubbing::DataApplicator
  def apply_data(data, stub); end
  def apply_data_to_struct(ref, data, struct); end
  def initialize(rules); end
  def member_value(ref, value); end
  include Seahorse::Model::Shapes
end
class Aws::Stubbing::StubData
  def apply_data(data, stub); end
  def initialize(operation); end
  def remove_checksums(stub); end
  def remove_paging_tokens(stub); end
  def stub(data = nil); end
end
class Aws::Stubbing::XmlError
  def initialize(error_code); end
  def to_xml; end
end
module Aws::Stubbing::Protocols
end
class Aws::Stubbing::Protocols::Json
  def build_body(operation, data); end
  def content_type(api); end
  def stub_data(api, operation, data); end
  def stub_error(error_code); end
end
class Aws::Stubbing::Protocols::Rest
  def apply_body(api, operation, resp, data); end
  def apply_headers(operation, resp, data); end
  def apply_status_code(operation, resp, data); end
  def build_body(api, operation, data); end
  def encode_error(opts, event_data); end
  def encode_event(opts, rules, event_data, builder); end
  def encode_eventstream_response(rules, data, builder); end
  def encode_modeled_event(opts, rules, event_type, event_data, builder); end
  def encode_unknown_event(opts, event_type, event_data); end
  def eventstream?(rules); end
  def head_operation(operation); end
  def new_http_response; end
  def streaming?(ref); end
  def stub_data(api, operation, data); end
  include Seahorse::Model::Shapes
end
class Aws::Stubbing::Protocols::RestJson < Aws::Stubbing::Protocols::Rest
  def body_for(_a, _b, rules, data); end
  def stub_error(error_code); end
end
class Aws::Stubbing::Protocols::RestXml < Aws::Stubbing::Protocols::Rest
  def body_for(api, operation, rules, data); end
  def stub_error(error_code); end
  def xmlns(api); end
end
class Aws::Stubbing::Protocols::Query
  def build_body(api, operation, data); end
  def stub_data(api, operation, data); end
  def stub_error(error_code); end
  def xmlns(api); end
end
class Aws::Stubbing::Protocols::EC2
  def build_body(api, operation, data); end
  def stub_data(api, operation, data); end
  def stub_error(error_code); end
end
class Aws::Stubbing::Protocols::RpcV2
  def build_body(operation, data); end
  def content_type(api); end
  def stub_data(api, operation, data); end
  def stub_error(error_code); end
end
class Aws::Stubbing::Protocols::ApiGateway < Aws::Stubbing::Protocols::RestJson
end
class Aws::ErrorHandler < Seahorse::Client::Handler
  def build_error(context, code, message, data); end
  def error(context); end
  def http_status_error(context); end
  def http_status_error_code(context); end
end
module Aws::Rest
end
class Aws::Rest::Handler < Seahorse::Client::Handler
  def apply_request_id(context); end
  def call(context); end
end
class Aws::Rest::ContentTypeHandler < Seahorse::Client::Handler
  def apply_default_content_type(context); end
  def call(context); end
  def eventstream?(context); end
  def non_empty_body?(body); end
end
module Aws::Rest::Request
end
class Aws::Rest::Request::Body
  def apply(http_req, params); end
  def body_params(params); end
  def build_body(params); end
  def initialize(serializer_class, rules); end
  def json_builder?; end
  def modeled_body?; end
  def payload_location_name; end
  def serialize(rules, params, location_name: nil); end
  def streaming?; end
  def xml_builder?; end
  include Seahorse::Model::Shapes
end
class Aws::Rest::Request::Builder
  def apply(context); end
  def populate_body(context); end
  def populate_endpoint(context); end
  def populate_headers(context); end
  def populate_http_method(context); end
  def serializer_class(context); end
end
class Aws::Rest::Request::Endpoint
  def apply_path_params(uri, params); end
  def apply_querystring_params(uri, params); end
  def escape(string); end
  def initialize(rules, request_uri_pattern); end
  def param_name(placeholder); end
  def param_value_for_placeholder(placeholder, params); end
  def timestamp(ref, value); end
  def uri(base_uri, params); end
end
class Aws::Rest::Request::Headers
  def apply(http_req, params); end
  def apply_header_map(headers, ref, values); end
  def apply_header_value(headers, ref, value); end
  def apply_json_trait(value); end
  def initialize(rules); end
  def list(headers, ref, values); end
  def timestamp(ref, value); end
  include Seahorse::Model::Shapes
end
class Aws::Rest::Request::QuerystringBuilder
  def build(params); end
  def build_part(shape_ref, param_value, query_keys); end
  def escape(string); end
  def generate_query_list(ref, values); end
  def generate_query_map(ref, value, query_keys); end
  def query_keys(params); end
  def query_map_of_string(hash, query_keys); end
  def query_map_of_string_list(hash, query_keys); end
  def query_value(ref, value); end
  def timestamp(ref, value); end
  include Seahorse::Model::Shapes
end
module Aws::Rest::Response
end
class Aws::Rest::Response::Body
  def apply(body, data); end
  def empty_blob_payload?(body); end
  def empty_body?(body); end
  def event_stream?; end
  def initialize(parser_class, rules); end
  def non_streaming_blob_payload?; end
  def parse(body, rules, target = nil); end
  def parse_eventstream(body); end
  def streaming?; end
  include Seahorse::Model::Shapes
end
module Aws::Rest::Response::HeaderListParser
  def self.parse_string_list(value); end
  def self.parse_timestamp_list(value, ref); end
  def self.read_quoted_value(buffer); end
  def self.read_unquoted_value(buffer); end
  def self.read_value(buffer); end
end
class Aws::Rest::Response::Headers
  def apply(http_resp, target); end
  def cast_value(ref, value); end
  def extract_header_map(headers, name, ref, data); end
  def extract_header_value(headers, name, ref, data); end
  def extract_json_trait(value); end
  def initialize(rules); end
  include Seahorse::Model::Shapes
end
class Aws::Rest::Response::Parser
  def apply(response); end
  def extract_body(rules, response); end
  def extract_headers(rules, response); end
  def extract_status_code(rules, response); end
  def parser_class(response); end
end
class Aws::Rest::Response::StatusCode
  def apply(http_resp, data); end
  def initialize(rules); end
end
module Aws::Xml
end
class Aws::Xml::Builder
  def blob(value); end
  def initialize(rules, options = nil); end
  def list(name, ref, values); end
  def map(name, ref, hash); end
  def member(name, ref, value); end
  def node(name, ref, *args, &block); end
  def serialize(params); end
  def shape_attrs(ref); end
  def structure(name, ref, values); end
  def structure_attrs(ref, values); end
  def timestamp(ref, value); end
  def to_xml(params); end
  def xml_attribute?(ref); end
  include Seahorse::Model::Shapes
end
class Aws::Xml::DefaultList < Array
  def nil?; end
end
class Aws::Xml::DefaultMap < Hash
  def nil?; end
end
class Aws::Xml::DocBuilder
  def attributes(attr); end
  def close_el(name); end
  def empty_element(name, attrs); end
  def escape(string, text_or_attr); end
  def increase_pad(&block); end
  def initialize(options = nil); end
  def inline_element(name, value, attrs); end
  def node(name, *args, &block); end
  def open_el(name, attrs); end
  def target; end
end
class Aws::Xml::ErrorHandler < Aws::ErrorHandler
  def apply_error_headers(rule, context, data); end
  def call(context); end
  def error_code(body, context); end
  def error_data(context, body, code); end
  def error_message(body); end
  def extract_error(body, context); end
  def parse_error_data(rule, body); end
  def remove_prefix(error_code, context); end
  def request_id(body); end
  def unescape(str); end
end
class Aws::Xml::Parser
  def initialize(rules, options = nil); end
  def parse(xml, target = nil, &unhandled_callback); end
  def self.engine; end
  def self.engine=(engine); end
  def self.load_engine(name); end
  def self.set_default_engine; end
  def self.try_load_engine(name); end
  include Seahorse::Model::Shapes
end
class Aws::Xml::Parser::NokogiriEngine
  def characters(chars); end
  def comment(*args); end
  def end_document; end
  def end_element_namespace(*ignored); end
  def error(msg); end
  def initialize(stack); end
  def parse(xml); end
  def start_document; end
  def start_element_namespace(element_name, attributes = nil, *ignored); end
  def xmldecl(*args); end
end
class Aws::Xml::Parser::Stack
  def attr(name, value); end
  def child_frame(name); end
  def consume_child_frame(frame); end
  def end_element(*args); end
  def error(msg, line = nil, column = nil); end
  def frame; end
  def initialize(ref, result = nil, &unhandled_callback); end
  def result; end
  def start_element(name); end
  def text(value); end
  def yield_unhandled_value(path, value); end
end
class Aws::Xml::Parser::Frame
  def child_frame(xml_name); end
  def consume_child_frame(child); end
  def initialize(path, parent, ref, result); end
  def parent; end
  def path; end
  def ref; end
  def result; end
  def self.frame_class(ref); end
  def self.new(path, parent, ref, result = nil); end
  def set_text(value); end
  def yield_unhandled_value(path, value); end
  include Seahorse::Model::Shapes
end
class Aws::Xml::Parser::StructureFrame < Aws::Xml::Parser::Frame
  def apply_default_value(name, ref); end
  def child_frame(xml_name); end
  def consume_child_frame(child); end
  def flattened_list?(ref); end
  def initialize(xml_name, parent, ref, result = nil); end
  def xml_name(ref); end
end
class Aws::Xml::Parser::ListFrame < Aws::Xml::Parser::Frame
  def child_frame(xml_name); end
  def consume_child_frame(child); end
  def initialize(*args); end
end
class Aws::Xml::Parser::FlatListFrame < Aws::Xml::Parser::Frame
  def child_frame(xml_name); end
  def consume_child_frame(child); end
  def initialize(xml_name, *args); end
  def result; end
  def set_text(value); end
end
class Aws::Xml::Parser::MapFrame < Aws::Xml::Parser::Frame
  def child_frame(xml_name); end
  def consume_child_frame(child); end
  def initialize(*args); end
end
class Aws::Xml::Parser::MapEntryFrame < Aws::Xml::Parser::Frame
  def child_frame(xml_name); end
  def initialize(xml_name, *args); end
  def key; end
  def value; end
end
class Aws::Xml::Parser::NullFrame < Aws::Xml::Parser::Frame
  def self.new(xml_name, parent); end
  def set_text(value); end
end
class Aws::Xml::Parser::UnknownMemberFrame < Aws::Xml::Parser::Frame
  def result; end
end
class Aws::Xml::Parser::BlobFrame < Aws::Xml::Parser::Frame
  def result; end
end
class Aws::Xml::Parser::BooleanFrame < Aws::Xml::Parser::Frame
  def result; end
end
class Aws::Xml::Parser::FloatFrame < Aws::Xml::Parser::Frame
  def result; end
end
class Aws::Xml::Parser::IntegerFrame < Aws::Xml::Parser::Frame
  def result; end
end
class Aws::Xml::Parser::StringFrame < Aws::Xml::Parser::Frame
  def result; end
end
class Aws::Xml::Parser::TimestampFrame < Aws::Xml::Parser::Frame
  def result; end
end
class Aws::Xml::Parser::ParsingError < RuntimeError
  def column; end
  def initialize(msg, line, column); end
  def line; end
end
module Aws::Json
  def self.dump(value); end
  def self.engine; end
  def self.engine=(engine); end
  def self.load(json); end
  def self.load_engine(name); end
  def self.set_default_engine; end
  def self.try_load_engine(name); end
end
class Aws::Json::Builder
  def encode(blob); end
  def format(ref, value); end
  def initialize(rules, _options = nil); end
  def list(ref, values); end
  def map(ref, values); end
  def serialize(params); end
  def structure(ref, values); end
  def timestamp(ref, value); end
  def to_json(params); end
  include Seahorse::Model::Shapes
end
class Aws::Json::ErrorHandler < Aws::ErrorHandler
  def apply_error_headers(rule, context, data); end
  def aws_query_error?(context); end
  def call(context); end
  def error_code(json, context); end
  def error_message(code, json); end
  def extract_error(body, context); end
  def parse_error_data(context, body, code); end
  def remove_prefix(error_code, context); end
end
class Aws::Json::Handler < Seahorse::Client::Handler
  def apply_request_id(context); end
  def build_body(context); end
  def build_request(context); end
  def call(context); end
  def content_type(context); end
  def parse_body(context); end
  def parse_response(response); end
  def query_compatible?(context); end
  def simple_json?(context); end
  def target(context); end
end
class Aws::Json::Parser
  def flattened_list?(shape); end
  def flattened_map?(shape); end
  def initialize(rules, query_compatible: nil); end
  def list(ref, values, target = nil); end
  def map(ref, values, target = nil); end
  def parse(json, target = nil); end
  def parse_ref(ref, value, target = nil); end
  def structure(ref, values, target = nil); end
  def time(value); end
  include Seahorse::Model::Shapes
end
module Aws::Json::JsonEngine
  def self.dump(value); end
  def self.load(json); end
end
class Aws::Json::ParseError < StandardError
  def error; end
  def initialize(error); end
end
module Aws::Query
end
class Aws::Query::Handler < Seahorse::Client::Handler
  def apply_params(param_list, params, rules); end
  def build_request(context); end
  def call(context); end
  def parse_xml(context); end
  def remove_wrapper(data, context); end
  def rules(context); end
  def xml(context); end
  include Seahorse::Model::Shapes
end
class Aws::Query::Handler::WRAPPER_STRUCT < Struct
  def response_metadata; end
  def response_metadata=(_); end
  def result; end
  def result=(_); end
  def self.[](*arg0); end
  def self.inspect; end
  def self.keyword_init?; end
  def self.members; end
  def self.new(*arg0); end
end
class Aws::Query::Handler::METADATA_STRUCT < Struct
  def request_id; end
  def request_id=(_); end
  def self.[](*arg0); end
  def self.inspect; end
  def self.keyword_init?; end
  def self.members; end
  def self.new(*arg0); end
end
class Aws::Query::EC2Handler < Aws::Query::Handler
  def apply_params(param_list, params, rules); end
  def parse_xml(context); end
end
class Aws::Query::Param
  def <=>(other); end
  def ==(other); end
  def escape(str); end
  def initialize(name, value = nil); end
  def name; end
  def to_s; end
  def value; end
end
class Aws::Query::ParamBuilder
  def apply(ref, params); end
  def blob(value); end
  def flat?(ref); end
  def format(ref, value, prefix); end
  def initialize(param_list); end
  def list(ref, values, prefix); end
  def map(ref, values, prefix); end
  def params; end
  def query_name(ref, default = nil); end
  def set(name, value); end
  def structure(ref, values, prefix); end
  def timestamp(ref, value); end
  include Seahorse::Model::Shapes
end
class Aws::Query::EC2ParamBuilder
  def apply(ref, params); end
  def blob(value); end
  def format(ref, value, prefix); end
  def initialize(param_list); end
  def list(ref, values, prefix); end
  def params; end
  def query_name(ref); end
  def set(name, value); end
  def structure(ref, values, prefix); end
  def timestamp(ref, value); end
  def ucfirst(str); end
  include Seahorse::Model::Shapes
end
class Aws::Query::ParamList
  def [](param_name); end
  def []=(param_name, param_value = nil); end
  def delete(param_name); end
  def each(&block); end
  def empty?; end
  def initialize; end
  def set(param_name, param_value = nil); end
  def to_a; end
  def to_io; end
  def to_s; end
  include Enumerable
end
class Aws::Query::ParamList::IoWrapper
  def initialize(param_list); end
  def param_list; end
  def read(bytes = nil, output_buffer = nil); end
  def rewind; end
  def size; end
end
module Aws::Cbor
  def self.decode(bytes); end
  def self.encode(data); end
  def self.engine; end
  def self.engine=(engine); end
  def self.load_engine(name); end
  def self.set_default_engine; end
  def self.try_load_engine(name); end
end
class Aws::Cbor::Encoder
  def add(value); end
  def add_auto_float(value); end
  def add_auto_integer(value); end
  def add_big_decimal(value); end
  def add_bignum(value); end
  def add_boolean(value); end
  def add_byte_string(value); end
  def add_double(value); end
  def add_float(value); end
  def add_integer(value); end
  def add_nil; end
  def add_string(value); end
  def add_tag(tag); end
  def add_time(value); end
  def bignum_to_bytes(value); end
  def bytes; end
  def end_indefinite_collection; end
  def head(major_type, value); end
  def initialize; end
  def start_array(length); end
  def start_indefinite_array; end
  def start_indefinite_map; end
  def start_map(length); end
end
class Aws::Cbor::Decoder
  def decode; end
  def decode_item; end
  def initialize(bytes); end
  def peek(n_bytes); end
  def peek_type; end
  def read_array; end
  def read_big_decimal; end
  def read_bignum(tag_value); end
  def read_binary_string; end
  def read_boolean; end
  def read_break_stop_code; end
  def read_count(add_info); end
  def read_double; end
  def read_end_indefinite_collection; end
  def read_float; end
  def read_half; end
  def read_info; end
  def read_integer; end
  def read_map; end
  def read_nil; end
  def read_reserved_undefined; end
  def read_start_indefinite_array; end
  def read_start_indefinite_map; end
  def read_string; end
  def read_tag; end
  def read_undefined; end
  def take(n_bytes); end
end
module Aws::Cbor::CborEngine
  def self.decode(bytes); end
  def self.encode(data); end
end
class Aws::Cbor::Tagged < Struct
  def self.[](*arg0); end
  def self.inspect; end
  def self.keyword_init?; end
  def self.members; end
  def self.new(*arg0); end
  def tag; end
  def tag=(_); end
  def value; end
  def value=(_); end
end
class Aws::Cbor::Error < StandardError
end
class Aws::Cbor::OutOfBytesError < Aws::Cbor::Error
  def initialize(n, left); end
end
class Aws::Cbor::UnknownTypeError < Aws::Cbor::Error
  def initialize(type); end
end
class Aws::Cbor::ExtraBytesError < Aws::Cbor::Error
  def initialize(pos, size); end
end
class Aws::Cbor::UnexpectedBreakCodeError < Aws::Cbor::Error
end
class Aws::Cbor::UnexpectedAdditionalInformationError < Aws::Cbor::Error
  def initialize(add_info); end
end
module Aws::RpcV2
end
class Aws::RpcV2::Handler < Seahorse::Client::Handler
  def apply_request_id(context); end
  def build_body(context); end
  def build_request(context); end
  def build_url(context); end
  def call(context); end
  def parse_body(context); end
  def query_compatible?(context); end
end
class Aws::RpcV2::ContentTypeHandler < Seahorse::Client::Handler
  def call(context); end
  def empty_input_structure?(context); end
  def eventstream_input?(context); end
  def eventstream_output?(context); end
end
class Aws::RpcV2::ErrorHandler < Aws::ErrorHandler
  def aws_query_error?(context); end
  def call(context); end
  def error_code(data, context); end
  def extract_error(body, context); end
  def parse_error_data(context, body, code); end
  def remove_prefix(error_code, context); end
  def valid_response?(context); end
end
class Aws::RpcV2::Builder
  def blob(value); end
  def format(ref, value); end
  def initialize(rules, _options = nil); end
  def list(ref, values); end
  def map(ref, values); end
  def serialize(params); end
  def structure(ref, values); end
  include Seahorse::Model::Shapes
end
class Aws::RpcV2::Parser
  def initialize(rules, query_compatible: nil); end
  def list(ref, values, target = nil); end
  def map(ref, values, target = nil); end
  def parse(cbor, target = nil); end
  def parse_ref(ref, value, target = nil); end
  def structure(ref, values, target = nil); end
  include Seahorse::Model::Shapes
end
module Aws::Binary
end
class Aws::Binary::DecodeHandler < Seahorse::Client::Handler
  def attach_eventstream_listeners(context, rules); end
  def call(context); end
  def eventstream?(ctx); end
end
class Aws::Binary::EncodeHandler < Seahorse::Client::Handler
  def call(context); end
  def eventstream_input?(ctx); end
  def signer_for(context); end
end
class Aws::Binary::EventStreamDecoder
  def emit_event(raw_event); end
  def events; end
  def extract_stream_class(type_class); end
  def initialize(protocol, rules, output_ref, error_refs, io, event_stream_handler = nil); end
  def parser_class(protocol); end
  def write(chunk); end
end
class Aws::Binary::EventStreamEncoder
  def encode(event_type, params); end
  def initialize(protocol, rules, input_ref, signer); end
  def prior_signature; end
  def prior_signature=(arg0); end
  def rules; end
  def serializer_class(protocol); end
end
class Aws::Binary::EventBuilder
  def _event_stream_message(event_ref, params); end
  def apply(event_type, params); end
  def build_payload_members(payload_ref, params); end
  def content_type(shape); end
  def header_value_type(shape, value); end
  def initialize(serializer_class, rules); end
  include Seahorse::Model::Shapes
end
class Aws::Binary::EventParser
  def apply(raw_event); end
  def eventpayload_streaming?(ref); end
  def initialize(parser_class, rules, error_refs, output_ref); end
  def parse(raw_event); end
  def parse_error_event(raw_event); end
  def parse_event(raw_event); end
  def parse_exception(raw_event); end
  def parse_payload(body, rules); end
  include Seahorse::Model::Shapes
end
class Aws::EventEmitter
  def emit(type, params); end
  def encoder; end
  def encoder=(arg0); end
  def initialize; end
  def on(type, callback); end
  def signal(type, event); end
  def signal_queue; end
  def signal_queue=(arg0); end
  def stream; end
  def stream=(arg0); end
  def validate_event; end
  def validate_event=(arg0); end
end
class Aws::EndpointCache
  def [](key); end
  def []=(key, value); end
  def _endpoint_operation_identifier(ctx); end
  def _request_endpoint(ctx); end
  def delete(key); end
  def delete_polling_thread(key); end
  def extract_key(ctx); end
  def initialize(options = nil); end
  def key?(key); end
  def max_entries; end
  def max_threads; end
  def pool; end
  def stop_polling!; end
  def threads_key?(key); end
  def update(key, ctx); end
  def update_polling_pool(key, thread); end
end
class Aws::EndpointCache::Endpoint
  def address; end
  def expired?; end
  def initialize(options); end
end
module Aws::ClientSideMonitoring
end
class Aws::ClientSideMonitoring::RequestMetrics
  def add_call_attempt(attempt); end
  def api_call; end
  def api_call_attempts; end
  def build_call_attempt(opts = nil); end
  def initialize(opts = nil); end
end
class Aws::ClientSideMonitoring::RequestMetrics::ApiCall
  def _truncate(document); end
  def api; end
  def attempt_count; end
  def client_id; end
  def complete(opts = nil); end
  def final_aws_exception; end
  def final_aws_exception_message; end
  def final_http_status_code; end
  def final_sdk_exception; end
  def final_sdk_exception_message; end
  def initialize(service, api, client_id, version, timestamp, region); end
  def latency; end
  def max_retries_exceeded; end
  def region; end
  def service; end
  def timestamp; end
  def to_json(*a); end
  def user_agent; end
  def version; end
end
class Aws::ClientSideMonitoring::RequestMetrics::ApiCallAttempt
  def _truncate(document); end
  def access_key; end
  def api; end
  def aws_exception; end
  def aws_exception=(arg0); end
  def aws_exception_msg; end
  def aws_exception_msg=(arg0); end
  def client_id; end
  def fqdn; end
  def fqdn=(arg0); end
  def http_status_code; end
  def http_status_code=(arg0); end
  def initialize(service, api, client_id, version, timestamp, fqdn, region, user_agent, access_key, session_token); end
  def region; end
  def region=(arg0); end
  def request_latency; end
  def request_latency=(arg0); end
  def sdk_exception; end
  def sdk_exception=(arg0); end
  def sdk_exception_msg; end
  def sdk_exception_msg=(arg0); end
  def service; end
  def session_token; end
  def timestamp; end
  def to_json(*a); end
  def user_agent; end
  def version; end
  def x_amz_id_2; end
  def x_amz_id_2=(arg0); end
  def x_amz_request_id; end
  def x_amz_request_id=(arg0); end
  def x_amzn_request_id; end
  def x_amzn_request_id=(arg0); end
end
class Aws::ClientSideMonitoring::Publisher
  def agent_host; end
  def agent_host=(value); end
  def agent_port; end
  def agent_port=(value); end
  def initialize(opts = nil); end
  def publish(request_metrics); end
  def send_datagram(msg); end
end
class Aws::ARN
  def account_id; end
  def as_json(_options = nil); end
  def initialize(options = nil); end
  def partition; end
  def region; end
  def resource; end
  def service; end
  def to_h; end
  def to_s; end
  def valid?; end
end
module Aws::ARNParser
  def self.arn?(str); end
  def self.parse(arn_str); end
end
class Aws::EC2Metadata
  def backoff(backoff); end
  def fetch_token; end
  def get(path); end
  def http_get(connection, path, token); end
  def http_put(connection, ttl); end
  def initialize(options = nil); end
  def open_connection; end
  def resolve_endpoint(endpoint, endpoint_mode); end
  def retry_errors(options = nil, &_block); end
end
class Aws::EC2Metadata::TokenRetrievalError < RuntimeError
end
class Aws::EC2Metadata::TokenExpiredError < RuntimeError
end
class Aws::EC2Metadata::MetadataNotFoundError < RuntimeError
end
class Aws::EC2Metadata::RequestForbiddenError < RuntimeError
end
class Aws::EC2Metadata::Token
  def expired?; end
  def initialize(options = nil); end
  def value; end
end
class Aws::LRUCache
  def [](key); end
  def []=(key, value); end
  def clear; end
  def initialize(options = nil); end
  def key?(key); end
end
class Aws::LRUCache::Entry
  def expired?; end
  def initialize(options = nil); end
  def value; end
end
module Aws::Endpoints
  def self.default_api_auth(context); end
  def self.default_auth_scheme(context); end
  def self.legacy_default_api_authtype(context); end
  def self.legacy_default_auth_scheme(context); end
  def self.merge_signing_defaults(auth_scheme, config); end
  def self.resolve_auth_scheme(context, endpoint); end
  def self.s3_or_s3v4_signature_version?(context); end
  def self.sigv4_name(config); end
end
class Aws::Endpoints::Rule
  def resolve_value(value, parameters, assigns); end
end
class Aws::Endpoints::Condition
  def argv; end
  def assign; end
  def assigned; end
  def fn; end
  def initialize(fn:, argv:, assign: nil); end
  def match?(parameters, assigns); end
  def self.from_json(conditions_json); end
end
class Aws::Endpoints::EndpointRule < Aws::Endpoints::Rule
  def conditions; end
  def documentation; end
  def endpoint; end
  def initialize(conditions:, endpoint:, type: nil, documentation: nil); end
  def match(parameters, assigned = nil); end
  def resolve_headers(parameters, assigns); end
  def resolve_properties(obj, parameters, assigns); end
  def resolved_endpoint(parameters, assigns); end
  def type; end
end
class Aws::Endpoints::Endpoint
  def headers; end
  def initialize(url:, properties: nil, headers: nil); end
  def properties; end
  def url; end
end
class Aws::Endpoints::ErrorRule < Aws::Endpoints::Rule
  def conditions; end
  def documentation; end
  def error; end
  def initialize(conditions:, type: nil, error: nil, documentation: nil); end
  def match(parameters, assigned = nil); end
  def resolved_error(parameters, assigns); end
  def type; end
end
class Aws::Endpoints::Function
  def argv; end
  def build_argv(argv_json); end
  def call(parameters, assigns); end
  def fn; end
  def initialize(fn:, argv:); end
end
module Aws::Endpoints::Matchers
  def self.attr(value, path); end
  def self.aws_parse_arn(value); end
  def self.aws_partition(value); end
  def self.aws_virtual_hostable_s3_bucket?(value, allow_sub_domains = nil); end
  def self.boolean_equals?(value1, value2); end
  def self.not(bool); end
  def self.parse_url(value); end
  def self.set?(value); end
  def self.string_equals?(value1, value2); end
  def self.substring(input, start, stop, reverse); end
  def self.uri_encode(value); end
  def self.valid_host_label?(value, allow_sub_domains = nil); end
end
class Aws::Endpoints::Reference
  def initialize(ref:); end
  def ref; end
  def resolve(parameters, assigns); end
end
class Aws::Endpoints::RulesProvider
  def initialize(rule_set); end
  def resolve_endpoint(parameters); end
  def resolve_rules(parameters); end
end
class Aws::Endpoints::RuleSet
  def initialize(version:, service_id:, parameters:, rules:); end
  def parameters; end
  def rules; end
  def self.rules_from_json(rules_json); end
  def service_id; end
  def version; end
end
module Aws::Endpoints::Templater
  def self.extract_value(key, parameters, assigns); end
  def self.replace(capture, parameters, assigns); end
  def self.resolve(string, parameters, assigns); end
end
class Aws::Endpoints::TreeRule
  def conditions; end
  def documentation; end
  def error; end
  def initialize(conditions:, rules:, type: nil, documentation: nil); end
  def match(parameters, assigned = nil); end
  def resolve_rules(parameters, assigns); end
  def type; end
end
class Aws::Endpoints::URL
  def _authority(url, uri); end
  def _is_ip(authority); end
  def as_json(_options = nil); end
  def authority; end
  def initialize(url); end
  def is_ip; end
  def normalized_path; end
  def path; end
  def scheme; end
end
class Aws::Plugins::SignatureV4 < Seahorse::Client::Plugin
  def add_handlers(handlers, cfg); end
  def self.apply_authtype(context); end
  def self.apply_signature(options = nil); end
  def self.build_signer(cfg); end
end
class Aws::Plugins::SignatureV4::Handler < Seahorse::Client::Handler
  def call(context); end
end
class Aws::Plugins::SignatureV4::MissingCredentialsSigner
  def sign_request(*args); end
end
class Aws::DefaultsModeConfigResolver
  def application_current_region; end
  def env_mobile?; end
  def initialize(sdk_defaults, cfg); end
  def resolve(option_name); end
  def resolve_auto_mode; end
  def resolve_for_mode(name, mode); end
  def resolved_mode; end
end
module Aws::DefaultsModeConfiguration
end
module Aws::STS
end
module Aws::STS::Types
end
class Anonymous_Struct_103 < Struct
  def duration_seconds; end
  def duration_seconds=(_); end
  def external_id; end
  def external_id=(_); end
  def policy; end
  def policy=(_); end
  def policy_arns; end
  def policy_arns=(_); end
  def provided_contexts; end
  def provided_contexts=(_); end
  def role_arn; end
  def role_arn=(_); end
  def role_session_name; end
  def role_session_name=(_); end
  def self.[](*arg0); end
  def self.inspect; end
  def self.keyword_init?; end
  def self.members; end
  def self.new(*arg0); end
  def serial_number; end
  def serial_number=(_); end
  def source_identity; end
  def source_identity=(_); end
  def tags; end
  def tags=(_); end
  def token_code; end
  def token_code=(_); end
  def transitive_tag_keys; end
  def transitive_tag_keys=(_); end
end
class Aws::STS::Types::AssumeRoleRequest < Anonymous_Struct_103
  include Aws::Structure
end
class Anonymous_Struct_104 < Struct
  def assumed_role_user; end
  def assumed_role_user=(_); end
  def credentials; end
  def credentials=(_); end
  def packed_policy_size; end
  def packed_policy_size=(_); end
  def self.[](*arg0); end
  def self.inspect; end
  def self.keyword_init?; end
  def self.members; end
  def self.new(*arg0); end
  def source_identity; end
  def source_identity=(_); end
end
class Aws::STS::Types::AssumeRoleResponse < Anonymous_Struct_104
  include Aws::Structure
end
class Anonymous_Struct_105 < Struct
  def duration_seconds; end
  def duration_seconds=(_); end
  def policy; end
  def policy=(_); end
  def policy_arns; end
  def policy_arns=(_); end
  def principal_arn; end
  def principal_arn=(_); end
  def role_arn; end
  def role_arn=(_); end
  def saml_assertion; end
  def saml_assertion=(_); end
  def self.[](*arg0); end
  def self.inspect; end
  def self.keyword_init?; end
  def self.members; end
  def self.new(*arg0); end
end
class Aws::STS::Types::AssumeRoleWithSAMLRequest < Anonymous_Struct_105
  include Aws::Structure
end
class Anonymous_Struct_106 < Struct
  def assumed_role_user; end
  def assumed_role_user=(_); end
  def audience; end
  def audience=(_); end
  def credentials; end
  def credentials=(_); end
  def issuer; end
  def issuer=(_); end
  def name_qualifier; end
  def name_qualifier=(_); end
  def packed_policy_size; end
  def packed_policy_size=(_); end
  def self.[](*arg0); end
  def self.inspect; end
  def self.keyword_init?; end
  def self.members; end
  def self.new(*arg0); end
  def source_identity; end
  def source_identity=(_); end
  def subject; end
  def subject=(_); end
  def subject_type; end
  def subject_type=(_); end
end
class Aws::STS::Types::AssumeRoleWithSAMLResponse < Anonymous_Struct_106
  include Aws::Structure
end
class Anonymous_Struct_107 < Struct
  def duration_seconds; end
  def duration_seconds=(_); end
  def policy; end
  def policy=(_); end
  def policy_arns; end
  def policy_arns=(_); end
  def provider_id; end
  def provider_id=(_); end
  def role_arn; end
  def role_arn=(_); end
  def role_session_name; end
  def role_session_name=(_); end
  def self.[](*arg0); end
  def self.inspect; end
  def self.keyword_init?; end
  def self.members; end
  def self.new(*arg0); end
  def web_identity_token; end
  def web_identity_token=(_); end
end
class Aws::STS::Types::AssumeRoleWithWebIdentityRequest < Anonymous_Struct_107
  include Aws::Structure
end
class Anonymous_Struct_108 < Struct
  def assumed_role_user; end
  def assumed_role_user=(_); end
  def audience; end
  def audience=(_); end
  def credentials; end
  def credentials=(_); end
  def packed_policy_size; end
  def packed_policy_size=(_); end
  def provider; end
  def provider=(_); end
  def self.[](*arg0); end
  def self.inspect; end
  def self.keyword_init?; end
  def self.members; end
  def self.new(*arg0); end
  def source_identity; end
  def source_identity=(_); end
  def subject_from_web_identity_token; end
  def subject_from_web_identity_token=(_); end
end
class Aws::STS::Types::AssumeRoleWithWebIdentityResponse < Anonymous_Struct_108
  include Aws::Structure
end
class Anonymous_Struct_109 < Struct
  def arn; end
  def arn=(_); end
  def assumed_role_id; end
  def assumed_role_id=(_); end
  def self.[](*arg0); end
  def self.inspect; end
  def self.keyword_init?; end
  def self.members; end
  def self.new(*arg0); end
end
class Aws::STS::Types::AssumedRoleUser < Anonymous_Struct_109
  include Aws::Structure
end
class Anonymous_Struct_110 < Struct
  def access_key_id; end
  def access_key_id=(_); end
  def expiration; end
  def expiration=(_); end
  def secret_access_key; end
  def secret_access_key=(_); end
  def self.[](*arg0); end
  def self.inspect; end
  def self.keyword_init?; end
  def self.members; end
  def self.new(*arg0); end
  def session_token; end
  def session_token=(_); end
end
class Aws::STS::Types::Credentials < Anonymous_Struct_110
  include Aws::Structure
end
class Anonymous_Struct_111 < Struct
  def encoded_message; end
  def encoded_message=(_); end
  def self.[](*arg0); end
  def self.inspect; end
  def self.keyword_init?; end
  def self.members; end
  def self.new(*arg0); end
end
class Aws::STS::Types::DecodeAuthorizationMessageRequest < Anonymous_Struct_111
  include Aws::Structure
end
class Anonymous_Struct_112 < Struct
  def decoded_message; end
  def decoded_message=(_); end
  def self.[](*arg0); end
  def self.inspect; end
  def self.keyword_init?; end
  def self.members; end
  def self.new(*arg0); end
end
class Aws::STS::Types::DecodeAuthorizationMessageResponse < Anonymous_Struct_112
  include Aws::Structure
end
class Anonymous_Struct_113 < Struct
  def message; end
  def message=(_); end
  def self.[](*arg0); end
  def self.inspect; end
  def self.keyword_init?; end
  def self.members; end
  def self.new(*arg0); end
end
class Aws::STS::Types::ExpiredTokenException < Anonymous_Struct_113
  include Aws::Structure
end
class Anonymous_Struct_114 < Struct
  def arn; end
  def arn=(_); end
  def federated_user_id; end
  def federated_user_id=(_); end
  def self.[](*arg0); end
  def self.inspect; end
  def self.keyword_init?; end
  def self.members; end
  def self.new(*arg0); end
end
class Aws::STS::Types::FederatedUser < Anonymous_Struct_114
  include Aws::Structure
end
class Anonymous_Struct_115 < Struct
  def access_key_id; end
  def access_key_id=(_); end
  def self.[](*arg0); end
  def self.inspect; end
  def self.keyword_init?; end
  def self.members; end
  def self.new(*arg0); end
end
class Aws::STS::Types::GetAccessKeyInfoRequest < Anonymous_Struct_115
  include Aws::Structure
end
class Anonymous_Struct_116 < Struct
  def account; end
  def account=(_); end
  def self.[](*arg0); end
  def self.inspect; end
  def self.keyword_init?; end
  def self.members; end
  def self.new(*arg0); end
end
class Aws::STS::Types::GetAccessKeyInfoResponse < Anonymous_Struct_116
  include Aws::Structure
end
class Aws::STS::Types::GetCallerIdentityRequest < Aws::EmptyStructure
end
class Anonymous_Struct_117 < Struct
  def account; end
  def account=(_); end
  def arn; end
  def arn=(_); end
  def self.[](*arg0); end
  def self.inspect; end
  def self.keyword_init?; end
  def self.members; end
  def self.new(*arg0); end
  def user_id; end
  def user_id=(_); end
end
class Aws::STS::Types::GetCallerIdentityResponse < Anonymous_Struct_117
  include Aws::Structure
end
class Anonymous_Struct_118 < Struct
  def duration_seconds; end
  def duration_seconds=(_); end
  def name; end
  def name=(_); end
  def policy; end
  def policy=(_); end
  def policy_arns; end
  def policy_arns=(_); end
  def self.[](*arg0); end
  def self.inspect; end
  def self.keyword_init?; end
  def self.members; end
  def self.new(*arg0); end
  def tags; end
  def tags=(_); end
end
class Aws::STS::Types::GetFederationTokenRequest < Anonymous_Struct_118
  include Aws::Structure
end
class Anonymous_Struct_119 < Struct
  def credentials; end
  def credentials=(_); end
  def federated_user; end
  def federated_user=(_); end
  def packed_policy_size; end
  def packed_policy_size=(_); end
  def self.[](*arg0); end
  def self.inspect; end
  def self.keyword_init?; end
  def self.members; end
  def self.new(*arg0); end
end
class Aws::STS::Types::GetFederationTokenResponse < Anonymous_Struct_119
  include Aws::Structure
end
class Anonymous_Struct_120 < Struct
  def duration_seconds; end
  def duration_seconds=(_); end
  def self.[](*arg0); end
  def self.inspect; end
  def self.keyword_init?; end
  def self.members; end
  def self.new(*arg0); end
  def serial_number; end
  def serial_number=(_); end
  def token_code; end
  def token_code=(_); end
end
class Aws::STS::Types::GetSessionTokenRequest < Anonymous_Struct_120
  include Aws::Structure
end
class Anonymous_Struct_121 < Struct
  def credentials; end
  def credentials=(_); end
  def self.[](*arg0); end
  def self.inspect; end
  def self.keyword_init?; end
  def self.members; end
  def self.new(*arg0); end
end
class Aws::STS::Types::GetSessionTokenResponse < Anonymous_Struct_121
  include Aws::Structure
end
class Anonymous_Struct_122 < Struct
  def message; end
  def message=(_); end
  def self.[](*arg0); end
  def self.inspect; end
  def self.keyword_init?; end
  def self.members; end
  def self.new(*arg0); end
end
class Aws::STS::Types::IDPCommunicationErrorException < Anonymous_Struct_122
  include Aws::Structure
end
class Anonymous_Struct_123 < Struct
  def message; end
  def message=(_); end
  def self.[](*arg0); end
  def self.inspect; end
  def self.keyword_init?; end
  def self.members; end
  def self.new(*arg0); end
end
class Aws::STS::Types::IDPRejectedClaimException < Anonymous_Struct_123
  include Aws::Structure
end
class Anonymous_Struct_124 < Struct
  def message; end
  def message=(_); end
  def self.[](*arg0); end
  def self.inspect; end
  def self.keyword_init?; end
  def self.members; end
  def self.new(*arg0); end
end
class Aws::STS::Types::InvalidAuthorizationMessageException < Anonymous_Struct_124
  include Aws::Structure
end
class Anonymous_Struct_125 < Struct
  def message; end
  def message=(_); end
  def self.[](*arg0); end
  def self.inspect; end
  def self.keyword_init?; end
  def self.members; end
  def self.new(*arg0); end
end
class Aws::STS::Types::InvalidIdentityTokenException < Anonymous_Struct_125
  include Aws::Structure
end
class Anonymous_Struct_126 < Struct
  def message; end
  def message=(_); end
  def self.[](*arg0); end
  def self.inspect; end
  def self.keyword_init?; end
  def self.members; end
  def self.new(*arg0); end
end
class Aws::STS::Types::MalformedPolicyDocumentException < Anonymous_Struct_126
  include Aws::Structure
end
class Anonymous_Struct_127 < Struct
  def message; end
  def message=(_); end
  def self.[](*arg0); end
  def self.inspect; end
  def self.keyword_init?; end
  def self.members; end
  def self.new(*arg0); end
end
class Aws::STS::Types::PackedPolicyTooLargeException < Anonymous_Struct_127
  include Aws::Structure
end
class Anonymous_Struct_128 < Struct
  def arn; end
  def arn=(_); end
  def self.[](*arg0); end
  def self.inspect; end
  def self.keyword_init?; end
  def self.members; end
  def self.new(*arg0); end
end
class Aws::STS::Types::PolicyDescriptorType < Anonymous_Struct_128
  include Aws::Structure
end
class Anonymous_Struct_129 < Struct
  def context_assertion; end
  def context_assertion=(_); end
  def provider_arn; end
  def provider_arn=(_); end
  def self.[](*arg0); end
  def self.inspect; end
  def self.keyword_init?; end
  def self.members; end
  def self.new(*arg0); end
end
class Aws::STS::Types::ProvidedContext < Anonymous_Struct_129
  include Aws::Structure
end
class Anonymous_Struct_130 < Struct
  def message; end
  def message=(_); end
  def self.[](*arg0); end
  def self.inspect; end
  def self.keyword_init?; end
  def self.members; end
  def self.new(*arg0); end
end
class Aws::STS::Types::RegionDisabledException < Anonymous_Struct_130
  include Aws::Structure
end
class Anonymous_Struct_131 < Struct
  def key; end
  def key=(_); end
  def self.[](*arg0); end
  def self.inspect; end
  def self.keyword_init?; end
  def self.members; end
  def self.new(*arg0); end
  def value; end
  def value=(_); end
end
class Aws::STS::Types::Tag < Anonymous_Struct_131
  include Aws::Structure
end
module Aws::STS::ClientApi
  include Seahorse::Model
end
module Aws::STS::Plugins
end
class Aws::STS::Plugins::Endpoints < Seahorse::Client::Plugin
  def add_handlers(handlers, _config); end
end
class Aws::STS::Plugins::Endpoints::Handler < Seahorse::Client::Handler
  def apply_endpoint_headers(context, headers); end
  def call(context); end
  def parameters_for_operation(context); end
end
class Aws::Plugins::CredentialsConfiguration < Seahorse::Client::Plugin
end
class Aws::Plugins::Logging < Seahorse::Client::Plugin
  def add_handlers(handlers, config); end
end
class Aws::Plugins::Logging::Handler < Seahorse::Client::Handler
  def call(context); end
  def format(config, response); end
  def log(config, response); end
end
class Aws::Plugins::ParamConverter < Seahorse::Client::Plugin
  def add_handlers(handlers, config); end
end
class Aws::Plugins::ParamConverter::Handler < Seahorse::Client::Handler
  def call(context); end
end
class Aws::Plugins::ParamValidator < Seahorse::Client::Plugin
  def add_handlers(handlers, config); end
end
class Aws::Plugins::ParamValidator::Handler < Seahorse::Client::Handler
  def call(context); end
end
class Aws::Plugins::UserAgent < Seahorse::Client::Plugin
  def self.feature(_feature, &block); end
  def self.metric(metric, &block); end
end
class Aws::Plugins::UserAgent::Handler < Seahorse::Client::Handler
  def call(context); end
  def set_user_agent(context); end
end
class Aws::Plugins::UserAgent::Handler::UserAgent
  def api_metadata; end
  def app_id_metadata; end
  def env_metadata; end
  def framework_metadata; end
  def initialize(context); end
  def language_metadata; end
  def metric_metadata; end
  def os_metadata; end
  def to_s; end
end
class Aws::Plugins::HelpfulSocketErrors < Seahorse::Client::Plugin
end
class Aws::Plugins::HelpfulSocketErrors::Handler < Seahorse::Client::Handler
  def call(context); end
  def no_such_endpoint_error(context, error); end
  def socket_endpoint_error?(error); end
end
module Aws::Plugins::Retries
end
class Aws::Plugins::Retries::ErrorInspector
  def checksum?; end
  def clock_skew?(context); end
  def endpoint_discovery?(context); end
  def expired_credentials?; end
  def extract_name(error); end
  def initialize(error, http_status_code); end
  def modeled_retryable?; end
  def modeled_throttling?; end
  def networking?; end
  def refreshable_credentials?(context); end
  def retryable?(context); end
  def server?; end
  def throttling_error?; end
end
class Aws::Plugins::Retries::RetryQuota
  def checkout_capacity(error_inspector); end
  def initialize(opts = nil); end
  def release(capacity_amount); end
end
class Aws::Plugins::Retries::ClientRateLimiter
  def calculate_time_window; end
  def cubic_success(timestamp); end
  def cubic_throttle(rate_to_use); end
  def enable_token_bucket; end
  def initialize; end
  def token_bucket_acquire(amount, wait_to_fill = nil); end
  def token_bucket_refill; end
  def token_bucket_update_rate(new_rps); end
  def update_measured_rate; end
  def update_sending_rate(is_throttling_error); end
end
class Aws::Plugins::Retries::ClockSkew
  def clock_correction(endpoint); end
  def clock_skewed?(context); end
  def estimated_skew(endpoint); end
  def initialize; end
  def server_time(response); end
  def set_clock_correction(endpoint, correction); end
  def update_clock_correction(context); end
  def update_estimated_skew(context); end
end
class Aws::Plugins::RetryErrors < Seahorse::Client::Plugin
  def add_handlers(handlers, config); end
  def self.resolve_adaptive_retry_wait_to_fill(cfg); end
  def self.resolve_correct_clock_skew(cfg); end
  def self.resolve_max_attempts(cfg); end
  def self.resolve_retry_mode(cfg); end
end
class Aws::Plugins::RetryErrors::Handler < Seahorse::Client::Handler
  def add_retry_headers(context); end
  def call(context); end
  def compute_request_ttl(context); end
  def exponential_backoff(retries); end
  def get_send_token(config); end
  def refresh_credentials?(context, error); end
  def request_bookkeeping(context, response, error_inspector); end
  def retry_request(context, error); end
  def retryable?(context, response, error_inspector); end
  def with_metric(retry_mode, &block); end
end
class Aws::Plugins::RetryErrors::LegacyHandler < Seahorse::Client::Handler
  def call(context); end
  def delay_retry(context); end
  def refresh_credentials?(context, error); end
  def response_truncatable?(context); end
  def retry_if_possible(response, error_inspector); end
  def retry_limit(context); end
  def retry_request(context, error); end
  def should_retry?(context, error); end
  def with_metric(&block); end
end
class Aws::Plugins::GlobalConfiguration < Seahorse::Client::Plugin
  def apply_aws_defaults(_client_class, options); end
  def apply_service_defaults(client_class, options); end
  def before_initialize(client_class, options); end
  def self.add_identifier(identifier); end
  def self.identifiers; end
end
class Aws::Plugins::RegionalEndpoint < Seahorse::Client::Plugin
  def after_initialize(client); end
  def self.env_global_endpoint(cfg); end
  def self.env_service_endpoint(cfg); end
  def self.handle_legacy_pseudo_regions(cfg); end
  def self.resolve_custom_config_endpoint(cfg); end
  def self.resolve_endpoint(cfg); end
  def self.resolve_ignore_configured_endpoint_urls(cfg); end
  def self.resolve_legacy_endpoint(cfg); end
  def self.resolve_region(cfg); end
  def self.resolve_sigv4a_signing_region_set(cfg); end
  def self.resolve_use_dualstack_endpoint(cfg); end
  def self.resolve_use_fips_endpoint(cfg); end
  def self.shared_config_endpoint(cfg); end
  def self.validate_region!(region); end
end
class Aws::Plugins::EndpointDiscovery < Seahorse::Client::Plugin
  def add_handlers(handlers, config); end
  def self.resolve_endpoint_discovery(cfg); end
end
class Aws::Plugins::EndpointDiscovery::Handler < Seahorse::Client::Handler
  def _apply_endpoint_discovery_user_agent(ctx); end
  def _discover_endpoint(ctx, required); end
  def _valid_uri(address); end
  def call(context); end
end
class Aws::Plugins::EndpointPattern < Seahorse::Client::Plugin
  def add_handlers(handlers, config); end
end
class Aws::Plugins::EndpointPattern::Handler < Seahorse::Client::Handler
  def _apply_endpoint_trait(context, trait); end
  def _replace_label_value(ori, label, input_ref, params); end
  def call(context); end
end
class Aws::Plugins::ResponsePaging < Seahorse::Client::Plugin
end
class Aws::Plugins::ResponsePaging::Handler < Seahorse::Client::Handler
  def call(context); end
end
class Aws::Plugins::StubResponses < Seahorse::Client::Plugin
  def add_handlers(handlers, config); end
  def after_initialize(client); end
end
class Aws::Plugins::StubResponses::Handler < Seahorse::Client::Handler
  def apply_stub(stub, response, async_mode = nil); end
  def call(context); end
  def signal_error(error, http_resp); end
  def signal_http(stub, http_resp, async_mode = nil); end
end
class Aws::Plugins::IdempotencyToken < Seahorse::Client::Plugin
end
class Aws::Plugins::IdempotencyToken::Handler < Seahorse::Client::Handler
  def auto_fill(params, ref); end
  def call(context); end
end
class Aws::Plugins::InvocationId < Seahorse::Client::Plugin
end
class Aws::Plugins::InvocationId::Handler < Seahorse::Client::Handler
  def call(context); end
end
class Aws::Plugins::JsonvalueConverter < Seahorse::Client::Plugin
end
class Aws::Plugins::JsonvalueConverter::Handler < Seahorse::Client::Handler
  def call(context); end
  def convert_jsonvalue(m, ref, params, context); end
  def serialize_jsonvalue(v, context); end
end
class Aws::Plugins::ClientMetricsPlugin < Seahorse::Client::Plugin
  def add_handlers(handlers, config); end
  def self.resolve_client_id(cfg); end
  def self.resolve_client_side_monitoring(cfg); end
  def self.resolve_client_side_monitoring_host(cfg); end
  def self.resolve_client_side_monitoring_port(cfg); end
  def self.resolve_publisher(cfg); end
end
class Aws::Plugins::ClientMetricsPlugin::Handler < Seahorse::Client::Handler
  def _calculate_service_id(context); end
  def _fallback_service_id(id); end
  def call(context); end
end
class Aws::Plugins::ClientMetricsSendPlugin < Seahorse::Client::Plugin
  def add_handlers(handlers, config); end
end
class Aws::Plugins::ClientMetricsSendPlugin::LatencyHandler < Seahorse::Client::Handler
  def call(context); end
end
class Aws::Plugins::ClientMetricsSendPlugin::AttemptHandler < Seahorse::Client::Handler
  def call(context); end
end
class Aws::Plugins::ClientMetricsSendPlugin::ErrorHandler < Seahorse::Client::Handler
  def _extract_error_name(error); end
  def call(context); end
end
class Aws::Plugins::TransferEncoding < Seahorse::Client::Plugin
end
class Aws::Plugins::TransferEncoding::Handler < Seahorse::Client::Handler
  def call(context); end
  def requires_length?(ref); end
  def streaming?(ref); end
  def unsigned_payload?(operation); end
end
class Aws::Plugins::HttpChecksum < Seahorse::Client::Plugin
  def add_handlers(handlers, _config); end
end
class Aws::Plugins::HttpChecksum::Handler < Seahorse::Client::Handler
  def call(context); end
  def checksum_required?(context); end
  def md5(value); end
  def update_in_chunks(digest, io); end
end
class Aws::Plugins::ChecksumAlgorithm < Seahorse::Client::Plugin
  def add_handlers(handlers, _config); end
  def self.calculate_checksum(algorithm, body); end
  def self.digest_for_algorithm(algorithm); end
  def self.operation_response_algorithms(context); end
  def self.request_algorithm_selection(context); end
  def self.request_validation_mode(context); end
  def self.trailer_length(algorithm, location_name); end
  def self.update_in_chunks(digest, io); end
end
class Aws::Plugins::ChecksumAlgorithm::Digest32
  def base64digest; end
  def initialize(digest_fn); end
  def update(chunk); end
  def value; end
end
class Aws::Plugins::ChecksumAlgorithm::OptionHandler < Seahorse::Client::Handler
  def call(context); end
end
class Aws::Plugins::ChecksumAlgorithm::ChecksumHandler < Seahorse::Client::Handler
  def add_verify_response_checksum_handlers(context); end
  def apply_request_trailer_checksum(context, checksum_properties); end
  def calculate_request_checksum(context, checksum_properties); end
  def call(context); end
  def checksum_request_in(context); end
  def response_header_to_verify(headers, validation_list); end
  def should_calculate_request_checksum?(context); end
  def should_verify_response_checksum?(context); end
end
class Aws::Plugins::ChecksumAlgorithm::AwsChunkedTrailerDigestIO
  def initialize(io, algorithm, location_name); end
  def read(length, buf = nil); end
  def rewind; end
  def size; end
end
class Aws::Plugins::RequestCompression < Seahorse::Client::Plugin
  def add_handlers(handlers, _config); end
  def after_initialize(client); end
  def self.resolve_disable_request_compression(cfg); end
  def self.resolve_request_min_compression_size_bytes(cfg); end
  def validate_disable_request_compression_input(cfg); end
  def validate_request_min_compression_size_bytes_input(cfg); end
end
class Aws::Plugins::RequestCompression::CompressionHandler < Seahorse::Client::Handler
  def call(context); end
  def gzip_compress(context); end
  def process_compression(encoding, context); end
  def process_streaming_compression(encoding, context); end
  def request_encoding_selection(context); end
  def should_compress?(context); end
  def streaming?(input); end
  def update_content_encoding(encoding, context); end
  def update_in_chunks(compressor, io); end
  def with_metric(encoding, &block); end
end
class Aws::Plugins::RequestCompression::CompressionHandler::GzipIO
  def initialize(body); end
  def read(length, buff = nil); end
end
class Aws::Plugins::RequestCompression::CompressionHandler::ChunkBuffer
  def initialize; end
  def last_chunk; end
  def write(data); end
end
class Aws::Plugins::DefaultsMode < Seahorse::Client::Plugin
  def self.resolve_defaults_mode(cfg); end
end
class Aws::Plugins::RecursionDetection < Seahorse::Client::Plugin
end
class Aws::Plugins::RecursionDetection::Handler < Seahorse::Client::Handler
  def call(context); end
  def validate_header(header_value); end
end
class Aws::Plugins::Sign < Seahorse::Client::Plugin
  def add_handlers(handlers, cfg); end
  def self.signer_for(auth_scheme, config, sigv4_region_override = nil, sigv4_credentials_override = nil); end
end
class Aws::Plugins::Sign::Handler < Seahorse::Client::Handler
  def call(context); end
  def v2_signing?(config); end
end
class Aws::Plugins::Sign::Bearer
  def initialize; end
  def presign_url(*args); end
  def sign(context); end
  def sign_event(*args); end
end
class Aws::Plugins::Sign::SignatureV4
  def apply_authtype(context, req); end
  def apply_clock_skew(context, req); end
  def initialize(auth_scheme, config, sigv4_overrides = nil); end
  def presign_url(*args); end
  def reset_signature(req); end
  def sign(context); end
  def sign_event(*args); end
  def unsigned_payload?(context, req); end
end
class Aws::Plugins::Sign::NullSigner
  def presign_url(*args); end
  def sign(context); end
  def sign_event(*args); end
end
module Aws::Plugins::Protocols
end
class Aws::Plugins::Protocols::Query < Seahorse::Client::Plugin
end
class Aws::STS::Plugins::STSRegionalEndpoints < Seahorse::Client::Plugin
  def self.resolve_sts_regional_endpoints(cfg); end
end
class Aws::STS::Client < Seahorse::Client::Base
  def assume_role(params = nil, options = nil); end
  def assume_role_with_saml(params = nil, options = nil); end
  def assume_role_with_web_identity(params = nil, options = nil); end
  def build_request(operation_name, params = nil); end
  def decode_authorization_message(params = nil, options = nil); end
  def get_access_key_info(params = nil, options = nil); end
  def get_caller_identity(params = nil, options = nil); end
  def get_federation_token(params = nil, options = nil); end
  def get_session_token(params = nil, options = nil); end
  def initialize(*args); end
  def self.errors_module; end
  def self.identifier; end
  def waiter_names; end
  include Anonymous_Module_132
  include Aws::ClientStubs
end
module Anonymous_Module_132
  def assume_role(*args, &block); end
  def assume_role_with_saml(*args, &block); end
  def assume_role_with_web_identity(*args, &block); end
  def decode_authorization_message(*args, &block); end
  def get_access_key_info(*args, &block); end
  def get_caller_identity(*args, &block); end
  def get_federation_token(*args, &block); end
  def get_session_token(*args, &block); end
end
module Aws::STS::Errors
  extend Aws::Errors::DynamicErrors
end
class Aws::STS::Errors::ServiceError < Aws::Errors::ServiceError
end
class Aws::STS::Errors::ExpiredTokenException < Aws::STS::Errors::ServiceError
  def initialize(context, message, data = nil); end
  def message; end
end
class Aws::STS::Errors::IDPCommunicationErrorException < Aws::STS::Errors::ServiceError
  def initialize(context, message, data = nil); end
  def message; end
end
class Aws::STS::Errors::IDPRejectedClaimException < Aws::STS::Errors::ServiceError
  def initialize(context, message, data = nil); end
  def message; end
end
class Aws::STS::Errors::InvalidAuthorizationMessageException < Aws::STS::Errors::ServiceError
  def initialize(context, message, data = nil); end
  def message; end
end
class Aws::STS::Errors::InvalidIdentityTokenException < Aws::STS::Errors::ServiceError
  def initialize(context, message, data = nil); end
  def message; end
end
class Aws::STS::Errors::MalformedPolicyDocumentException < Aws::STS::Errors::ServiceError
  def initialize(context, message, data = nil); end
  def message; end
end
class Aws::STS::Errors::PackedPolicyTooLargeException < Aws::STS::Errors::ServiceError
  def initialize(context, message, data = nil); end
  def message; end
end
class Aws::STS::Errors::RegionDisabledException < Aws::STS::Errors::ServiceError
  def initialize(context, message, data = nil); end
  def message; end
end
class Aws::STS::Resource
  def client; end
  def initialize(options = nil); end
end
class Aws::STS::EndpointParameters < Struct
  def endpoint; end
  def endpoint=(_); end
  def initialize(options = nil); end
  def region; end
  def region=(_); end
  def self.[](*arg0); end
  def self.inspect; end
  def self.keyword_init?; end
  def self.members; end
  def self.new(*arg0); end
  def use_dual_stack; end
  def use_dual_stack=(_); end
  def use_fips; end
  def use_fips=(_); end
  def use_global_endpoint; end
  def use_global_endpoint=(_); end
  include Aws::Structure
end
class Aws::STS::EndpointProvider
  def resolve_endpoint(parameters); end
end
module Aws::STS::Endpoints
end
class Aws::STS::Endpoints::AssumeRole
  def self.build(context); end
end
class Aws::STS::Endpoints::AssumeRoleWithSAML
  def self.build(context); end
end
class Aws::STS::Endpoints::AssumeRoleWithWebIdentity
  def self.build(context); end
end
class Aws::STS::Endpoints::DecodeAuthorizationMessage
  def self.build(context); end
end
class Aws::STS::Endpoints::GetAccessKeyInfo
  def self.build(context); end
end
class Aws::STS::Endpoints::GetCallerIdentity
  def self.build(context); end
end
class Aws::STS::Endpoints::GetFederationToken
  def self.build(context); end
end
class Aws::STS::Endpoints::GetSessionToken
  def self.build(context); end
end
class Aws::STS::Presigner
  def get_caller_identity_presigned_url(options = nil); end
  def initialize(options = nil); end
end
module Aws::SSO
end
module Aws::SSO::Types
end
class Anonymous_Struct_133 < Struct
  def account_id; end
  def account_id=(_); end
  def account_name; end
  def account_name=(_); end
  def email_address; end
  def email_address=(_); end
  def self.[](*arg0); end
  def self.inspect; end
  def self.keyword_init?; end
  def self.members; end
  def self.new(*arg0); end
end
class Aws::SSO::Types::AccountInfo < Anonymous_Struct_133
  include Aws::Structure
end
class Anonymous_Struct_134 < Struct
  def access_token; end
  def access_token=(_); end
  def account_id; end
  def account_id=(_); end
  def role_name; end
  def role_name=(_); end
  def self.[](*arg0); end
  def self.inspect; end
  def self.keyword_init?; end
  def self.members; end
  def self.new(*arg0); end
end
class Aws::SSO::Types::GetRoleCredentialsRequest < Anonymous_Struct_134
  include Aws::Structure
end
class Anonymous_Struct_135 < Struct
  def role_credentials; end
  def role_credentials=(_); end
  def self.[](*arg0); end
  def self.inspect; end
  def self.keyword_init?; end
  def self.members; end
  def self.new(*arg0); end
end
class Aws::SSO::Types::GetRoleCredentialsResponse < Anonymous_Struct_135
  include Aws::Structure
end
class Anonymous_Struct_136 < Struct
  def message; end
  def message=(_); end
  def self.[](*arg0); end
  def self.inspect; end
  def self.keyword_init?; end
  def self.members; end
  def self.new(*arg0); end
end
class Aws::SSO::Types::InvalidRequestException < Anonymous_Struct_136
  include Aws::Structure
end
class Anonymous_Struct_137 < Struct
  def access_token; end
  def access_token=(_); end
  def account_id; end
  def account_id=(_); end
  def max_results; end
  def max_results=(_); end
  def next_token; end
  def next_token=(_); end
  def self.[](*arg0); end
  def self.inspect; end
  def self.keyword_init?; end
  def self.members; end
  def self.new(*arg0); end
end
class Aws::SSO::Types::ListAccountRolesRequest < Anonymous_Struct_137
  include Aws::Structure
end
class Anonymous_Struct_138 < Struct
  def next_token; end
  def next_token=(_); end
  def role_list; end
  def role_list=(_); end
  def self.[](*arg0); end
  def self.inspect; end
  def self.keyword_init?; end
  def self.members; end
  def self.new(*arg0); end
end
class Aws::SSO::Types::ListAccountRolesResponse < Anonymous_Struct_138
  include Aws::Structure
end
class Anonymous_Struct_139 < Struct
  def access_token; end
  def access_token=(_); end
  def max_results; end
  def max_results=(_); end
  def next_token; end
  def next_token=(_); end
  def self.[](*arg0); end
  def self.inspect; end
  def self.keyword_init?; end
  def self.members; end
  def self.new(*arg0); end
end
class Aws::SSO::Types::ListAccountsRequest < Anonymous_Struct_139
  include Aws::Structure
end
class Anonymous_Struct_140 < Struct
  def account_list; end
  def account_list=(_); end
  def next_token; end
  def next_token=(_); end
  def self.[](*arg0); end
  def self.inspect; end
  def self.keyword_init?; end
  def self.members; end
  def self.new(*arg0); end
end
class Aws::SSO::Types::ListAccountsResponse < Anonymous_Struct_140
  include Aws::Structure
end
class Anonymous_Struct_141 < Struct
  def access_token; end
  def access_token=(_); end
  def self.[](*arg0); end
  def self.inspect; end
  def self.keyword_init?; end
  def self.members; end
  def self.new(*arg0); end
end
class Aws::SSO::Types::LogoutRequest < Anonymous_Struct_141
  include Aws::Structure
end
class Anonymous_Struct_142 < Struct
  def message; end
  def message=(_); end
  def self.[](*arg0); end
  def self.inspect; end
  def self.keyword_init?; end
  def self.members; end
  def self.new(*arg0); end
end
class Aws::SSO::Types::ResourceNotFoundException < Anonymous_Struct_142
  include Aws::Structure
end
class Anonymous_Struct_143 < Struct
  def access_key_id; end
  def access_key_id=(_); end
  def expiration; end
  def expiration=(_); end
  def secret_access_key; end
  def secret_access_key=(_); end
  def self.[](*arg0); end
  def self.inspect; end
  def self.keyword_init?; end
  def self.members; end
  def self.new(*arg0); end
  def session_token; end
  def session_token=(_); end
end
class Aws::SSO::Types::RoleCredentials < Anonymous_Struct_143
  include Aws::Structure
end
class Anonymous_Struct_144 < Struct
  def account_id; end
  def account_id=(_); end
  def role_name; end
  def role_name=(_); end
  def self.[](*arg0); end
  def self.inspect; end
  def self.keyword_init?; end
  def self.members; end
  def self.new(*arg0); end
end
class Aws::SSO::Types::RoleInfo < Anonymous_Struct_144
  include Aws::Structure
end
class Anonymous_Struct_145 < Struct
  def message; end
  def message=(_); end
  def self.[](*arg0); end
  def self.inspect; end
  def self.keyword_init?; end
  def self.members; end
  def self.new(*arg0); end
end
class Aws::SSO::Types::TooManyRequestsException < Anonymous_Struct_145
  include Aws::Structure
end
class Anonymous_Struct_146 < Struct
  def message; end
  def message=(_); end
  def self.[](*arg0); end
  def self.inspect; end
  def self.keyword_init?; end
  def self.members; end
  def self.new(*arg0); end
end
class Aws::SSO::Types::UnauthorizedException < Anonymous_Struct_146
  include Aws::Structure
end
module Aws::SSO::ClientApi
  include Seahorse::Model
end
module Aws::SSO::Plugins
end
class Aws::SSO::Plugins::Endpoints < Seahorse::Client::Plugin
  def add_handlers(handlers, _config); end
end
class Aws::SSO::Plugins::Endpoints::Handler < Seahorse::Client::Handler
  def apply_endpoint_headers(context, headers); end
  def call(context); end
  def parameters_for_operation(context); end
end
class Aws::Plugins::Protocols::RestJson < Seahorse::Client::Plugin
end
class Aws::SSO::Client < Seahorse::Client::Base
  def build_request(operation_name, params = nil); end
  def get_role_credentials(params = nil, options = nil); end
  def initialize(*args); end
  def list_account_roles(params = nil, options = nil); end
  def list_accounts(params = nil, options = nil); end
  def logout(params = nil, options = nil); end
  def self.errors_module; end
  def self.identifier; end
  def waiter_names; end
  include Anonymous_Module_147
  include Aws::ClientStubs
end
module Anonymous_Module_147
  def get_role_credentials(*args, &block); end
  def list_account_roles(*args, &block); end
  def list_accounts(*args, &block); end
  def logout(*args, &block); end
end
module Aws::SSO::Errors
  extend Aws::Errors::DynamicErrors
end
class Aws::SSO::Errors::ServiceError < Aws::Errors::ServiceError
end
class Aws::SSO::Errors::InvalidRequestException < Aws::SSO::Errors::ServiceError
  def initialize(context, message, data = nil); end
  def message; end
end
class Aws::SSO::Errors::ResourceNotFoundException < Aws::SSO::Errors::ServiceError
  def initialize(context, message, data = nil); end
  def message; end
end
class Aws::SSO::Errors::TooManyRequestsException < Aws::SSO::Errors::ServiceError
  def initialize(context, message, data = nil); end
  def message; end
end
class Aws::SSO::Errors::UnauthorizedException < Aws::SSO::Errors::ServiceError
  def initialize(context, message, data = nil); end
  def message; end
end
class Aws::SSO::Resource
  def client; end
  def initialize(options = nil); end
end
class Aws::SSO::EndpointParameters < Struct
  def endpoint; end
  def endpoint=(_); end
  def initialize(options = nil); end
  def region; end
  def region=(_); end
  def self.[](*arg0); end
  def self.inspect; end
  def self.keyword_init?; end
  def self.members; end
  def self.new(*arg0); end
  def use_dual_stack; end
  def use_dual_stack=(_); end
  def use_fips; end
  def use_fips=(_); end
  include Aws::Structure
end
class Aws::SSO::EndpointProvider
  def resolve_endpoint(parameters); end
end
module Aws::SSO::Endpoints
end
class Aws::SSO::Endpoints::GetRoleCredentials
  def self.build(context); end
end
class Aws::SSO::Endpoints::ListAccountRoles
  def self.build(context); end
end
class Aws::SSO::Endpoints::ListAccounts
  def self.build(context); end
end
class Aws::SSO::Endpoints::Logout
  def self.build(context); end
end
module Aws::SSOOIDC
end
module Aws::SSOOIDC::Types
end
class Anonymous_Struct_148 < Struct
  def error; end
  def error=(_); end
  def error_description; end
  def error_description=(_); end
  def self.[](*arg0); end
  def self.inspect; end
  def self.keyword_init?; end
  def self.members; end
  def self.new(*arg0); end
end
class Aws::SSOOIDC::Types::AccessDeniedException < Anonymous_Struct_148
  include Aws::Structure
end
class Anonymous_Struct_149 < Struct
  def error; end
  def error=(_); end
  def error_description; end
  def error_description=(_); end
  def self.[](*arg0); end
  def self.inspect; end
  def self.keyword_init?; end
  def self.members; end
  def self.new(*arg0); end
end
class Aws::SSOOIDC::Types::AuthorizationPendingException < Anonymous_Struct_149
  include Aws::Structure
end
class Anonymous_Struct_150 < Struct
  def client_id; end
  def client_id=(_); end
  def client_secret; end
  def client_secret=(_); end
  def code; end
  def code=(_); end
  def code_verifier; end
  def code_verifier=(_); end
  def device_code; end
  def device_code=(_); end
  def grant_type; end
  def grant_type=(_); end
  def redirect_uri; end
  def redirect_uri=(_); end
  def refresh_token; end
  def refresh_token=(_); end
  def scope; end
  def scope=(_); end
  def self.[](*arg0); end
  def self.inspect; end
  def self.keyword_init?; end
  def self.members; end
  def self.new(*arg0); end
end
class Aws::SSOOIDC::Types::CreateTokenRequest < Anonymous_Struct_150
  include Aws::Structure
end
class Anonymous_Struct_151 < Struct
  def access_token; end
  def access_token=(_); end
  def expires_in; end
  def expires_in=(_); end
  def id_token; end
  def id_token=(_); end
  def refresh_token; end
  def refresh_token=(_); end
  def self.[](*arg0); end
  def self.inspect; end
  def self.keyword_init?; end
  def self.members; end
  def self.new(*arg0); end
  def token_type; end
  def token_type=(_); end
end
class Aws::SSOOIDC::Types::CreateTokenResponse < Anonymous_Struct_151
  include Aws::Structure
end
class Anonymous_Struct_152 < Struct
  def assertion; end
  def assertion=(_); end
  def client_id; end
  def client_id=(_); end
  def code; end
  def code=(_); end
  def code_verifier; end
  def code_verifier=(_); end
  def grant_type; end
  def grant_type=(_); end
  def redirect_uri; end
  def redirect_uri=(_); end
  def refresh_token; end
  def refresh_token=(_); end
  def requested_token_type; end
  def requested_token_type=(_); end
  def scope; end
  def scope=(_); end
  def self.[](*arg0); end
  def self.inspect; end
  def self.keyword_init?; end
  def self.members; end
  def self.new(*arg0); end
  def subject_token; end
  def subject_token=(_); end
  def subject_token_type; end
  def subject_token_type=(_); end
end
class Aws::SSOOIDC::Types::CreateTokenWithIAMRequest < Anonymous_Struct_152
  include Aws::Structure
end
class Anonymous_Struct_153 < Struct
  def access_token; end
  def access_token=(_); end
  def expires_in; end
  def expires_in=(_); end
  def id_token; end
  def id_token=(_); end
  def issued_token_type; end
  def issued_token_type=(_); end
  def refresh_token; end
  def refresh_token=(_); end
  def scope; end
  def scope=(_); end
  def self.[](*arg0); end
  def self.inspect; end
  def self.keyword_init?; end
  def self.members; end
  def self.new(*arg0); end
  def token_type; end
  def token_type=(_); end
end
class Aws::SSOOIDC::Types::CreateTokenWithIAMResponse < Anonymous_Struct_153
  include Aws::Structure
end
class Anonymous_Struct_154 < Struct
  def error; end
  def error=(_); end
  def error_description; end
  def error_description=(_); end
  def self.[](*arg0); end
  def self.inspect; end
  def self.keyword_init?; end
  def self.members; end
  def self.new(*arg0); end
end
class Aws::SSOOIDC::Types::ExpiredTokenException < Anonymous_Struct_154
  include Aws::Structure
end
class Anonymous_Struct_155 < Struct
  def error; end
  def error=(_); end
  def error_description; end
  def error_description=(_); end
  def self.[](*arg0); end
  def self.inspect; end
  def self.keyword_init?; end
  def self.members; end
  def self.new(*arg0); end
end
class Aws::SSOOIDC::Types::InternalServerException < Anonymous_Struct_155
  include Aws::Structure
end
class Anonymous_Struct_156 < Struct
  def error; end
  def error=(_); end
  def error_description; end
  def error_description=(_); end
  def self.[](*arg0); end
  def self.inspect; end
  def self.keyword_init?; end
  def self.members; end
  def self.new(*arg0); end
end
class Aws::SSOOIDC::Types::InvalidClientException < Anonymous_Struct_156
  include Aws::Structure
end
class Anonymous_Struct_157 < Struct
  def error; end
  def error=(_); end
  def error_description; end
  def error_description=(_); end
  def self.[](*arg0); end
  def self.inspect; end
  def self.keyword_init?; end
  def self.members; end
  def self.new(*arg0); end
end
class Aws::SSOOIDC::Types::InvalidClientMetadataException < Anonymous_Struct_157
  include Aws::Structure
end
class Anonymous_Struct_158 < Struct
  def error; end
  def error=(_); end
  def error_description; end
  def error_description=(_); end
  def self.[](*arg0); end
  def self.inspect; end
  def self.keyword_init?; end
  def self.members; end
  def self.new(*arg0); end
end
class Aws::SSOOIDC::Types::InvalidGrantException < Anonymous_Struct_158
  include Aws::Structure
end
class Anonymous_Struct_159 < Struct
  def error; end
  def error=(_); end
  def error_description; end
  def error_description=(_); end
  def self.[](*arg0); end
  def self.inspect; end
  def self.keyword_init?; end
  def self.members; end
  def self.new(*arg0); end
end
class Aws::SSOOIDC::Types::InvalidRedirectUriException < Anonymous_Struct_159
  include Aws::Structure
end
class Anonymous_Struct_160 < Struct
  def error; end
  def error=(_); end
  def error_description; end
  def error_description=(_); end
  def self.[](*arg0); end
  def self.inspect; end
  def self.keyword_init?; end
  def self.members; end
  def self.new(*arg0); end
end
class Aws::SSOOIDC::Types::InvalidRequestException < Anonymous_Struct_160
  include Aws::Structure
end
class Anonymous_Struct_161 < Struct
  def endpoint; end
  def endpoint=(_); end
  def error; end
  def error=(_); end
  def error_description; end
  def error_description=(_); end
  def region; end
  def region=(_); end
  def self.[](*arg0); end
  def self.inspect; end
  def self.keyword_init?; end
  def self.members; end
  def self.new(*arg0); end
end
class Aws::SSOOIDC::Types::InvalidRequestRegionException < Anonymous_Struct_161
  include Aws::Structure
end
class Anonymous_Struct_162 < Struct
  def error; end
  def error=(_); end
  def error_description; end
  def error_description=(_); end
  def self.[](*arg0); end
  def self.inspect; end
  def self.keyword_init?; end
  def self.members; end
  def self.new(*arg0); end
end
class Aws::SSOOIDC::Types::InvalidScopeException < Anonymous_Struct_162
  include Aws::Structure
end
class Anonymous_Struct_163 < Struct
  def client_name; end
  def client_name=(_); end
  def client_type; end
  def client_type=(_); end
  def entitled_application_arn; end
  def entitled_application_arn=(_); end
  def grant_types; end
  def grant_types=(_); end
  def issuer_url; end
  def issuer_url=(_); end
  def redirect_uris; end
  def redirect_uris=(_); end
  def scopes; end
  def scopes=(_); end
  def self.[](*arg0); end
  def self.inspect; end
  def self.keyword_init?; end
  def self.members; end
  def self.new(*arg0); end
end
class Aws::SSOOIDC::Types::RegisterClientRequest < Anonymous_Struct_163
  include Aws::Structure
end
class Anonymous_Struct_164 < Struct
  def authorization_endpoint; end
  def authorization_endpoint=(_); end
  def client_id; end
  def client_id=(_); end
  def client_id_issued_at; end
  def client_id_issued_at=(_); end
  def client_secret; end
  def client_secret=(_); end
  def client_secret_expires_at; end
  def client_secret_expires_at=(_); end
  def self.[](*arg0); end
  def self.inspect; end
  def self.keyword_init?; end
  def self.members; end
  def self.new(*arg0); end
  def token_endpoint; end
  def token_endpoint=(_); end
end
class Aws::SSOOIDC::Types::RegisterClientResponse < Anonymous_Struct_164
  include Aws::Structure
end
class Anonymous_Struct_165 < Struct
  def error; end
  def error=(_); end
  def error_description; end
  def error_description=(_); end
  def self.[](*arg0); end
  def self.inspect; end
  def self.keyword_init?; end
  def self.members; end
  def self.new(*arg0); end
end
class Aws::SSOOIDC::Types::SlowDownException < Anonymous_Struct_165
  include Aws::Structure
end
class Anonymous_Struct_166 < Struct
  def client_id; end
  def client_id=(_); end
  def client_secret; end
  def client_secret=(_); end
  def self.[](*arg0); end
  def self.inspect; end
  def self.keyword_init?; end
  def self.members; end
  def self.new(*arg0); end
  def start_url; end
  def start_url=(_); end
end
class Aws::SSOOIDC::Types::StartDeviceAuthorizationRequest < Anonymous_Struct_166
  include Aws::Structure
end
class Anonymous_Struct_167 < Struct
  def device_code; end
  def device_code=(_); end
  def expires_in; end
  def expires_in=(_); end
  def interval; end
  def interval=(_); end
  def self.[](*arg0); end
  def self.inspect; end
  def self.keyword_init?; end
  def self.members; end
  def self.new(*arg0); end
  def user_code; end
  def user_code=(_); end
  def verification_uri; end
  def verification_uri=(_); end
  def verification_uri_complete; end
  def verification_uri_complete=(_); end
end
class Aws::SSOOIDC::Types::StartDeviceAuthorizationResponse < Anonymous_Struct_167
  include Aws::Structure
end
class Anonymous_Struct_168 < Struct
  def error; end
  def error=(_); end
  def error_description; end
  def error_description=(_); end
  def self.[](*arg0); end
  def self.inspect; end
  def self.keyword_init?; end
  def self.members; end
  def self.new(*arg0); end
end
class Aws::SSOOIDC::Types::UnauthorizedClientException < Anonymous_Struct_168
  include Aws::Structure
end
class Anonymous_Struct_169 < Struct
  def error; end
  def error=(_); end
  def error_description; end
  def error_description=(_); end
  def self.[](*arg0); end
  def self.inspect; end
  def self.keyword_init?; end
  def self.members; end
  def self.new(*arg0); end
end
class Aws::SSOOIDC::Types::UnsupportedGrantTypeException < Anonymous_Struct_169
  include Aws::Structure
end
module Aws::SSOOIDC::ClientApi
  include Seahorse::Model
end
module Aws::SSOOIDC::Plugins
end
class Aws::SSOOIDC::Plugins::Endpoints < Seahorse::Client::Plugin
  def add_handlers(handlers, _config); end
end
class Aws::SSOOIDC::Plugins::Endpoints::Handler < Seahorse::Client::Handler
  def apply_endpoint_headers(context, headers); end
  def call(context); end
  def parameters_for_operation(context); end
end
class Aws::SSOOIDC::Client < Seahorse::Client::Base
  def build_request(operation_name, params = nil); end
  def create_token(params = nil, options = nil); end
  def create_token_with_iam(params = nil, options = nil); end
  def initialize(*args); end
  def register_client(params = nil, options = nil); end
  def self.errors_module; end
  def self.identifier; end
  def start_device_authorization(params = nil, options = nil); end
  def waiter_names; end
  include Anonymous_Module_170
  include Aws::ClientStubs
end
module Anonymous_Module_170
  def create_token(*args, &block); end
  def create_token_with_iam(*args, &block); end
  def register_client(*args, &block); end
  def start_device_authorization(*args, &block); end
end
module Aws::SSOOIDC::Errors
  extend Aws::Errors::DynamicErrors
end
class Aws::SSOOIDC::Errors::ServiceError < Aws::Errors::ServiceError
end
class Aws::SSOOIDC::Errors::AccessDeniedException < Aws::SSOOIDC::Errors::ServiceError
  def error; end
  def error_description; end
  def initialize(context, message, data = nil); end
end
class Aws::SSOOIDC::Errors::AuthorizationPendingException < Aws::SSOOIDC::Errors::ServiceError
  def error; end
  def error_description; end
  def initialize(context, message, data = nil); end
end
class Aws::SSOOIDC::Errors::ExpiredTokenException < Aws::SSOOIDC::Errors::ServiceError
  def error; end
  def error_description; end
  def initialize(context, message, data = nil); end
end
class Aws::SSOOIDC::Errors::InternalServerException < Aws::SSOOIDC::Errors::ServiceError
  def error; end
  def error_description; end
  def initialize(context, message, data = nil); end
end
class Aws::SSOOIDC::Errors::InvalidClientException < Aws::SSOOIDC::Errors::ServiceError
  def error; end
  def error_description; end
  def initialize(context, message, data = nil); end
end
class Aws::SSOOIDC::Errors::InvalidClientMetadataException < Aws::SSOOIDC::Errors::ServiceError
  def error; end
  def error_description; end
  def initialize(context, message, data = nil); end
end
class Aws::SSOOIDC::Errors::InvalidGrantException < Aws::SSOOIDC::Errors::ServiceError
  def error; end
  def error_description; end
  def initialize(context, message, data = nil); end
end
class Aws::SSOOIDC::Errors::InvalidRedirectUriException < Aws::SSOOIDC::Errors::ServiceError
  def error; end
  def error_description; end
  def initialize(context, message, data = nil); end
end
class Aws::SSOOIDC::Errors::InvalidRequestException < Aws::SSOOIDC::Errors::ServiceError
  def error; end
  def error_description; end
  def initialize(context, message, data = nil); end
end
class Aws::SSOOIDC::Errors::InvalidRequestRegionException < Aws::SSOOIDC::Errors::ServiceError
  def endpoint; end
  def error; end
  def error_description; end
  def initialize(context, message, data = nil); end
  def region; end
end
class Aws::SSOOIDC::Errors::InvalidScopeException < Aws::SSOOIDC::Errors::ServiceError
  def error; end
  def error_description; end
  def initialize(context, message, data = nil); end
end
class Aws::SSOOIDC::Errors::SlowDownException < Aws::SSOOIDC::Errors::ServiceError
  def error; end
  def error_description; end
  def initialize(context, message, data = nil); end
end
class Aws::SSOOIDC::Errors::UnauthorizedClientException < Aws::SSOOIDC::Errors::ServiceError
  def error; end
  def error_description; end
  def initialize(context, message, data = nil); end
end
class Aws::SSOOIDC::Errors::UnsupportedGrantTypeException < Aws::SSOOIDC::Errors::ServiceError
  def error; end
  def error_description; end
  def initialize(context, message, data = nil); end
end
class Aws::SSOOIDC::Resource
  def client; end
  def initialize(options = nil); end
end
class Aws::SSOOIDC::EndpointParameters < Struct
  def endpoint; end
  def endpoint=(_); end
  def initialize(options = nil); end
  def region; end
  def region=(_); end
  def self.[](*arg0); end
  def self.inspect; end
  def self.keyword_init?; end
  def self.members; end
  def self.new(*arg0); end
  def use_dual_stack; end
  def use_dual_stack=(_); end
  def use_fips; end
  def use_fips=(_); end
  include Aws::Structure
end
class Aws::SSOOIDC::EndpointProvider
  def resolve_endpoint(parameters); end
end
module Aws::SSOOIDC::Endpoints
end
class Aws::SSOOIDC::Endpoints::CreateToken
  def self.build(context); end
end
class Aws::SSOOIDC::Endpoints::CreateTokenWithIAM
  def self.build(context); end
end
class Aws::SSOOIDC::Endpoints::RegisterClient
  def self.build(context); end
end
class Aws::SSOOIDC::Endpoints::StartDeviceAuthorization
  def self.build(context); end
end
class Aws::Plugins::Protocols::JsonRpc < Seahorse::Client::Plugin
end
class Aws::Plugins::Protocols::RestXml < Seahorse::Client::Plugin
end
class Aws::Plugins::EventStreamConfiguration < Seahorse::Client::Plugin
end
module Aws::Waiters
end
module Aws::Waiters::Errors
end
class Aws::Waiters::Errors::WaiterFailed < StandardError
end
class Aws::Waiters::Errors::FailureStateError < Aws::Waiters::Errors::WaiterFailed
  def initialize(response); end
  def response; end
end
class Aws::Waiters::Errors::TooManyAttemptsError < Aws::Waiters::Errors::WaiterFailed
  def attempts; end
  def initialize(attempts); end
end
class Aws::Waiters::Errors::UnexpectedError < Aws::Waiters::Errors::WaiterFailed
  def error; end
  def initialize(error); end
end
class Aws::Waiters::Errors::NoSuchWaiterError < ArgumentError
  def initialize(waiter_name, waiter_names); end
end
class Aws::Waiters::Poller
  def acceptor_matches?(acceptor, response); end
  def call(options = nil); end
  def initialize(options = nil); end
  def matches_error?(acceptor, response); end
  def matches_path?(acceptor, response); end
  def matches_pathAll?(acceptor, response); end
  def matches_pathAny?(acceptor, response); end
  def matches_status?(acceptor, response); end
  def non_empty_array(acceptor, response, &block); end
  def operation_name; end
  def path(acceptor); end
  def send_request(options); end
end
class Aws::Waiters::Waiter
  def before_attempt(&block); end
  def before_wait(&block); end
  def delay; end
  def delay=(arg0); end
  def initialize(options = nil); end
  def interval; end
  def interval=(arg0); end
  def max_attempts; end
  def max_attempts=(arg0); end
  def poll(options); end
  def poller; end
  def trigger_before_attempt(attempts); end
  def trigger_before_wait(attempts, response); end
  def wait(options); end
end
