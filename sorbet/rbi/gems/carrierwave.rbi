# This file is autogenerated. Do not edit it by hand. Regenerate it with:
#   srb rbi gems

# typed: true
#
# If you would like to make changes to this file, great! Please create the gem's shim here:
#
#   https://github.com/sorbet/sorbet-typed/new/master?filename=lib/carrierwave/all/carrierwave.rbi
#
# carrierwave-3.0.7

module CarrierWave
  def self.base_path; end
  def self.base_path=(arg0); end
  def self.clean_cached_files!(seconds = nil); end
  def self.configure(&block); end
  def self.generate_cache_id; end
  def self.root; end
  def self.root=(arg0); end
  def self.tmp_path; end
  def self.tmp_path=(arg0); end
end
module CarrierWave::Utilities
end
module CarrierWave::Utilities::Uri
  def decode_uri(str); end
  def encode_non_ascii(str); end
  def encode_path(path); end
end
module CarrierWave::Utilities::FileName
  def basename; end
  def extension; end
  def split_extension(filename); end
end
class CarrierWave::UploadError < StandardError
end
class CarrierWave::IntegrityError < CarrierWave::UploadError
end
class CarrierWave::InvalidParameter < CarrierWave::UploadError
end
class CarrierWave::ProcessingError < CarrierWave::UploadError
end
class CarrierWave::DownloadError < CarrierWave::UploadError
end
class CarrierWave::UnknownStorageError < StandardError
end
class CarrierWave::SanitizedFile
  def chmod!(path, permissions); end
  def content_type; end
  def content_type=(type); end
  def copy!(new_path); end
  def copy_to(new_path, permissions = nil, directory_permissions = nil); end
  def declared_content_type; end
  def delete; end
  def empty?; end
  def exists?; end
  def file; end
  def file=(file); end
  def filename; end
  def guessed_safe_content_type; end
  def identified_content_type; end
  def identifier; end
  def initialize(file); end
  def is_path?; end
  def mkdir!(path, directory_permissions); end
  def move!(new_path); end
  def move_to(new_path, permissions = nil, directory_permissions = nil, keep_filename = nil); end
  def original_filename; end
  def path; end
  def read(*args); end
  def sanitize(name); end
  def sanitize_regexp; end
  def self.sanitize_regexp; end
  def self.sanitize_regexp=(arg0); end
  def size; end
  def to_file; end
  def with_io(&block); end
  include CarrierWave::Utilities::FileName
end
class CarrierWave::Mounter
  def blank?; end
  def blank_uploader; end
  def cache(new_files); end
  def cache_names; end
  def cache_names=(cache_names); end
  def clear!; end
  def clear_unstaged; end
  def column; end
  def download_errors; end
  def handle_error; end
  def identifiers; end
  def initialize(record, column); end
  def integrity_errors; end
  def option(name); end
  def processing_errors; end
  def read_identifiers; end
  def record; end
  def remote_request_headers; end
  def remote_request_headers=(arg0); end
  def remote_urls; end
  def remote_urls=(urls); end
  def remove!; end
  def remove; end
  def remove=(value); end
  def remove?; end
  def remove_added; end
  def remove_previous; end
  def reset_changes!; end
  def self.build(record, column); end
  def serialization_column; end
  def store!; end
  def temporary_identifiers; end
  def uploader_class; end
  def uploader_options; end
  def uploader_options=(arg0); end
  def uploaders; end
  def urls(*args); end
  def write_identifier; end
  def write_temporary_identifier; end
end
class CarrierWave::Mounter::Single < CarrierWave::Mounter
  def identifier; end
  def temporary_identifier; end
end
class CarrierWave::Mounter::Multiple < CarrierWave::Mounter
  def identifier; end
  def temporary_identifier; end
end
module CarrierWave::Mount
  def build_uploader(uploader, column, &block); end
  def mount_base(column, uploader = nil, options = nil, &block); end
  def mount_uploader(column, uploader = nil, options = nil, &block); end
  def mount_uploaders(column, uploader = nil, options = nil, &block); end
  def uploader_option(column, option); end
  def uploader_options; end
  def uploaders; end
end
module CarrierWave::Mount::Extension
  def _mounter(column); end
  def initialize_dup(other); end
  def read_uploader(column); end
  def write_uploader(column, identifier); end
end
module CarrierWave::RMagick
  def convert(format); end
  def create_info_block(options); end
  def destroy_image(image); end
  def dimension_from(value); end
  def height; end
  def manipulate!(options = nil, &block); end
  def resize_and_pad(width, height, background = nil, gravity = nil); end
  def resize_to_fill(width, height, gravity = nil); end
  def resize_to_fit(width, height); end
  def resize_to_geometry_string(geometry_string); end
  def resize_to_limit(width, height); end
  def rmagick_image; end
  def width; end
  extend ActiveSupport::Concern
end
module CarrierWave::RMagick::ClassMethods
  def convert(format); end
  def resize_and_pad(width, height, background = nil, gravity = nil); end
  def resize_to_fill(width, height, gravity = nil); end
  def resize_to_fit(width, height); end
  def resize_to_geometry_string(geometry_string); end
  def resize_to_limit(width, height); end
end
module CarrierWave::MiniMagick
  def convert(format, page = nil, &block); end
  def height; end
  def manipulate!; end
  def mini_magick_image; end
  def minimagick!(block = nil); end
  def resize_and_pad(width, height, background = nil, gravity = nil, combine_options: nil, &block); end
  def resize_to_fill(width, height, gravity = nil, combine_options: nil, &block); end
  def resize_to_fit(width, height, combine_options: nil, &block); end
  def resize_to_limit(width, height, combine_options: nil, &block); end
  def resolve_dimensions(*dimensions); end
  def width; end
  extend ActiveSupport::Concern
end
module CarrierWave::MiniMagick::ClassMethods
  def convert(format); end
  def resize_and_pad(width, height, background = nil, gravity = nil); end
  def resize_to_fill(width, height, gravity = nil); end
  def resize_to_fit(width, height); end
  def resize_to_limit(width, height); end
end
module CarrierWave::Vips
  def convert(format, page = nil); end
  def height; end
  def resize_and_pad(width, height, background = nil, gravity = nil, alpha = nil, combine_options: nil); end
  def resize_to_fill(width, height, _gravity = nil, combine_options: nil); end
  def resize_to_fit(width, height, combine_options: nil); end
  def resize_to_limit(width, height, combine_options: nil); end
  def resolve_dimensions(*dimensions); end
  def vips!; end
  def vips_image; end
  def width; end
  extend ActiveSupport::Concern
end
module CarrierWave::Vips::ClassMethods
  def convert(format); end
  def resize_and_pad(width, height, background = nil, gravity = nil, alpha = nil); end
  def resize_to_fill(width, height, gravity = nil); end
  def resize_to_fit(width, height); end
  def resize_to_limit(width, height); end
end
module CarrierWave::Storage
end
class CarrierWave::Storage::Abstract
  def cache!(new_file); end
  def clean_cache!(seconds); end
  def delete_dir!(path); end
  def identifier; end
  def initialize(uploader); end
  def retrieve!(identifier); end
  def retrieve_from_cache!(identifier); end
  def store!(file); end
  def uploader; end
end
class CarrierWave::Storage::File < CarrierWave::Storage::Abstract
  def cache!(new_file); end
  def clean_cache!(seconds); end
  def delete_dir!(path); end
  def initialize(*); end
  def retrieve!(identifier); end
  def retrieve_from_cache!(identifier); end
  def store!(file); end
end
class CarrierWave::Storage::Fog < CarrierWave::Storage::Abstract
  def cache!(new_file); end
  def clean_cache!(seconds); end
  def connection; end
  def delete_dir!(path); end
  def retrieve!(identifier); end
  def retrieve_from_cache!(identifier); end
  def self.connection_cache; end
  def self.eager_load; end
  def store!(file); end
end
class CarrierWave::Storage::Fog::File
  def acl_header; end
  def attributes; end
  def authenticated_url(options = nil); end
  def connection; end
  def content_type; end
  def content_type=(new_content_type); end
  def copy_options; end
  def copy_to(new_path); end
  def delete; end
  def directory; end
  def exists?; end
  def file; end
  def filename(options = nil); end
  def fog_provider; end
  def headers; end
  def initialize(uploader, base, path); end
  def path; end
  def public_url; end
  def read; end
  def read_source_file; end
  def size; end
  def store(new_file); end
  def to_file; end
  def url(options = nil); end
  def url_options_supported?(local_file); end
  include CarrierWave::Utilities::FileName
  include CarrierWave::Utilities::Uri
end
module CarrierWave::Downloader
end
class CarrierWave::Downloader::RemoteFile
  def content_type; end
  def file; end
  def filename_from_header; end
  def filename_from_uri; end
  def headers; end
  def initialize(file); end
  def method_missing(*args, &block); end
  def original_filename; end
  def respond_to_missing?(*args); end
  def uri; end
end
class CarrierWave::Downloader::Base
  def download(url, remote_headers = nil); end
  def initialize(uploader); end
  def process_uri(source); end
  def skip_ssrf_protection?(uri); end
  def uploader; end
  include CarrierWave::Utilities::Uri
end
module CarrierWave::Uploader
end
module CarrierWave::Uploader::Configuration
  extend ActiveSupport::Concern
end
module CarrierWave::Uploader::Configuration::ClassMethods
  def add_config(name); end
  def add_deprecated_config(name); end
  def cache_storage(storage = nil); end
  def cache_storage=(storage = nil); end
  def configure; end
  def reset_config; end
  def storage(storage = nil); end
  def storage=(storage = nil); end
end
module CarrierWave::Uploader::Callbacks
  def with_callbacks(kind, *args); end
  extend ActiveSupport::Concern
end
module CarrierWave::Uploader::Callbacks::ClassMethods
  def after(kind, callback); end
  def before(kind, callback); end
end
module CarrierWave::Uploader::Proxy
  def blank?; end
  def content_type; end
  def current_path; end
  def identifier; end
  def length; end
  def path; end
  def read(*args); end
  def size; end
  def temporary_identifier; end
end
module CarrierWave::Uploader::Url
  def to_s; end
  def url(options = nil); end
  extend ActiveSupport::Concern
  include CarrierWave::Uploader::Configuration
  include CarrierWave::Utilities::Uri
end
module CarrierWave::Uploader::Mountable
  def index; end
  def initialize(model = nil, mounted_as = nil); end
  def model; end
  def mounted_as; end
end
class CarrierWave::FormNotMultipart < CarrierWave::UploadError
  def message; end
end
class CarrierWave::CacheCounter
  def self.increment; end
end
module CarrierWave::Uploader::Cache
  def cache!(new_file = nil); end
  def cache_id; end
  def cache_id=(cache_id); end
  def cache_name; end
  def cache_path(for_file = nil); end
  def cache_storage; end
  def cache_stored_file!; end
  def cached?; end
  def full_original_filename; end
  def original_filename; end
  def original_filename=(filename); end
  def retrieve_from_cache!(cache_name); end
  def sanitized_file; end
  def workfile_path(for_file = nil); end
  extend ActiveSupport::Concern
  include CarrierWave::Uploader::Callbacks
  include CarrierWave::Uploader::Configuration
end
module CarrierWave::Uploader::Cache::ClassMethods
  def clean_cached_files!(seconds = nil); end
end
module CarrierWave::Uploader::Store
  def deduplicate(current_identifiers); end
  def deduplicated_filename; end
  def filename; end
  def full_filename(for_file); end
  def retrieve_from_store!(identifier); end
  def storage; end
  def store!(new_file = nil); end
  def store_path(for_file = nil); end
  extend ActiveSupport::Concern
  include CarrierWave::Uploader::Cache
  include CarrierWave::Uploader::Callbacks
  include CarrierWave::Uploader::Configuration
end
module CarrierWave::Uploader::Download
  def download!(uri, remote_headers = nil); end
  extend ActiveSupport::Concern
  include CarrierWave::Uploader::Cache
  include CarrierWave::Uploader::Callbacks
  include CarrierWave::Uploader::Configuration
end
module CarrierWave::Uploader::Remove
  def remove!; end
  extend ActiveSupport::Concern
  include CarrierWave::Uploader::Callbacks
end
module CarrierWave::Uploader::ExtensionAllowlist
  def allowlisted_extension?(allowlist, extension); end
  def check_extension_allowlist!(new_file); end
  def extension_allowlist; end
  extend ActiveSupport::Concern
end
module CarrierWave::Uploader::ExtensionDenylist
  def check_extension_denylist!(new_file); end
  def denylisted_extension?(denylist, extension); end
  def extension_denylist; end
  extend ActiveSupport::Concern
end
module CarrierWave::Uploader::ContentTypeAllowlist
  def allowlisted_content_type?(allowlist, content_type); end
  def check_content_type_allowlist!(new_file); end
  def content_type_allowlist; end
  extend ActiveSupport::Concern
end
module CarrierWave::Uploader::ContentTypeDenylist
  def check_content_type_denylist!(new_file); end
  def content_type_denylist; end
  def denylisted_content_type?(denylist, content_type); end
  extend ActiveSupport::Concern
end
module CarrierWave::Uploader::FileSize
  def check_size!(new_file); end
  def size_range; end
  extend ActiveSupport::Concern
end
module CarrierWave::Uploader::Dimension
  def check_dimensions!(new_file); end
  def height_range; end
  def width_range; end
  extend ActiveSupport::Concern
end
module CarrierWave::Uploader::Processing
  def forcing_extension(filename); end
  def process!(new_file = nil); end
  extend ActiveSupport::Concern
  include CarrierWave::Uploader::Callbacks
end
module CarrierWave::Uploader::Processing::ClassMethods
  def process(*args); end
end
module CarrierWave::Uploader::Versions
  def active_sibling_versions; end
  def active_versions; end
  def cache!(*args); end
  def cache_versions!(new_file); end
  def derived_versions; end
  def descendant_version_names; end
  def full_filename(for_file); end
  def full_original_filename; end
  def recreate_versions!(*names); end
  def remove_versions!; end
  def retrieve_versions_from_cache!(cache_name); end
  def retrieve_versions_from_store!(identifier); end
  def store_versions!(new_file); end
  def url(*args); end
  def version_exists?(name); end
  def version_name; end
  def versions; end
  extend ActiveSupport::Concern
  include CarrierWave::Uploader::Callbacks
end
class CarrierWave::Uploader::Versions::Builder
  def build(superclass); end
  def configure(options, &block); end
  def deep_dup; end
  def initialize(name); end
  def method_missing(name, *args); end
  def respond_to_missing?(*); end
end
module CarrierWave::Uploader::Versions::ClassMethods
  def inherited(subclass); end
  def version(name, options = nil, &block); end
end
module CarrierWave::Uploader::DefaultUrl
  def default_url(*args); end
  def url(*args); end
end
module CarrierWave::Uploader::Serialization
  def as_json(options = nil); end
  def serializable_hash(options = nil); end
  def to_json(options = nil); end
  def to_xml(options = nil); end
  extend ActiveSupport::Concern
end
class CarrierWave::Uploader::Base
  def _after_callbacks; end
  def _after_callbacks?; end
  def _before_callbacks; end
  def _before_callbacks?; end
  def _cache_storage; end
  def _cache_storage?; end
  def _storage; end
  def _storage?; end
  def asset_host; end
  def asset_host=(value); end
  def base_path; end
  def base_path=(value); end
  def cache_dir; end
  def cache_dir=(value); end
  def cache_only; end
  def cache_only=(value); end
  def delete_tmp_file_after_storage; end
  def delete_tmp_file_after_storage=(value); end
  def directory_permissions; end
  def directory_permissions=(value); end
  def download_retry_count; end
  def download_retry_count=(value); end
  def download_retry_wait_time; end
  def download_retry_wait_time=(value); end
  def downloader; end
  def downloader=(value); end
  def enable_processing; end
  def enable_processing=(value); end
  def ensure_multipart_form; end
  def ensure_multipart_form=(value); end
  def file; end
  def fog_attributes; end
  def fog_attributes=(value); end
  def fog_authenticated_url_expiration; end
  def fog_authenticated_url_expiration=(value); end
  def fog_aws_accelerate; end
  def fog_aws_accelerate=(value); end
  def fog_credentials; end
  def fog_credentials=(value); end
  def fog_directory; end
  def fog_directory=(value); end
  def fog_provider; end
  def fog_provider=(value); end
  def fog_public; end
  def fog_public=(value); end
  def fog_use_ssl_for_aws; end
  def fog_use_ssl_for_aws=(value); end
  def force_extension; end
  def force_extension=(value); end
  def ignore_download_errors; end
  def ignore_download_errors=(value); end
  def ignore_integrity_errors; end
  def ignore_integrity_errors=(value); end
  def ignore_processing_errors; end
  def ignore_processing_errors=(value); end
  def mount_on; end
  def mount_on=(value); end
  def move_to_cache; end
  def move_to_cache=(value); end
  def move_to_store; end
  def move_to_store=(value); end
  def parent_version; end
  def parent_version=(arg0); end
  def permissions; end
  def permissions=(value); end
  def processors; end
  def processors?; end
  def remove_previously_stored_files_after_update; end
  def remove_previously_stored_files_after_update=(value); end
  def root; end
  def root=(value); end
  def self._after_callbacks; end
  def self._after_callbacks=(value); end
  def self._after_callbacks?; end
  def self._before_callbacks; end
  def self._before_callbacks=(value); end
  def self._before_callbacks?; end
  def self._cache_storage; end
  def self._cache_storage=(value); end
  def self._cache_storage?; end
  def self._storage; end
  def self._storage=(value); end
  def self._storage?; end
  def self.asset_host(value = nil); end
  def self.asset_host=(value); end
  def self.base_path(value = nil); end
  def self.base_path=(value); end
  def self.cache_dir(value = nil); end
  def self.cache_dir=(value); end
  def self.cache_only(value = nil); end
  def self.cache_only=(value); end
  def self.delete_tmp_file_after_storage(value = nil); end
  def self.delete_tmp_file_after_storage=(value); end
  def self.directory_permissions(value = nil); end
  def self.directory_permissions=(value); end
  def self.download_retry_count(value = nil); end
  def self.download_retry_count=(value); end
  def self.download_retry_wait_time(value = nil); end
  def self.download_retry_wait_time=(value); end
  def self.downloader(value = nil); end
  def self.downloader=(value); end
  def self.enable_processing(value = nil); end
  def self.enable_processing=(value); end
  def self.ensure_multipart_form(value = nil); end
  def self.ensure_multipart_form=(value); end
  def self.fog_attributes(value = nil); end
  def self.fog_attributes=(value); end
  def self.fog_authenticated_url_expiration(value = nil); end
  def self.fog_authenticated_url_expiration=(value); end
  def self.fog_aws_accelerate(value = nil); end
  def self.fog_aws_accelerate=(value); end
  def self.fog_credentials(value = nil); end
  def self.fog_credentials=(value); end
  def self.fog_directory(value = nil); end
  def self.fog_directory=(value); end
  def self.fog_provider(value = nil); end
  def self.fog_provider=(value); end
  def self.fog_public(value = nil); end
  def self.fog_public=(value); end
  def self.fog_use_ssl_for_aws(value = nil); end
  def self.fog_use_ssl_for_aws=(value); end
  def self.force_extension(value = nil); end
  def self.force_extension=(value); end
  def self.ignore_download_errors(value = nil); end
  def self.ignore_download_errors=(value); end
  def self.ignore_integrity_errors(value = nil); end
  def self.ignore_integrity_errors=(value); end
  def self.ignore_processing_errors(value = nil); end
  def self.ignore_processing_errors=(value); end
  def self.mount_on(value = nil); end
  def self.mount_on=(value); end
  def self.move_to_cache(value = nil); end
  def self.move_to_cache=(value); end
  def self.move_to_store(value = nil); end
  def self.move_to_store=(value); end
  def self.permissions(value = nil); end
  def self.permissions=(value); end
  def self.processors; end
  def self.processors=(value); end
  def self.processors?; end
  def self.remove_previously_stored_files_after_update(value = nil); end
  def self.remove_previously_stored_files_after_update=(value); end
  def self.root(value = nil); end
  def self.root=(value); end
  def self.storage_engines(value = nil); end
  def self.storage_engines=(value); end
  def self.store_dir(value = nil); end
  def self.store_dir=(value); end
  def self.validate_download(value = nil); end
  def self.validate_download=(value); end
  def self.validate_integrity(value = nil); end
  def self.validate_integrity=(value); end
  def self.validate_processing(value = nil); end
  def self.validate_processing=(value); end
  def self.version_names; end
  def self.version_names=(value); end
  def self.version_names?; end
  def self.version_options; end
  def self.version_options=(value); end
  def self.version_options?; end
  def self.versions; end
  def self.versions=(value); end
  def self.versions?; end
  def staged; end
  def staged=(arg0); end
  def storage_engines; end
  def storage_engines=(value); end
  def store_dir; end
  def store_dir=(value); end
  def validate_download; end
  def validate_download=(value); end
  def validate_integrity; end
  def validate_integrity=(value); end
  def validate_processing; end
  def validate_processing=(value); end
  extend CarrierWave::Uploader::Cache::ClassMethods
  extend CarrierWave::Uploader::Callbacks::ClassMethods
  extend CarrierWave::Uploader::Configuration::ClassMethods
  extend CarrierWave::Uploader::Processing::ClassMethods
  extend CarrierWave::Uploader::Versions::ClassMethods
  include CarrierWave::Uploader::Cache
  include CarrierWave::Uploader::Cache
  include CarrierWave::Uploader::Cache
  include CarrierWave::Uploader::Callbacks
  include CarrierWave::Uploader::Callbacks
  include CarrierWave::Uploader::Callbacks
  include CarrierWave::Uploader::Callbacks
  include CarrierWave::Uploader::Callbacks
  include CarrierWave::Uploader::Callbacks
  include CarrierWave::Uploader::Callbacks
  include CarrierWave::Uploader::Configuration
  include CarrierWave::Uploader::Configuration
  include CarrierWave::Uploader::Configuration
  include CarrierWave::Uploader::Configuration
  include CarrierWave::Uploader::Configuration
  include CarrierWave::Uploader::ContentTypeAllowlist
  include CarrierWave::Uploader::ContentTypeDenylist
  include CarrierWave::Uploader::DefaultUrl
  include CarrierWave::Uploader::Dimension
  include CarrierWave::Uploader::Download
  include CarrierWave::Uploader::ExtensionAllowlist
  include CarrierWave::Uploader::ExtensionDenylist
  include CarrierWave::Uploader::FileSize
  include CarrierWave::Uploader::Mountable
  include CarrierWave::Uploader::Processing
  include CarrierWave::Uploader::Proxy
  include CarrierWave::Uploader::Remove
  include CarrierWave::Uploader::Serialization
  include CarrierWave::Uploader::Store
  include CarrierWave::Uploader::Url
  include CarrierWave::Uploader::Versions
end
module CarrierWave::Compatibility
end
module CarrierWave::Compatibility::Paperclip
  def interpolate_paperclip_path(path); end
  def paperclip_default_style; end
  def paperclip_path; end
  def paperclip_style; end
  def store_dir; end
  def store_path(for_file = nil); end
  extend ActiveSupport::Concern
end
module CarrierWave::Compatibility::Paperclip::ClassMethods
  def interpolate(sym, &block); end
end
module CarrierWave::Test
end
module CarrierWave::Test::Matchers
  def be_format(expected); end
  def be_identical_to(expected); end
  def be_no_larger_than(width, height); end
  def be_no_taller_than(height); end
  def be_no_wider_than(width); end
  def have_dimensions(width, height); end
  def have_directory_permissions(expected); end
  def have_height(height); end
  def have_permissions(expected); end
  def have_width(width); end
end
class CarrierWave::Test::Matchers::BeIdenticalTo
  def description; end
  def failure_message; end
  def failure_message_when_negated; end
  def initialize(expected); end
  def matches?(actual); end
  def negative_failure_message; end
end
class CarrierWave::Test::Matchers::HavePermissions
  def description; end
  def failure_message; end
  def failure_message_when_negated; end
  def initialize(expected); end
  def matches?(actual); end
  def negative_failure_message; end
end
class CarrierWave::Test::Matchers::HaveDirectoryPermissions
  def description; end
  def failure_message; end
  def failure_message_when_negated; end
  def initialize(expected); end
  def matches?(actual); end
  def negative_failure_message; end
end
class CarrierWave::Test::Matchers::BeNoLargerThan
  def description; end
  def failure_message; end
  def failure_message_when_negated; end
  def initialize(width, height); end
  def matches?(actual); end
  def negative_failure_message; end
end
class CarrierWave::Test::Matchers::HaveDimensions
  def description; end
  def failure_message; end
  def failure_message_when_negated; end
  def initialize(width, height); end
  def matches?(actual); end
  def negative_failure_message; end
end
class CarrierWave::Test::Matchers::HaveHeight
  def description; end
  def failure_message; end
  def failure_message_when_negated; end
  def initialize(height); end
  def matches?(actual); end
  def negative_failure_message; end
end
class CarrierWave::Test::Matchers::HaveWidth
  def description; end
  def failure_message; end
  def failure_message_when_negated; end
  def initialize(width); end
  def matches?(actual); end
  def negative_failure_message; end
end
class CarrierWave::Test::Matchers::BeNoWiderThan
  def description; end
  def failure_message; end
  def failure_message_when_negated; end
  def initialize(width); end
  def matches?(actual); end
  def negative_failure_message; end
end
class CarrierWave::Test::Matchers::BeNoTallerThan
  def description; end
  def failure_message; end
  def failure_message_when_negated; end
  def initialize(height); end
  def matches?(actual); end
  def negative_failure_message; end
end
class CarrierWave::Test::Matchers::BeFormat
  def description; end
  def failure_message; end
  def failure_message_when_negated; end
  def initialize(expected); end
  def matches?(actual); end
  def negative_failure_message; end
end
class CarrierWave::Test::Matchers::ImageLoader
  def self.load_image(filename); end
end
class CarrierWave::Test::Matchers::MagickWrapper
  def format; end
  def height; end
  def image; end
  def initialize(filename); end
  def width; end
end
class CarrierWave::Test::Matchers::MiniMagickWrapper
  def format; end
  def height; end
  def image; end
  def initialize(filename); end
  def width; end
end
class CarrierWave::Railtie < Rails::Railtie
end
module CarrierWave::Validations
end
module CarrierWave::Validations::ActiveModel
  extend ActiveSupport::Concern
end
class CarrierWave::Validations::ActiveModel::ProcessingValidator < ActiveModel::EachValidator
  def validate_each(record, attribute, value); end
end
class CarrierWave::Validations::ActiveModel::IntegrityValidator < ActiveModel::EachValidator
  def validate_each(record, attribute, value); end
end
class CarrierWave::Validations::ActiveModel::DownloadValidator < ActiveModel::EachValidator
  def validate_each(record, attribute, value); end
end
module CarrierWave::Validations::ActiveModel::HelperMethods
  def validates_download_of(*attr_names); end
  def validates_integrity_of(*attr_names); end
  def validates_processing_of(*attr_names); end
end
module CarrierWave::ActiveRecord
  def mount_base(column, uploader = nil, options = nil, &block); end
  include CarrierWave::Mount
end
class ActiveRecord::Base
  extend CarrierWave::ActiveRecord
end
