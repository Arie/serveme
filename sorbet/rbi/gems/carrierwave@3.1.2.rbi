# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `carrierwave` gem.
# Please instead update this file by running `bin/tapioca gem carrierwave`.


# source://carrierwave//lib/carrierwave.rb#8
module CarrierWave
  class << self
    # Returns the value of attribute base_path.
    #
    # source://carrierwave//lib/carrierwave.rb#11
    def base_path; end

    # Sets the attribute base_path
    #
    # @param value the value to set the attribute base_path to.
    #
    # source://carrierwave//lib/carrierwave.rb#11
    def base_path=(_arg0); end

    # source://carrierwave//lib/carrierwave.rb#18
    def clean_cached_files!(seconds = T.unsafe(nil)); end

    # source://carrierwave//lib/carrierwave.rb#14
    def configure(&block); end

    # source://carrierwave//lib/carrierwave.rb#26
    def deprecator; end

    # Generates a unique cache id for use in the caching system
    #
    # === Returns
    #
    # [String] a cache id in the format TIMEINT-PID-COUNTER-RND
    #
    # source://carrierwave//lib/carrierwave/uploader/cache.rb#26
    def generate_cache_id; end

    # Returns the value of attribute root.
    #
    # source://carrierwave//lib/carrierwave.rb#11
    def root; end

    # Sets the attribute root
    #
    # @param value the value to set the attribute root to.
    #
    # source://carrierwave//lib/carrierwave.rb#11
    def root=(_arg0); end

    # source://carrierwave//lib/carrierwave.rb#22
    def tmp_path; end

    # Sets the attribute tmp_path
    #
    # @param value the value to set the attribute tmp_path to.
    #
    # source://carrierwave//lib/carrierwave.rb#12
    def tmp_path=(_arg0); end
  end
end

# source://carrierwave//lib/carrierwave/uploader/cache.rb#11
class CarrierWave::CacheCounter
  class << self
    # source://carrierwave//lib/carrierwave/uploader/cache.rb#14
    def increment; end
  end
end

# source://carrierwave//lib/carrierwave/compatibility/paperclip.rb#2
module CarrierWave::Compatibility; end

# source://carrierwave//lib/carrierwave/compatibility/paperclip.rb#46
module CarrierWave::Compatibility::Paperclip
  extend ::ActiveSupport::Concern
  include GeneratedInstanceMethods

  mixes_in_class_methods GeneratedClassMethods
  mixes_in_class_methods ::CarrierWave::Compatibility::Paperclip::ClassMethods

  # source://carrierwave//lib/carrierwave/compatibility/paperclip.rb#79
  def paperclip_default_style; end

  # source://carrierwave//lib/carrierwave/compatibility/paperclip.rb#83
  def paperclip_path; end

  # source://carrierwave//lib/carrierwave/compatibility/paperclip.rb#86
  def paperclip_style; end

  # source://carrierwave//lib/carrierwave/compatibility/paperclip.rb#75
  def store_dir; end

  # source://carrierwave//lib/carrierwave/compatibility/paperclip.rb#68
  def store_path(for_file = T.unsafe(nil)); end

  private

  # source://carrierwave//lib/carrierwave/compatibility/paperclip.rb#98
  def interpolate_paperclip_path(path); end

  module GeneratedClassMethods
    def mappings; end
    def mappings=(value); end
    def mappings?; end
  end

  module GeneratedInstanceMethods
    def mappings; end
    def mappings=(value); end
    def mappings?; end
  end
end

# source://carrierwave//lib/carrierwave/compatibility/paperclip.rb#90
module CarrierWave::Compatibility::Paperclip::ClassMethods
  # source://carrierwave//lib/carrierwave/compatibility/paperclip.rb#91
  def interpolate(sym, &block); end
end

# source://carrierwave//lib/carrierwave/compatibility/paperclip.rb#49
CarrierWave::Compatibility::Paperclip::DEFAULT_MAPPINGS = T.let(T.unsafe(nil), Hash)

# source://carrierwave//lib/carrierwave/error.rb#6
class CarrierWave::DownloadError < ::CarrierWave::UploadError; end

# source://carrierwave//lib/carrierwave/downloader/remote_file.rb#2
module CarrierWave::Downloader; end

# source://carrierwave//lib/carrierwave/downloader/base.rb#8
class CarrierWave::Downloader::Base
  include ::CarrierWave::Utilities::Uri

  # @return [Base] a new instance of Base
  #
  # source://carrierwave//lib/carrierwave/downloader/base.rb#13
  def initialize(uploader); end

  # Downloads a file from given URL and returns a RemoteFile.
  #
  # === Parameters
  #
  # [url (String)] The URL where the remote file is stored
  # [remote_headers (Hash)] Request headers
  #
  # source://carrierwave//lib/carrierwave/downloader/base.rb#25
  def download(url, remote_headers = T.unsafe(nil)); end

  # Processes the given URL by parsing it, and escaping if necessary. Public to allow overriding.
  #
  # === Parameters
  #
  # [url (String)] The URL where the remote file is stored
  #
  # source://carrierwave//lib/carrierwave/downloader/base.rb#66
  def process_uri(source); end

  # If this returns true, SSRF protection will be bypassed.
  # You can override this if you want to allow accessing specific local URIs that are not SSRF exploitable.
  #
  # === Parameters
  #
  # [uri (URI)] The URI where the remote file is stored
  #
  # === Examples
  #
  #     class CarrierWave::Downloader::CustomDownloader < CarrierWave::Downloader::Base
  #       def skip_ssrf_protection?(uri)
  #         uri.hostname == 'localhost' && uri.port == 80
  #       end
  #     end
  #
  #     my_uploader.downloader = CarrierWave::Downloader::CustomDownloader
  #
  # @return [Boolean]
  #
  # source://carrierwave//lib/carrierwave/downloader/base.rb#96
  def skip_ssrf_protection?(uri); end

  # Returns the value of attribute uploader.
  #
  # source://carrierwave//lib/carrierwave/downloader/base.rb#11
  def uploader; end
end

# source://carrierwave//lib/carrierwave/downloader/remote_file.rb#3
class CarrierWave::Downloader::RemoteFile
  # @return [RemoteFile] a new instance of RemoteFile
  #
  # source://carrierwave//lib/carrierwave/downloader/remote_file.rb#6
  def initialize(file); end

  # source://carrierwave//lib/carrierwave/downloader/remote_file.rb#26
  def content_type; end

  # Returns the value of attribute file.
  #
  # source://carrierwave//lib/carrierwave/downloader/remote_file.rb#4
  def file; end

  # source://carrierwave//lib/carrierwave/downloader/remote_file.rb#30
  def headers; end

  # source://carrierwave//lib/carrierwave/downloader/remote_file.rb#34
  def original_filename; end

  # Returns the value of attribute uri.
  #
  # source://carrierwave//lib/carrierwave/downloader/remote_file.rb#4
  def uri; end

  private

  # source://carrierwave//lib/carrierwave/downloader/remote_file.rb#46
  def filename_from_header; end

  # source://carrierwave//lib/carrierwave/downloader/remote_file.rb#55
  def filename_from_uri; end

  # source://carrierwave//lib/carrierwave/downloader/remote_file.rb#59
  def method_missing(*args, &block); end

  # @return [Boolean]
  #
  # source://carrierwave//lib/carrierwave/downloader/remote_file.rb#63
  def respond_to_missing?(*args); end
end

# source://carrierwave//lib/carrierwave/uploader/cache.rb#5
class CarrierWave::FormNotMultipart < ::CarrierWave::UploadError
  # source://carrierwave//lib/carrierwave/uploader/cache.rb#6
  def message; end
end

# source://carrierwave//lib/carrierwave/error.rb#3
class CarrierWave::IntegrityError < ::CarrierWave::UploadError; end

# source://carrierwave//lib/carrierwave/error.rb#4
class CarrierWave::InvalidParameter < ::CarrierWave::UploadError; end

# This module simplifies manipulation with MiniMagick by providing a set
# of convenient helper methods. If you want to use them, you'll need to
# require this file:
#
#     require 'carrierwave/processing/mini_magick'
#
# And then include it in your uploader:
#
#     class MyUploader < CarrierWave::Uploader::Base
#       include CarrierWave::MiniMagick
#     end
#
# You can now use the provided helpers:
#
#     class MyUploader < CarrierWave::Uploader::Base
#       include CarrierWave::MiniMagick
#
#       process :resize_to_fit => [200, 200]
#     end
#
# Or create your own helpers with the powerful minimagick! method, which
# yields an ImageProcessing::Builder object. Check out the ImageProcessing
# docs at http://github.com/janko-m/image_processing and the list of all
# available ImageMagick options at
# http://www.imagemagick.org/script/command-line-options.php for more info.
#
#     class MyUploader < CarrierWave::Uploader::Base
#       include CarrierWave::MiniMagick
#
#       process :radial_blur => 10
#
#       def radial_blur(amount)
#         minimagick! do |builder|
#           builder.radial_blur(amount)
#           builder = yield(builder) if block_given?
#           builder
#         end
#       end
#     end
#
# === Note
#
# The ImageProcessing gem uses MiniMagick, a mini replacement for RMagick
# that uses ImageMagick command-line tools, to build a "convert" command that
# performs the processing.
#
# You can find more information here:
#
# https://github.com/minimagick/minimagick/
#
# source://carrierwave//lib/carrierwave/processing/mini_magick.rb#55
module CarrierWave::MiniMagick
  extend ::ActiveSupport::Concern

  mixes_in_class_methods ::CarrierWave::MiniMagick::ClassMethods

  # Changes the image encoding format to the given format
  #
  # See http://www.imagemagick.org/script/command-line-options.php#format
  #
  # === Parameters
  #
  # [format (#to_s)] an abbreviation of the format
  #
  # === Yields
  #
  # [MiniMagick::Image] additional manipulations to perform
  #
  # === Examples
  #
  #     image.convert(:png)
  #
  # source://carrierwave//lib/carrierwave/processing/mini_magick.rb#105
  def convert(format, page = T.unsafe(nil), &block); end

  # Crop the image to the contents of a box positioned at [left] and [top], with the dimensions given
  # by [width] and [height]. The original image bottom/right edge is preserved if the cropping box falls
  # outside the image bounds.
  #
  # === Parameters
  #
  # [left (integer)] left edge of area to extract
  # [top (integer)] top edge of area to extract
  # [width (Integer)] width of area to extract
  # [height (Integer)] height of area to extract
  #
  # === Yields
  #
  # [MiniMagick::Image] additional manipulations to perform
  #
  # source://carrierwave//lib/carrierwave/processing/mini_magick.rb#233
  def crop(left, top, width, height, combine_options: T.unsafe(nil), &block); end

  # Returns the height of the image in pixels.
  #
  # === Returns
  #
  # [Integer] the image's height in pixels
  #
  # source://carrierwave//lib/carrierwave/processing/mini_magick.rb#260
  def height; end

  # Manipulate the image with MiniMagick. This method will load up an image
  # and then pass each of its frames to the supplied block. It will then
  # save the image to disk.
  #
  # NOTE: This method exists mostly for backwards compatibility, you should
  # probably use #minimagick!.
  #
  # === Gotcha
  #
  # This method assumes that the object responds to +current_path+.
  # Any class that this module is mixed into must have a +current_path+ method.
  # CarrierWave::Uploader does, so you won't need to worry about this in
  # most cases.
  #
  # === Yields
  #
  # [MiniMagick::Image] manipulations to perform
  #
  # === Raises
  #
  # [CarrierWave::ProcessingError] if manipulation failed.
  #
  # source://carrierwave//lib/carrierwave/processing/mini_magick.rb#287
  def manipulate!; end

  # Process the image with MiniMagick, using the ImageProcessing gem. This
  # method will build a "convert" ImageMagick command and execute it on the
  # current image.
  #
  # === Gotcha
  #
  # This method assumes that the object responds to +current_path+.
  # Any class that this module is mixed into must have a +current_path+ method.
  # CarrierWave::Uploader does, so you won't need to worry about this in
  # most cases.
  #
  # === Yields
  #
  # [ImageProcessing::Builder] use it to define processing to be performed
  #
  # === Raises
  #
  # [CarrierWave::ProcessingError] if processing failed.
  #
  # source://carrierwave//lib/carrierwave/processing/mini_magick.rb#321
  def minimagick!(block = T.unsafe(nil)); end

  # Resize the image to fit within the specified dimensions while retaining
  # the original aspect ratio. If necessary, will pad the remaining area
  # with the given color, which defaults to transparent (for gif and png,
  # white for jpeg).
  #
  # See http://www.imagemagick.org/script/command-line-options.php#gravity
  # for gravity options.
  #
  # === Parameters
  #
  # [width (Integer)] the width to scale the image to
  # [height (Integer)] the height to scale the image to
  # [background (String, :transparent)] the color of the background as a hexcode, like "#ff45de"
  # [gravity (String)] how to position the image
  # [combine_options (Hash)] additional ImageMagick options to apply before resizing
  #
  # === Yields
  #
  # [MiniMagick::Image] additional manipulations to perform
  #
  # source://carrierwave//lib/carrierwave/processing/mini_magick.rb#208
  def resize_and_pad(width, height, background = T.unsafe(nil), gravity = T.unsafe(nil), combine_options: T.unsafe(nil), &block); end

  # Resize the image to fit within the specified dimensions while retaining
  # the aspect ratio of the original image. If necessary, crop the image in the
  # larger dimension.
  #
  # === Parameters
  #
  # [width (Integer)] the width to scale the image to
  # [height (Integer)] the height to scale the image to
  # [gravity (String)] the current gravity suggestion (default: 'Center'; options: 'NorthWest', 'North', 'NorthEast', 'West', 'Center', 'East', 'SouthWest', 'South', 'SouthEast')
  # [combine_options (Hash)] additional ImageMagick options to apply before resizing
  #
  # === Yields
  #
  # [MiniMagick::Image] additional manipulations to perform
  #
  # source://carrierwave//lib/carrierwave/processing/mini_magick.rb#178
  def resize_to_fill(width, height, gravity = T.unsafe(nil), combine_options: T.unsafe(nil), &block); end

  # Resize the image to fit within the specified dimensions while retaining
  # the original aspect ratio. The image may be shorter or narrower than
  # specified in the smaller dimension but will not be larger than the specified values.
  #
  # === Parameters
  #
  # [width (Integer)] the width to scale the image to
  # [height (Integer)] the height to scale the image to
  # [combine_options (Hash)] additional ImageMagick options to apply before resizing
  #
  # === Yields
  #
  # [MiniMagick::Image] additional manipulations to perform
  #
  # source://carrierwave//lib/carrierwave/processing/mini_magick.rb#153
  def resize_to_fit(width, height, combine_options: T.unsafe(nil), &block); end

  # Resize the image to fit within the specified dimensions while retaining
  # the original aspect ratio. Will only resize the image if it is larger than the
  # specified dimensions. The resulting image may be shorter or narrower than specified
  # in the smaller dimension but will not be larger than the specified values.
  #
  # === Parameters
  #
  # [width (Integer)] the width to scale the image to
  # [height (Integer)] the height to scale the image to
  # [combine_options (Hash)] additional ImageMagick options to apply before resizing
  #
  # === Yields
  #
  # [MiniMagick::Image] additional manipulations to perform
  #
  # source://carrierwave//lib/carrierwave/processing/mini_magick.rb#129
  def resize_to_limit(width, height, combine_options: T.unsafe(nil), &block); end

  # Returns the width of the image in pixels.
  #
  # === Returns
  #
  # [Integer] the image's width in pixels
  #
  # source://carrierwave//lib/carrierwave/processing/mini_magick.rb#249
  def width; end

  private

  # source://carrierwave//lib/carrierwave/processing/mini_magick.rb#357
  def mini_magick_image; end

  # source://carrierwave//lib/carrierwave/processing/mini_magick.rb#350
  def resolve_dimensions(*dimensions); end
end

# source://carrierwave//lib/carrierwave/processing/mini_magick.rb#62
module CarrierWave::MiniMagick::ClassMethods
  # source://carrierwave//lib/carrierwave/processing/mini_magick.rb#63
  def convert(format); end

  # source://carrierwave//lib/carrierwave/processing/mini_magick.rb#83
  def crop(left, top, width, height); end

  # source://carrierwave//lib/carrierwave/processing/mini_magick.rb#79
  def resize_and_pad(width, height, background = T.unsafe(nil), gravity = T.unsafe(nil)); end

  # source://carrierwave//lib/carrierwave/processing/mini_magick.rb#75
  def resize_to_fill(width, height, gravity = T.unsafe(nil)); end

  # source://carrierwave//lib/carrierwave/processing/mini_magick.rb#71
  def resize_to_fit(width, height); end

  # source://carrierwave//lib/carrierwave/processing/mini_magick.rb#67
  def resize_to_limit(width, height); end
end

# If a Class is extended with this module, it gains the mount_uploader
# method, which is used for mapping attributes to uploaders and allowing
# easy assignment.
#
# You can use mount_uploader with pretty much any class, however it is
# intended to be used with some kind of persistent storage, like an ORM.
# If you want to persist the uploaded files in a particular Class, it
# needs to implement a `read_uploader` and a `write_uploader` method.
#
# source://carrierwave//lib/carrierwave/mount.rb#13
module CarrierWave::Mount
  # Mounts the given uploader on the given column. This means that assigning
  # and reading from the column will upload and retrieve files. Supposing
  # that a User class has an uploader mounted on image, you can assign and
  # retrieve files like this:
  #
  #     @user.image # => <Uploader>
  #     @user.image.store!(some_file_object)
  #
  #     @user.image.url # => '/some_url.png'
  #
  # It is also possible (but not recommended) to omit the uploader, which
  # will create an anonymous uploader class.
  #
  # Passing a block makes it possible to customize the uploader. This can be
  # convenient for brevity, but if there is any significant logic in the
  # uploader, you should do the right thing and have it in its own file.
  #
  # === Added instance methods
  #
  # Supposing a class has used +mount_uploader+ to mount an uploader on a column
  # named +image+, in that case the following methods will be added to the class:
  #
  # [image]                   Returns an instance of the uploader only if anything has been uploaded
  # [image=]                  Caches the given file
  #
  # [image_url]               Returns the url to the uploaded file
  #
  # [image_cache]             Returns a string that identifies the cache location of the file
  # [image_cache=]            Retrieves the file from the cache based on the given cache name
  #
  # [remote_image_url]        Returns previously cached remote url
  # [remote_image_url=]       Retrieve the file from the remote url
  #
  # [remove_image]            An attribute reader that can be used with a checkbox to mark a file for removal
  # [remove_image=]           An attribute writer that can be used with a checkbox to mark a file for removal
  # [remove_image?]           Whether the file should be removed when store_image! is called.
  #
  # [store_image!]            Stores a file that has been assigned with +image=+
  # [remove_image!]           Removes the uploaded file from the filesystem.
  #
  # [image_integrity_error]   Returns an error object if the last file to be assigned caused an integrity error
  # [image_processing_error]  Returns an error object if the last file to be assigned caused a processing error
  # [image_download_error]    Returns an error object if the last file to be remotely assigned caused a download error
  #
  # [image_identifier]        Reads out the identifier of the file
  #
  # === Parameters
  #
  # [column (Symbol)]                   the attribute to mount this uploader on
  # [uploader (CarrierWave::Uploader)]  the uploader class to mount
  # [options (Hash{Symbol => Object})]  a set of options
  # [&block (Proc)]                     customize anonymous uploaders
  #
  # === Options
  #
  # [:mount_on => Symbol] if the name of the column to be serialized to differs you can override it using this option
  # [:ignore_integrity_errors => Boolean] if set to true, integrity errors will result in caching failing silently
  # [:ignore_processing_errors => Boolean] if set to true, processing errors will result in caching failing silently
  #
  # === Examples
  #
  # Mounting uploaders on different columns.
  #
  #     class Song
  #       mount_uploader :lyrics, LyricsUploader
  #       mount_uploader :alternative_lyrics, LyricsUploader
  #       mount_uploader :file, SongUploader
  #     end
  #
  # This will add an anonymous uploader with only the default settings:
  #
  #     class Data
  #       mount_uploader :csv
  #     end
  #
  # this will add an anonymous uploader overriding the store_dir:
  #
  #     class Product
  #       mount_uploader :blueprint do
  #         def store_dir
  #           'blueprints'
  #         end
  #       end
  #     end
  #
  # source://carrierwave//lib/carrierwave/mount.rb#134
  def mount_uploader(column, uploader = T.unsafe(nil), options = T.unsafe(nil), &block); end

  # Mounts the given uploader on the given array column. This means that
  # assigning and reading from the array column will upload and retrieve
  # multiple files. Supposing that a User class has an uploader mounted on
  # images, and that images can store an array, for example it could be a
  # PostgreSQL JSON column. You can assign and retrieve files like this:
  #
  #     @user.images # => []
  #     @user.images = [some_file_object]
  #     @user.images # => [<Uploader>]
  #
  #     @user.images[0].url # => '/some_url.png'
  #
  # It is also possible (but not recommended) to omit the uploader, which
  # will create an anonymous uploader class.
  #
  # Passing a block makes it possible to customize the uploader. This can be
  # convenient for brevity, but if there is any significant logic in the
  # uploader, you should do the right thing and have it in its own file.
  #
  # === Added instance methods
  #
  # Supposing a class has used +mount_uploaders+ to mount an uploader on a column
  # named +images+, in that case the following methods will be added to the class:
  #
  # [images]                  Returns an array of uploaders for each uploaded file
  # [images=]                 Caches the given files
  #
  # [images_urls]             Returns the urls to the uploaded files
  #
  # [images_cache]            Returns a string that identifies the cache location of the files
  # [images_cache=]           Retrieves the files from the cache based on the given cache name
  #
  # [remote_image_urls]       Returns previously cached remote urls
  # [remote_image_urls=]      Retrieve files from the given remote urls
  #
  # [remove_images]           An attribute reader that can be used with a checkbox to mark the files for removal
  # [remove_images=]          An attribute writer that can be used with a checkbox to mark the files for removal
  # [remove_images?]          Whether the files should be removed when store_image! is called.
  #
  # [store_images!]           Stores all files that have been assigned with +images=+
  # [remove_images!]          Removes the uploaded file from the filesystem.
  #
  # [image_integrity_errors]   Returns error objects of files which failed to pass integrity check
  # [image_processing_errors]  Returns error objects of files which failed to be processed
  # [image_download_errors]    Returns error objects of files which failed to be downloaded
  #
  # [image_identifiers]       Reads out the identifiers of the files
  #
  # === Parameters
  #
  # [column (Symbol)]                   the attribute to mount this uploader on
  # [uploader (CarrierWave::Uploader)]  the uploader class to mount
  # [options (Hash{Symbol => Object})]  a set of options
  # [&block (Proc)]                     customize anonymous uploaders
  #
  # === Options
  #
  # [:mount_on => Symbol] if the name of the column to be serialized to differs you can override it using this option
  # [:ignore_integrity_errors => Boolean] if set to true, integrity errors will result in caching failing silently
  # [:ignore_processing_errors => Boolean] if set to true, processing errors will result in caching failing silently
  #
  # === Examples
  #
  # Mounting uploaders on different columns.
  #
  #     class Song
  #       mount_uploaders :lyrics, LyricsUploader
  #       mount_uploaders :alternative_lyrics, LyricsUploader
  #       mount_uploaders :files, SongUploader
  #     end
  #
  # This will add an anonymous uploader with only the default settings:
  #
  #     class Data
  #       mount_uploaders :csv_files
  #     end
  #
  # this will add an anonymous uploader overriding the store_dir:
  #
  #     class Product
  #       mount_uploaders :blueprints do
  #         def store_dir
  #           'blueprints'
  #         end
  #       end
  #     end
  #
  # source://carrierwave//lib/carrierwave/mount.rb#279
  def mount_uploaders(column, uploader = T.unsafe(nil), options = T.unsafe(nil), &block); end

  # Return a particular option for a particular uploader
  #
  # === Parameters
  #
  # [column (Symbol)] The column the uploader is mounted at
  # [option (Symbol)] The option, e.g. validate_integrity
  #
  # === Returns
  #
  # [Object] The option value
  #
  # source://carrierwave//lib/carrierwave/mount.rb#40
  def uploader_option(column, option); end

  # source://carrierwave//lib/carrierwave/mount.rb#24
  def uploader_options; end

  # === Returns
  #
  # [Hash{Symbol => CarrierWave}] what uploaders are mounted on which columns
  #
  # source://carrierwave//lib/carrierwave/mount.rb#20
  def uploaders; end

  private

  # source://carrierwave//lib/carrierwave/mount.rb#405
  def build_uploader(uploader, column, &block); end

  # source://carrierwave//lib/carrierwave/mount.rb#327
  def mount_base(column, uploader = T.unsafe(nil), options = T.unsafe(nil), &block); end
end

# source://carrierwave//lib/carrierwave/mount.rb#417
module CarrierWave::Mount::Extension
  # overwrite this to read from a serialized attribute
  #
  # source://carrierwave//lib/carrierwave/mount.rb#422
  def read_uploader(column); end

  # overwrite this to write to a serialized attribute
  #
  # source://carrierwave//lib/carrierwave/mount.rb#427
  def write_uploader(column, identifier); end

  private

  # source://carrierwave//lib/carrierwave/mount.rb#436
  def _mounter(column); end

  # source://carrierwave//lib/carrierwave/mount.rb#431
  def initialize_dup(other); end
end

# this is an internal class, used by CarrierWave::Mount so that
# we don't pollute the model with a lot of methods.
#
# source://carrierwave//lib/carrierwave/mounter.rb#5
class CarrierWave::Mounter
  # @return [Mounter] a new instance of Mounter
  #
  # source://carrierwave//lib/carrierwave/mounter.rb#38
  def initialize(record, column); end

  # @return [Boolean]
  #
  # source://carrierwave//lib/carrierwave/mounter.rb#166
  def blank?; end

  # source://carrierwave//lib/carrierwave/mounter.rb#54
  def blank_uploader; end

  # source://carrierwave//lib/carrierwave/mounter.rb#74
  def cache(new_files); end

  # source://carrierwave//lib/carrierwave/mounter.rb#103
  def cache_names; end

  # source://carrierwave//lib/carrierwave/mounter.rb#107
  def cache_names=(cache_names); end

  # source://carrierwave//lib/carrierwave/mounter.rb#185
  def clear!; end

  # Returns the value of attribute column.
  #
  # source://carrierwave//lib/carrierwave/mounter.rb#34
  def column; end

  # Returns the value of attribute download_errors.
  #
  # source://carrierwave//lib/carrierwave/mounter.rb#34
  def download_errors; end

  # source://carrierwave//lib/carrierwave/mounter.rb#58
  def identifiers; end

  # Returns the value of attribute integrity_errors.
  #
  # source://carrierwave//lib/carrierwave/mounter.rb#34
  def integrity_errors; end

  # Returns the value of attribute processing_errors.
  #
  # source://carrierwave//lib/carrierwave/mounter.rb#34
  def processing_errors; end

  # source://carrierwave//lib/carrierwave/mounter.rb#62
  def read_identifiers; end

  # Returns the value of attribute record.
  #
  # source://carrierwave//lib/carrierwave/mounter.rb#34
  def record; end

  # Returns the value of attribute remote_request_headers.
  #
  # source://carrierwave//lib/carrierwave/mounter.rb#36
  def remote_request_headers; end

  # Sets the attribute remote_request_headers
  #
  # @param value the value to set the attribute remote_request_headers to.
  #
  # source://carrierwave//lib/carrierwave/mounter.rb#36
  def remote_request_headers=(_arg0); end

  # Returns the value of attribute remote_urls.
  #
  # source://carrierwave//lib/carrierwave/mounter.rb#34
  def remote_urls; end

  # source://carrierwave//lib/carrierwave/mounter.rb#121
  def remote_urls=(urls); end

  # Returns the value of attribute remove.
  #
  # source://carrierwave//lib/carrierwave/mounter.rb#34
  def remove; end

  # source://carrierwave//lib/carrierwave/mounter.rb#180
  def remove!; end

  # source://carrierwave//lib/carrierwave/mounter.rb#170
  def remove=(value); end

  # @return [Boolean]
  #
  # source://carrierwave//lib/carrierwave/mounter.rb#176
  def remove?; end

  # source://carrierwave//lib/carrierwave/mounter.rb#208
  def remove_added; end

  # source://carrierwave//lib/carrierwave/mounter.rb#200
  def remove_previous; end

  # source://carrierwave//lib/carrierwave/mounter.rb#191
  def reset_changes!; end

  # source://carrierwave//lib/carrierwave/mounter.rb#196
  def serialization_column; end

  # source://carrierwave//lib/carrierwave/mounter.rb#142
  def store!; end

  # source://carrierwave//lib/carrierwave/mounter.rb#50
  def uploader_class; end

  # Returns the value of attribute uploader_options.
  #
  # source://carrierwave//lib/carrierwave/mounter.rb#36
  def uploader_options; end

  # Sets the attribute uploader_options
  #
  # @param value the value to set the attribute uploader_options to.
  #
  # source://carrierwave//lib/carrierwave/mounter.rb#36
  def uploader_options=(_arg0); end

  # source://carrierwave//lib/carrierwave/mounter.rb#66
  def uploaders; end

  # source://carrierwave//lib/carrierwave/mounter.rb#162
  def urls(*args); end

  # source://carrierwave//lib/carrierwave/mounter.rb#146
  def write_identifier; end

  private

  # source://carrierwave//lib/carrierwave/mounter.rb#223
  def clear_unstaged; end

  # source://carrierwave//lib/carrierwave/mounter.rb#230
  def handle_error; end

  # source://carrierwave//lib/carrierwave/mounter.rb#218
  def option(name); end

  # source://carrierwave//lib/carrierwave/mounter.rb#249
  def temporary_identifiers; end

  # source://carrierwave//lib/carrierwave/mounter.rb#243
  def write_temporary_identifier; end

  class << self
    # source://carrierwave//lib/carrierwave/mounter.rb#26
    def build(record, column); end
  end
end

# :nodoc
#
# source://carrierwave//lib/carrierwave/mounter.rb#16
class CarrierWave::Mounter::Multiple < ::CarrierWave::Mounter
  # source://carrierwave//lib/carrierwave/mounter.rb#17
  def identifier; end

  # source://carrierwave//lib/carrierwave/mounter.rb#21
  def temporary_identifier; end
end

# source://carrierwave//lib/carrierwave/mounter.rb#6
class CarrierWave::Mounter::Single < ::CarrierWave::Mounter
  # :nodoc
  #
  # source://carrierwave//lib/carrierwave/mounter.rb#7
  def identifier; end

  # source://carrierwave//lib/carrierwave/mounter.rb#11
  def temporary_identifier; end
end

# source://carrierwave//lib/carrierwave/error.rb#5
class CarrierWave::ProcessingError < ::CarrierWave::UploadError; end

# This module simplifies manipulation with RMagick by providing a set
# of convenient helper methods. If you want to use them, you'll need to
# require this file:
#
#     require 'carrierwave/processing/rmagick'
#
# And then include it in your uploader:
#
#     class MyUploader < CarrierWave::Uploader::Base
#       include CarrierWave::RMagick
#     end
#
# You can now use the provided helpers:
#
#     class MyUploader < CarrierWave::Uploader::Base
#       include CarrierWave::RMagick
#
#       process :resize_to_fit => [200, 200]
#     end
#
# Or create your own helpers with the powerful manipulate! method. Check
# out the RMagick docs at https://rmagick.github.io/ for more
# info
#
#     class MyUploader < CarrierWave::Uploader::Base
#       include CarrierWave::RMagick
#
#       process :do_stuff => 10.0
#
#       def do_stuff(blur_factor)
#         manipulate! do |img|
#           img = img.sepiatone
#           img = img.auto_orient
#           img = img.radial_blur(blur_factor)
#         end
#       end
#     end
#
# === Note
#
# You should be aware how RMagick handles memory. manipulate! takes care
# of freeing up memory for you, but for optimum memory usage you should
# use destructive operations as much as possible:
#
# DON'T DO THIS:
#     img = img.resize_to_fit
#
# DO THIS INSTEAD:
#     img.resize_to_fit!
#
# Read this for more information why:
#
# http://rubyforge.org/forum/forum.php?thread_id=1374&forum_id=1618
#
# source://carrierwave//lib/carrierwave/processing/rmagick.rb#58
module CarrierWave::RMagick
  extend ::ActiveSupport::Concern

  # Changes the image encoding format to the given format
  #
  # See even https://rmagick.github.io/magick.html#formats
  #
  # === Parameters
  #
  # [format (#to_s)] an abbreviation of the format
  #
  # === Yields
  #
  # [Magick::Image] additional manipulations to perform
  #
  # === Examples
  #
  #     image.convert(:png)
  #
  # source://carrierwave//lib/carrierwave/processing/rmagick.rb#128
  def convert(format); end

  # Crop the image to the contents of a box positioned at [left] and [top], with the dimensions given
  # by [width] and [height]. The original image bottom/right edge is preserved if the cropping box falls
  # outside the image bounds.
  #
  # === Parameters
  #
  # [left (integer)] left edge of area to extract
  # [top (integer)] top edge of area to extract
  # [width (Integer)] width of area to extract
  # [height (Integer)] height of area to extract
  #
  # === Yields
  #
  # [Magick::Image] additional manipulations to perform
  #
  # source://carrierwave//lib/carrierwave/processing/rmagick.rb#283
  def crop(left, top, width, height, combine_options: T.unsafe(nil)); end

  # Returns the height of the image.
  #
  # === Returns
  #
  # [Integer] the image's height in pixels
  #
  # source://carrierwave//lib/carrierwave/processing/rmagick.rb#312
  def height; end

  # Manipulate the image with RMagick. This method will load up an image
  # and then pass each of its frames to the supplied block. It will then
  # save the image to disk.
  #
  # === Gotcha
  #
  # This method assumes that the object responds to +current_path+.
  # Any class that this module is mixed into must have a +current_path+ method.
  # CarrierWave::Uploader does, so you won't need to worry about this in
  # most cases.
  #
  # === Yields
  #
  # [Magick::Image] manipulations to perform
  # [Integer] Frame index if the image contains multiple frames
  # [Hash] options, see below
  #
  # === Options
  #
  # The options argument to this method is also yielded as the third
  # block argument.
  #
  # Currently, the following options are defined:
  #
  # ==== :write
  # A hash of assignments to be evaluated in the block given to the RMagick write call.
  #
  # An example:
  #
  #      manipulate! do |img, index, options|
  #        options[:write] = {
  #          :quality => 50,
  #          :depth => 8
  #        }
  #        img
  #      end
  #
  # This will translate to the following RMagick::Image#write call:
  #
  #     image.write do |img|
  #       self.quality = 50
  #       self.depth = 8
  #     end
  #
  # ==== :read
  # A hash of assignments to be given to the RMagick read call.
  #
  # The options available are identical to those for write, but are passed in directly, like this:
  #
  #     manipulate! :read => { :density => 300 }
  #
  # ==== :format
  # Specify the output format. If unset, the filename extension is used to determine the format.
  #
  # === Raises
  #
  # [CarrierWave::ProcessingError] if manipulation failed.
  #
  # source://carrierwave//lib/carrierwave/processing/rmagick.rb#375
  def manipulate!(options = T.unsafe(nil), &block); end

  # Resize the image to fit within the specified dimensions while retaining
  # the original aspect ratio. If necessary, will pad the remaining area
  # with the given color, which defaults to transparent (for gif and png,
  # white for jpeg).
  #
  # === Parameters
  #
  # [width (Integer)] the width to scale the image to
  # [height (Integer)] the height to scale the image to
  # [background (String, :transparent)] the color of the background as a hexcode, like "#ff45de"
  # [gravity (Magick::GravityType)] how to position the image
  #
  # === Yields
  #
  # [Magick::Image] additional manipulations to perform
  #
  # source://carrierwave//lib/carrierwave/processing/rmagick.rb#232
  def resize_and_pad(width, height, background = T.unsafe(nil), gravity = T.unsafe(nil)); end

  # From the RMagick documentation: "Resize the image to fit within the
  # specified dimensions while retaining the aspect ratio of the original
  # image. If necessary, crop the image in the larger dimension."
  #
  # See even https://rmagick.github.io/image3.html#resize_to_fill
  #
  # === Parameters
  #
  # [width (Integer)] the width to scale the image to
  # [height (Integer)] the height to scale the image to
  #
  # === Yields
  #
  # [Magick::Image] additional manipulations to perform
  #
  # source://carrierwave//lib/carrierwave/processing/rmagick.rb#205
  def resize_to_fill(width, height, gravity = T.unsafe(nil)); end

  # From the RMagick documentation: "Resize the image to fit within the
  # specified dimensions while retaining the original aspect ratio. The
  # image may be shorter or narrower than specified in the smaller dimension
  # but will not be larger than the specified values."
  #
  # See even https://rmagick.github.io/image3.html#resize_to_fit
  #
  # === Parameters
  #
  # [width (Integer)] the width to scale the image to
  # [height (Integer)] the height to scale the image to
  #
  # === Yields
  #
  # [Magick::Image] additional manipulations to perform
  #
  # source://carrierwave//lib/carrierwave/processing/rmagick.rb#179
  def resize_to_fit(width, height); end

  # Resize the image per the provided geometry string.
  #
  # === Parameters
  #
  # [geometry_string (String)] the proportions in which to scale image
  #
  # === Yields
  #
  # [Magick::Image] additional manipulations to perform
  #
  # source://carrierwave//lib/carrierwave/processing/rmagick.rb#256
  def resize_to_geometry_string(geometry_string); end

  # Resize the image to fit within the specified dimensions while retaining
  # the original aspect ratio. Will only resize the image if it is larger than the
  # specified dimensions. The resulting image may be shorter or narrower than specified
  # in the smaller dimension but will not be larger than the specified values.
  #
  # === Parameters
  #
  # [width (Integer)] the width to scale the image to
  # [height (Integer)] the height to scale the image to
  #
  # === Yields
  #
  # [Magick::Image] additional manipulations to perform
  #
  # source://carrierwave//lib/carrierwave/processing/rmagick.rb#148
  def resize_to_limit(width, height); end

  # Returns the width of the image.
  #
  # === Returns
  #
  # [Integer] the image's width in pixels
  #
  # source://carrierwave//lib/carrierwave/processing/rmagick.rb#301
  def width; end

  private

  # source://carrierwave//lib/carrierwave/processing/rmagick.rb#406
  def create_info_block(options); end

  # source://carrierwave//lib/carrierwave/processing/rmagick.rb#419
  def destroy_image(image); end

  # source://carrierwave//lib/carrierwave/processing/rmagick.rb#423
  def dimension_from(value); end

  # source://carrierwave//lib/carrierwave/processing/rmagick.rb#428
  def rmagick_image; end
end

# source://carrierwave//lib/carrierwave/processing/rmagick.rb#81
module CarrierWave::RMagick::ClassMethods
  # source://carrierwave//lib/carrierwave/processing/rmagick.rb#82
  def convert(format); end

  # source://carrierwave//lib/carrierwave/processing/rmagick.rb#106
  def crop(left, top, width, height); end

  # source://carrierwave//lib/carrierwave/processing/rmagick.rb#98
  def resize_and_pad(width, height, background = T.unsafe(nil), gravity = T.unsafe(nil)); end

  # source://carrierwave//lib/carrierwave/processing/rmagick.rb#94
  def resize_to_fill(width, height, gravity = T.unsafe(nil)); end

  # source://carrierwave//lib/carrierwave/processing/rmagick.rb#90
  def resize_to_fit(width, height); end

  # source://carrierwave//lib/carrierwave/processing/rmagick.rb#102
  def resize_to_geometry_string(geometry_string); end

  # source://carrierwave//lib/carrierwave/processing/rmagick.rb#86
  def resize_to_limit(width, height); end
end

# source://carrierwave//lib/carrierwave.rb#56
class CarrierWave::Railtie < ::Rails::Railtie; end

# SanitizedFile is a base class which provides a common API around all
# the different quirky Ruby File libraries. It has support for Tempfile,
# File, StringIO, Merb-style upload Hashes, as well as paths given as
# Strings and Pathnames.
#
# It's probably needlessly comprehensive and complex. Help is appreciated.
#
# source://carrierwave//lib/carrierwave/sanitized_file.rb#14
class CarrierWave::SanitizedFile
  include ::CarrierWave::Utilities::FileName

  # @return [SanitizedFile] a new instance of SanitizedFile
  #
  # source://carrierwave//lib/carrierwave/sanitized_file.rb#27
  def initialize(file); end

  # Returns the content type of the file.
  #
  # === Returns
  #
  # [String] the content type of the file
  #
  # source://carrierwave//lib/carrierwave/sanitized_file.rb#251
  def content_type; end

  # Sets the content type of the file.
  #
  # === Returns
  #
  # [String] the content type of the file
  #
  # source://carrierwave//lib/carrierwave/sanitized_file.rb#266
  def content_type=(type); end

  # Helper to create copy of file in new path.
  #
  # source://carrierwave//lib/carrierwave/sanitized_file.rb#217
  def copy!(new_path); end

  # Creates a copy of this file and moves it to the given path. Returns the copy.
  #
  # === Parameters
  #
  # [new_path (String)] The path where the file should be copied to.
  # [permissions (Integer)] permissions to set on the copy
  # [directory_permissions (Integer)] permissions to set on created directories.
  #
  # === Returns
  #
  # @return [CarrierWave::SanitizedFile] the location where the file will be stored.
  #
  # source://carrierwave//lib/carrierwave/sanitized_file.rb#204
  def copy_to(new_path, permissions = T.unsafe(nil), directory_permissions = T.unsafe(nil)); end

  # Removes the file from the filesystem.
  #
  # source://carrierwave//lib/carrierwave/sanitized_file.rb#228
  def delete; end

  # === Returns
  #
  # [Boolean] whether the file is valid and has a non-zero size
  #
  # @return [Boolean]
  #
  # source://carrierwave//lib/carrierwave/sanitized_file.rb#110
  def empty?; end

  # === Returns
  #
  # [Boolean] Whether the file exists
  #
  # @return [Boolean]
  #
  # source://carrierwave//lib/carrierwave/sanitized_file.rb#119
  def exists?; end

  # Returns the value of attribute file.
  #
  # source://carrierwave//lib/carrierwave/sanitized_file.rb#17
  def file; end

  # Returns the filename, sanitized to strip out any evil characters.
  #
  # === Returns
  #
  # [String] the sanitized filename
  #
  # source://carrierwave//lib/carrierwave/sanitized_file.rb#55
  def filename; end

  # Returns the filename, sanitized to strip out any evil characters.
  #
  # === Returns
  #
  # [String] the sanitized filename
  #
  # source://carrierwave//lib/carrierwave/sanitized_file.rb#55
  def identifier; end

  # === Returns
  #
  # [Boolean] whether the file is supplied as a pathname or string.
  #
  # @return [Boolean]
  #
  # source://carrierwave//lib/carrierwave/sanitized_file.rb#101
  def is_path?; end

  # Helper to move file to new path.
  #
  # source://carrierwave//lib/carrierwave/sanitized_file.rb#183
  def move!(new_path); end

  # Moves the file to the given path
  #
  # === Parameters
  #
  # [new_path (String)] The path where the file should be moved.
  # [permissions (Integer)] permissions to set on the file in its new location.
  # [directory_permissions (Integer)] permissions to set on created directories.
  #
  # source://carrierwave//lib/carrierwave/sanitized_file.rb#169
  def move_to(new_path, permissions = T.unsafe(nil), directory_permissions = T.unsafe(nil), keep_filename = T.unsafe(nil)); end

  # Returns the filename as is, without sanitizing it.
  #
  # === Returns
  #
  # [String] the unsanitized filename
  #
  # source://carrierwave//lib/carrierwave/sanitized_file.rb#39
  def original_filename; end

  # Returns the full path to the file. If the file has no path, it will return nil.
  #
  # === Returns
  #
  # [String, nil] the path where the file is located.
  #
  # source://carrierwave//lib/carrierwave/sanitized_file.rb#87
  def path; end

  # Returns the contents of the file.
  #
  # === Returns
  #
  # [String] contents of the file
  #
  # source://carrierwave//lib/carrierwave/sanitized_file.rb#130
  def read(*args); end

  # Rewinds the underlying file.
  #
  # source://carrierwave//lib/carrierwave/sanitized_file.rb#156
  def rewind; end

  # Used to sanitize the file name. Public to allow overriding for non-latin characters.
  #
  # === Returns
  #
  # [Regexp] the regexp for sanitizing the file name
  #
  # source://carrierwave//lib/carrierwave/sanitized_file.rb#277
  def sanitize_regexp; end

  # Returns the file's size.
  #
  # === Returns
  #
  # [Integer] the file's size in bytes.
  #
  # source://carrierwave//lib/carrierwave/sanitized_file.rb#68
  def size; end

  # Returns a File object, or nil if it does not exist.
  #
  # === Returns
  #
  # [File] a File object representing the SanitizedFile
  #
  # source://carrierwave//lib/carrierwave/sanitized_file.rb#239
  def to_file; end

  private

  # source://carrierwave//lib/carrierwave/sanitized_file.rb#302
  def chmod!(path, permissions); end

  # source://carrierwave//lib/carrierwave/sanitized_file.rb#317
  def declared_content_type; end

  # source://carrierwave//lib/carrierwave/sanitized_file.rb#283
  def file=(file); end

  # Guess content type from its file extension. Limit what to be returned to prevent spoofing.
  #
  # source://carrierwave//lib/carrierwave/sanitized_file.rb#325
  def guessed_safe_content_type; end

  # source://carrierwave//lib/carrierwave/sanitized_file.rb#332
  def identified_content_type; end

  # create the directory if it doesn't exist
  #
  # source://carrierwave//lib/carrierwave/sanitized_file.rb#296
  def mkdir!(path, directory_permissions); end

  # Sanitize the filename, to prevent hacking
  #
  # source://carrierwave//lib/carrierwave/sanitized_file.rb#307
  def sanitize(name); end

  # source://carrierwave//lib/carrierwave/sanitized_file.rb#349
  def with_io(&block); end

  class << self
    # source://carrierwave//lib/carrierwave/sanitized_file.rb#22
    def sanitize_regexp; end

    # Sets the attribute sanitize_regexp
    #
    # @param value the value to set the attribute sanitize_regexp to.
    #
    # source://carrierwave//lib/carrierwave/sanitized_file.rb#20
    def sanitize_regexp=(_arg0); end
  end
end

# source://carrierwave//lib/carrierwave/storage/abstract.rb#2
module CarrierWave::Storage; end

# This file serves mostly as a specification for Storage engines. There is no requirement
# that storage engines must be a subclass of this class.
#
# source://carrierwave//lib/carrierwave/storage/abstract.rb#8
class CarrierWave::Storage::Abstract
  # @return [Abstract] a new instance of Abstract
  #
  # source://carrierwave//lib/carrierwave/storage/abstract.rb#12
  def initialize(uploader); end

  # @raise [NotImplementedError]
  #
  # source://carrierwave//lib/carrierwave/storage/abstract.rb#26
  def cache!(new_file); end

  # @raise [NotImplementedError]
  #
  # source://carrierwave//lib/carrierwave/storage/abstract.rb#38
  def clean_cache!(seconds); end

  # @raise [NotImplementedError]
  #
  # source://carrierwave//lib/carrierwave/storage/abstract.rb#34
  def delete_dir!(path); end

  # source://carrierwave//lib/carrierwave/storage/abstract.rb#16
  def identifier; end

  # source://carrierwave//lib/carrierwave/storage/abstract.rb#23
  def retrieve!(identifier); end

  # @raise [NotImplementedError]
  #
  # source://carrierwave//lib/carrierwave/storage/abstract.rb#30
  def retrieve_from_cache!(identifier); end

  # source://carrierwave//lib/carrierwave/storage/abstract.rb#20
  def store!(file); end

  # Returns the value of attribute uploader.
  #
  # source://carrierwave//lib/carrierwave/storage/abstract.rb#10
  def uploader; end
end

# File storage stores file to the Filesystem (surprising, no?). There's really not much
# to it, it uses the store_dir defined on the uploader as the storage location. That's
# pretty much it.
#
# source://carrierwave//lib/carrierwave/storage/file.rb#9
class CarrierWave::Storage::File < ::CarrierWave::Storage::Abstract
  # @return [File] a new instance of File
  #
  # source://carrierwave//lib/carrierwave/storage/file.rb#10
  def initialize(*_arg0); end

  # Stores given file to cache directory.
  #
  # === Parameters
  #
  # [new_file (File, IOString, Tempfile)] any kind of file object
  #
  # === Returns
  #
  # [CarrierWave::SanitizedFile] a sanitized file
  #
  # source://carrierwave//lib/carrierwave/storage/file.rb#67
  def cache!(new_file); end

  # source://carrierwave//lib/carrierwave/storage/file.rb#111
  def clean_cache!(seconds); end

  # Deletes a cache dir
  #
  # source://carrierwave//lib/carrierwave/storage/file.rb#97
  def delete_dir!(path); end

  # Retrieve the file from its store path
  #
  # === Parameters
  #
  # [identifier (String)] the filename of the file
  #
  # === Returns
  #
  # [CarrierWave::SanitizedFile] a sanitized file
  #
  # source://carrierwave//lib/carrierwave/storage/file.rb#51
  def retrieve!(identifier); end

  # Retrieves the file with the given cache_name from the cache.
  #
  # === Parameters
  #
  # [cache_name (String)] uniquely identifies a cache file
  #
  # === Raises
  #
  # [CarrierWave::InvalidParameter] if the cache_name is incorrectly formatted.
  #
  # source://carrierwave//lib/carrierwave/storage/file.rb#90
  def retrieve_from_cache!(identifier); end

  # Move the file to the uploader's store path.
  #
  # By default, store!() uses copy_to(), which operates by copying the file
  # from the cache to the store, then deleting the file from the cache.
  # If move_to_store() is overridden to return true, then store!() uses move_to(),
  # which simply moves the file from cache to store.  Useful for large files.
  #
  # === Parameters
  #
  # [file (CarrierWave::SanitizedFile)] the file to store
  #
  # === Returns
  #
  # [CarrierWave::SanitizedFile] a sanitized file
  #
  # source://carrierwave//lib/carrierwave/storage/file.rb#31
  def store!(file); end
end

# Stores things using the "fog" gem.
#
# fog supports storing files with AWS, Google, Local and Rackspace
#
# You need to setup some options to configure your usage:
#
# [:fog_credentials]  host info and credentials for service
# [:fog_directory]    specifies name of directory to store data in, assumed to already exist
#
# [:fog_attributes]                   (optional) additional attributes to set on files
# [:fog_public]                       (optional) public readability, defaults to true
# [:fog_authenticated_url_expiration] (optional) time (in seconds) that authenticated urls
#   will be valid, when fog_public is false and provider is AWS or Google, defaults to 600
# [:fog_use_ssl_for_aws]              (optional) #public_url will use https for the AWS generated URL]
# [:fog_aws_accelerate]               (optional) #public_url will use s3-accelerate subdomain
#   instead of s3, defaults to false
# [:fog_aws_fips]                     (optional) #public_url will use s3-fips subdomain
#   instead of s3, defaults to false
#
#
# AWS credentials contain the following keys:
#
# [:aws_access_key_id]
# [:aws_secret_access_key]
# [:region]                 (optional) defaults to 'us-east-1'
#   :region should be one of ['eu-west-1', 'us-east-1', 'ap-southeast-1', 'us-west-1', 'ap-northeast-1', 'eu-central-1']
#
#
# Google credentials contain the following keys:
# [:google_storage_access_key_id]
# [:google_storage_secret_access_key]
#
#
# Local credentials contain the following keys:
#
# [:local_root]             local path to files
#
#
# Rackspace credentials contain the following keys:
#
# [:rackspace_username]
# [:rackspace_api_key]
#
#
# A full example with AWS credentials:
#     CarrierWave.configure do |config|
#       config.fog_credentials = {
#         :aws_access_key_id => 'xxxxxx',
#         :aws_secret_access_key => 'yyyyyy',
#         :provider => 'AWS'
#       }
#       config.fog_directory = 'directoryname'
#       config.fog_public = true
#     end
#
# source://carrierwave//lib/carrierwave/storage/fog.rb#60
class CarrierWave::Storage::Fog < ::CarrierWave::Storage::Abstract
  # Stores given file to cache directory.
  #
  # === Parameters
  #
  # [new_file (File, IOString, Tempfile)] any kind of file object
  #
  # === Returns
  #
  # [CarrierWave::SanitizedFile] a sanitized file
  #
  # source://carrierwave//lib/carrierwave/storage/fog.rb#118
  def cache!(new_file); end

  # source://carrierwave//lib/carrierwave/storage/fog.rb#146
  def clean_cache!(seconds); end

  # source://carrierwave//lib/carrierwave/storage/fog.rb#159
  def connection; end

  # Deletes a cache dir
  #
  # source://carrierwave//lib/carrierwave/storage/fog.rb#142
  def delete_dir!(path); end

  # Retrieve a file
  #
  # === Parameters
  #
  # [identifier (String)] unique identifier for file
  #
  # === Returns
  #
  # [CarrierWave::Storage::Fog::File] the stored file
  #
  # source://carrierwave//lib/carrierwave/storage/fog.rb#103
  def retrieve!(identifier); end

  # Retrieves the file with the given cache_name from the cache.
  #
  # === Parameters
  #
  # [cache_name (String)] uniquely identifies a cache file
  #
  # === Raises
  #
  # [CarrierWave::InvalidParameter] if the cache_name is incorrectly formatted.
  #
  # source://carrierwave//lib/carrierwave/storage/fog.rb#135
  def retrieve_from_cache!(identifier); end

  # Store a file
  #
  # === Parameters
  #
  # [file (CarrierWave::SanitizedFile)] the file to store
  #
  # === Returns
  #
  # [CarrierWave::Storage::Fog::File] the stored file
  #
  # source://carrierwave//lib/carrierwave/storage/fog.rb#86
  def store!(file); end

  class << self
    # source://carrierwave//lib/carrierwave/storage/fog.rb#62
    def connection_cache; end

    # source://carrierwave//lib/carrierwave/storage/fog.rb#66
    def eager_load; end
  end
end

# source://carrierwave//lib/carrierwave/storage/fog.rb#166
class CarrierWave::Storage::Fog::File
  include ::CarrierWave::Utilities::Uri
  include ::CarrierWave::Utilities::FileName

  # @return [File] a new instance of File
  #
  # source://carrierwave//lib/carrierwave/storage/fog.rb#279
  def initialize(uploader, base, path); end

  # Return all attributes from file
  #
  # === Returns
  #
  # [Hash] attributes from file
  #
  # source://carrierwave//lib/carrierwave/storage/fog.rb#188
  def attributes; end

  # Return a temporary authenticated url to a private file, if available
  # Only supported for AWS, Rackspace, Google, AzureRM and Aliyun providers
  #
  # === Returns
  #
  # [String] temporary authenticated url
  #   or
  # [NilClass] no authenticated url available
  #
  # source://carrierwave//lib/carrierwave/storage/fog.rb#202
  def authenticated_url(options = T.unsafe(nil)); end

  # Lookup value for file content-type header
  #
  # === Returns
  #
  # [String] value of content-type
  #
  # source://carrierwave//lib/carrierwave/storage/fog.rb#235
  def content_type; end

  # Set non-default content-type header (default is file.content_type)
  #
  # === Returns
  #
  # [String] returns new content type value
  #
  # source://carrierwave//lib/carrierwave/storage/fog.rb#246
  def content_type=(new_content_type); end

  # Creates a copy of this file and returns it.
  #
  # === Parameters
  #
  # [new_path (String)] The path where the file should be copied to.
  #
  # === Returns
  #
  # @return [CarrierWave::Storage::Fog::File] the location where the file will be stored.
  #
  # source://carrierwave//lib/carrierwave/storage/fog.rb#456
  def copy_to(new_path); end

  # Remove the file from service
  #
  # === Returns
  #
  # [Boolean] true for success or raises error
  #
  # source://carrierwave//lib/carrierwave/storage/fog.rb#257
  def delete; end

  # === Returns
  #
  # [Boolean] whether the file is non-existent or empty
  #
  # @return [Boolean]
  #
  # source://carrierwave//lib/carrierwave/storage/fog.rb#319
  def empty?; end

  # Check if the file exists on the remote service
  #
  # === Returns
  #
  # [Boolean] true if file exists or false
  #
  # @return [Boolean]
  #
  # source://carrierwave//lib/carrierwave/storage/fog.rb#329
  def exists?; end

  # Return file name, if available
  #
  # === Returns
  #
  # [String] file name
  #   or
  # [NilClass] no file name available
  #
  # source://carrierwave//lib/carrierwave/storage/fog.rb#440
  def filename(options = T.unsafe(nil)); end

  # deprecated: All attributes from file (includes headers)
  #
  # === Returns
  #
  # [Hash] attributes from file
  #
  # source://carrierwave//lib/carrierwave/storage/fog.rb#271
  def headers; end

  # Current local path to file
  #
  # === Returns
  #
  # [String] a path to file
  #
  # source://carrierwave//lib/carrierwave/storage/fog.rb#179
  def path; end

  # Return a url to a public file, if available
  #
  # === Returns
  #
  # [String] public url
  #   or
  # [NilClass] no public url available
  #
  # source://carrierwave//lib/carrierwave/storage/fog.rb#365
  def public_url; end

  # Read content of file from service
  #
  # === Returns
  #
  # [String] contents of file
  #
  # source://carrierwave//lib/carrierwave/storage/fog.rb#289
  def read; end

  # Return size of file body
  #
  # === Returns
  #
  # [Integer] size of file body
  #
  # source://carrierwave//lib/carrierwave/storage/fog.rb#310
  def size; end

  # Write file to service
  #
  # === Returns
  #
  # [Boolean] true on success or raises error
  #
  # source://carrierwave//lib/carrierwave/storage/fog.rb#339
  def store(new_file); end

  # Return the local file
  #
  # === Returns
  #
  # [File] The local file as Ruby's File class
  #   or
  # [NilClass] When there's no file, or the file is remotely stored
  #
  # source://carrierwave//lib/carrierwave/storage/fog.rb#470
  def to_file; end

  # Return url to file, if available
  #
  # === Returns
  #
  # [String] url
  #   or
  # [NilClass] no url available
  #
  # source://carrierwave//lib/carrierwave/storage/fog.rb#423
  def url(options = T.unsafe(nil)); end

  private

  # source://carrierwave//lib/carrierwave/storage/fog.rb#525
  def acl_header; end

  # connection to service
  #
  # === Returns
  #
  # [Fog::#{provider}::Storage] connection to service
  #
  # source://carrierwave//lib/carrierwave/storage/fog.rb#489
  def connection; end

  # source://carrierwave//lib/carrierwave/storage/fog.rb#518
  def copy_options; end

  # local reference to directory containing file
  #
  # === Returns
  #
  # [Fog::#{provider}::Directory] containing directory
  #
  # source://carrierwave//lib/carrierwave/storage/fog.rb#500
  def directory; end

  # lookup file
  #
  # === Returns
  #
  # [Fog::#{provider}::File] file data from remote service
  #
  # source://carrierwave//lib/carrierwave/storage/fog.rb#514
  def file; end

  # source://carrierwave//lib/carrierwave/storage/fog.rb#536
  def fog_provider; end

  # source://carrierwave//lib/carrierwave/storage/fog.rb#540
  def read_source_file; end

  # @return [Boolean]
  #
  # source://carrierwave//lib/carrierwave/storage/fog.rb#551
  def url_options_supported?(local_file); end
end

# source://carrierwave//lib/carrierwave/storage/fog.rb#167
CarrierWave::Storage::Fog::File::DEFAULT_S3_REGION = T.let(T.unsafe(nil), String)

# source://carrierwave//lib/carrierwave/test/matchers.rb#2
module CarrierWave::Test; end

# These are some matchers that can be used in RSpec specs, to simplify the testing
# of uploaders.
#
# source://carrierwave//lib/carrierwave/test/matchers.rb#8
module CarrierWave::Test::Matchers
  # source://carrierwave//lib/carrierwave/test/matchers.rb#331
  def be_format(expected); end

  # source://carrierwave//lib/carrierwave/test/matchers.rb#36
  def be_identical_to(expected); end

  # source://carrierwave//lib/carrierwave/test/matchers.rb#132
  def be_no_larger_than(width, height); end

  # source://carrierwave//lib/carrierwave/test/matchers.rb#298
  def be_no_taller_than(height); end

  # source://carrierwave//lib/carrierwave/test/matchers.rb#265
  def be_no_wider_than(width); end

  # source://carrierwave//lib/carrierwave/test/matchers.rb#166
  def have_dimensions(width, height); end

  # source://carrierwave//lib/carrierwave/test/matchers.rb#98
  def have_directory_permissions(expected); end

  # source://carrierwave//lib/carrierwave/test/matchers.rb#199
  def have_height(height); end

  # source://carrierwave//lib/carrierwave/test/matchers.rb#67
  def have_permissions(expected); end

  # source://carrierwave//lib/carrierwave/test/matchers.rb#232
  def have_width(width); end
end

# source://carrierwave//lib/carrierwave/test/matchers.rb#302
class CarrierWave::Test::Matchers::BeFormat
  # @return [BeFormat] a new instance of BeFormat
  #
  # source://carrierwave//lib/carrierwave/test/matchers.rb#303
  def initialize(expected); end

  # source://carrierwave//lib/carrierwave/test/matchers.rb#323
  def description; end

  # source://carrierwave//lib/carrierwave/test/matchers.rb#315
  def failure_message; end

  # source://carrierwave//lib/carrierwave/test/matchers.rb#319
  def failure_message_when_negated; end

  # @return [Boolean]
  #
  # source://carrierwave//lib/carrierwave/test/matchers.rb#307
  def matches?(actual); end

  # RSpec 2 compatibility:
  #
  # source://carrierwave//lib/carrierwave/test/matchers.rb#319
  def negative_failure_message; end
end

# source://carrierwave//lib/carrierwave/test/matchers.rb#10
class CarrierWave::Test::Matchers::BeIdenticalTo
  # @return [BeIdenticalTo] a new instance of BeIdenticalTo
  #
  # source://carrierwave//lib/carrierwave/test/matchers.rb#11
  def initialize(expected); end

  # source://carrierwave//lib/carrierwave/test/matchers.rb#28
  def description; end

  # source://carrierwave//lib/carrierwave/test/matchers.rb#20
  def failure_message; end

  # source://carrierwave//lib/carrierwave/test/matchers.rb#24
  def failure_message_when_negated; end

  # @return [Boolean]
  #
  # source://carrierwave//lib/carrierwave/test/matchers.rb#15
  def matches?(actual); end

  # RSpec 2 compatibility:
  #
  # source://carrierwave//lib/carrierwave/test/matchers.rb#24
  def negative_failure_message; end
end

# source://carrierwave//lib/carrierwave/test/matchers.rb#102
class CarrierWave::Test::Matchers::BeNoLargerThan
  # @return [BeNoLargerThan] a new instance of BeNoLargerThan
  #
  # source://carrierwave//lib/carrierwave/test/matchers.rb#103
  def initialize(width, height); end

  # source://carrierwave//lib/carrierwave/test/matchers.rb#124
  def description; end

  # source://carrierwave//lib/carrierwave/test/matchers.rb#116
  def failure_message; end

  # source://carrierwave//lib/carrierwave/test/matchers.rb#120
  def failure_message_when_negated; end

  # @return [Boolean]
  #
  # source://carrierwave//lib/carrierwave/test/matchers.rb#107
  def matches?(actual); end

  # RSpec 2 compatibility:
  #
  # source://carrierwave//lib/carrierwave/test/matchers.rb#120
  def negative_failure_message; end
end

# source://carrierwave//lib/carrierwave/test/matchers.rb#269
class CarrierWave::Test::Matchers::BeNoTallerThan
  # @return [BeNoTallerThan] a new instance of BeNoTallerThan
  #
  # source://carrierwave//lib/carrierwave/test/matchers.rb#270
  def initialize(height); end

  # source://carrierwave//lib/carrierwave/test/matchers.rb#290
  def description; end

  # source://carrierwave//lib/carrierwave/test/matchers.rb#282
  def failure_message; end

  # source://carrierwave//lib/carrierwave/test/matchers.rb#286
  def failure_message_when_negated; end

  # @return [Boolean]
  #
  # source://carrierwave//lib/carrierwave/test/matchers.rb#274
  def matches?(actual); end

  # RSpec 2 compatibility:
  #
  # source://carrierwave//lib/carrierwave/test/matchers.rb#286
  def negative_failure_message; end
end

# source://carrierwave//lib/carrierwave/test/matchers.rb#236
class CarrierWave::Test::Matchers::BeNoWiderThan
  # @return [BeNoWiderThan] a new instance of BeNoWiderThan
  #
  # source://carrierwave//lib/carrierwave/test/matchers.rb#237
  def initialize(width); end

  # source://carrierwave//lib/carrierwave/test/matchers.rb#257
  def description; end

  # source://carrierwave//lib/carrierwave/test/matchers.rb#249
  def failure_message; end

  # source://carrierwave//lib/carrierwave/test/matchers.rb#253
  def failure_message_when_negated; end

  # @return [Boolean]
  #
  # source://carrierwave//lib/carrierwave/test/matchers.rb#241
  def matches?(actual); end

  # RSpec 2 compatibility:
  #
  # source://carrierwave//lib/carrierwave/test/matchers.rb#253
  def negative_failure_message; end
end

# source://carrierwave//lib/carrierwave/test/matchers.rb#136
class CarrierWave::Test::Matchers::HaveDimensions
  # @return [HaveDimensions] a new instance of HaveDimensions
  #
  # source://carrierwave//lib/carrierwave/test/matchers.rb#137
  def initialize(width, height); end

  # source://carrierwave//lib/carrierwave/test/matchers.rb#158
  def description; end

  # source://carrierwave//lib/carrierwave/test/matchers.rb#150
  def failure_message; end

  # source://carrierwave//lib/carrierwave/test/matchers.rb#154
  def failure_message_when_negated; end

  # @return [Boolean]
  #
  # source://carrierwave//lib/carrierwave/test/matchers.rb#141
  def matches?(actual); end

  # RSpec 2 compatibility:
  #
  # source://carrierwave//lib/carrierwave/test/matchers.rb#154
  def negative_failure_message; end
end

# source://carrierwave//lib/carrierwave/test/matchers.rb#71
class CarrierWave::Test::Matchers::HaveDirectoryPermissions
  # @return [HaveDirectoryPermissions] a new instance of HaveDirectoryPermissions
  #
  # source://carrierwave//lib/carrierwave/test/matchers.rb#72
  def initialize(expected); end

  # source://carrierwave//lib/carrierwave/test/matchers.rb#90
  def description; end

  # source://carrierwave//lib/carrierwave/test/matchers.rb#82
  def failure_message; end

  # source://carrierwave//lib/carrierwave/test/matchers.rb#86
  def failure_message_when_negated; end

  # @return [Boolean]
  #
  # source://carrierwave//lib/carrierwave/test/matchers.rb#76
  def matches?(actual); end

  # RSpec 2 compatibility:
  #
  # source://carrierwave//lib/carrierwave/test/matchers.rb#86
  def negative_failure_message; end
end

# source://carrierwave//lib/carrierwave/test/matchers.rb#170
class CarrierWave::Test::Matchers::HaveHeight
  # @return [HaveHeight] a new instance of HaveHeight
  #
  # source://carrierwave//lib/carrierwave/test/matchers.rb#171
  def initialize(height); end

  # source://carrierwave//lib/carrierwave/test/matchers.rb#191
  def description; end

  # source://carrierwave//lib/carrierwave/test/matchers.rb#183
  def failure_message; end

  # source://carrierwave//lib/carrierwave/test/matchers.rb#187
  def failure_message_when_negated; end

  # @return [Boolean]
  #
  # source://carrierwave//lib/carrierwave/test/matchers.rb#175
  def matches?(actual); end

  # RSpec 2 compatibility:
  #
  # source://carrierwave//lib/carrierwave/test/matchers.rb#187
  def negative_failure_message; end
end

# source://carrierwave//lib/carrierwave/test/matchers.rb#40
class CarrierWave::Test::Matchers::HavePermissions
  # @return [HavePermissions] a new instance of HavePermissions
  #
  # source://carrierwave//lib/carrierwave/test/matchers.rb#41
  def initialize(expected); end

  # source://carrierwave//lib/carrierwave/test/matchers.rb#59
  def description; end

  # source://carrierwave//lib/carrierwave/test/matchers.rb#51
  def failure_message; end

  # source://carrierwave//lib/carrierwave/test/matchers.rb#55
  def failure_message_when_negated; end

  # @return [Boolean]
  #
  # source://carrierwave//lib/carrierwave/test/matchers.rb#45
  def matches?(actual); end

  # RSpec 2 compatibility:
  #
  # source://carrierwave//lib/carrierwave/test/matchers.rb#55
  def negative_failure_message; end
end

# source://carrierwave//lib/carrierwave/test/matchers.rb#203
class CarrierWave::Test::Matchers::HaveWidth
  # @return [HaveWidth] a new instance of HaveWidth
  #
  # source://carrierwave//lib/carrierwave/test/matchers.rb#204
  def initialize(width); end

  # source://carrierwave//lib/carrierwave/test/matchers.rb#224
  def description; end

  # source://carrierwave//lib/carrierwave/test/matchers.rb#216
  def failure_message; end

  # source://carrierwave//lib/carrierwave/test/matchers.rb#220
  def failure_message_when_negated; end

  # @return [Boolean]
  #
  # source://carrierwave//lib/carrierwave/test/matchers.rb#208
  def matches?(actual); end

  # RSpec 2 compatibility:
  #
  # source://carrierwave//lib/carrierwave/test/matchers.rb#220
  def negative_failure_message; end
end

# source://carrierwave//lib/carrierwave/test/matchers.rb#335
class CarrierWave::Test::Matchers::ImageLoader
  class << self
    # source://carrierwave//lib/carrierwave/test/matchers.rb#336
    def load_image(filename); end
  end
end

# source://carrierwave//lib/carrierwave/test/matchers.rb#356
class CarrierWave::Test::Matchers::MagickWrapper
  # @return [MagickWrapper] a new instance of MagickWrapper
  #
  # source://carrierwave//lib/carrierwave/test/matchers.rb#371
  def initialize(filename); end

  # source://carrierwave//lib/carrierwave/test/matchers.rb#367
  def format; end

  # source://carrierwave//lib/carrierwave/test/matchers.rb#363
  def height; end

  # Returns the value of attribute image.
  #
  # source://carrierwave//lib/carrierwave/test/matchers.rb#357
  def image; end

  # source://carrierwave//lib/carrierwave/test/matchers.rb#359
  def width; end
end

# source://carrierwave//lib/carrierwave/test/matchers.rb#376
class CarrierWave::Test::Matchers::MiniMagickWrapper
  # @return [MiniMagickWrapper] a new instance of MiniMagickWrapper
  #
  # source://carrierwave//lib/carrierwave/test/matchers.rb#391
  def initialize(filename); end

  # source://carrierwave//lib/carrierwave/test/matchers.rb#387
  def format; end

  # source://carrierwave//lib/carrierwave/test/matchers.rb#383
  def height; end

  # Returns the value of attribute image.
  #
  # source://carrierwave//lib/carrierwave/test/matchers.rb#377
  def image; end

  # source://carrierwave//lib/carrierwave/test/matchers.rb#379
  def width; end
end

# source://carrierwave//lib/carrierwave/error.rb#7
class CarrierWave::UnknownStorageError < ::StandardError; end

# source://carrierwave//lib/carrierwave/error.rb#2
class CarrierWave::UploadError < ::StandardError; end

# See CarrierWave::Uploader::Base
#
# source://carrierwave//lib/carrierwave/uploader/configuration.rb#5
module CarrierWave::Uploader; end

# An uploader is a class that allows you to easily handle the caching and storage of
# uploaded files. Please refer to the README for configuration options.
#
# Once you have an uploader you can use it in isolation:
#
#     my_uploader = MyUploader.new
#     my_uploader.cache!(File.open(path_to_file))
#     my_uploader.retrieve_from_store!('monkey.png')
#
# Alternatively, you can mount it on an ORM or other persistence layer, with
# +CarrierWave::Mount#mount_uploader+. There are extensions for activerecord and datamapper
# these are *very* simple (they are only a dozen lines of code), so adding your own should
# be trivial.
#
# source://carrierwave//lib/carrierwave/uploader.rb#44
class CarrierWave::Uploader::Base
  include ::CarrierWave::Uploader::Configuration
  include ::CarrierWave::Uploader::Callbacks
  include ::CarrierWave::Uploader::Proxy
  include ::CarrierWave::Utilities::Uri
  include ::CarrierWave::Uploader::Url
  include ::CarrierWave::Uploader::Mountable
  include ::CarrierWave::Uploader::Cache
  include ::CarrierWave::Uploader::Store
  include ::CarrierWave::Uploader::Download
  include ::CarrierWave::Uploader::Remove
  include ::CarrierWave::Uploader::ExtensionAllowlist
  include ::CarrierWave::Uploader::ExtensionDenylist
  include ::CarrierWave::Uploader::ContentTypeAllowlist
  include ::CarrierWave::Uploader::ContentTypeDenylist
  include ::CarrierWave::Uploader::FileSize
  include ::CarrierWave::Uploader::Dimension
  include ::CarrierWave::Uploader::Processing
  include ::CarrierWave::Uploader::Versions
  include ::CarrierWave::Uploader::DefaultUrl
  include ::CarrierWave::Uploader::Serialization
  extend ::CarrierWave::Uploader::Configuration::ClassMethods
  extend ::CarrierWave::Uploader::Callbacks::ClassMethods
  extend ::CarrierWave::Uploader::Cache::ClassMethods
  extend ::CarrierWave::Uploader::Store::ClassMethods
  extend ::CarrierWave::Uploader::Processing::ClassMethods
  extend ::CarrierWave::Uploader::Versions::ClassMethods

  # source://carrierwave//lib/carrierwave/uploader/callbacks.rb#7
  def _after_callbacks; end

  # source://carrierwave//lib/carrierwave/uploader/callbacks.rb#7
  def _after_callbacks?; end

  # source://carrierwave//lib/carrierwave/uploader/callbacks.rb#7
  def _before_callbacks; end

  # source://carrierwave//lib/carrierwave/uploader/callbacks.rb#7
  def _before_callbacks?; end

  # source://carrierwave//lib/carrierwave/uploader/configuration.rb#10
  def _cache_storage; end

  # source://carrierwave//lib/carrierwave/uploader/configuration.rb#10
  def _cache_storage?; end

  # source://carrierwave//lib/carrierwave/uploader/configuration.rb#10
  def _storage; end

  # source://carrierwave//lib/carrierwave/uploader/configuration.rb#10
  def _storage?; end

  # source://carrierwave//lib/carrierwave/uploader/configuration.rb#146
  def asset_host; end

  # source://carrierwave//lib/carrierwave/uploader/configuration.rb#142
  def asset_host=(value); end

  # source://carrierwave//lib/carrierwave/uploader/configuration.rb#146
  def base_path; end

  # source://carrierwave//lib/carrierwave/uploader/configuration.rb#142
  def base_path=(value); end

  # source://carrierwave//lib/carrierwave/uploader/configuration.rb#146
  def cache_dir; end

  # source://carrierwave//lib/carrierwave/uploader/configuration.rb#142
  def cache_dir=(value); end

  # source://carrierwave//lib/carrierwave/uploader/configuration.rb#146
  def cache_only; end

  # source://carrierwave//lib/carrierwave/uploader/configuration.rb#142
  def cache_only=(value); end

  # source://carrierwave//lib/carrierwave/uploader/configuration.rb#146
  def delete_tmp_file_after_storage; end

  # source://carrierwave//lib/carrierwave/uploader/configuration.rb#142
  def delete_tmp_file_after_storage=(value); end

  # source://carrierwave//lib/carrierwave/uploader/configuration.rb#146
  def directory_permissions; end

  # source://carrierwave//lib/carrierwave/uploader/configuration.rb#142
  def directory_permissions=(value); end

  # source://carrierwave//lib/carrierwave/uploader/configuration.rb#146
  def download_retry_count; end

  # source://carrierwave//lib/carrierwave/uploader/configuration.rb#142
  def download_retry_count=(value); end

  # source://carrierwave//lib/carrierwave/uploader/configuration.rb#146
  def download_retry_wait_time; end

  # source://carrierwave//lib/carrierwave/uploader/configuration.rb#142
  def download_retry_wait_time=(value); end

  # source://carrierwave//lib/carrierwave/uploader/configuration.rb#146
  def downloader; end

  # source://carrierwave//lib/carrierwave/uploader/configuration.rb#142
  def downloader=(value); end

  # source://carrierwave//lib/carrierwave/uploader/configuration.rb#146
  def enable_processing; end

  # source://carrierwave//lib/carrierwave/uploader/configuration.rb#142
  def enable_processing=(value); end

  # source://carrierwave//lib/carrierwave/uploader/configuration.rb#146
  def ensure_multipart_form; end

  # source://carrierwave//lib/carrierwave/uploader/configuration.rb#142
  def ensure_multipart_form=(value); end

  # Returns the value of attribute file.
  #
  # source://carrierwave//lib/carrierwave/uploader.rb#45
  def file; end

  # source://carrierwave//lib/carrierwave/uploader/store.rb#20
  def filename_safeguard_checked; end

  # source://carrierwave//lib/carrierwave/uploader/store.rb#20
  def filename_safeguard_checked=(_arg0); end

  # source://carrierwave//lib/carrierwave/uploader/store.rb#20
  def filename_safeguard_checked?; end

  # source://carrierwave//lib/carrierwave/uploader/configuration.rb#146
  def fog_attributes; end

  # source://carrierwave//lib/carrierwave/uploader/configuration.rb#142
  def fog_attributes=(value); end

  # source://carrierwave//lib/carrierwave/uploader/configuration.rb#146
  def fog_authenticated_url_expiration; end

  # source://carrierwave//lib/carrierwave/uploader/configuration.rb#142
  def fog_authenticated_url_expiration=(value); end

  # source://carrierwave//lib/carrierwave/uploader/configuration.rb#146
  def fog_aws_accelerate; end

  # source://carrierwave//lib/carrierwave/uploader/configuration.rb#142
  def fog_aws_accelerate=(value); end

  # source://carrierwave//lib/carrierwave/uploader/configuration.rb#146
  def fog_aws_fips; end

  # source://carrierwave//lib/carrierwave/uploader/configuration.rb#142
  def fog_aws_fips=(value); end

  # source://carrierwave//lib/carrierwave/uploader/configuration.rb#146
  def fog_credentials; end

  # source://carrierwave//lib/carrierwave/uploader/configuration.rb#142
  def fog_credentials=(value); end

  # source://carrierwave//lib/carrierwave/uploader/configuration.rb#146
  def fog_directory; end

  # source://carrierwave//lib/carrierwave/uploader/configuration.rb#142
  def fog_directory=(value); end

  # source://carrierwave//lib/carrierwave/uploader/configuration.rb#172
  def fog_provider; end

  # source://carrierwave//lib/carrierwave/uploader/configuration.rb#168
  def fog_provider=(value); end

  # source://carrierwave//lib/carrierwave/uploader/configuration.rb#146
  def fog_public; end

  # source://carrierwave//lib/carrierwave/uploader/configuration.rb#142
  def fog_public=(value); end

  # source://carrierwave//lib/carrierwave/uploader/configuration.rb#146
  def fog_use_ssl_for_aws; end

  # source://carrierwave//lib/carrierwave/uploader/configuration.rb#142
  def fog_use_ssl_for_aws=(value); end

  # source://carrierwave//lib/carrierwave/uploader/configuration.rb#146
  def force_extension; end

  # source://carrierwave//lib/carrierwave/uploader/configuration.rb#142
  def force_extension=(value); end

  # source://carrierwave//lib/carrierwave/uploader/configuration.rb#146
  def ignore_download_errors; end

  # source://carrierwave//lib/carrierwave/uploader/configuration.rb#142
  def ignore_download_errors=(value); end

  # source://carrierwave//lib/carrierwave/uploader/configuration.rb#146
  def ignore_integrity_errors; end

  # source://carrierwave//lib/carrierwave/uploader/configuration.rb#142
  def ignore_integrity_errors=(value); end

  # source://carrierwave//lib/carrierwave/uploader/configuration.rb#146
  def ignore_processing_errors; end

  # source://carrierwave//lib/carrierwave/uploader/configuration.rb#142
  def ignore_processing_errors=(value); end

  # source://carrierwave//lib/carrierwave/uploader/configuration.rb#146
  def mount_on; end

  # source://carrierwave//lib/carrierwave/uploader/configuration.rb#142
  def mount_on=(value); end

  # source://carrierwave//lib/carrierwave/uploader/configuration.rb#146
  def move_to_cache; end

  # source://carrierwave//lib/carrierwave/uploader/configuration.rb#142
  def move_to_cache=(value); end

  # source://carrierwave//lib/carrierwave/uploader/configuration.rb#146
  def move_to_store; end

  # source://carrierwave//lib/carrierwave/uploader/configuration.rb#142
  def move_to_store=(value); end

  # source://carrierwave//lib/carrierwave/uploader/versions.rb#97
  def parent_version; end

  # source://carrierwave//lib/carrierwave/uploader/versions.rb#97
  def parent_version=(_arg0); end

  # source://carrierwave//lib/carrierwave/uploader/configuration.rb#146
  def permissions; end

  # source://carrierwave//lib/carrierwave/uploader/configuration.rb#142
  def permissions=(value); end

  # source://carrierwave//lib/carrierwave/uploader/processing.rb#9
  def processors; end

  # source://carrierwave//lib/carrierwave/uploader/processing.rb#9
  def processors?; end

  # source://carrierwave//lib/carrierwave/uploader/configuration.rb#146
  def remove_previously_stored_files_after_update; end

  # source://carrierwave//lib/carrierwave/uploader/configuration.rb#142
  def remove_previously_stored_files_after_update=(value); end

  # source://carrierwave//lib/carrierwave/uploader/configuration.rb#146
  def root; end

  # source://carrierwave//lib/carrierwave/uploader/configuration.rb#142
  def root=(value); end

  # source://carrierwave//lib/carrierwave/uploader/configuration.rb#146
  def skip_ssrf_protection; end

  # source://carrierwave//lib/carrierwave/uploader/configuration.rb#142
  def skip_ssrf_protection=(value); end

  # source://carrierwave//lib/carrierwave/uploader/cache.rb#49
  def staged; end

  # source://carrierwave//lib/carrierwave/uploader/cache.rb#49
  def staged=(_arg0); end

  # source://carrierwave//lib/carrierwave/uploader/configuration.rb#146
  def storage_engines; end

  # source://carrierwave//lib/carrierwave/uploader/configuration.rb#142
  def storage_engines=(value); end

  # source://carrierwave//lib/carrierwave/uploader/configuration.rb#146
  def store_dir; end

  # source://carrierwave//lib/carrierwave/uploader/configuration.rb#142
  def store_dir=(value); end

  # source://carrierwave//lib/carrierwave/uploader/configuration.rb#146
  def validate_download; end

  # source://carrierwave//lib/carrierwave/uploader/configuration.rb#142
  def validate_download=(value); end

  # source://carrierwave//lib/carrierwave/uploader/configuration.rb#146
  def validate_integrity; end

  # source://carrierwave//lib/carrierwave/uploader/configuration.rb#142
  def validate_integrity=(value); end

  # source://carrierwave//lib/carrierwave/uploader/configuration.rb#146
  def validate_processing; end

  # source://carrierwave//lib/carrierwave/uploader/configuration.rb#142
  def validate_processing=(value); end

  class << self
    # source://carrierwave//lib/carrierwave/uploader/callbacks.rb#7
    def _after_callbacks; end

    # source://carrierwave//lib/carrierwave/uploader/callbacks.rb#7
    def _after_callbacks=(value); end

    # source://carrierwave//lib/carrierwave/uploader/callbacks.rb#7
    def _after_callbacks?; end

    # source://carrierwave//lib/carrierwave/uploader/callbacks.rb#7
    def _before_callbacks; end

    # source://carrierwave//lib/carrierwave/uploader/callbacks.rb#7
    def _before_callbacks=(value); end

    # source://carrierwave//lib/carrierwave/uploader/callbacks.rb#7
    def _before_callbacks?; end

    # source://carrierwave//lib/carrierwave/uploader/configuration.rb#10
    def _cache_storage; end

    # source://carrierwave//lib/carrierwave/uploader/configuration.rb#10
    def _cache_storage=(value); end

    # source://carrierwave//lib/carrierwave/uploader/configuration.rb#10
    def _cache_storage?; end

    # source://carrierwave//lib/carrierwave/uploader/configuration.rb#10
    def _storage; end

    # source://carrierwave//lib/carrierwave/uploader/configuration.rb#10
    def _storage=(value); end

    # source://carrierwave//lib/carrierwave/uploader/configuration.rb#10
    def _storage?; end

    # source://carrierwave//lib/carrierwave/uploader/configuration.rb#130
    def asset_host(value = T.unsafe(nil)); end

    # source://carrierwave//lib/carrierwave/uploader/configuration.rb#138
    def asset_host=(value); end

    # source://carrierwave//lib/carrierwave/uploader/configuration.rb#130
    def base_path(value = T.unsafe(nil)); end

    # source://carrierwave//lib/carrierwave/uploader/configuration.rb#138
    def base_path=(value); end

    # source://carrierwave//lib/carrierwave/uploader/configuration.rb#130
    def cache_dir(value = T.unsafe(nil)); end

    # source://carrierwave//lib/carrierwave/uploader/configuration.rb#138
    def cache_dir=(value); end

    # source://carrierwave//lib/carrierwave/uploader/configuration.rb#130
    def cache_only(value = T.unsafe(nil)); end

    # source://carrierwave//lib/carrierwave/uploader/configuration.rb#138
    def cache_only=(value); end

    # source://carrierwave//lib/carrierwave/uploader/configuration.rb#130
    def delete_tmp_file_after_storage(value = T.unsafe(nil)); end

    # source://carrierwave//lib/carrierwave/uploader/configuration.rb#138
    def delete_tmp_file_after_storage=(value); end

    # source://carrierwave//lib/carrierwave/uploader/configuration.rb#130
    def directory_permissions(value = T.unsafe(nil)); end

    # source://carrierwave//lib/carrierwave/uploader/configuration.rb#138
    def directory_permissions=(value); end

    # source://carrierwave//lib/carrierwave/uploader/configuration.rb#130
    def download_retry_count(value = T.unsafe(nil)); end

    # source://carrierwave//lib/carrierwave/uploader/configuration.rb#138
    def download_retry_count=(value); end

    # source://carrierwave//lib/carrierwave/uploader/configuration.rb#130
    def download_retry_wait_time(value = T.unsafe(nil)); end

    # source://carrierwave//lib/carrierwave/uploader/configuration.rb#138
    def download_retry_wait_time=(value); end

    # source://carrierwave//lib/carrierwave/uploader/configuration.rb#130
    def downloader(value = T.unsafe(nil)); end

    # source://carrierwave//lib/carrierwave/uploader/configuration.rb#138
    def downloader=(value); end

    # source://carrierwave//lib/carrierwave/uploader/configuration.rb#130
    def enable_processing(value = T.unsafe(nil)); end

    # source://carrierwave//lib/carrierwave/uploader/configuration.rb#138
    def enable_processing=(value); end

    # source://carrierwave//lib/carrierwave/uploader/configuration.rb#130
    def ensure_multipart_form(value = T.unsafe(nil)); end

    # source://carrierwave//lib/carrierwave/uploader/configuration.rb#138
    def ensure_multipart_form=(value); end

    # source://carrierwave//lib/carrierwave/uploader/store.rb#20
    def filename_safeguard_checked; end

    # source://carrierwave//lib/carrierwave/uploader/store.rb#20
    def filename_safeguard_checked=(value); end

    # source://carrierwave//lib/carrierwave/uploader/store.rb#20
    def filename_safeguard_checked?; end

    # source://carrierwave//lib/carrierwave/uploader/configuration.rb#130
    def fog_attributes(value = T.unsafe(nil)); end

    # source://carrierwave//lib/carrierwave/uploader/configuration.rb#138
    def fog_attributes=(value); end

    # source://carrierwave//lib/carrierwave/uploader/configuration.rb#130
    def fog_authenticated_url_expiration(value = T.unsafe(nil)); end

    # source://carrierwave//lib/carrierwave/uploader/configuration.rb#138
    def fog_authenticated_url_expiration=(value); end

    # source://carrierwave//lib/carrierwave/uploader/configuration.rb#130
    def fog_aws_accelerate(value = T.unsafe(nil)); end

    # source://carrierwave//lib/carrierwave/uploader/configuration.rb#138
    def fog_aws_accelerate=(value); end

    # source://carrierwave//lib/carrierwave/uploader/configuration.rb#130
    def fog_aws_fips(value = T.unsafe(nil)); end

    # source://carrierwave//lib/carrierwave/uploader/configuration.rb#138
    def fog_aws_fips=(value); end

    # source://carrierwave//lib/carrierwave/uploader/configuration.rb#130
    def fog_credentials(value = T.unsafe(nil)); end

    # source://carrierwave//lib/carrierwave/uploader/configuration.rb#138
    def fog_credentials=(value); end

    # source://carrierwave//lib/carrierwave/uploader/configuration.rb#130
    def fog_directory(value = T.unsafe(nil)); end

    # source://carrierwave//lib/carrierwave/uploader/configuration.rb#138
    def fog_directory=(value); end

    # source://carrierwave//lib/carrierwave/uploader/configuration.rb#160
    def fog_provider(value = T.unsafe(nil)); end

    # source://carrierwave//lib/carrierwave/uploader/configuration.rb#164
    def fog_provider=(value); end

    # source://carrierwave//lib/carrierwave/uploader/configuration.rb#130
    def fog_public(value = T.unsafe(nil)); end

    # source://carrierwave//lib/carrierwave/uploader/configuration.rb#138
    def fog_public=(value); end

    # source://carrierwave//lib/carrierwave/uploader/configuration.rb#130
    def fog_use_ssl_for_aws(value = T.unsafe(nil)); end

    # source://carrierwave//lib/carrierwave/uploader/configuration.rb#138
    def fog_use_ssl_for_aws=(value); end

    # source://carrierwave//lib/carrierwave/uploader/configuration.rb#130
    def force_extension(value = T.unsafe(nil)); end

    # source://carrierwave//lib/carrierwave/uploader/configuration.rb#138
    def force_extension=(value); end

    # source://carrierwave//lib/carrierwave/uploader/configuration.rb#130
    def ignore_download_errors(value = T.unsafe(nil)); end

    # source://carrierwave//lib/carrierwave/uploader/configuration.rb#138
    def ignore_download_errors=(value); end

    # source://carrierwave//lib/carrierwave/uploader/configuration.rb#130
    def ignore_integrity_errors(value = T.unsafe(nil)); end

    # source://carrierwave//lib/carrierwave/uploader/configuration.rb#138
    def ignore_integrity_errors=(value); end

    # source://carrierwave//lib/carrierwave/uploader/configuration.rb#130
    def ignore_processing_errors(value = T.unsafe(nil)); end

    # source://carrierwave//lib/carrierwave/uploader/configuration.rb#138
    def ignore_processing_errors=(value); end

    # source://carrierwave//lib/carrierwave/uploader/configuration.rb#130
    def mount_on(value = T.unsafe(nil)); end

    # source://carrierwave//lib/carrierwave/uploader/configuration.rb#138
    def mount_on=(value); end

    # source://carrierwave//lib/carrierwave/uploader/configuration.rb#130
    def move_to_cache(value = T.unsafe(nil)); end

    # source://carrierwave//lib/carrierwave/uploader/configuration.rb#138
    def move_to_cache=(value); end

    # source://carrierwave//lib/carrierwave/uploader/configuration.rb#130
    def move_to_store(value = T.unsafe(nil)); end

    # source://carrierwave//lib/carrierwave/uploader/configuration.rb#138
    def move_to_store=(value); end

    # source://carrierwave//lib/carrierwave/uploader/configuration.rb#130
    def permissions(value = T.unsafe(nil)); end

    # source://carrierwave//lib/carrierwave/uploader/configuration.rb#138
    def permissions=(value); end

    # source://carrierwave//lib/carrierwave/uploader/processing.rb#9
    def processors; end

    # source://carrierwave//lib/carrierwave/uploader/processing.rb#9
    def processors=(value); end

    # source://carrierwave//lib/carrierwave/uploader/processing.rb#9
    def processors?; end

    # source://carrierwave//lib/carrierwave/uploader/configuration.rb#130
    def remove_previously_stored_files_after_update(value = T.unsafe(nil)); end

    # source://carrierwave//lib/carrierwave/uploader/configuration.rb#138
    def remove_previously_stored_files_after_update=(value); end

    # source://carrierwave//lib/carrierwave/uploader/configuration.rb#130
    def root(value = T.unsafe(nil)); end

    # source://carrierwave//lib/carrierwave/uploader/configuration.rb#138
    def root=(value); end

    # source://carrierwave//lib/carrierwave/uploader/configuration.rb#130
    def skip_ssrf_protection(value = T.unsafe(nil)); end

    # source://carrierwave//lib/carrierwave/uploader/configuration.rb#138
    def skip_ssrf_protection=(value); end

    # source://carrierwave//lib/carrierwave/uploader/configuration.rb#130
    def storage_engines(value = T.unsafe(nil)); end

    # source://carrierwave//lib/carrierwave/uploader/configuration.rb#138
    def storage_engines=(value); end

    # source://carrierwave//lib/carrierwave/uploader/configuration.rb#130
    def store_dir(value = T.unsafe(nil)); end

    # source://carrierwave//lib/carrierwave/uploader/configuration.rb#138
    def store_dir=(value); end

    # source://carrierwave//lib/carrierwave/uploader/configuration.rb#130
    def validate_download(value = T.unsafe(nil)); end

    # source://carrierwave//lib/carrierwave/uploader/configuration.rb#138
    def validate_download=(value); end

    # source://carrierwave//lib/carrierwave/uploader/configuration.rb#130
    def validate_integrity(value = T.unsafe(nil)); end

    # source://carrierwave//lib/carrierwave/uploader/configuration.rb#138
    def validate_integrity=(value); end

    # source://carrierwave//lib/carrierwave/uploader/configuration.rb#130
    def validate_processing(value = T.unsafe(nil)); end

    # source://carrierwave//lib/carrierwave/uploader/configuration.rb#138
    def validate_processing=(value); end

    # source://carrierwave//lib/carrierwave/uploader/versions.rb#92
    def version_names; end

    # source://carrierwave//lib/carrierwave/uploader/versions.rb#92
    def version_names=(value); end

    # source://carrierwave//lib/carrierwave/uploader/versions.rb#92
    def version_names?; end

    # source://carrierwave//lib/carrierwave/uploader/versions.rb#92
    def version_options; end

    # source://carrierwave//lib/carrierwave/uploader/versions.rb#92
    def version_options=(value); end

    # source://carrierwave//lib/carrierwave/uploader/versions.rb#92
    def version_options?; end

    # source://carrierwave//lib/carrierwave/uploader/versions.rb#92
    def versions; end

    # source://carrierwave//lib/carrierwave/uploader/versions.rb#92
    def versions=(value); end

    # source://carrierwave//lib/carrierwave/uploader/versions.rb#92
    def versions?; end

    private

    # source://activesupport/8.0.2/lib/active_support/class_attribute.rb#15
    def __class_attr__after_callbacks; end

    # source://activesupport/8.0.2/lib/active_support/class_attribute.rb#17
    def __class_attr__after_callbacks=(new_value); end

    # source://activesupport/8.0.2/lib/active_support/class_attribute.rb#15
    def __class_attr__before_callbacks; end

    # source://activesupport/8.0.2/lib/active_support/class_attribute.rb#17
    def __class_attr__before_callbacks=(new_value); end

    # source://activesupport/8.0.2/lib/active_support/class_attribute.rb#15
    def __class_attr__cache_storage; end

    # source://activesupport/8.0.2/lib/active_support/class_attribute.rb#17
    def __class_attr__cache_storage=(new_value); end

    # source://activesupport/8.0.2/lib/active_support/class_attribute.rb#15
    def __class_attr__storage; end

    # source://activesupport/8.0.2/lib/active_support/class_attribute.rb#17
    def __class_attr__storage=(new_value); end

    # source://activesupport/8.0.2/lib/active_support/class_attribute.rb#15
    def __class_attr_filename_safeguard_checked; end

    # source://activesupport/8.0.2/lib/active_support/class_attribute.rb#17
    def __class_attr_filename_safeguard_checked=(new_value); end

    # source://activesupport/8.0.2/lib/active_support/class_attribute.rb#15
    def __class_attr_processors; end

    # source://activesupport/8.0.2/lib/active_support/class_attribute.rb#17
    def __class_attr_processors=(new_value); end

    # source://activesupport/8.0.2/lib/active_support/class_attribute.rb#15
    def __class_attr_version_names; end

    # source://activesupport/8.0.2/lib/active_support/class_attribute.rb#17
    def __class_attr_version_names=(new_value); end

    # source://activesupport/8.0.2/lib/active_support/class_attribute.rb#15
    def __class_attr_version_options; end

    # source://activesupport/8.0.2/lib/active_support/class_attribute.rb#17
    def __class_attr_version_options=(new_value); end

    # source://activesupport/8.0.2/lib/active_support/class_attribute.rb#15
    def __class_attr_versions; end

    # source://activesupport/8.0.2/lib/active_support/class_attribute.rb#17
    def __class_attr_versions=(new_value); end
  end
end

# source://carrierwave//lib/carrierwave/uploader/cache.rb#36
module CarrierWave::Uploader::Cache
  extend ::ActiveSupport::Concern
  include GeneratedInstanceMethods
  include ::CarrierWave::Uploader::Callbacks
  include ::CarrierWave::Uploader::Configuration

  mixes_in_class_methods GeneratedClassMethods
  mixes_in_class_methods ::CarrierWave::Uploader::Callbacks::ClassMethods
  mixes_in_class_methods ::CarrierWave::Uploader::Configuration::ClassMethods
  mixes_in_class_methods ::CarrierWave::Uploader::Cache::ClassMethods

  # Caches the given file. Calls process! to trigger any process callbacks.
  #
  # By default, cache!() uses copy_to(), which operates by copying the file
  # to the cache, then deleting the original file.  If move_to_cache() is
  # overridden to return true, then cache!() uses move_to(), which simply
  # moves the file to the cache.  Useful for large files.
  #
  # === Parameters
  #
  # [new_file (File, IOString, Tempfile)] any kind of file object
  #
  # === Raises
  #
  # [CarrierWave::FormNotMultipart] if the assigned parameter is a string
  #
  # @raise [CarrierWave::FormNotMultipart]
  #
  # source://carrierwave//lib/carrierwave/uploader/cache.rb#125
  def cache!(new_file = T.unsafe(nil)); end

  # Returns a String which uniquely identifies the currently cached file for later retrieval
  #
  # === Returns
  #
  # [String] a cache name, in the format TIMEINT-PID-COUNTER-RND/filename.txt
  #
  # source://carrierwave//lib/carrierwave/uploader/cache.rb#105
  def cache_name; end

  # Calculates the path where the cache file should be stored.
  #
  # === Parameters
  #
  # [for_file (String)] name of the file <optional>
  #
  # === Returns
  #
  # [String] the cache path
  #
  # source://carrierwave//lib/carrierwave/uploader/cache.rb#185
  def cache_path(for_file = T.unsafe(nil)); end

  # Caches the remotely stored file
  #
  # This is useful when about to process images. Most processing solutions
  # require the file to be stored on the local filesystem.
  #
  # source://carrierwave//lib/carrierwave/uploader/cache.rb#89
  def cache_stored_file!; end

  # Returns true if the uploader has been cached
  #
  # === Returns
  #
  # [Bool] whether the current file is cached
  #
  # @return [Boolean]
  #
  # source://carrierwave//lib/carrierwave/uploader/cache.rb#79
  def cached?; end

  # Retrieves the file with the given cache_name from the cache.
  #
  # === Parameters
  #
  # [cache_name (String)] uniquely identifies a cache file
  #
  # === Raises
  #
  # [CarrierWave::InvalidParameter] if the cache_name is incorrectly formatted.
  #
  # source://carrierwave//lib/carrierwave/uploader/cache.rb#165
  def retrieve_from_cache!(cache_name); end

  # source://activesupport/8.0.2/lib/active_support/deprecation/method_wrappers.rb#46
  def sanitized_file(*args, **_arg1, &block); end

  protected

  # Returns the value of attribute cache_id.
  #
  # source://carrierwave//lib/carrierwave/uploader/cache.rb#191
  def cache_id; end

  private

  # @raise [CarrierWave::InvalidParameter]
  #
  # source://carrierwave//lib/carrierwave/uploader/cache.rb#201
  def cache_id=(cache_id); end

  # source://carrierwave//lib/carrierwave/uploader/cache.rb#213
  def cache_storage; end

  # We can override the full_original_filename method in other modules
  #
  # source://carrierwave//lib/carrierwave/uploader/cache.rb#218
  def full_original_filename; end

  # Returns the value of attribute original_filename.
  #
  # source://carrierwave//lib/carrierwave/uploader/cache.rb#199
  def original_filename; end

  # @raise [CarrierWave::InvalidParameter]
  #
  # source://carrierwave//lib/carrierwave/uploader/cache.rb#208
  def original_filename=(filename); end

  # source://carrierwave//lib/carrierwave/uploader/cache.rb#195
  def workfile_path(for_file = T.unsafe(nil)); end

  module GeneratedClassMethods
    def _after_callbacks; end
    def _after_callbacks=(value); end
    def _after_callbacks?; end
    def _before_callbacks; end
    def _before_callbacks=(value); end
    def _before_callbacks?; end
    def _cache_storage; end
    def _cache_storage=(value); end
    def _cache_storage?; end
    def _storage; end
    def _storage=(value); end
    def _storage?; end
  end

  module GeneratedInstanceMethods
    def _after_callbacks; end
    def _after_callbacks?; end
    def _before_callbacks; end
    def _before_callbacks?; end
    def _cache_storage; end
    def _cache_storage?; end
    def _storage; end
    def _storage?; end
  end
end

# source://carrierwave//lib/carrierwave/uploader/cache.rb#52
module CarrierWave::Uploader::Cache::ClassMethods
  # Removes cached files which are older than one day. You could call this method
  # from a rake task to clean out old cached files.
  #
  # You can call this method directly on the module like this:
  #
  #   CarrierWave.clean_cached_files!
  #
  # === Note
  #
  # This only works as long as you haven't done anything funky with your cache_dir.
  # It's recommended that you keep cache files in one place only.
  #
  # source://carrierwave//lib/carrierwave/uploader/cache.rb#67
  def clean_cached_files!(seconds = T.unsafe(nil)); end
end

# source://carrierwave//lib/carrierwave/uploader/callbacks.rb#3
module CarrierWave::Uploader::Callbacks
  extend ::ActiveSupport::Concern
  include GeneratedInstanceMethods

  mixes_in_class_methods GeneratedClassMethods
  mixes_in_class_methods ::CarrierWave::Uploader::Callbacks::ClassMethods

  # source://carrierwave//lib/carrierwave/uploader/callbacks.rb#13
  def with_callbacks(kind, *args); end

  module GeneratedClassMethods
    def _after_callbacks; end
    def _after_callbacks=(value); end
    def _after_callbacks?; end
    def _before_callbacks; end
    def _before_callbacks=(value); end
    def _before_callbacks?; end
  end

  module GeneratedInstanceMethods
    def _after_callbacks; end
    def _after_callbacks?; end
    def _before_callbacks; end
    def _before_callbacks?; end
  end
end

# source://carrierwave//lib/carrierwave/uploader/callbacks.rb#19
module CarrierWave::Uploader::Callbacks::ClassMethods
  # source://carrierwave//lib/carrierwave/uploader/callbacks.rb#25
  def after(kind, callback); end

  # source://carrierwave//lib/carrierwave/uploader/callbacks.rb#20
  def before(kind, callback); end
end

# source://carrierwave//lib/carrierwave/uploader/configuration.rb#6
module CarrierWave::Uploader::Configuration
  extend ::ActiveSupport::Concern
  include GeneratedInstanceMethods

  mixes_in_class_methods GeneratedClassMethods
  mixes_in_class_methods ::CarrierWave::Uploader::Configuration::ClassMethods

  module GeneratedClassMethods
    def _cache_storage; end
    def _cache_storage=(value); end
    def _cache_storage?; end
    def _storage; end
    def _storage=(value); end
    def _storage?; end
  end

  module GeneratedInstanceMethods
    def _cache_storage; end
    def _cache_storage?; end
    def _storage; end
    def _storage?; end
  end
end

# source://carrierwave//lib/carrierwave/uploader/configuration.rb#57
module CarrierWave::Uploader::Configuration::ClassMethods
  # source://carrierwave//lib/carrierwave/uploader/configuration.rb#126
  def add_config(name); end

  # source://carrierwave//lib/carrierwave/uploader/configuration.rb#158
  def add_deprecated_config(name); end

  # Sets the cache storage engine to be used when storing cache files with this uploader.
  # Same as .storage except for required methods being #cache!(CarrierWave::SanitizedFile),
  # #retrieve_from_cache! and #delete_dir!.
  #
  # === Parameters
  #
  # [storage (Symbol, Class)] The cache storage engine to use for this uploader
  #
  # === Returns
  #
  # [Class] the cache storage engine to be used with this uploader
  #
  # === Examples
  #
  #     cache_storage :file
  #     cache_storage CarrierWave::Storage::File
  #     cache_storage MyCustomStorageEngine
  #
  # source://carrierwave//lib/carrierwave/uploader/configuration.rb#118
  def cache_storage(storage = T.unsafe(nil)); end

  # Sets the cache storage engine to be used when storing cache files with this uploader.
  # Same as .storage except for required methods being #cache!(CarrierWave::SanitizedFile),
  # #retrieve_from_cache! and #delete_dir!.
  #
  # === Parameters
  #
  # [storage (Symbol, Class)] The cache storage engine to use for this uploader
  #
  # === Returns
  #
  # [Class] the cache storage engine to be used with this uploader
  #
  # === Examples
  #
  #     cache_storage :file
  #     cache_storage CarrierWave::Storage::File
  #     cache_storage MyCustomStorageEngine
  #
  # source://carrierwave//lib/carrierwave/uploader/configuration.rb#118
  def cache_storage=(storage = T.unsafe(nil)); end

  # @yield [_self]
  # @yieldparam _self [CarrierWave::Uploader::Configuration::ClassMethods] the object that the method was called on
  #
  # source://carrierwave//lib/carrierwave/uploader/configuration.rb#178
  def configure; end

  # sets configuration back to default
  #
  # source://carrierwave//lib/carrierwave/uploader/configuration.rb#185
  def reset_config; end

  # Sets the storage engine to be used when storing files with this uploader.
  # Can be any class that implements a #store!(CarrierWave::SanitizedFile) and a #retrieve!
  # method. See lib/carrierwave/storage/file.rb for an example. Storage engines should
  # be added to CarrierWave::Uploader::Base.storage_engines so they can be referred
  # to by a symbol, which should be more convenient
  #
  # If no argument is given, it will simply return the currently used storage engine.
  #
  # === Parameters
  #
  # [storage (Symbol, Class)] The storage engine to use for this uploader
  #
  # === Returns
  #
  # [Class] the storage engine to be used with this uploader
  #
  # === Examples
  #
  #     storage :file
  #     storage CarrierWave::Storage::File
  #     storage MyCustomStorageEngine
  #
  # source://carrierwave//lib/carrierwave/uploader/configuration.rb#82
  def storage(storage = T.unsafe(nil)); end

  # Sets the storage engine to be used when storing files with this uploader.
  # Can be any class that implements a #store!(CarrierWave::SanitizedFile) and a #retrieve!
  # method. See lib/carrierwave/storage/file.rb for an example. Storage engines should
  # be added to CarrierWave::Uploader::Base.storage_engines so they can be referred
  # to by a symbol, which should be more convenient
  #
  # If no argument is given, it will simply return the currently used storage engine.
  #
  # === Parameters
  #
  # [storage (Symbol, Class)] The storage engine to use for this uploader
  #
  # === Returns
  #
  # [Class] the storage engine to be used with this uploader
  #
  # === Examples
  #
  #     storage :file
  #     storage CarrierWave::Storage::File
  #     storage MyCustomStorageEngine
  #
  # source://carrierwave//lib/carrierwave/uploader/configuration.rb#82
  def storage=(storage = T.unsafe(nil)); end
end

# source://carrierwave//lib/carrierwave/uploader/content_type_allowlist.rb#3
module CarrierWave::Uploader::ContentTypeAllowlist
  extend ::ActiveSupport::Concern

  # Override this method in your uploader to provide an allowlist of files content types
  # which are allowed to be uploaded.
  # Not only strings but Regexp are allowed as well.
  #
  # === Returns
  #
  # [NilClass, String, Regexp, Array[String, Regexp]] an allowlist of content types which are allowed to be uploaded
  #
  # === Examples
  #
  #     def content_type_allowlist
  #       %w(text/json application/json)
  #     end
  #
  # Basically the same, but using a Regexp:
  #
  #     def content_type_allowlist
  #       [/(text|application)\/json/]
  #     end
  #
  # source://carrierwave//lib/carrierwave/uploader/content_type_allowlist.rb#31
  def content_type_allowlist; end

  private

  # @return [Boolean]
  #
  # source://carrierwave//lib/carrierwave/uploader/content_type_allowlist.rb#53
  def allowlisted_content_type?(allowlist, content_type); end

  # source://carrierwave//lib/carrierwave/uploader/content_type_allowlist.rb#36
  def check_content_type_allowlist!(new_file); end
end

# source://carrierwave//lib/carrierwave/uploader/content_type_denylist.rb#3
module CarrierWave::Uploader::ContentTypeDenylist
  extend ::ActiveSupport::Concern

  # Override this method in your uploader to provide a denylist of files content types
  # which are not allowed to be uploaded.
  # Not only strings but Regexp are allowed as well.
  #
  # === Returns
  #
  # [NilClass, String, Regexp, Array[String, Regexp]] a denylist of content types which are not allowed to be uploaded
  #
  # === Examples
  #
  #     def content_type_denylist
  #       %w(text/json application/json)
  #     end
  #
  # Basically the same, but using a Regexp:
  #
  #     def content_type_denylist
  #       [/(text|application)\/json/]
  #     end
  #
  # source://carrierwave//lib/carrierwave/uploader/content_type_denylist.rb#31
  def content_type_denylist; end

  private

  # source://carrierwave//lib/carrierwave/uploader/content_type_denylist.rb#36
  def check_content_type_denylist!(new_file); end

  # @return [Boolean]
  #
  # source://carrierwave//lib/carrierwave/uploader/content_type_denylist.rb#56
  def denylisted_content_type?(denylist, content_type); end
end

# source://carrierwave//lib/carrierwave/uploader/default_url.rb#3
module CarrierWave::Uploader::DefaultUrl
  # Override this method in your uploader to provide a default url
  # in case no file has been cached/stored yet.
  #
  # source://carrierwave//lib/carrierwave/uploader/default_url.rb#13
  def default_url(*args); end

  # source://carrierwave//lib/carrierwave/uploader/default_url.rb#5
  def url(*args); end
end

# source://carrierwave//lib/carrierwave/uploader/dimension.rb#5
module CarrierWave::Uploader::Dimension
  extend ::ActiveSupport::Concern

  # Override this method in your uploader to provide a Range of height which
  # are allowed to be uploaded.
  # === Returns
  #
  # [NilClass, Range] a height range which are permitted to be uploaded
  #
  # === Examples
  #
  #     def height_range
  #       1000..
  #     end
  #
  # source://carrierwave//lib/carrierwave/uploader/dimension.rb#40
  def height_range; end

  # Override this method in your uploader to provide a Range of width which
  # are allowed to be uploaded.
  # === Returns
  #
  # [NilClass, Range] a width range which are permitted to be uploaded
  #
  # === Examples
  #
  #     def width_range
  #       1000..2000
  #     end
  #
  # source://carrierwave//lib/carrierwave/uploader/dimension.rb#25
  def width_range; end

  private

  # source://carrierwave//lib/carrierwave/uploader/dimension.rb#44
  def check_dimensions!(new_file); end
end

# source://carrierwave//lib/carrierwave/uploader/download.rb#3
module CarrierWave::Uploader::Download
  extend ::ActiveSupport::Concern
  include GeneratedInstanceMethods
  include ::CarrierWave::Uploader::Callbacks
  include ::CarrierWave::Uploader::Configuration
  include ::CarrierWave::Uploader::Cache

  mixes_in_class_methods GeneratedClassMethods
  mixes_in_class_methods ::CarrierWave::Uploader::Callbacks::ClassMethods
  mixes_in_class_methods ::CarrierWave::Uploader::Configuration::ClassMethods
  mixes_in_class_methods ::CarrierWave::Uploader::Cache::ClassMethods

  # Caches the file by downloading it from the given URL, using downloader.
  #
  # === Parameters
  #
  # [url (String)] The URL where the remote file is stored
  # [remote_headers (Hash)] Request headers
  #
  # source://carrierwave//lib/carrierwave/uploader/download.rb#18
  def download!(uri, remote_headers = T.unsafe(nil)); end

  module GeneratedClassMethods
    def _after_callbacks; end
    def _after_callbacks=(value); end
    def _after_callbacks?; end
    def _before_callbacks; end
    def _before_callbacks=(value); end
    def _before_callbacks?; end
    def _cache_storage; end
    def _cache_storage=(value); end
    def _cache_storage?; end
    def _storage; end
    def _storage=(value); end
    def _storage?; end
  end

  module GeneratedInstanceMethods
    def _after_callbacks; end
    def _after_callbacks?; end
    def _before_callbacks; end
    def _before_callbacks?; end
    def _cache_storage; end
    def _cache_storage?; end
    def _storage; end
    def _storage?; end
  end
end

# source://carrierwave//lib/carrierwave/uploader/extension_allowlist.rb#3
module CarrierWave::Uploader::ExtensionAllowlist
  extend ::ActiveSupport::Concern

  # Override this method in your uploader to provide an allowlist of extensions which
  # are allowed to be uploaded. Compares the file's extension case insensitive.
  # Furthermore, not only strings but Regexp are allowed as well.
  #
  # When using a Regexp in the allowlist, `\A` and `\z` are automatically added to
  # the Regexp expression, also case insensitive.
  #
  # === Returns
  #
  # [NilClass, String, Regexp, Array[String, Regexp]] an allowlist of extensions which are allowed to be uploaded
  #
  # === Examples
  #
  #     def extension_allowlist
  #       %w(jpg jpeg gif png)
  #     end
  #
  # Basically the same, but using a Regexp:
  #
  #     def extension_allowlist
  #       [/jpe?g/, 'gif', 'png']
  #     end
  #
  # source://carrierwave//lib/carrierwave/uploader/extension_allowlist.rb#34
  def extension_allowlist; end

  private

  # @return [Boolean]
  #
  # source://carrierwave//lib/carrierwave/uploader/extension_allowlist.rb#57
  def allowlisted_extension?(allowlist, extension); end

  # source://carrierwave//lib/carrierwave/uploader/extension_allowlist.rb#39
  def check_extension_allowlist!(new_file); end
end

# source://carrierwave//lib/carrierwave/uploader/extension_denylist.rb#3
module CarrierWave::Uploader::ExtensionDenylist
  extend ::ActiveSupport::Concern

  # [NilClass, String, Regexp, Array[String, Regexp]] a deny list of extensions which are prohibited to be uploaded
  #
  # === Examples
  #
  #     def extension_denylist
  #       %w(swf tiff)
  #     end
  #
  # Basically the same, but using a Regexp:
  #
  #     def extension_denylist
  #       [/swf/, 'tiff']
  #     end
  #
  # source://carrierwave//lib/carrierwave/uploader/extension_denylist.rb#34
  def extension_denylist; end

  private

  # source://carrierwave//lib/carrierwave/uploader/extension_denylist.rb#39
  def check_extension_denylist!(new_file); end

  # @return [Boolean]
  #
  # source://carrierwave//lib/carrierwave/uploader/extension_denylist.rb#59
  def denylisted_extension?(denylist, extension); end
end

# source://carrierwave//lib/carrierwave/uploader/file_size.rb#5
module CarrierWave::Uploader::FileSize
  extend ::ActiveSupport::Concern

  # Override this method in your uploader to provide a Range of Size which
  # are allowed to be uploaded.
  # === Returns
  #
  # [NilClass, Range] a size range (in bytes) which are permitted to be uploaded
  #
  # === Examples
  #
  #     def size_range
  #       3256...5748
  #     end
  #
  # source://carrierwave//lib/carrierwave/uploader/file_size.rb#25
  def size_range; end

  private

  # source://carrierwave//lib/carrierwave/uploader/file_size.rb#29
  def check_size!(new_file); end
end

# source://carrierwave//lib/carrierwave/uploader/mountable.rb#3
module CarrierWave::Uploader::Mountable
  # If a model is given as the first parameter, it will be stored in the
  # uploader, and available through +#model+. Likewise, mounted_as stores
  # the name of the column where this instance of the uploader is mounted.
  # These values can then be used inside your uploader.
  #
  # If you do not wish to mount your uploaders with the ORM extensions in
  # -more then you can override this method inside your uploader. Just be
  # sure to call +super+
  #
  # === Parameters
  #
  # [model (Object)] Any kind of model object
  # [mounted_as (Symbol)] The name of the column where this uploader is mounted
  #
  # === Examples
  #
  #     class MyUploader < CarrierWave::Uploader::Base
  #
  #       def store_dir
  #         File.join('public', 'files', mounted_as, model.permalink)
  #       end
  #     end
  #
  # source://carrierwave//lib/carrierwave/uploader/mountable.rb#31
  def initialize(model = T.unsafe(nil), mounted_as = T.unsafe(nil)); end

  # Returns array index of given uploader within currently mounted uploaders
  #
  # source://carrierwave//lib/carrierwave/uploader/mountable.rb#39
  def index; end

  # Returns the value of attribute model.
  #
  # source://carrierwave//lib/carrierwave/uploader/mountable.rb#5
  def model; end

  # Returns the value of attribute mounted_as.
  #
  # source://carrierwave//lib/carrierwave/uploader/mountable.rb#5
  def mounted_as; end
end

# source://carrierwave//lib/carrierwave/uploader/processing.rb#3
module CarrierWave::Uploader::Processing
  extend ::ActiveSupport::Concern
  include GeneratedInstanceMethods
  include ::CarrierWave::Uploader::Callbacks

  mixes_in_class_methods GeneratedClassMethods
  mixes_in_class_methods ::CarrierWave::Uploader::Callbacks::ClassMethods
  mixes_in_class_methods ::CarrierWave::Uploader::Processing::ClassMethods

  # Apply all process callbacks added through CarrierWave.process
  #
  # source://carrierwave//lib/carrierwave/uploader/processing.rb#84
  def process!(new_file = T.unsafe(nil)); end

  private

  # source://carrierwave//lib/carrierwave/uploader/processing.rb#119
  def forcing_extension(filename); end

  module GeneratedClassMethods
    def _after_callbacks; end
    def _after_callbacks=(value); end
    def _after_callbacks?; end
    def _before_callbacks; end
    def _before_callbacks=(value); end
    def _before_callbacks?; end
    def processors; end
    def processors=(value); end
    def processors?; end
  end

  module GeneratedInstanceMethods
    def _after_callbacks; end
    def _after_callbacks?; end
    def _before_callbacks; end
    def _before_callbacks?; end
    def processors; end
    def processors?; end
  end
end

# source://carrierwave//lib/carrierwave/uploader/processing.rb#15
module CarrierWave::Uploader::Processing::ClassMethods
  # Adds a processor callback which applies operations as a file is uploaded.
  # The argument may be the name of any method of the uploader, expressed as a symbol,
  # or a list of such methods, or a hash where the key is a method and the value is
  # an array of arguments to call the method with. Also accepts an :if or :unless condition
  #
  # === Parameters
  #
  # args (*Symbol, Hash{Symbol => Array[]})
  #
  # === Examples
  #
  #     class MyUploader < CarrierWave::Uploader::Base
  #
  #       process :sepiatone, :vignette
  #       process :scale => [200, 200]
  #       process :scale => [200, 200], :if => :image?
  #       process :scale => [200, 200], :unless => :disallowed_image_type?
  #       process :sepiatone, :if => :image?
  #
  #       def sepiatone
  #         ...
  #       end
  #
  #       def vignette
  #         ...
  #       end
  #
  #       def scale(height, width)
  #         ...
  #       end
  #
  #       def image?
  #         ...
  #       end
  #
  #       def disallowed_image_type?
  #         ...
  #       end
  #
  #     end
  #
  # source://carrierwave//lib/carrierwave/uploader/processing.rb#59
  def process(*args); end
end

# source://carrierwave//lib/carrierwave/uploader/proxy.rb#3
module CarrierWave::Uploader::Proxy
  # === Returns
  #
  # [Boolean] Whether the uploaded file is blank
  #
  # @return [Boolean]
  #
  # source://carrierwave//lib/carrierwave/uploader/proxy.rb#10
  def blank?; end

  # Read the content type of the file
  #
  # === Returns
  #
  # [String] content type of the file
  #
  # source://carrierwave//lib/carrierwave/uploader/proxy.rb#93
  def content_type; end

  # === Returns
  #
  # [String] the path where the file is currently located.
  #
  # source://carrierwave//lib/carrierwave/uploader/proxy.rb#19
  def current_path; end

  # Returns a string that uniquely identifies the retrieved or last stored file
  #
  # === Returns
  #
  # [String] uniquely identifies a file
  #
  # source://carrierwave//lib/carrierwave/uploader/proxy.rb#32
  def identifier; end

  # Return the size of the file when asked for its length
  #
  # === Returns
  #
  # [Integer] size of the file
  #
  # === Note
  #
  # This was added because of the way Rails handles length/size validations in 3.0.6 and above.
  #
  # source://carrierwave//lib/carrierwave/uploader/proxy.rb#82
  def length; end

  # === Returns
  #
  # [String] the path where the file is currently located.
  #
  # source://carrierwave//lib/carrierwave/uploader/proxy.rb#19
  def path; end

  # Read the contents of the file
  #
  # === Returns
  #
  # [String] contents of the file
  #
  # source://carrierwave//lib/carrierwave/uploader/proxy.rb#56
  def read(*args); end

  # Fetches the size of the currently stored/cached file
  #
  # === Returns
  #
  # [Integer] size of the file
  #
  # source://carrierwave//lib/carrierwave/uploader/proxy.rb#67
  def size; end

  # Returns a String which is to be used as a temporary value which gets assigned to the column.
  # The purpose is to mark the column that it will be updated. Finally before the save it will be
  # overwritten by the #identifier value, which is usually #filename.
  #
  # === Returns
  #
  # [String] a temporary_identifier, by default the value of #cache_name is used
  #
  # source://carrierwave//lib/carrierwave/uploader/proxy.rb#45
  def temporary_identifier; end
end

# source://carrierwave//lib/carrierwave/uploader/remove.rb#3
module CarrierWave::Uploader::Remove
  extend ::ActiveSupport::Concern
  include GeneratedInstanceMethods
  include ::CarrierWave::Uploader::Callbacks

  mixes_in_class_methods GeneratedClassMethods
  mixes_in_class_methods ::CarrierWave::Uploader::Callbacks::ClassMethods

  # Removes the file and reset it
  #
  # source://carrierwave//lib/carrierwave/uploader/remove.rb#11
  def remove!; end

  module GeneratedClassMethods
    def _after_callbacks; end
    def _after_callbacks=(value); end
    def _after_callbacks?; end
    def _before_callbacks; end
    def _before_callbacks=(value); end
    def _before_callbacks?; end
  end

  module GeneratedInstanceMethods
    def _after_callbacks; end
    def _after_callbacks?; end
    def _before_callbacks; end
    def _before_callbacks?; end
  end
end

# source://carrierwave//lib/carrierwave/uploader/serialization.rb#6
module CarrierWave::Uploader::Serialization
  extend ::ActiveSupport::Concern

  # source://carrierwave//lib/carrierwave/uploader/serialization.rb#13
  def as_json(options = T.unsafe(nil)); end

  # source://carrierwave//lib/carrierwave/uploader/serialization.rb#9
  def serializable_hash(options = T.unsafe(nil)); end

  # source://carrierwave//lib/carrierwave/uploader/serialization.rb#17
  def to_json(options = T.unsafe(nil)); end

  # source://carrierwave//lib/carrierwave/uploader/serialization.rb#21
  def to_xml(options = T.unsafe(nil)); end
end

# source://carrierwave//lib/carrierwave/uploader/store.rb#3
module CarrierWave::Uploader::Store
  extend ::ActiveSupport::Concern
  include GeneratedInstanceMethods
  include ::CarrierWave::Uploader::Callbacks
  include ::CarrierWave::Uploader::Configuration
  include ::CarrierWave::Uploader::Cache

  mixes_in_class_methods GeneratedClassMethods
  mixes_in_class_methods ::CarrierWave::Uploader::Callbacks::ClassMethods
  mixes_in_class_methods ::CarrierWave::Uploader::Configuration::ClassMethods
  mixes_in_class_methods ::CarrierWave::Uploader::Cache::ClassMethods
  mixes_in_class_methods ::CarrierWave::Uploader::Store::ClassMethods

  # Look for an identifier which doesn't collide with the given already-stored identifiers.
  # It is done by adding a index number as the suffix.
  # For example, if there's 'image.jpg' and the @deduplication_index is set to 2,
  # The stored file will be named as 'image(2).jpg'.
  #
  # === Parameters
  #
  # [current_identifiers (Array[String])] List of identifiers for already-stored files
  #
  # source://carrierwave//lib/carrierwave/uploader/store.rb#134
  def deduplicate(current_identifiers); end

  # Returns a filename which doesn't conflict with already-stored files.
  #
  # === Returns
  #
  # [String] the filename with suffix added for deduplication
  #
  # source://carrierwave//lib/carrierwave/uploader/store.rb#58
  def deduplicated_filename; end

  # Override this in your Uploader to change the filename.
  #
  # Be careful using record ids as filenames. If the filename is stored in the database
  # the record id will be nil when the filename is set. Don't use record ids unless you
  # understand this limitation.
  #
  # Do not use the version_name in the filename, as it will prevent versions from being
  # loaded correctly.
  #
  # === Returns
  #
  # [String] a filename
  #
  # source://carrierwave//lib/carrierwave/uploader/store.rb#47
  def filename; end

  # Retrieves the file from the storage.
  #
  # === Parameters
  #
  # [identifier (String)] uniquely identifies the file to retrieve
  #
  # source://carrierwave//lib/carrierwave/uploader/store.rb#117
  def retrieve_from_store!(identifier); end

  # Stores the file by passing it to this Uploader's storage engine.
  #
  # If new_file is omitted, a previously cached file will be stored.
  #
  # === Parameters
  #
  # [new_file (File, IOString, Tempfile)] any kind of file object
  #
  # source://carrierwave//lib/carrierwave/uploader/store.rb#93
  def store!(new_file = T.unsafe(nil)); end

  # Calculates the path where the file should be stored. If +for_file+ is given, it will be
  # used as the identifier, otherwise +CarrierWave::Uploader#identifier+ is assumed.
  #
  # === Parameters
  #
  # [for_file (String)] name of the file <optional>
  #
  # === Returns
  #
  # [String] the store path
  #
  # source://carrierwave//lib/carrierwave/uploader/store.rb#80
  def store_path(for_file = T.unsafe(nil)); end

  private

  # source://carrierwave//lib/carrierwave/uploader/store.rb#146
  def full_filename(for_file); end

  # source://carrierwave//lib/carrierwave/uploader/store.rb#150
  def show_warning_when_filename_is_unavailable(_); end

  # source://carrierwave//lib/carrierwave/uploader/store.rb#162
  def storage; end

  module GeneratedClassMethods
    def _after_callbacks; end
    def _after_callbacks=(value); end
    def _after_callbacks?; end
    def _before_callbacks; end
    def _before_callbacks=(value); end
    def _before_callbacks?; end
    def _cache_storage; end
    def _cache_storage=(value); end
    def _cache_storage?; end
    def _storage; end
    def _storage=(value); end
    def _storage?; end
    def filename_safeguard_checked; end
    def filename_safeguard_checked=(value); end
    def filename_safeguard_checked?; end
  end

  module GeneratedInstanceMethods
    def _after_callbacks; end
    def _after_callbacks?; end
    def _before_callbacks; end
    def _before_callbacks?; end
    def _cache_storage; end
    def _cache_storage?; end
    def _storage; end
    def _storage?; end
    def filename_safeguard_checked; end
    def filename_safeguard_checked=(value); end
    def filename_safeguard_checked?; end
  end
end

# source://carrierwave//lib/carrierwave/uploader/store.rb#23
module CarrierWave::Uploader::Store::ClassMethods
  private

  # source://carrierwave//lib/carrierwave/uploader/store.rb#26
  def inherited(subclass); end
end

# source://carrierwave//lib/carrierwave/uploader/url.rb#3
module CarrierWave::Uploader::Url
  include ::CarrierWave::Utilities::Uri
  extend ::ActiveSupport::Concern
  include GeneratedInstanceMethods
  include ::CarrierWave::Uploader::Configuration

  mixes_in_class_methods GeneratedClassMethods
  mixes_in_class_methods ::CarrierWave::Uploader::Configuration::ClassMethods

  # source://carrierwave//lib/carrierwave/uploader/url.rb#38
  def to_s; end

  # === Parameters
  #
  # [Hash] optional, the query params (only AWS)
  #
  # === Returns
  #
  # [String] the location where this file is accessible via a url
  #
  # source://carrierwave//lib/carrierwave/uploader/url.rb#17
  def url(options = T.unsafe(nil)); end

  module GeneratedClassMethods
    def _cache_storage; end
    def _cache_storage=(value); end
    def _cache_storage?; end
    def _storage; end
    def _storage=(value); end
    def _storage?; end
  end

  module GeneratedInstanceMethods
    def _cache_storage; end
    def _cache_storage?; end
    def _storage; end
    def _storage?; end
  end
end

# source://carrierwave//lib/carrierwave/uploader/versions.rb#5
module CarrierWave::Uploader::Versions
  extend ::ActiveSupport::Concern
  include GeneratedInstanceMethods
  include ::CarrierWave::Uploader::Callbacks

  mixes_in_class_methods GeneratedClassMethods
  mixes_in_class_methods ::CarrierWave::Uploader::Callbacks::ClassMethods
  mixes_in_class_methods ::CarrierWave::Uploader::Versions::ClassMethods

  # Copies the parent's cache_id when caching a version file.
  # This behavior is not essential but it makes easier to understand
  # that the cached files are generated by the single upload attempt.
  #
  # source://carrierwave//lib/carrierwave/uploader/versions.rb#233
  def cache!(*args); end

  # Recreate versions and reprocess them. This can be used to recreate
  # versions if their parameters somehow have changed.
  #
  # source://carrierwave//lib/carrierwave/uploader/versions.rb#279
  def recreate_versions!(*names); end

  # When given a version name as a parameter, will return the url for that version
  # This also works with nested versions.
  # When given a query hash as a parameter, will return the url with signature that contains query params
  # Query hash only works with AWS (S3 storage).
  #
  # === Example
  #
  #     my_uploader.url                 # => /path/to/my/uploader.gif
  #     my_uploader.url(:thumb)         # => /path/to/my/thumb_uploader.gif
  #     my_uploader.url(:thumb, :small) # => /path/to/my/thumb_small_uploader.gif
  #     my_uploader.url(:query => {"response-content-disposition" => "attachment"})
  #     my_uploader.url(:version, :sub_version, :query => {"response-content-disposition" => "attachment"})
  #
  # === Parameters
  #
  # [*args (Symbol)] any number of versions
  # OR/AND
  # [Hash] query params
  #
  # === Returns
  #
  # [String] the location where this file is accessible via a url
  #
  # source://carrierwave//lib/carrierwave/uploader/versions.rb#263
  def url(*args); end

  # === Parameters
  #
  # [name (#to_sym)] name of the version
  #
  # === Returns
  #
  # [Boolean] True when the version satisfy its :if or :unless condition
  #
  # @return [Boolean]
  #
  # source://carrierwave//lib/carrierwave/uploader/versions.rb#201
  def version_active?(name); end

  # === Parameters
  #
  # [name (#to_sym)] name of the version
  #
  # === Returns
  #
  # [Boolean] True when the version satisfy its :if or :unless condition
  #
  # @return [Boolean]
  #
  # source://activesupport/8.0.2/lib/active_support/deprecation/method_wrappers.rb#46
  def version_exists?(*args, **_arg1, &block); end

  # === Returns
  #
  # [String] the name of this version of the uploader
  #
  # source://carrierwave//lib/carrierwave/uploader/versions.rb#187
  def version_name; end

  # Returns a hash mapping the name of each version of the uploader to an instance of it
  #
  # === Returns
  #
  # [Hash{Symbol => CarrierWave::Uploader}] a list of uploader instances
  #
  # source://carrierwave//lib/carrierwave/uploader/versions.rb#172
  def versions; end

  protected

  # source://carrierwave//lib/carrierwave/uploader/versions.rb#302
  def active_versions; end

  # source://carrierwave//lib/carrierwave/uploader/versions.rb#296
  def descendant_version_names; end

  private

  # source://carrierwave//lib/carrierwave/uploader/versions.rb#318
  def active_sibling_versions; end

  # source://carrierwave//lib/carrierwave/uploader/versions.rb#330
  def cache_versions!(new_file); end

  # source://carrierwave//lib/carrierwave/uploader/versions.rb#310
  def derived_versions; end

  # source://carrierwave//lib/carrierwave/uploader/versions.rb#322
  def full_filename(for_file); end

  # source://carrierwave//lib/carrierwave/uploader/versions.rb#326
  def full_original_filename; end

  # source://carrierwave//lib/carrierwave/uploader/versions.rb#338
  def remove_versions!; end

  # source://carrierwave//lib/carrierwave/uploader/versions.rb#342
  def retrieve_versions_from_cache!(cache_name); end

  # source://carrierwave//lib/carrierwave/uploader/versions.rb#346
  def retrieve_versions_from_store!(identifier); end

  # source://carrierwave//lib/carrierwave/uploader/versions.rb#334
  def store_versions!(new_file); end

  module GeneratedClassMethods
    def _after_callbacks; end
    def _after_callbacks=(value); end
    def _after_callbacks?; end
    def _before_callbacks; end
    def _before_callbacks=(value); end
    def _before_callbacks?; end
    def version_names; end
    def version_names=(value); end
    def version_names?; end
    def version_options; end
    def version_options=(value); end
    def version_options?; end
    def versions; end
    def versions=(value); end
    def versions?; end
  end

  module GeneratedInstanceMethods
    def _after_callbacks; end
    def _after_callbacks?; end
    def _before_callbacks; end
    def _before_callbacks?; end
  end
end

# source://carrierwave//lib/carrierwave/uploader/versions.rb#6
class CarrierWave::Uploader::Versions::Builder
  # @return [Builder] a new instance of Builder
  #
  # source://carrierwave//lib/carrierwave/uploader/versions.rb#7
  def initialize(name); end

  # source://carrierwave//lib/carrierwave/uploader/versions.rb#20
  def build(superclass); end

  # source://carrierwave//lib/carrierwave/uploader/versions.rb#14
  def configure(options, &block); end

  # source://carrierwave//lib/carrierwave/uploader/versions.rb#67
  def deep_dup; end

  # source://carrierwave//lib/carrierwave/uploader/versions.rb#73
  def method_missing(name, *args); end

  private

  # @return [Boolean]
  #
  # source://carrierwave//lib/carrierwave/uploader/versions.rb#82
  def respond_to_missing?(*_arg0); end
end

# source://carrierwave//lib/carrierwave/uploader/versions.rb#113
module CarrierWave::Uploader::Versions::ClassMethods
  # Adds a new version to this uploader
  #
  # === Parameters
  #
  # [name (#to_sym)] name of the version
  # [options (Hash)] optional options hash
  # [&block (Proc)] a block to eval on this version of the uploader
  #
  # === Examples
  #
  #     class MyUploader < CarrierWave::Uploader::Base
  #
  #       version :thumb do
  #         process :scale => [200, 200]
  #       end
  #
  #       version :preview, :if => :image? do
  #         process :scale => [200, 200]
  #       end
  #
  #       version :square, :unless => :invalid_image_type? do
  #         process :scale => [100, 100]
  #       end
  #
  #     end
  #
  # source://carrierwave//lib/carrierwave/uploader/versions.rb#142
  def version(name, options = T.unsafe(nil), &block); end

  private

  # source://carrierwave//lib/carrierwave/uploader/versions.rb#158
  def inherited(subclass); end
end

# source://carrierwave//lib/carrierwave/utilities/uri.rb#4
module CarrierWave::Utilities; end

# source://carrierwave//lib/carrierwave/utilities/file_name.rb#3
module CarrierWave::Utilities::FileName
  # Returns the part of the filename before the extension. So if a file is called 'test.jpeg'
  # this would return 'test'
  #
  # === Returns
  #
  # [String] the first part of the filename
  #
  # source://carrierwave//lib/carrierwave/utilities/file_name.rb#13
  def basename; end

  # Returns the file extension
  #
  # === Returns
  #
  # [String] extension of file or "" if the file has no extension
  #
  # source://carrierwave//lib/carrierwave/utilities/file_name.rb#24
  def extension; end

  private

  # source://carrierwave//lib/carrierwave/utilities/file_name.rb#30
  def split_extension(filename); end
end

# source://carrierwave//lib/carrierwave/utilities/uri.rb#5
module CarrierWave::Utilities::Uri
  private

  # source://carrierwave//lib/carrierwave/utilities/uri.rb#21
  def decode_uri(str); end

  # source://carrierwave//lib/carrierwave/utilities/uri.rb#17
  def encode_non_ascii(str); end

  # source://carrierwave//lib/carrierwave/utilities/uri.rb#13
  def encode_path(path); end
end

# source://carrierwave//lib/carrierwave/utilities/uri.rb#9
CarrierWave::Utilities::Uri::NON_ASCII = T.let(T.unsafe(nil), Regexp)

# based on Ruby < 2.0's URI.encode
#
# source://carrierwave//lib/carrierwave/utilities/uri.rb#7
CarrierWave::Utilities::Uri::PATH_SAFE = T.let(T.unsafe(nil), String)

# source://carrierwave//lib/carrierwave/utilities/uri.rb#8
CarrierWave::Utilities::Uri::PATH_UNSAFE = T.let(T.unsafe(nil), Regexp)

# source://carrierwave//lib/carrierwave/version.rb#2
CarrierWave::VERSION = T.let(T.unsafe(nil), String)

# This module simplifies manipulation with vips by providing a set
# of convenient helper methods. If you want to use them, you'll need to
# require this file:
#
#     require 'carrierwave/processing/vips'
#
# And then include it in your uploader:
#
#     class MyUploader < CarrierWave::Uploader::Base
#       include CarrierWave::Vips
#     end
#
# You can now use the provided helpers:
#
#     class MyUploader < CarrierWave::Uploader::Base
#       include CarrierWave::Vips
#
#       process :resize_to_fit => [200, 200]
#     end
#
# Or create your own helpers with the powerful vips! method, which
# yields an ImageProcessing::Builder object. Check out the ImageProcessing
# docs at http://github.com/janko-m/image_processing and the list of all
# available Vips options at
# https://libvips.github.io/libvips/API/current/using-cli.html for more info.
#
#     class MyUploader < CarrierWave::Uploader::Base
#       include CarrierWave::Vips
#
#       process :radial_blur => 10
#
#       def radial_blur(amount)
#         vips! do |builder|
#           builder.radial_blur(amount)
#           builder = yield(builder) if block_given?
#           builder
#         end
#       end
#     end
#
# === Note
#
# The ImageProcessing gem uses ruby-vips, a binding for the vips image
# library. You can find more information here:
#
# https://github.com/libvips/ruby-vips
#
# source://carrierwave//lib/carrierwave/processing/vips.rb#52
module CarrierWave::Vips
  extend ::ActiveSupport::Concern

  # Changes the image encoding format to the given format
  #
  # See https://libvips.github.io/libvips/API/current/using-cli.html#using-command-line-conversion
  #
  # === Parameters
  #
  # [format (#to_s)] an abbreviation of the format
  #
  # === Yields
  #
  # [Vips::Image] additional manipulations to perform
  #
  # === Examples
  #
  #     image.convert(:png)
  #
  # source://carrierwave//lib/carrierwave/processing/vips.rb#104
  def convert(format, page = T.unsafe(nil)); end

  # Crop the image to the contents of a box positioned at [left] and [top], with the dimensions given
  # by [width] and [height]. The original image bottom/right edge is preserved if the cropping box falls
  # outside the image bounds.
  #
  # === Parameters
  #
  # [left (integer)] left edge of area to extract
  # [top (integer)] top edge of area to extract
  # [width (Integer)] width of area to extract
  # [height (Integer)] height of area to extract
  #
  # === Yields
  #
  # [Vips::Image] additional manipulations to perform
  #
  # source://carrierwave//lib/carrierwave/processing/vips.rb#231
  def crop(left, top, width, height, combine_options: T.unsafe(nil)); end

  # Returns the height of the image in pixels.
  #
  # === Returns
  #
  # [Integer] the image's height in pixels
  #
  # source://carrierwave//lib/carrierwave/processing/vips.rb#260
  def height; end

  # Resize the image to fit within the specified dimensions while retaining
  # the original aspect ratio. If necessary, will pad the remaining area
  # with the given color, which defaults to transparent (for gif and png,
  # white for jpeg).
  #
  # See https://libvips.github.io/libvips/API/current/libvips-conversion.html#VipsCompassDirection
  # for gravity options.
  #
  # === Parameters
  #
  # [width (Integer)] the width to scale the image to
  # [height (Integer)] the height to scale the image to
  # [background (List, nil)] the color of the background as a RGB, like [0, 255, 255], nil indicates transparent
  # [gravity (String)] how to position the image
  # [alpha (Boolean, nil)] pad the image with the alpha channel if supported
  # [combine_options (Hash)] additional vips options to apply before resizing
  #
  # === Yields
  #
  # [Vips::Image] additional manipulations to perform
  #
  # source://carrierwave//lib/carrierwave/processing/vips.rb#206
  def resize_and_pad(width, height, background = T.unsafe(nil), gravity = T.unsafe(nil), alpha = T.unsafe(nil), combine_options: T.unsafe(nil)); end

  # Resize the image to fit within the specified dimensions while retaining
  # the aspect ratio of the original image. If necessary, crop the image in the
  # larger dimension.
  #
  # === Parameters
  #
  # [width (Integer)] the width to scale the image to
  # [height (Integer)] the height to scale the image to
  # [combine_options (Hash)] additional vips options to apply before resizing
  #
  # === Yields
  #
  # [Vips::Image] additional manipulations to perform
  #
  # source://carrierwave//lib/carrierwave/processing/vips.rb#176
  def resize_to_fill(width, height, _gravity = T.unsafe(nil), combine_options: T.unsafe(nil)); end

  # Resize the image to fit within the specified dimensions while retaining
  # the original aspect ratio. The image may be shorter or narrower than
  # specified in the smaller dimension but will not be larger than the specified values.
  #
  # === Parameters
  #
  # [width (Integer)] the width to scale the image to
  # [height (Integer)] the height to scale the image to
  # [combine_options (Hash)] additional Vips options to apply before resizing
  #
  # === Yields
  #
  # [Vips::Image] additional manipulations to perform
  #
  # source://carrierwave//lib/carrierwave/processing/vips.rb#152
  def resize_to_fit(width, height, combine_options: T.unsafe(nil)); end

  # Resize the image to fit within the specified dimensions while retaining
  # the original aspect ratio. Will only resize the image if it is larger than the
  # specified dimensions. The resulting image may be shorter or narrower than specified
  # in the smaller dimension but will not be larger than the specified values.
  #
  # === Parameters
  #
  # [width (Integer)] the width to scale the image to
  # [height (Integer)] the height to scale the image to
  # [combine_options (Hash)] additional Vips options to apply before resizing
  #
  # === Yields
  #
  # [Vips::Image] additional manipulations to perform
  #
  # source://carrierwave//lib/carrierwave/processing/vips.rb#128
  def resize_to_limit(width, height, combine_options: T.unsafe(nil)); end

  # Process the image with vip, using the ImageProcessing gem. This
  # method will build a "convert" vips command and execute it on the
  # current image.
  #
  # === Gotcha
  #
  # This method assumes that the object responds to +current_path+.
  # Any class that this module is mixed into must have a +current_path+ method.
  # CarrierWave::Uploader does, so you won't need to worry about this in
  # most cases.
  #
  # === Yields
  #
  # [ImageProcessing::Builder] use it to define processing to be performed
  #
  # === Raises
  #
  # [CarrierWave::ProcessingError] if processing failed.
  #
  # source://carrierwave//lib/carrierwave/processing/vips.rb#282
  def vips!; end

  # Returns the width of the image in pixels.
  #
  # === Returns
  #
  # [Integer] the image's width in pixels
  #
  # source://carrierwave//lib/carrierwave/processing/vips.rb#249
  def width; end

  private

  # source://carrierwave//lib/carrierwave/processing/vips.rb#303
  def resolve_dimensions(*dimensions); end

  # source://carrierwave//lib/carrierwave/processing/vips.rb#310
  def vips_image; end
end

# source://carrierwave//lib/carrierwave/processing/vips.rb#61
module CarrierWave::Vips::ClassMethods
  # source://carrierwave//lib/carrierwave/processing/vips.rb#62
  def convert(format); end

  # source://carrierwave//lib/carrierwave/processing/vips.rb#82
  def crop(left, top, width, height); end

  # source://carrierwave//lib/carrierwave/processing/vips.rb#78
  def resize_and_pad(width, height, background = T.unsafe(nil), gravity = T.unsafe(nil), alpha = T.unsafe(nil)); end

  # source://carrierwave//lib/carrierwave/processing/vips.rb#74
  def resize_to_fill(width, height, gravity = T.unsafe(nil)); end

  # source://carrierwave//lib/carrierwave/processing/vips.rb#70
  def resize_to_fit(width, height); end

  # source://carrierwave//lib/carrierwave/processing/vips.rb#66
  def resize_to_limit(width, height); end
end
