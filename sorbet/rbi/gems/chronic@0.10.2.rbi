# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `chronic` gem.
# Please instead update this file by running `bin/tapioca gem chronic`.


# Parse natural language dates and times into Time or Chronic::Span objects.
#
# Examples:
#
#   require 'chronic'
#
#   Time.now   #=> Sun Aug 27 23:18:25 PDT 2006
#
#   Chronic.parse('tomorrow')
#     #=> Mon Aug 28 12:00:00 PDT 2006
#
#   Chronic.parse('monday', :context => :past)
#     #=> Mon Aug 21 12:00:00 PDT 2006
#
# source://chronic//lib/chronic/handlers.rb#1
module Chronic
  class << self
    # Construct a new time object determining possible month overflows
    # and leap years.
    #
    # year   - Integer year.
    # month  - Integer month.
    # day    - Integer day.
    # hour   - Integer hour.
    # minute - Integer minute.
    # second - Integer second.
    #
    # Returns a new Time object constructed from these params.
    #
    # source://chronic//lib/chronic.rb#104
    def construct(year, month = T.unsafe(nil), day = T.unsafe(nil), hour = T.unsafe(nil), minute = T.unsafe(nil), second = T.unsafe(nil), offset = T.unsafe(nil)); end

    # Returns true when debug mode is enabled.
    #
    # source://chronic//lib/chronic.rb#61
    def debug; end

    # Returns true when debug mode is enabled.
    #
    # source://chronic//lib/chronic.rb#61
    def debug=(_arg0); end

    # Parses a string containing a natural language date or time.
    #
    # If the parser can find a date or time, either a Time or Chronic::Span
    # will be returned (depending on the value of `:guess`). If no
    # date or time can be found, `nil` will be returned.
    #
    # text - The String text to parse.
    # opts - An optional Hash of configuration options passed to Parser::new.
    #
    # source://chronic//lib/chronic.rb#89
    def parse(text, options = T.unsafe(nil)); end

    # Examples:
    #
    #   require 'chronic'
    #   require 'active_support/time'
    #
    #   Time.zone = 'UTC'
    #   Chronic.time_class = Time.zone
    #   Chronic.parse('June 15 2006 at 5:54 AM')
    #     # => Thu, 15 Jun 2006 05:45:00 UTC +00:00
    #
    # Returns The Time class Chronic uses internally.
    #
    # source://chronic//lib/chronic.rb#74
    def time_class; end

    # Examples:
    #
    #   require 'chronic'
    #   require 'active_support/time'
    #
    #   Time.zone = 'UTC'
    #   Chronic.time_class = Time.zone
    #   Chronic.parse('June 15 2006 at 5:54 AM')
    #     # => Thu, 15 Jun 2006 05:45:00 UTC +00:00
    #
    # Returns The Time class Chronic uses internally.
    #
    # source://chronic//lib/chronic.rb#74
    def time_class=(_arg0); end
  end
end

# source://chronic//lib/chronic/date.rb#2
class Chronic::Date
  class << self
    # Checks if given number could be day
    #
    # @return [Boolean]
    #
    # source://chronic//lib/chronic/date.rb#38
    def could_be_day?(day); end

    # Checks if given number could be month
    #
    # @return [Boolean]
    #
    # source://chronic//lib/chronic/date.rb#43
    def could_be_month?(month); end

    # Checks if given number could be year
    #
    # @return [Boolean]
    #
    # source://chronic//lib/chronic/date.rb#48
    def could_be_year?(year); end

    # Build a year from a 2 digit suffix.
    #
    # year - The two digit Integer year to build from.
    # bias - The Integer amount of future years to bias.
    #
    # Examples:
    #
    #   make_year(96, 50) #=> 1996
    #   make_year(79, 20) #=> 2079
    #   make_year(00, 50) #=> 2000
    #
    # Returns The Integer 4 digit year.
    #
    # source://chronic//lib/chronic/date.rb#64
    def make_year(year, bias); end

    # @return [Boolean]
    #
    # source://chronic//lib/chronic/date.rb#73
    def month_overflow?(year, month, day); end
  end
end

# source://chronic//lib/chronic/date.rb#27
Chronic::Date::DAYS = T.let(T.unsafe(nil), Hash)

# 24 * 60 * 60
#
# source://chronic//lib/chronic/date.rb#12
Chronic::Date::DAY_SECONDS = T.let(T.unsafe(nil), Integer)

# 14 * 24 * 60 * 60
#
# source://chronic//lib/chronic/date.rb#9
Chronic::Date::FORTNIGHT_SECONDS = T.let(T.unsafe(nil), Integer)

# source://chronic//lib/chronic/date.rb#13
Chronic::Date::MONTHS = T.let(T.unsafe(nil), Hash)

# source://chronic//lib/chronic/date.rb#4
Chronic::Date::MONTH_DAYS = T.let(T.unsafe(nil), Array)

# source://chronic//lib/chronic/date.rb#5
Chronic::Date::MONTH_DAYS_LEAP = T.let(T.unsafe(nil), Array)

# 30 * 24 * 60 * 60
#
# source://chronic//lib/chronic/date.rb#8
Chronic::Date::MONTH_SECONDS = T.let(T.unsafe(nil), Integer)

# 91 * 24 * 60 * 60
#
# source://chronic//lib/chronic/date.rb#7
Chronic::Date::SEASON_SECONDS = T.let(T.unsafe(nil), Integer)

# 2 * 24 * 60 * 60
#
# source://chronic//lib/chronic/date.rb#11
Chronic::Date::WEEKEND_SECONDS = T.let(T.unsafe(nil), Integer)

# 7 * 24 * 60 * 60
#
# source://chronic//lib/chronic/date.rb#10
Chronic::Date::WEEK_SECONDS = T.let(T.unsafe(nil), Integer)

# source://chronic//lib/chronic/date.rb#3
Chronic::Date::YEAR_MONTHS = T.let(T.unsafe(nil), Integer)

# 365 * 24 * 60 * 60
#
# source://chronic//lib/chronic/date.rb#6
Chronic::Date::YEAR_SECONDS = T.let(T.unsafe(nil), Integer)

# source://chronic//lib/chronic/grabber.rb#2
class Chronic::Grabber < ::Chronic::Tag
  # source://chronic//lib/chronic/grabber.rb#29
  def to_s; end

  class << self
    # Scan an Array of Tokens and apply any necessary Grabber tags to
    # each token.
    #
    # tokens  - An Array of Token objects to scan.
    # options - The Hash of options specified in Chronic::parse.
    #
    # Returns an Array of Token objects.
    #
    # source://chronic//lib/chronic/grabber.rb#11
    def scan(tokens, options); end

    # token - The Token object to scan.
    #
    # Returns a new Grabber object.
    #
    # source://chronic//lib/chronic/grabber.rb#20
    def scan_for_all(token); end
  end
end

# source://chronic//lib/chronic/handler.rb#2
class Chronic::Handler
  # pattern        - An Array of patterns to match tokens against.
  # handler_method - A Symbol representing the method to be invoked
  #   when a pattern matches.
  #
  # @return [Handler] a new instance of Handler
  #
  # source://chronic//lib/chronic/handler.rb#11
  def initialize(pattern, handler_method); end

  # other - The other Handler object to compare.
  #
  # Returns true if these Handlers match.
  #
  # source://chronic//lib/chronic/handler.rb#82
  def ==(other); end

  # Returns the value of attribute handler_method.
  #
  # source://chronic//lib/chronic/handler.rb#6
  def handler_method; end

  # source://chronic//lib/chronic/handler.rb#70
  def invoke(type, tokens, parser, options); end

  # tokens - An Array of tokens to process.
  # definitions - A Hash of definitions to check against.
  #
  # Returns true if a match is found.
  #
  # source://chronic//lib/chronic/handler.rb#20
  def match(tokens, definitions); end

  # Returns the value of attribute pattern.
  #
  # source://chronic//lib/chronic/handler.rb#4
  def pattern; end

  private

  # @return [Boolean]
  #
  # source://chronic//lib/chronic/handler.rb#88
  def tags_match?(name, tokens, token_index); end
end

# source://chronic//lib/chronic/handlers.rb#2
module Chronic::Handlers
  private

  # support methods
  #
  # source://chronic//lib/chronic/handlers.rb#495
  def day_or_time(day_start, time_tokens, options); end

  # source://chronic//lib/chronic/handlers.rb#586
  def dealias_and_disambiguate_times(tokens, options); end

  # Recursively finds repeaters within other repeaters.
  # Returns a Span representing the innermost time span
  # or nil if no repeater union could be found
  #
  # source://chronic//lib/chronic/handlers.rb#559
  def find_within(tags, span, pointer); end

  # source://chronic//lib/chronic/handlers.rb#506
  def get_anchor(tokens, options); end

  # source://chronic//lib/chronic/handlers.rb#542
  def get_repeaters(tokens); end

  # Handle generic timestamp (ruby 1.8)
  #
  # source://chronic//lib/chronic/handlers.rb#134
  def handle_generic(tokens, options); end

  # Handle month/day
  #
  # source://chronic//lib/chronic/handlers.rb#6
  def handle_m_d(month, day, time_tokens, options); end

  # Handle ordinal/repeater/grabber/repeater
  #
  # source://chronic//lib/chronic/handlers.rb#488
  def handle_o_r_g_r(tokens, options); end

  # Handle ordinal/repeater/separator/repeater
  #
  # source://chronic//lib/chronic/handlers.rb#482
  def handle_o_r_s_r(tokens, options); end

  # Handle ordinal this month
  #
  # source://chronic//lib/chronic/handlers.rb#53
  def handle_od_rm(tokens, options); end

  # Handle ordinal-day/repeater-month-name
  #
  # source://chronic//lib/chronic/handlers.rb#60
  def handle_od_rmn(tokens, options); end

  # Handle oridinal-day/repeater-month-name/scalar-year
  #
  # source://chronic//lib/chronic/handlers.rb#176
  def handle_od_rmn_sy(tokens, options); end

  # Handle oridinal repeaters
  #
  # source://chronic//lib/chronic/handlers.rb#463
  def handle_orr(tokens, outer_span, options); end

  # Handle pointer/scalar/repeater
  #
  # source://chronic//lib/chronic/handlers.rb#442
  def handle_p_s_r(tokens, options); end

  # Handle repeaters
  #
  # source://chronic//lib/chronic/handlers.rb#412
  def handle_r(tokens, options); end

  # Handle repeater/grabber/repeater
  #
  # source://chronic//lib/chronic/handlers.rb#418
  def handle_r_g_r(tokens, options); end

  # Handle RepeaterDayName OrdinalDay
  #
  # source://chronic//lib/chronic/handlers.rb#327
  def handle_rdn_od(tokens, options); end

  # Handle RepeaterDayName RepeaterMonthName OrdinalDay
  #
  # source://chronic//lib/chronic/handlers.rb#287
  def handle_rdn_rmn_od(tokens, options); end

  # Handle RepeaterDayName RepeaterMonthName OrdinalDay ScalarYear
  #
  # source://chronic//lib/chronic/handlers.rb#310
  def handle_rdn_rmn_od_sy(tokens, options); end

  # Handle RepeaterDayName RepeaterMonthName ScalarDay
  #
  # source://chronic//lib/chronic/handlers.rb#353
  def handle_rdn_rmn_sd(tokens, options); end

  # Handle RepeaterDayName RepeaterMonthName ScalarDay ScalarYear
  #
  # source://chronic//lib/chronic/handlers.rb#376
  def handle_rdn_rmn_sd_sy(tokens, options); end

  # Handle repeater-month-name/ordinal-day
  #
  # source://chronic//lib/chronic/handlers.rb#43
  def handle_rmn_od(tokens, options); end

  # Handle repeater-month-name/ordinal-day with separator-on
  #
  # source://chronic//lib/chronic/handlers.rb#96
  def handle_rmn_od_on(tokens, options); end

  # Handle repeater-month-name/ordinal-day/scalar-year
  #
  # source://chronic//lib/chronic/handlers.rb#159
  def handle_rmn_od_sy(tokens, options); end

  # Handle repeater-month-name/scalar-day
  #
  # source://chronic//lib/chronic/handlers.rb#16
  def handle_rmn_sd(tokens, options); end

  # Handle repeater-month-name/scalar-day with separator-on
  #
  # source://chronic//lib/chronic/handlers.rb#26
  def handle_rmn_sd_on(tokens, options); end

  # Handle repeater-month-name/scalar-day/scalar-year
  #
  # source://chronic//lib/chronic/handlers.rb#142
  def handle_rmn_sd_sy(tokens, options); end

  # Handle repeater-month-name/scalar-year
  #
  # source://chronic//lib/chronic/handlers.rb#113
  def handle_rmn_sy(tokens, options); end

  # source://chronic//lib/chronic/handlers.rb#453
  def handle_s_r_a_s_r_p_a(tokens, options); end

  # Handle scalar/repeater/pointer
  #
  # source://chronic//lib/chronic/handlers.rb#435
  def handle_s_r_p(tokens, options); end

  # Handle scalar/repeater/pointer/anchor
  #
  # source://chronic//lib/chronic/handlers.rb#448
  def handle_s_r_p_a(tokens, options); end

  # Handle scalar-day/repeater-month-name
  #
  # source://chronic//lib/chronic/handlers.rb#86
  def handle_sd_rmn(tokens, options); end

  # Handle scalar-day/repeater-month-name/scalar-year
  #
  # source://chronic//lib/chronic/handlers.rb#193
  def handle_sd_rmn_sy(tokens, options); end

  # Handle scalar-day/scalar-month
  #
  # source://chronic//lib/chronic/handlers.rb#249
  def handle_sd_sm(tokens, options); end

  # Handle scalar-day/scalar-month/scalar-year (endian little)
  #
  # source://chronic//lib/chronic/handlers.rb#217
  def handle_sd_sm_sy(tokens, options); end

  # source://chronic//lib/chronic/handlers.rb#392
  def handle_sm_rmn_sy(tokens, options); end

  # Handle scalar-month/scalar-day
  #
  # source://chronic//lib/chronic/handlers.rb#231
  def handle_sm_sd(tokens, options); end

  # Handle scalar-month/scalar-day/scalar-year (endian middle)
  #
  # source://chronic//lib/chronic/handlers.rb#200
  def handle_sm_sd_sy(tokens, options); end

  # Handle scalar-month/scalar-year
  #
  # source://chronic//lib/chronic/handlers.rb#273
  def handle_sm_sy(tokens, options); end

  # Handle scalar/repeater/pointer helper
  #
  # source://chronic//lib/chronic/handlers.rb#426
  def handle_srp(tokens, span, options); end

  # source://chronic//lib/chronic/handlers.rb#69
  def handle_sy_rmn_od(tokens, options); end

  # Handle scalar-year/scalar-month
  #
  # source://chronic//lib/chronic/handlers.rb#280
  def handle_sy_sm(tokens, options); end

  # Handle scalar-year/scalar-month/scalar-day
  #
  # source://chronic//lib/chronic/handlers.rb#224
  def handle_sy_sm_sd(tokens, options); end

  # source://chronic//lib/chronic/handlers.rb#255
  def handle_year_and_month(year, month); end

  # source://chronic//lib/chronic/handlers.rb#546
  def month_overflow?(year, month, day); end

  # source://chronic//lib/chronic/handlers.rb#572
  def time_with_rollover(year, month, day); end

  class << self
    # support methods
    #
    # source://chronic//lib/chronic/handlers.rb#495
    def day_or_time(day_start, time_tokens, options); end

    # source://chronic//lib/chronic/handlers.rb#586
    def dealias_and_disambiguate_times(tokens, options); end

    # Recursively finds repeaters within other repeaters.
    # Returns a Span representing the innermost time span
    # or nil if no repeater union could be found
    #
    # source://chronic//lib/chronic/handlers.rb#559
    def find_within(tags, span, pointer); end

    # source://chronic//lib/chronic/handlers.rb#506
    def get_anchor(tokens, options); end

    # source://chronic//lib/chronic/handlers.rb#542
    def get_repeaters(tokens); end

    # Handle generic timestamp (ruby 1.8)
    #
    # source://chronic//lib/chronic/handlers.rb#134
    def handle_generic(tokens, options); end

    # Handle month/day
    #
    # source://chronic//lib/chronic/handlers.rb#6
    def handle_m_d(month, day, time_tokens, options); end

    # Handle ordinal/repeater/grabber/repeater
    #
    # source://chronic//lib/chronic/handlers.rb#488
    def handle_o_r_g_r(tokens, options); end

    # Handle ordinal/repeater/separator/repeater
    #
    # source://chronic//lib/chronic/handlers.rb#482
    def handle_o_r_s_r(tokens, options); end

    # Handle ordinal this month
    #
    # source://chronic//lib/chronic/handlers.rb#53
    def handle_od_rm(tokens, options); end

    # Handle ordinal-day/repeater-month-name
    #
    # source://chronic//lib/chronic/handlers.rb#60
    def handle_od_rmn(tokens, options); end

    # Handle oridinal-day/repeater-month-name/scalar-year
    #
    # source://chronic//lib/chronic/handlers.rb#176
    def handle_od_rmn_sy(tokens, options); end

    # Handle oridinal repeaters
    #
    # source://chronic//lib/chronic/handlers.rb#463
    def handle_orr(tokens, outer_span, options); end

    # Handle pointer/scalar/repeater
    #
    # source://chronic//lib/chronic/handlers.rb#442
    def handle_p_s_r(tokens, options); end

    # Handle repeaters
    #
    # source://chronic//lib/chronic/handlers.rb#412
    def handle_r(tokens, options); end

    # Handle repeater/grabber/repeater
    #
    # source://chronic//lib/chronic/handlers.rb#418
    def handle_r_g_r(tokens, options); end

    # Handle RepeaterDayName OrdinalDay
    #
    # source://chronic//lib/chronic/handlers.rb#327
    def handle_rdn_od(tokens, options); end

    # Handle RepeaterDayName RepeaterMonthName OrdinalDay
    #
    # source://chronic//lib/chronic/handlers.rb#287
    def handle_rdn_rmn_od(tokens, options); end

    # Handle RepeaterDayName RepeaterMonthName OrdinalDay ScalarYear
    #
    # source://chronic//lib/chronic/handlers.rb#310
    def handle_rdn_rmn_od_sy(tokens, options); end

    # Handle RepeaterDayName RepeaterMonthName ScalarDay
    #
    # source://chronic//lib/chronic/handlers.rb#353
    def handle_rdn_rmn_sd(tokens, options); end

    # Handle RepeaterDayName RepeaterMonthName ScalarDay ScalarYear
    #
    # source://chronic//lib/chronic/handlers.rb#376
    def handle_rdn_rmn_sd_sy(tokens, options); end

    # Handle repeater-month-name/ordinal-day
    #
    # source://chronic//lib/chronic/handlers.rb#43
    def handle_rmn_od(tokens, options); end

    # Handle repeater-month-name/ordinal-day with separator-on
    #
    # source://chronic//lib/chronic/handlers.rb#96
    def handle_rmn_od_on(tokens, options); end

    # Handle repeater-month-name/ordinal-day/scalar-year
    #
    # source://chronic//lib/chronic/handlers.rb#159
    def handle_rmn_od_sy(tokens, options); end

    # Handle repeater-month-name/scalar-day
    #
    # source://chronic//lib/chronic/handlers.rb#16
    def handle_rmn_sd(tokens, options); end

    # Handle repeater-month-name/scalar-day with separator-on
    #
    # source://chronic//lib/chronic/handlers.rb#26
    def handle_rmn_sd_on(tokens, options); end

    # Handle repeater-month-name/scalar-day/scalar-year
    #
    # source://chronic//lib/chronic/handlers.rb#142
    def handle_rmn_sd_sy(tokens, options); end

    # Handle repeater-month-name/scalar-year
    #
    # source://chronic//lib/chronic/handlers.rb#113
    def handle_rmn_sy(tokens, options); end

    # source://chronic//lib/chronic/handlers.rb#453
    def handle_s_r_a_s_r_p_a(tokens, options); end

    # Handle scalar/repeater/pointer
    #
    # source://chronic//lib/chronic/handlers.rb#435
    def handle_s_r_p(tokens, options); end

    # Handle scalar/repeater/pointer/anchor
    #
    # source://chronic//lib/chronic/handlers.rb#448
    def handle_s_r_p_a(tokens, options); end

    # Handle scalar-day/repeater-month-name
    #
    # source://chronic//lib/chronic/handlers.rb#86
    def handle_sd_rmn(tokens, options); end

    # Handle scalar-day/repeater-month-name/scalar-year
    #
    # source://chronic//lib/chronic/handlers.rb#193
    def handle_sd_rmn_sy(tokens, options); end

    # Handle scalar-day/scalar-month
    #
    # source://chronic//lib/chronic/handlers.rb#249
    def handle_sd_sm(tokens, options); end

    # Handle scalar-day/scalar-month/scalar-year (endian little)
    #
    # source://chronic//lib/chronic/handlers.rb#217
    def handle_sd_sm_sy(tokens, options); end

    # source://chronic//lib/chronic/handlers.rb#392
    def handle_sm_rmn_sy(tokens, options); end

    # Handle scalar-month/scalar-day
    #
    # source://chronic//lib/chronic/handlers.rb#231
    def handle_sm_sd(tokens, options); end

    # Handle scalar-month/scalar-day/scalar-year (endian middle)
    #
    # source://chronic//lib/chronic/handlers.rb#200
    def handle_sm_sd_sy(tokens, options); end

    # Handle scalar-month/scalar-year
    #
    # source://chronic//lib/chronic/handlers.rb#273
    def handle_sm_sy(tokens, options); end

    # Handle scalar/repeater/pointer helper
    #
    # source://chronic//lib/chronic/handlers.rb#426
    def handle_srp(tokens, span, options); end

    # source://chronic//lib/chronic/handlers.rb#69
    def handle_sy_rmn_od(tokens, options); end

    # Handle scalar-year/scalar-month
    #
    # source://chronic//lib/chronic/handlers.rb#280
    def handle_sy_sm(tokens, options); end

    # Handle scalar-year/scalar-month/scalar-day
    #
    # source://chronic//lib/chronic/handlers.rb#224
    def handle_sy_sm_sd(tokens, options); end

    # source://chronic//lib/chronic/handlers.rb#255
    def handle_year_and_month(year, month); end

    # @return [Boolean]
    #
    # source://chronic//lib/chronic/handlers.rb#546
    def month_overflow?(year, month, day); end

    # source://chronic//lib/chronic/handlers.rb#572
    def time_with_rollover(year, month, day); end
  end
end

# source://chronic//lib/chronic/mini_date.rb#2
class Chronic::MiniDate
  # @return [MiniDate] a new instance of MiniDate
  #
  # source://chronic//lib/chronic/mini_date.rb#9
  def initialize(month, day); end

  # Returns the value of attribute day.
  #
  # source://chronic//lib/chronic/mini_date.rb#3
  def day; end

  # Sets the attribute day
  #
  # @param value the value to set the attribute day to.
  #
  # source://chronic//lib/chronic/mini_date.rb#3
  def day=(_arg0); end

  # @return [Boolean]
  #
  # source://chronic//lib/chronic/mini_date.rb#34
  def equals?(other); end

  # @return [Boolean]
  #
  # source://chronic//lib/chronic/mini_date.rb#18
  def is_between?(md_start, md_end); end

  # Returns the value of attribute month.
  #
  # source://chronic//lib/chronic/mini_date.rb#3
  def month; end

  # Sets the attribute month
  #
  # @param value the value to set the attribute month to.
  #
  # source://chronic//lib/chronic/mini_date.rb#3
  def month=(_arg0); end

  class << self
    # source://chronic//lib/chronic/mini_date.rb#5
    def from_time(time); end
  end
end

# source://chronic//lib/chronic/numerizer.rb#4
class Chronic::Numerizer
  class << self
    # source://chronic//lib/chronic/numerizer.rb#72
    def numerize(string); end

    private

    # source://chronic//lib/chronic/numerizer.rb#117
    def andition(string); end
  end
end

# source://chronic//lib/chronic/numerizer.rb#64
Chronic::Numerizer::BIG_PREFIXES = T.let(T.unsafe(nil), Array)

# source://chronic//lib/chronic/numerizer.rb#6
Chronic::Numerizer::DIRECT_NUMS = T.let(T.unsafe(nil), Array)

# source://chronic//lib/chronic/numerizer.rb#31
Chronic::Numerizer::ORDINALS = T.let(T.unsafe(nil), Array)

# source://chronic//lib/chronic/numerizer.rb#52
Chronic::Numerizer::TEN_PREFIXES = T.let(T.unsafe(nil), Array)

# source://chronic//lib/chronic/ordinal.rb#2
class Chronic::Ordinal < ::Chronic::Tag
  # source://chronic//lib/chronic/ordinal.rb#26
  def to_s; end

  class << self
    # Scan an Array of Token objects and apply any necessary Ordinal
    # tags to each token.
    #
    # tokens - An Array of tokens to scan.
    # options - The Hash of options specified in Chronic::parse.
    #
    # Returns an Array of tokens.
    #
    # source://chronic//lib/chronic/ordinal.rb#11
    def scan(tokens, options); end
  end
end

# source://chronic//lib/chronic/ordinal.rb#31
class Chronic::OrdinalDay < ::Chronic::Ordinal
  # source://chronic//lib/chronic/ordinal.rb#32
  def to_s; end
end

# source://chronic//lib/chronic/ordinal.rb#37
class Chronic::OrdinalMonth < ::Chronic::Ordinal
  # source://chronic//lib/chronic/ordinal.rb#38
  def to_s; end
end

# source://chronic//lib/chronic/ordinal.rb#43
class Chronic::OrdinalYear < ::Chronic::Ordinal
  # source://chronic//lib/chronic/ordinal.rb#44
  def to_s; end
end

# source://chronic//lib/chronic/parser.rb#4
class Chronic::Parser
  include ::Chronic::Handlers

  # options - An optional Hash of configuration options:
  #        :context - If your string represents a birthday, you can set
  #                   this value to :past and if an ambiguous string is
  #                   given, it will assume it is in the past.
  #        :now - Time, all computations will be based off of time
  #               instead of Time.now.
  #        :hours24 - Time will be parsed as it would be 24 hour clock.
  #        :guess - By default the parser will guess a single point in time
  #                 for the given date or time. If you'd rather have the
  #                 entire time span returned, set this to false
  #                 and a Chronic::Span will be returned. Setting :guess to :end
  #                 will return last time from Span, to :middle for middle (same as just true)
  #                 and :begin for first time from span.
  #        :ambiguous_time_range - If an Integer is given, ambiguous times
  #                  (like 5:00) will be assumed to be within the range of
  #                  that time in the AM to that time in the PM. For
  #                  example, if you set it to `7`, then the parser will
  #                  look for the time between 7am and 7pm. In the case of
  #                  5:00, it would assume that means 5:00pm. If `:none`
  #                  is given, no assumption will be made, and the first
  #                  matching instance of that time will be used.
  #        :endian_precedence - By default, Chronic will parse "03/04/2011"
  #                 as the fourth day of the third month. Alternatively you
  #                 can tell Chronic to parse this as the third day of the
  #                 fourth month by setting this to [:little, :middle].
  #        :ambiguous_year_future_bias - When parsing two digit years
  #                 (ie 79) unlike Rubys Time class, Chronic will attempt
  #                 to assume the full year using this figure. Chronic will
  #                 look x amount of years into the future and past. If the
  #                 two digit year is `now + x years` it's assumed to be the
  #                 future, `now - x years` is assumed to be the past.
  #
  # @return [Parser] a new instance of Parser
  #
  # source://chronic//lib/chronic/parser.rb#52
  def initialize(options = T.unsafe(nil)); end

  # List of Handler definitions. See Chronic.parse for a list of options this
  # method accepts.
  #
  # options - An optional Hash of configuration options.
  #
  # Returns a Hash of Handler definitions.
  #
  # source://chronic//lib/chronic/parser.rb#146
  def definitions(options = T.unsafe(nil)); end

  # Guess a specific time within the given span.
  #
  # span - The Chronic::Span object to calcuate a guess from.
  #
  # Returns a new Time object.
  #
  # source://chronic//lib/chronic/parser.rb#133
  def guess(span, mode = T.unsafe(nil)); end

  # Returns the value of attribute now.
  #
  # source://chronic//lib/chronic/parser.rb#18
  def now; end

  # Sets the attribute now
  #
  # @param value the value to set the attribute now to.
  #
  # source://chronic//lib/chronic/parser.rb#18
  def now=(_arg0); end

  # Returns the value of attribute options.
  #
  # source://chronic//lib/chronic/parser.rb#19
  def options; end

  # Parse "text" with the given options
  # Returns either a Time or Chronic::Span, depending on the value of options[:guess]
  #
  # source://chronic//lib/chronic/parser.rb#59
  def parse(text); end

  # Clean up the specified text ready for parsing.
  #
  # Clean up the string by stripping unwanted characters, converting
  # idioms to their canonical form, converting number words to numbers
  # (three => 3), and converting ordinal words to numeric
  # ordinals (third => 3rd)
  #
  # text - The String text to normalize.
  #
  # Examples:
  #
  #   Chronic.pre_normalize('first day in May')
  #     #=> "1st day in may"
  #
  #   Chronic.pre_normalize('tomorrow after noon')
  #     #=> "next day future 12:00"
  #
  #   Chronic.pre_normalize('one hundred and thirty six days from now')
  #     #=> "136 days future this second"
  #
  # Returns a new String ready for Chronic to parse.
  #
  # source://chronic//lib/chronic/parser.rb#89
  def pre_normalize(text); end

  private

  # source://chronic//lib/chronic/parser.rb#225
  def tokenize(text, options); end

  # source://chronic//lib/chronic/parser.rb#234
  def tokens_to_span(tokens, options); end
end

# Hash of default configuration options.
#
# source://chronic//lib/chronic/parser.rb#8
Chronic::Parser::DEFAULT_OPTIONS = T.let(T.unsafe(nil), Hash)

# source://chronic//lib/chronic/pointer.rb#2
class Chronic::Pointer < ::Chronic::Tag
  # source://chronic//lib/chronic/pointer.rb#28
  def to_s; end

  class << self
    # Scan an Array of Token objects and apply any necessary Pointer
    # tags to each token.
    #
    # tokens - An Array of tokens to scan.
    # options - The Hash of options specified in Chronic::parse.
    #
    # Returns an Array of tokens.
    #
    # source://chronic//lib/chronic/pointer.rb#11
    def scan(tokens, options); end

    # token - The Token object we want to scan.
    #
    # Returns a new Pointer object.
    #
    # source://chronic//lib/chronic/pointer.rb#20
    def scan_for_all(token); end
  end
end

# source://chronic//lib/chronic/repeater.rb#2
class Chronic::Repeater < ::Chronic::Tag
  # source://chronic//lib/chronic/repeater.rb#123
  def <=>(other); end

  # returns the next occurance of this repeatable.
  #
  # source://chronic//lib/chronic/repeater.rb#133
  def next(pointer); end

  # source://chronic//lib/chronic/repeater.rb#137
  def this(pointer); end

  # source://chronic//lib/chronic/repeater.rb#141
  def to_s; end

  # returns the width (in seconds or months) of this repeatable.
  #
  # source://chronic//lib/chronic/repeater.rb#128
  def width; end

  class << self
    # Scan an Array of Token objects and apply any necessary Repeater
    # tags to each token.
    #
    # tokens - An Array of tokens to scan.
    # options - The Hash of options specified in Chronic::parse.
    #
    # Returns an Array of tokens.
    #
    # source://chronic//lib/chronic/repeater.rb#11
    def scan(tokens, options); end

    # token - The Token object we want to scan.
    #
    # Returns a new Repeater object.
    #
    # source://chronic//lib/chronic/repeater.rb#59
    def scan_for_day_names(token, options = T.unsafe(nil)); end

    # token - The Token object we want to scan.
    #
    # Returns a new Repeater object.
    #
    # source://chronic//lib/chronic/repeater.rb#75
    def scan_for_day_portions(token, options = T.unsafe(nil)); end

    # token - The Token object we want to scan.
    #
    # Returns a new Repeater object.
    #
    # source://chronic//lib/chronic/repeater.rb#38
    def scan_for_month_names(token, options = T.unsafe(nil)); end

    # token - The Token object we want to scan.
    #
    # Returns a new Repeater object.
    #
    # source://chronic//lib/chronic/repeater.rb#25
    def scan_for_season_names(token, options = T.unsafe(nil)); end

    # token - The Token object we want to scan.
    #
    # Returns a new Repeater object.
    #
    # source://chronic//lib/chronic/repeater.rb#90
    def scan_for_times(token, options = T.unsafe(nil)); end

    # token - The Token object we want to scan.
    #
    # Returns a new Repeater object.
    #
    # source://chronic//lib/chronic/repeater.rb#97
    def scan_for_units(token, options = T.unsafe(nil)); end
  end
end

# source://chronic//lib/chronic/repeaters/repeater_day.rb#2
class Chronic::RepeaterDay < ::Chronic::Repeater
  # @return [RepeaterDay] a new instance of RepeaterDay
  #
  # source://chronic//lib/chronic/repeaters/repeater_day.rb#5
  def initialize(type, options = T.unsafe(nil)); end

  # source://chronic//lib/chronic/repeaters/repeater_day.rb#10
  def next(pointer); end

  # source://chronic//lib/chronic/repeaters/repeater_day.rb#41
  def offset(span, amount, pointer); end

  # source://chronic//lib/chronic/repeaters/repeater_day.rb#23
  def this(pointer = T.unsafe(nil)); end

  # source://chronic//lib/chronic/repeaters/repeater_day.rb#50
  def to_s; end

  # source://chronic//lib/chronic/repeaters/repeater_day.rb#46
  def width; end
end

# (24 * 60 * 60)
#
# source://chronic//lib/chronic/repeaters/repeater_day.rb#3
Chronic::RepeaterDay::DAY_SECONDS = T.let(T.unsafe(nil), Integer)

# source://chronic//lib/chronic/repeaters/repeater_day_name.rb#2
class Chronic::RepeaterDayName < ::Chronic::Repeater
  # @return [RepeaterDayName] a new instance of RepeaterDayName
  #
  # source://chronic//lib/chronic/repeaters/repeater_day_name.rb#5
  def initialize(type, options = T.unsafe(nil)); end

  # source://chronic//lib/chronic/repeaters/repeater_day_name.rb#10
  def next(pointer); end

  # source://chronic//lib/chronic/repeaters/repeater_day_name.rb#31
  def this(pointer = T.unsafe(nil)); end

  # source://chronic//lib/chronic/repeaters/repeater_day_name.rb#42
  def to_s; end

  # source://chronic//lib/chronic/repeaters/repeater_day_name.rb#38
  def width; end

  private

  # source://chronic//lib/chronic/repeaters/repeater_day_name.rb#48
  def symbol_to_number(sym); end
end

# (24 * 60 * 60)
#
# source://chronic//lib/chronic/repeaters/repeater_day_name.rb#3
Chronic::RepeaterDayName::DAY_SECONDS = T.let(T.unsafe(nil), Integer)

# source://chronic//lib/chronic/repeaters/repeater_day_portion.rb#2
class Chronic::RepeaterDayPortion < ::Chronic::Repeater
  # @return [RepeaterDayPortion] a new instance of RepeaterDayPortion
  #
  # source://chronic//lib/chronic/repeaters/repeater_day_portion.rb#12
  def initialize(type, options = T.unsafe(nil)); end

  # source://chronic//lib/chronic/repeaters/repeater_day_portion.rb#26
  def next(pointer); end

  # source://chronic//lib/chronic/repeaters/repeater_day_portion.rb#79
  def offset(span, amount, pointer); end

  # source://chronic//lib/chronic/repeaters/repeater_day_portion.rb#71
  def this(context = T.unsafe(nil)); end

  # source://chronic//lib/chronic/repeaters/repeater_day_portion.rb#96
  def to_s; end

  # source://chronic//lib/chronic/repeaters/repeater_day_portion.rb#86
  def width; end

  private

  # source://chronic//lib/chronic/repeaters/repeater_day_portion.rb#101
  def construct_date_from_reference_and_offset(reference, offset = T.unsafe(nil)); end
end

# source://chronic//lib/chronic/repeaters/repeater_day_portion.rb#3
Chronic::RepeaterDayPortion::PORTIONS = T.let(T.unsafe(nil), Hash)

# source://chronic//lib/chronic/repeaters/repeater_fortnight.rb#2
class Chronic::RepeaterFortnight < ::Chronic::Repeater
  # @return [RepeaterFortnight] a new instance of RepeaterFortnight
  #
  # source://chronic//lib/chronic/repeaters/repeater_fortnight.rb#5
  def initialize(type, options = T.unsafe(nil)); end

  # source://chronic//lib/chronic/repeaters/repeater_fortnight.rb#10
  def next(pointer); end

  # source://chronic//lib/chronic/repeaters/repeater_fortnight.rb#59
  def offset(span, amount, pointer); end

  # source://chronic//lib/chronic/repeaters/repeater_fortnight.rb#35
  def this(pointer = T.unsafe(nil)); end

  # source://chronic//lib/chronic/repeaters/repeater_fortnight.rb#68
  def to_s; end

  # source://chronic//lib/chronic/repeaters/repeater_fortnight.rb#64
  def width; end
end

# (14 * 24 * 60 * 60)
#
# source://chronic//lib/chronic/repeaters/repeater_fortnight.rb#3
Chronic::RepeaterFortnight::FORTNIGHT_SECONDS = T.let(T.unsafe(nil), Integer)

# source://chronic//lib/chronic/repeaters/repeater_hour.rb#2
class Chronic::RepeaterHour < ::Chronic::Repeater
  # @return [RepeaterHour] a new instance of RepeaterHour
  #
  # source://chronic//lib/chronic/repeaters/repeater_hour.rb#5
  def initialize(type, options = T.unsafe(nil)); end

  # source://chronic//lib/chronic/repeaters/repeater_hour.rb#10
  def next(pointer); end

  # source://chronic//lib/chronic/repeaters/repeater_hour.rb#46
  def offset(span, amount, pointer); end

  # source://chronic//lib/chronic/repeaters/repeater_hour.rb#28
  def this(pointer = T.unsafe(nil)); end

  # source://chronic//lib/chronic/repeaters/repeater_hour.rb#55
  def to_s; end

  # source://chronic//lib/chronic/repeaters/repeater_hour.rb#51
  def width; end
end

# 60 * 60
#
# source://chronic//lib/chronic/repeaters/repeater_hour.rb#3
Chronic::RepeaterHour::HOUR_SECONDS = T.let(T.unsafe(nil), Integer)

# source://chronic//lib/chronic/repeaters/repeater_minute.rb#2
class Chronic::RepeaterMinute < ::Chronic::Repeater
  # @return [RepeaterMinute] a new instance of RepeaterMinute
  #
  # source://chronic//lib/chronic/repeaters/repeater_minute.rb#5
  def initialize(type, options = T.unsafe(nil)); end

  # source://chronic//lib/chronic/repeaters/repeater_minute.rb#10
  def next(pointer = T.unsafe(nil)); end

  # source://chronic//lib/chronic/repeaters/repeater_minute.rb#46
  def offset(span, amount, pointer); end

  # source://chronic//lib/chronic/repeaters/repeater_minute.rb#28
  def this(pointer = T.unsafe(nil)); end

  # source://chronic//lib/chronic/repeaters/repeater_minute.rb#55
  def to_s; end

  # source://chronic//lib/chronic/repeaters/repeater_minute.rb#51
  def width; end
end

# source://chronic//lib/chronic/repeaters/repeater_minute.rb#3
Chronic::RepeaterMinute::MINUTE_SECONDS = T.let(T.unsafe(nil), Integer)

# source://chronic//lib/chronic/repeaters/repeater_month.rb#2
class Chronic::RepeaterMonth < ::Chronic::Repeater
  # @return [RepeaterMonth] a new instance of RepeaterMonth
  #
  # source://chronic//lib/chronic/repeaters/repeater_month.rb#8
  def initialize(type, options = T.unsafe(nil)); end

  # source://chronic//lib/chronic/repeaters/repeater_month.rb#13
  def next(pointer); end

  # source://chronic//lib/chronic/repeaters/repeater_month.rb#43
  def offset(span, amount, pointer); end

  # source://chronic//lib/chronic/repeaters/repeater_month.rb#47
  def offset_by(time, amount, pointer); end

  # source://chronic//lib/chronic/repeaters/repeater_month.rb#25
  def this(pointer = T.unsafe(nil)); end

  # source://chronic//lib/chronic/repeaters/repeater_month.rb#70
  def to_s; end

  # source://chronic//lib/chronic/repeaters/repeater_month.rb#66
  def width; end

  private

  # source://chronic//lib/chronic/repeaters/repeater_month.rb#76
  def month_days(year, month); end
end

# source://chronic//lib/chronic/repeaters/repeater_month.rb#5
Chronic::RepeaterMonth::MONTH_DAYS = T.let(T.unsafe(nil), Array)

# source://chronic//lib/chronic/repeaters/repeater_month.rb#6
Chronic::RepeaterMonth::MONTH_DAYS_LEAP = T.let(T.unsafe(nil), Array)

# 30 * 24 * 60 * 60
#
# source://chronic//lib/chronic/repeaters/repeater_month.rb#3
Chronic::RepeaterMonth::MONTH_SECONDS = T.let(T.unsafe(nil), Integer)

# source://chronic//lib/chronic/repeaters/repeater_month.rb#4
Chronic::RepeaterMonth::YEAR_MONTHS = T.let(T.unsafe(nil), Integer)

# source://chronic//lib/chronic/repeaters/repeater_month_name.rb#2
class Chronic::RepeaterMonthName < ::Chronic::Repeater
  # @return [RepeaterMonthName] a new instance of RepeaterMonthName
  #
  # source://chronic//lib/chronic/repeaters/repeater_month_name.rb#19
  def initialize(type, options = T.unsafe(nil)); end

  # source://chronic//lib/chronic/repeaters/repeater_month_name.rb#87
  def index; end

  # source://chronic//lib/chronic/repeaters/repeater_month_name.rb#24
  def next(pointer); end

  # source://chronic//lib/chronic/repeaters/repeater_month_name.rb#72
  def this(pointer = T.unsafe(nil)); end

  # source://chronic//lib/chronic/repeaters/repeater_month_name.rb#91
  def to_s; end

  # source://chronic//lib/chronic/repeaters/repeater_month_name.rb#83
  def width; end
end

# source://chronic//lib/chronic/repeaters/repeater_month_name.rb#4
Chronic::RepeaterMonthName::MONTHS = T.let(T.unsafe(nil), Hash)

# 30 * 24 * 60 * 60
#
# source://chronic//lib/chronic/repeaters/repeater_month_name.rb#3
Chronic::RepeaterMonthName::MONTH_SECONDS = T.let(T.unsafe(nil), Integer)

# source://chronic//lib/chronic/repeaters/repeater_season.rb#2
class Chronic::RepeaterSeason < ::Chronic::Repeater
  # @return [RepeaterSeason] a new instance of RepeaterSeason
  #
  # source://chronic//lib/chronic/repeaters/repeater_season.rb#11
  def initialize(type, options = T.unsafe(nil)); end

  # source://chronic//lib/chronic/repeaters/repeater_season.rb#17
  def next(pointer); end

  # source://chronic//lib/chronic/repeaters/repeater_season.rb#48
  def offset(span, amount, pointer); end

  # source://chronic//lib/chronic/repeaters/repeater_season.rb#52
  def offset_by(time, amount, pointer); end

  # source://chronic//lib/chronic/repeaters/repeater_season.rb#26
  def this(pointer = T.unsafe(nil)); end

  # source://chronic//lib/chronic/repeaters/repeater_season.rb#61
  def to_s; end

  # source://chronic//lib/chronic/repeaters/repeater_season.rb#57
  def width; end

  private

  # source://chronic//lib/chronic/repeaters/repeater_season.rb#104
  def construct_season(start, finish); end

  # source://chronic//lib/chronic/repeaters/repeater_season.rb#79
  def find_current_season(md); end

  # source://chronic//lib/chronic/repeaters/repeater_season.rb#67
  def find_next_season_span(direction, next_season); end

  # source://chronic//lib/chronic/repeaters/repeater_season.rb#85
  def num_seconds_til(goal, direction); end

  # source://chronic//lib/chronic/repeaters/repeater_season.rb#100
  def num_seconds_til_end(season_symbol, direction); end

  # source://chronic//lib/chronic/repeaters/repeater_season.rb#96
  def num_seconds_til_start(season_symbol, direction); end
end

# source://chronic//lib/chronic/repeaters/repeater_season.rb#4
Chronic::RepeaterSeason::SEASONS = T.let(T.unsafe(nil), Hash)

# 91 * 24 * 60 * 60
#
# source://chronic//lib/chronic/repeaters/repeater_season.rb#3
Chronic::RepeaterSeason::SEASON_SECONDS = T.let(T.unsafe(nil), Integer)

# source://chronic//lib/chronic/repeaters/repeater_season_name.rb#2
class Chronic::RepeaterSeasonName < ::Chronic::RepeaterSeason
  # source://chronic//lib/chronic/repeaters/repeater_season_name.rb#6
  def next(pointer); end

  # source://chronic//lib/chronic/repeaters/repeater_season_name.rb#33
  def offset(span, amount, pointer); end

  # source://chronic//lib/chronic/repeaters/repeater_season_name.rb#37
  def offset_by(time, amount, pointer); end

  # source://chronic//lib/chronic/repeaters/repeater_season_name.rb#11
  def this(pointer = T.unsafe(nil)); end
end

# (24 * 60 * 60)
#
# source://chronic//lib/chronic/repeaters/repeater_season_name.rb#4
Chronic::RepeaterSeasonName::DAY_SECONDS = T.let(T.unsafe(nil), Integer)

# 91 * 24 * 60 * 60
#
# source://chronic//lib/chronic/repeaters/repeater_season_name.rb#3
Chronic::RepeaterSeasonName::SEASON_SECONDS = T.let(T.unsafe(nil), Integer)

# source://chronic//lib/chronic/repeaters/repeater_second.rb#2
class Chronic::RepeaterSecond < ::Chronic::Repeater
  # @return [RepeaterSecond] a new instance of RepeaterSecond
  #
  # source://chronic//lib/chronic/repeaters/repeater_second.rb#5
  def initialize(type, options = T.unsafe(nil)); end

  # source://chronic//lib/chronic/repeaters/repeater_second.rb#10
  def next(pointer = T.unsafe(nil)); end

  # source://chronic//lib/chronic/repeaters/repeater_second.rb#30
  def offset(span, amount, pointer); end

  # source://chronic//lib/chronic/repeaters/repeater_second.rb#24
  def this(pointer = T.unsafe(nil)); end

  # source://chronic//lib/chronic/repeaters/repeater_second.rb#39
  def to_s; end

  # source://chronic//lib/chronic/repeaters/repeater_second.rb#35
  def width; end
end

# haha, awesome
#
# source://chronic//lib/chronic/repeaters/repeater_second.rb#3
Chronic::RepeaterSecond::SECOND_SECONDS = T.let(T.unsafe(nil), Integer)

# source://chronic//lib/chronic/repeaters/repeater_time.rb#2
class Chronic::RepeaterTime < ::Chronic::Repeater
  # @raise [ArgumentError]
  # @return [RepeaterTime] a new instance of RepeaterTime
  #
  # source://chronic//lib/chronic/repeaters/repeater_time.rb#29
  def initialize(time, options = T.unsafe(nil)); end

  # Return the next past or future Span for the time that this Repeater represents
  #   pointer - Symbol representing which temporal direction to fetch the next day
  #             must be either :past or :future
  #
  # source://chronic//lib/chronic/repeaters/repeater_time.rb#69
  def next(pointer); end

  # source://chronic//lib/chronic/repeaters/repeater_time.rb#122
  def this(context = T.unsafe(nil)); end

  # source://chronic//lib/chronic/repeaters/repeater_time.rb#134
  def to_s; end

  # source://chronic//lib/chronic/repeaters/repeater_time.rb#130
  def width; end
end

# source://chronic//lib/chronic/repeaters/repeater_time.rb#3
class Chronic::RepeaterTime::Tick
  # @return [Tick] a new instance of Tick
  #
  # source://chronic//lib/chronic/repeaters/repeater_time.rb#6
  def initialize(time, ambiguous = T.unsafe(nil)); end

  # source://chronic//lib/chronic/repeaters/repeater_time.rb#15
  def *(other); end

  # @return [Boolean]
  #
  # source://chronic//lib/chronic/repeaters/repeater_time.rb#11
  def ambiguous?; end

  # Returns the value of attribute time.
  #
  # source://chronic//lib/chronic/repeaters/repeater_time.rb#4
  def time; end

  # Sets the attribute time
  #
  # @param value the value to set the attribute time to.
  #
  # source://chronic//lib/chronic/repeaters/repeater_time.rb#4
  def time=(_arg0); end

  # source://chronic//lib/chronic/repeaters/repeater_time.rb#19
  def to_f; end

  # source://chronic//lib/chronic/repeaters/repeater_time.rb#23
  def to_s; end
end

# source://chronic//lib/chronic/repeaters/repeater_week.rb#2
class Chronic::RepeaterWeek < ::Chronic::Repeater
  # @return [RepeaterWeek] a new instance of RepeaterWeek
  #
  # source://chronic//lib/chronic/repeaters/repeater_week.rb#5
  def initialize(type, options = T.unsafe(nil)); end

  # source://chronic//lib/chronic/repeaters/repeater_week.rb#10
  def next(pointer); end

  # source://chronic//lib/chronic/repeaters/repeater_week.rb#62
  def offset(span, amount, pointer); end

  # source://chronic//lib/chronic/repeaters/repeater_week.rb#35
  def this(pointer = T.unsafe(nil)); end

  # source://chronic//lib/chronic/repeaters/repeater_week.rb#71
  def to_s; end

  # source://chronic//lib/chronic/repeaters/repeater_week.rb#67
  def width; end
end

# (7 * 24 * 60 * 60)
#
# source://chronic//lib/chronic/repeaters/repeater_week.rb#3
Chronic::RepeaterWeek::WEEK_SECONDS = T.let(T.unsafe(nil), Integer)

# source://chronic//lib/chronic/repeaters/repeater_weekday.rb#2
class Chronic::RepeaterWeekday < ::Chronic::Repeater
  # @return [RepeaterWeekday] a new instance of RepeaterWeekday
  #
  # source://chronic//lib/chronic/repeaters/repeater_weekday.rb#14
  def initialize(type, options = T.unsafe(nil)); end

  # source://chronic//lib/chronic/repeaters/repeater_weekday.rb#19
  def next(pointer); end

  # source://chronic//lib/chronic/repeaters/repeater_weekday.rb#52
  def offset(span, amount, pointer); end

  # source://chronic//lib/chronic/repeaters/repeater_weekday.rb#41
  def this(pointer = T.unsafe(nil)); end

  # source://chronic//lib/chronic/repeaters/repeater_weekday.rb#68
  def to_s; end

  # source://chronic//lib/chronic/repeaters/repeater_weekday.rb#64
  def width; end

  private

  # @return [Boolean]
  #
  # source://chronic//lib/chronic/repeaters/repeater_weekday.rb#78
  def is_weekday?(day); end

  # @return [Boolean]
  #
  # source://chronic//lib/chronic/repeaters/repeater_weekday.rb#74
  def is_weekend?(day); end

  # source://chronic//lib/chronic/repeaters/repeater_weekday.rb#82
  def symbol_to_number(sym); end
end

# source://chronic//lib/chronic/repeaters/repeater_weekday.rb#4
Chronic::RepeaterWeekday::DAYS = T.let(T.unsafe(nil), Hash)

# (24 * 60 * 60)
#
# source://chronic//lib/chronic/repeaters/repeater_weekday.rb#3
Chronic::RepeaterWeekday::DAY_SECONDS = T.let(T.unsafe(nil), Integer)

# source://chronic//lib/chronic/repeaters/repeater_weekend.rb#2
class Chronic::RepeaterWeekend < ::Chronic::Repeater
  # @return [RepeaterWeekend] a new instance of RepeaterWeekend
  #
  # source://chronic//lib/chronic/repeaters/repeater_weekend.rb#5
  def initialize(type, options = T.unsafe(nil)); end

  # source://chronic//lib/chronic/repeaters/repeater_weekend.rb#10
  def next(pointer); end

  # source://chronic//lib/chronic/repeaters/repeater_weekend.rb#51
  def offset(span, amount, pointer); end

  # source://chronic//lib/chronic/repeaters/repeater_weekend.rb#34
  def this(pointer = T.unsafe(nil)); end

  # source://chronic//lib/chronic/repeaters/repeater_weekend.rb#63
  def to_s; end

  # source://chronic//lib/chronic/repeaters/repeater_weekend.rb#59
  def width; end
end

# (2 * 24 * 60 * 60)
#
# source://chronic//lib/chronic/repeaters/repeater_weekend.rb#3
Chronic::RepeaterWeekend::WEEKEND_SECONDS = T.let(T.unsafe(nil), Integer)

# source://chronic//lib/chronic/repeaters/repeater_year.rb#2
class Chronic::RepeaterYear < ::Chronic::Repeater
  # @return [RepeaterYear] a new instance of RepeaterYear
  #
  # source://chronic//lib/chronic/repeaters/repeater_year.rb#5
  def initialize(type, options = T.unsafe(nil)); end

  # source://chronic//lib/chronic/repeaters/repeater_year.rb#10
  def next(pointer); end

  # source://chronic//lib/chronic/repeaters/repeater_year.rb#46
  def offset(span, amount, pointer); end

  # source://chronic//lib/chronic/repeaters/repeater_year.rb#28
  def this(pointer = T.unsafe(nil)); end

  # source://chronic//lib/chronic/repeaters/repeater_year.rb#57
  def to_s; end

  # source://chronic//lib/chronic/repeaters/repeater_year.rb#53
  def width; end

  private

  # source://chronic//lib/chronic/repeaters/repeater_year.rb#63
  def build_offset_time(time, amount, direction); end

  # source://chronic//lib/chronic/repeaters/repeater_year.rb#70
  def month_days(year, month); end
end

# 365 * 24 * 60 * 60
#
# source://chronic//lib/chronic/repeaters/repeater_year.rb#3
Chronic::RepeaterYear::YEAR_SECONDS = T.let(T.unsafe(nil), Integer)

# source://chronic//lib/chronic/scalar.rb#2
class Chronic::Scalar < ::Chronic::Tag
  # source://chronic//lib/chronic/scalar.rb#35
  def to_s; end

  class << self
    # Scan an Array of Token objects and apply any necessary Scalar
    # tags to each token.
    #
    # tokens - An Array of tokens to scan.
    # options - The Hash of options specified in Chronic::parse.
    #
    # Returns an Array of tokens.
    #
    # source://chronic//lib/chronic/scalar.rb#12
    def scan(tokens, options); end
  end
end

# source://chronic//lib/chronic/scalar.rb#3
Chronic::Scalar::DAY_PORTIONS = T.let(T.unsafe(nil), Array)

# source://chronic//lib/chronic/scalar.rb#64
class Chronic::ScalarDay < ::Chronic::Scalar
  # source://chronic//lib/chronic/scalar.rb#65
  def to_s; end
end

# source://chronic//lib/chronic/scalar.rb#58
class Chronic::ScalarHour < ::Chronic::Scalar
  # source://chronic//lib/chronic/scalar.rb#59
  def to_s; end
end

# source://chronic//lib/chronic/scalar.rb#52
class Chronic::ScalarMinute < ::Chronic::Scalar
  # source://chronic//lib/chronic/scalar.rb#53
  def to_s; end
end

# source://chronic//lib/chronic/scalar.rb#70
class Chronic::ScalarMonth < ::Chronic::Scalar
  # source://chronic//lib/chronic/scalar.rb#71
  def to_s; end
end

# source://chronic//lib/chronic/scalar.rb#46
class Chronic::ScalarSecond < ::Chronic::Scalar
  # source://chronic//lib/chronic/scalar.rb#47
  def to_s; end
end

# source://chronic//lib/chronic/scalar.rb#40
class Chronic::ScalarSubsecond < ::Chronic::Scalar
  # source://chronic//lib/chronic/scalar.rb#41
  def to_s; end
end

# source://chronic//lib/chronic/scalar.rb#76
class Chronic::ScalarYear < ::Chronic::Scalar
  # source://chronic//lib/chronic/scalar.rb#77
  def to_s; end
end

# source://chronic//lib/chronic/season.rb#2
class Chronic::Season
  # @return [Season] a new instance of Season
  #
  # source://chronic//lib/chronic/season.rb#7
  def initialize(start_date, end_date); end

  # Returns the value of attribute end.
  #
  # source://chronic//lib/chronic/season.rb#5
  def end; end

  # Returns the value of attribute start.
  #
  # source://chronic//lib/chronic/season.rb#4
  def start; end

  class << self
    # source://chronic//lib/chronic/season.rb#12
    def find_next_season(season, pointer); end

    # source://chronic//lib/chronic/season.rb#18
    def season_after(season); end

    # source://chronic//lib/chronic/season.rb#22
    def season_before(season); end
  end
end

# source://chronic//lib/chronic/separator.rb#2
class Chronic::Separator < ::Chronic::Tag
  # source://chronic//lib/chronic/separator.rb#124
  def to_s; end

  class << self
    # Scan an Array of Token objects and apply any necessary Separator
    # tags to each token.
    #
    # tokens - An Array of tokens to scan.
    # options - The Hash of options specified in Chronic::parse.
    #
    # Returns an Array of tokens.
    #
    # source://chronic//lib/chronic/separator.rb#11
    def scan(tokens, options); end

    # token - The Token object we want to scan.
    #
    # Returns a new SeperatorAnd Object object.
    #
    # source://chronic//lib/chronic/separator.rb#106
    def scan_for_and(token); end

    # token - The Token object we want to scan.
    #
    # Returns a new SeparatorAt object.
    #
    # source://chronic//lib/chronic/separator.rb#85
    def scan_for_at(token); end

    # token - The Token object we want to scan.
    #
    # Returns a new SeparatorColon object.
    #
    # source://chronic//lib/chronic/separator.rb#46
    def scan_for_colon(token); end

    # token - The Token object we want to scan.
    #
    # Returns a new SeparatorComma object.
    #
    # source://chronic//lib/chronic/separator.rb#32
    def scan_for_commas(token); end

    # token - The Token object we want to scan.
    #
    # Returns a new SeparatorDash object.
    #
    # source://chronic//lib/chronic/separator.rb#67
    def scan_for_dash(token); end

    # token - The Token object we want to scan.
    #
    # Returns a new SeparatorDot object.
    #
    # source://chronic//lib/chronic/separator.rb#39
    def scan_for_dots(token); end

    # token - The Token object we want to scan.
    #
    # Returns a new SeparatorIn object.
    #
    # source://chronic//lib/chronic/separator.rb#92
    def scan_for_in(token); end

    # token - The Token object we want to scan.
    #
    # Returns a new SeparatorOn object.
    #
    # source://chronic//lib/chronic/separator.rb#99
    def scan_for_on(token); end

    # token - The Token object we want to scan.
    #
    # Returns a new SeparatorQuote object.
    #
    # source://chronic//lib/chronic/separator.rb#74
    def scan_for_quote(token); end

    # token - The Token object we want to scan.
    #
    # Returns a new SeparatorSlash object.
    #
    # source://chronic//lib/chronic/separator.rb#60
    def scan_for_slash(token); end

    # token - The Token object we want to scan.
    #
    # Returns a new SeparatorSpace object.
    #
    # source://chronic//lib/chronic/separator.rb#53
    def scan_for_space(token); end

    # token - The Token object we want to scan.
    #
    # Returns a new SeperatorT Object object.
    #
    # source://chronic//lib/chronic/separator.rb#113
    def scan_for_t(token); end

    # token - The Token object we want to scan.
    #
    # Returns a new SeperatorW Object object.
    #
    # source://chronic//lib/chronic/separator.rb#120
    def scan_for_w(token); end
  end
end

# source://chronic//lib/chronic/separator.rb#189
class Chronic::SeparatorAnd < ::Chronic::Separator
  # source://chronic//lib/chronic/separator.rb#190
  def to_s; end
end

# source://chronic//lib/chronic/separator.rb#171
class Chronic::SeparatorAt < ::Chronic::Separator
  # source://chronic//lib/chronic/separator.rb#172
  def to_s; end
end

# source://chronic//lib/chronic/separator.rb#141
class Chronic::SeparatorColon < ::Chronic::Separator
  # source://chronic//lib/chronic/separator.rb#142
  def to_s; end
end

# source://chronic//lib/chronic/separator.rb#129
class Chronic::SeparatorComma < ::Chronic::Separator
  # source://chronic//lib/chronic/separator.rb#130
  def to_s; end
end

# source://chronic//lib/chronic/separator.rb#159
class Chronic::SeparatorDash < ::Chronic::Separator
  # source://chronic//lib/chronic/separator.rb#160
  def to_s; end
end

# source://chronic//lib/chronic/separator.rb#135
class Chronic::SeparatorDot < ::Chronic::Separator
  # source://chronic//lib/chronic/separator.rb#136
  def to_s; end
end

# source://chronic//lib/chronic/separator.rb#177
class Chronic::SeparatorIn < ::Chronic::Separator
  # source://chronic//lib/chronic/separator.rb#178
  def to_s; end
end

# source://chronic//lib/chronic/separator.rb#183
class Chronic::SeparatorOn < ::Chronic::Separator
  # source://chronic//lib/chronic/separator.rb#184
  def to_s; end
end

# source://chronic//lib/chronic/separator.rb#165
class Chronic::SeparatorQuote < ::Chronic::Separator
  # source://chronic//lib/chronic/separator.rb#166
  def to_s; end
end

# source://chronic//lib/chronic/separator.rb#153
class Chronic::SeparatorSlash < ::Chronic::Separator
  # source://chronic//lib/chronic/separator.rb#154
  def to_s; end
end

# source://chronic//lib/chronic/separator.rb#147
class Chronic::SeparatorSpace < ::Chronic::Separator
  # source://chronic//lib/chronic/separator.rb#148
  def to_s; end
end

# source://chronic//lib/chronic/separator.rb#195
class Chronic::SeparatorT < ::Chronic::Separator
  # source://chronic//lib/chronic/separator.rb#196
  def to_s; end
end

# source://chronic//lib/chronic/separator.rb#201
class Chronic::SeparatorW < ::Chronic::Separator
  # source://chronic//lib/chronic/separator.rb#202
  def to_s; end
end

# source://chronic//lib/chronic/sign.rb#2
class Chronic::Sign < ::Chronic::Tag
  # source://chronic//lib/chronic/sign.rb#32
  def to_s; end

  class << self
    # Scan an Array of Token objects and apply any necessary Sign
    # tags to each token.
    #
    # tokens - An Array of tokens to scan.
    # options - The Hash of options specified in Chronic::parse.
    #
    # Returns an Array of tokens.
    #
    # source://chronic//lib/chronic/sign.rb#11
    def scan(tokens, options); end

    # token - The Token object we want to scan.
    #
    # Returns a new SignMinus object.
    #
    # source://chronic//lib/chronic/sign.rb#28
    def scan_for_minus(token); end

    # token - The Token object we want to scan.
    #
    # Returns a new SignPlus object.
    #
    # source://chronic//lib/chronic/sign.rb#21
    def scan_for_plus(token); end
  end
end

# source://chronic//lib/chronic/sign.rb#43
class Chronic::SignMinus < ::Chronic::Sign
  # source://chronic//lib/chronic/sign.rb#44
  def to_s; end
end

# source://chronic//lib/chronic/sign.rb#37
class Chronic::SignPlus < ::Chronic::Sign
  # source://chronic//lib/chronic/sign.rb#38
  def to_s; end
end

# A Span represents a range of time. Since this class extends
# Range, you can use #begin and #end to get the beginning and
# ending times of the span (they will be of class Time)
#
# source://chronic//lib/chronic/span.rb#5
class Chronic::Span < ::Range
  # Add a number of seconds to this span, returning the
  # resulting Span
  #
  # source://chronic//lib/chronic/span.rb#13
  def +(seconds); end

  # Subtract a number of seconds to this span, returning the
  # resulting Span
  #
  # source://chronic//lib/chronic/span.rb#19
  def -(seconds); end

  # Prints this span in a nice fashion
  #
  # source://chronic//lib/chronic/span.rb#24
  def to_s; end

  # Returns the width of this span in seconds
  #
  # source://chronic//lib/chronic/span.rb#7
  def width; end
end

# Tokens are tagged with subclassed instances of this class when
# they match specific criteria.
#
# source://chronic//lib/chronic/tag.rb#4
class Chronic::Tag
  # type - The Symbol type of this tag.
  #
  # @return [Tag] a new instance of Tag
  #
  # source://chronic//lib/chronic/tag.rb#9
  def initialize(type, options = T.unsafe(nil)); end

  # time - Set the start Time for this Tag.
  #
  # source://chronic//lib/chronic/tag.rb#15
  def start=(time); end

  # Returns the value of attribute type.
  #
  # source://chronic//lib/chronic/tag.rb#6
  def type; end

  # Sets the attribute type
  #
  # @param value the value to set the attribute type to.
  #
  # source://chronic//lib/chronic/tag.rb#6
  def type=(_arg0); end

  class << self
    private

    # source://chronic//lib/chronic/tag.rb#22
    def scan_for(token, klass, items = T.unsafe(nil), options = T.unsafe(nil)); end
  end
end

# source://chronic//lib/chronic/time.rb#2
class Chronic::Time
  class << self
    # Checks if given number could be hour
    #
    # @return [Boolean]
    #
    # source://chronic//lib/chronic/time.rb#9
    def could_be_hour?(hour); end

    # Checks if given number could be minute
    #
    # @return [Boolean]
    #
    # source://chronic//lib/chronic/time.rb#14
    def could_be_minute?(minute); end

    # Checks if given number could be second
    #
    # @return [Boolean]
    #
    # source://chronic//lib/chronic/time.rb#19
    def could_be_second?(second); end

    # Checks if given number could be subsecond
    #
    # @return [Boolean]
    #
    # source://chronic//lib/chronic/time.rb#24
    def could_be_subsecond?(subsecond); end

    # normalize offset in seconds to offset as string +mm:ss or -mm:ss
    #
    # source://chronic//lib/chronic/time.rb#29
    def normalize_offset(offset); end
  end
end

# 60 * 60
#
# source://chronic//lib/chronic/time.rb#3
Chronic::Time::HOUR_SECONDS = T.let(T.unsafe(nil), Integer)

# source://chronic//lib/chronic/time.rb#4
Chronic::Time::MINUTE_SECONDS = T.let(T.unsafe(nil), Integer)

# haha, awesome
#
# source://chronic//lib/chronic/time.rb#5
Chronic::Time::SECOND_SECONDS = T.let(T.unsafe(nil), Integer)

# source://chronic//lib/chronic/time.rb#6
Chronic::Time::SUBSECOND_SECONDS = T.let(T.unsafe(nil), Float)

# source://chronic//lib/chronic/time_zone.rb#2
class Chronic::TimeZone < ::Chronic::Tag
  # source://chronic//lib/chronic/time_zone.rb#28
  def to_s; end

  class << self
    # Scan an Array of Token objects and apply any necessary TimeZone
    # tags to each token.
    #
    # tokens - An Array of tokens to scan.
    # options - The Hash of options specified in Chronic::parse.
    #
    # Returns an Array of tokens.
    #
    # source://chronic//lib/chronic/time_zone.rb#11
    def scan(tokens, options); end

    # token - The Token object we want to scan.
    #
    # Returns a new Pointer object.
    #
    # source://chronic//lib/chronic/time_zone.rb#20
    def scan_for_all(token); end
  end
end

# source://chronic//lib/chronic/token.rb#2
class Chronic::Token
  # @return [Token] a new instance of Token
  #
  # source://chronic//lib/chronic/token.rb#7
  def initialize(word); end

  # tag_class - The tag Class to search for.
  #
  # Returns The first Tag that matches the given class.
  #
  # source://chronic//lib/chronic/token.rb#38
  def get_tag(tag_class); end

  # source://chronic//lib/chronic/token.rb#47
  def inspect; end

  # Tag this token with the specified tag.
  #
  # new_tag - The new Tag object.
  #
  # Returns nothing.
  #
  # source://chronic//lib/chronic/token.rb#17
  def tag(new_tag); end

  # Returns true if this token has any tags.
  #
  # @return [Boolean]
  #
  # source://chronic//lib/chronic/token.rb#31
  def tagged?; end

  # Returns the value of attribute tags.
  #
  # source://chronic//lib/chronic/token.rb#5
  def tags; end

  # Sets the attribute tags
  #
  # @param value the value to set the attribute tags to.
  #
  # source://chronic//lib/chronic/token.rb#5
  def tags=(_arg0); end

  # Print this Token in a pretty way
  #
  # source://chronic//lib/chronic/token.rb#43
  def to_s; end

  # Remove all tags of the given class.
  #
  # tag_class - The tag Class to remove.
  #
  # Returns nothing.
  #
  # source://chronic//lib/chronic/token.rb#26
  def untag(tag_class); end

  # Returns the value of attribute word.
  #
  # source://chronic//lib/chronic/token.rb#4
  def word; end

  # Sets the attribute word
  #
  # @param value the value to set the attribute word to.
  #
  # source://chronic//lib/chronic/token.rb#4
  def word=(_arg0); end
end

# source://chronic//lib/chronic.rb#56
Chronic::VERSION = T.let(T.unsafe(nil), String)
