# This file is autogenerated. Do not edit it by hand. Regenerate it with:
#   srb rbi gems

# typed: true
#
# If you would like to make changes to this file, great! Please create the gem's shim here:
#
#   https://github.com/sorbet/sorbet-typed/new/master?filename=lib/cucumber-cucumber-expressions/all/cucumber-cucumber-expressions.rbi
#
# cucumber-cucumber-expressions-17.1.0

module Cucumber
end
module Cucumber::CucumberExpressions
end
class Cucumber::CucumberExpressions::Node
  def end; end
  def initialize(type, nodes, token, start, ending); end
  def nodes; end
  def start; end
  def text; end
  def to_hash; end
  def token; end
  def type; end
end
module Cucumber::CucumberExpressions::NodeType
end
class Cucumber::CucumberExpressions::Token
  def end; end
  def initialize(type, text, start, ending); end
  def self.can_escape(codepoint); end
  def self.is_escape_character(codepoint); end
  def self.purpose_of(token); end
  def self.symbol_of(token); end
  def self.type_of(codepoint); end
  def start; end
  def text; end
  def to_hash; end
  def type; end
end
module Cucumber::CucumberExpressions::TokenType
end
class Cucumber::CucumberExpressions::CucumberExpressionError < StandardError
  def build_message(index, expression, pointer, problem, solution); end
  def point_at(index); end
  def point_at_located(node); end
end
class Cucumber::CucumberExpressions::AlternativeMayNotExclusivelyContainOptionals < Cucumber::CucumberExpressions::CucumberExpressionError
  def initialize(node, expression); end
end
class Cucumber::CucumberExpressions::AlternativeMayNotBeEmpty < Cucumber::CucumberExpressions::CucumberExpressionError
  def initialize(node, expression); end
end
class Cucumber::CucumberExpressions::CantEscape < Cucumber::CucumberExpressions::CucumberExpressionError
  def initialize(expression, index); end
end
class Cucumber::CucumberExpressions::OptionalMayNotBeEmpty < Cucumber::CucumberExpressions::CucumberExpressionError
  def initialize(node, expression); end
end
class Cucumber::CucumberExpressions::ParameterIsNotAllowedInOptional < Cucumber::CucumberExpressions::CucumberExpressionError
  def initialize(node, expression); end
end
class Cucumber::CucumberExpressions::OptionalIsNotAllowedInOptional < Cucumber::CucumberExpressions::CucumberExpressionError
  def initialize(node, expression); end
end
class Cucumber::CucumberExpressions::TheEndOfLineCannotBeEscaped < Cucumber::CucumberExpressions::CucumberExpressionError
  def initialize(expression); end
end
class Cucumber::CucumberExpressions::MissingEndToken < Cucumber::CucumberExpressions::CucumberExpressionError
  def initialize(expression, begin_token, end_token, current); end
end
class Cucumber::CucumberExpressions::AlternationNotAllowedInOptional < Cucumber::CucumberExpressions::CucumberExpressionError
  def initialize(expression, current); end
end
class Cucumber::CucumberExpressions::InvalidParameterTypeName < Cucumber::CucumberExpressions::CucumberExpressionError
  def initialize(type_name); end
end
class Cucumber::CucumberExpressions::InvalidParameterTypeNameInNode < Cucumber::CucumberExpressions::CucumberExpressionError
  def initialize(expression, token); end
end
class Cucumber::CucumberExpressions::UndefinedParameterTypeError < Cucumber::CucumberExpressions::CucumberExpressionError
  def initialize(node, expression, undefined_parameter_type_name); end
  def undefined_parameter_type_name; end
end
class Cucumber::CucumberExpressions::AmbiguousParameterTypeError < Cucumber::CucumberExpressions::CucumberExpressionError
  def expressions(generated_expressions); end
  def initialize(parameter_type_regexp, expression_regexp, parameter_types, generated_expressions); end
  def parameter_type_names(parameter_types); end
end
class Cucumber::CucumberExpressions::ParameterType
  def <=>(other); end
  def initialize(name, regexp, type, transformer, use_for_snippets, prefer_for_regexp_match); end
  def name; end
  def prefer_for_regexp_match; end
  def regexp_source(regexp); end
  def regexps; end
  def self.check_parameter_type_name(type_name); end
  def self.is_valid_parameter_type_name(type_name); end
  def string_array(regexps); end
  def transform(self_obj, group_values); end
  def transformer; end
  def type; end
  def use_for_snippets; end
end
class Cucumber::CucumberExpressions::ParameterTypeMatcher
  def <=>(other); end
  def advance_to(new_match_position); end
  def find; end
  def full_word?; end
  def group; end
  def initialize(parameter_type, regexp, text, match_position = nil); end
  def parameter_type; end
  def space_after_match_or_sentence_end?; end
  def space_before_match_or_sentence_start?; end
  def start; end
end
class Cucumber::CucumberExpressions::GeneratedExpression
  def get_parameter_name(type_name, usage_by_type_name); end
  def initialize(expression_template, parameters_types); end
  def parameter_names; end
  def parameter_types; end
  def source; end
end
class Cucumber::CucumberExpressions::CombinatorialGeneratedExpressionFactory
  def generate_expressions; end
  def generate_permutations(generated_expressions, depth, current_parameter_types); end
  def initialize(expression_template, parameter_type_combinations); end
end
class Cucumber::CucumberExpressions::CucumberExpressionGenerator
  def create_parameter_type_matchers(text); end
  def create_parameter_type_matchers2(parameter_type, text); end
  def escape(s); end
  def generate_expressions(text); end
  def initialize(parameter_type_registry); end
end
class Cucumber::CucumberExpressions::ParameterTypeRegistry
  def define_parameter_type(parameter_type); end
  def initialize; end
  def lookup_by_regexp(parameter_type_regexp, expression_regexp, text); end
  def lookup_by_type_name(name); end
  def parameter_types; end
end
class Cucumber::CucumberExpressions::Group
  def children; end
  def end; end
  def initialize(value, start, _end, children); end
  def start; end
  def value; end
  def values; end
end
class Cucumber::CucumberExpressions::Argument
  def group; end
  def initialize(group, parameter_type); end
  def parameter_type; end
  def self.build(tree_regexp, text, parameter_types); end
  def value(self_obj = nil); end
end
class Cucumber::CucumberExpressions::GroupBuilder
  def add(group_builder); end
  def build(match, group_indices); end
  def capturing?; end
  def children; end
  def initialize; end
  def move_children_to(group_builder); end
  def set_non_capturing!; end
  def source; end
  def source=(arg0); end
end
class Cucumber::CucumberExpressions::TreeRegexp
  def create_group_builder(regexp); end
  def group_builder; end
  def initialize(regexp); end
  def is_non_capturing(source, i); end
  def match(s); end
  def regexp; end
end
class Cucumber::CucumberExpressions::CucumberExpressionTokenizer
  def convert_buffer_to_token(token_type); end
  def should_create_new_token?(previous_token_type, current_token_type); end
  def token_type_of(codepoint, treat_as_text); end
  def tokenize(expression); end
end
class Cucumber::CucumberExpressions::CucumberExpressionParser
  def create_alternative_nodes(start, _end, separators, alternatives); end
  def looking_at(tokens, at, token); end
  def looking_at_any(tokens, at, token_types); end
  def parse(expression); end
  def parse_between(type, begin_token, end_token, parsers); end
  def parse_token(expression, parsers, tokens, start_at); end
  def parse_tokens_until(expression, parsers, tokens, start_at, end_tokens); end
  def split_alternatives(start, _end, alternation); end
end
class Cucumber::CucumberExpressions::CucumberExpression
  def assert_no_optionals(node, &raise_error); end
  def assert_no_parameters(node, &raise_error); end
  def assert_not_empty(node, &raise_error); end
  def escape_regex(expression); end
  def initialize(expression, parameter_type_registry); end
  def match(text); end
  def regexp; end
  def rewrite_alternation(node); end
  def rewrite_alternative(node); end
  def rewrite_expression(node); end
  def rewrite_optional(node); end
  def rewrite_parameter(node); end
  def rewrite_to_regex(node); end
  def source; end
  def to_s; end
end
class Cucumber::CucumberExpressions::RegularExpression
  def initialize(expression_regexp, parameter_type_registry); end
  def match(text); end
  def regexp; end
  def source; end
  def to_s; end
end
