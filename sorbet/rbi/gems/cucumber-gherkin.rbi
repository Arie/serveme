# This file is autogenerated. Do not edit it by hand. Regenerate it with:
#   srb rbi gems

# typed: true
#
# If you would like to make changes to this file, great! Please create the gem's shim here:
#
#   https://github.com/sorbet/sorbet-typed/new/master?filename=lib/cucumber-gherkin/all/cucumber-gherkin.rbi
#
# cucumber-gherkin-27.0.0

module Gherkin
  def self.encode_source_message(uri, data); end
  def self.from_paths(paths, options = nil); end
  def self.from_source(uri, data, options = nil); end
  def self.from_sources(sources, options = nil); end
end
class Gherkin::AstNode
  def add(rule_type, obj); end
  def get_items(rule_type); end
  def get_single(rule_type); end
  def get_token(token_type); end
  def get_tokens(token_type); end
  def initialize(rule_type); end
  def rule_type; end
end
class Gherkin::AstBuilder
  def build(token); end
  def current_node; end
  def end_rule(rule_type); end
  def ensure_cell_count(rows); end
  def get_cells(table_row_token); end
  def get_description(node); end
  def get_location(token, column); end
  def get_result; end
  def get_steps(node); end
  def get_table_rows(node); end
  def get_tags(node); end
  def initialize(id_generator); end
  def reset; end
  def start_rule(rule_type); end
  def transform_node(node); end
end
class Gherkin::Dialect
  def and_keywords; end
  def background_keywords; end
  def but_keywords; end
  def examples_keywords; end
  def feature_keywords; end
  def given_keywords; end
  def initialize(spec); end
  def rule_keywords; end
  def scenario_keywords; end
  def scenario_outline_keywords; end
  def self.for(name); end
  def then_keywords; end
  def when_keywords; end
end
class Gherkin::ParserError < StandardError
end
class Gherkin::AstNodeNotLocatedException < StandardError
end
class Gherkin::DoubleIterationException < StandardError
end
class Gherkin::ParserException < Gherkin::ParserError
  def initialize(message, location); end
  def location; end
end
class Gherkin::NoSuchLanguageException < Gherkin::ParserException
  def initialize(language, location); end
end
class Gherkin::AstBuilderException < Gherkin::ParserException
end
class Gherkin::CompositeParserException < Gherkin::ParserError
  def errors; end
  def initialize(errors); end
end
class Gherkin::UnexpectedTokenException < Gherkin::ParserException
  def initialize(received_token, expected_token_types, state_comment); end
end
class Gherkin::UnexpectedEOFException < Gherkin::ParserException
  def initialize(received_token, expected_token_types, state_comment); end
end
class Gherkin::TokenMatcher
  def _match_DocStringSeparator(token, separator, is_open); end
  def add_keyword_type_mappings(keywords, type); end
  def change_dialect(dialect_name, location); end
  def initialize(dialect_name = nil); end
  def match_BackgroundLine(token); end
  def match_Comment(token); end
  def match_DocStringSeparator(token); end
  def match_EOF(token); end
  def match_Empty(token); end
  def match_ExamplesLine(token); end
  def match_FeatureLine(token); end
  def match_Language(token); end
  def match_Other(token); end
  def match_RuleLine(token); end
  def match_ScenarioLine(token); end
  def match_StepLine(token); end
  def match_TableRow(token); end
  def match_TagLine(token); end
  def match_title_line(token, token_type, keywords); end
  def reset; end
  def set_token_matched(token, matched_type, text = nil, keyword = nil, indent = nil, keyword_type = nil, items = nil); end
  def unescape_docstring(text); end
end
class Anonymous_Struct_665 < Struct
  def line; end
  def line=(_); end
  def location; end
  def location=(_); end
  def self.[](*arg0); end
  def self.inspect; end
  def self.keyword_init?; end
  def self.members; end
  def self.new(*arg0); end
end
class Gherkin::Token < Anonymous_Struct_665
  def detach; end
  def eof?; end
  def matched_gherkin_dialect; end
  def matched_gherkin_dialect=(arg0); end
  def matched_indent; end
  def matched_indent=(arg0); end
  def matched_items; end
  def matched_items=(arg0); end
  def matched_keyword; end
  def matched_keyword=(arg0); end
  def matched_keyword_type; end
  def matched_keyword_type=(arg0); end
  def matched_text; end
  def matched_text=(arg0); end
  def matched_type; end
  def matched_type=(arg0); end
  def token_value; end
end
class Gherkin::GherkinLine
  def empty?; end
  def get_line_text(indent_to_remove); end
  def get_rest_trimmed(length); end
  def indent; end
  def initialize(line_text, line_number); end
  def split_table_cells(row); end
  def start_with?(prefix); end
  def start_with_title_keyword?(keyword); end
  def table_cells; end
  def tags; end
  def trimmed_line_text; end
end
class Anonymous_Struct_666 < Struct
  def column; end
  def column=(_); end
  def self.[](*arg0); end
  def self.inspect; end
  def self.keyword_init?; end
  def self.members; end
  def self.new(*arg0); end
  def text; end
  def text=(_); end
end
class Gherkin::GherkinLine::Span < Anonymous_Struct_666
end
class Gherkin::TokenScanner
  def initialize(source_or_io); end
  def read; end
end
class Gherkin::ParserContext
  def errors; end
  def initialize(token_scanner, token_matcher, token_queue, errors); end
  def token_matcher; end
  def token_queue; end
  def token_scanner; end
end
class Gherkin::Parser
  def add_error(context, error); end
  def build(context, token); end
  def end_rule(context, rule_type); end
  def get_result; end
  def handle_ast_error(context, &action); end
  def handle_external_error(context, default_value, &action); end
  def initialize(ast_builder = nil); end
  def lookahead_0(context, currentToken); end
  def lookahead_1(context, currentToken); end
  def match_BackgroundLine(context, token); end
  def match_Comment(context, token); end
  def match_DocStringSeparator(context, token); end
  def match_EOF(context, token); end
  def match_Empty(context, token); end
  def match_ExamplesLine(context, token); end
  def match_FeatureLine(context, token); end
  def match_Language(context, token); end
  def match_Other(context, token); end
  def match_RuleLine(context, token); end
  def match_ScenarioLine(context, token); end
  def match_StepLine(context, token); end
  def match_TableRow(context, token); end
  def match_TagLine(context, token); end
  def match_token(state, token, context); end
  def match_token_at_0(token, context); end
  def match_token_at_1(token, context); end
  def match_token_at_10(token, context); end
  def match_token_at_11(token, context); end
  def match_token_at_12(token, context); end
  def match_token_at_13(token, context); end
  def match_token_at_14(token, context); end
  def match_token_at_15(token, context); end
  def match_token_at_16(token, context); end
  def match_token_at_17(token, context); end
  def match_token_at_18(token, context); end
  def match_token_at_19(token, context); end
  def match_token_at_2(token, context); end
  def match_token_at_20(token, context); end
  def match_token_at_21(token, context); end
  def match_token_at_22(token, context); end
  def match_token_at_23(token, context); end
  def match_token_at_24(token, context); end
  def match_token_at_25(token, context); end
  def match_token_at_26(token, context); end
  def match_token_at_27(token, context); end
  def match_token_at_28(token, context); end
  def match_token_at_29(token, context); end
  def match_token_at_3(token, context); end
  def match_token_at_30(token, context); end
  def match_token_at_31(token, context); end
  def match_token_at_32(token, context); end
  def match_token_at_33(token, context); end
  def match_token_at_34(token, context); end
  def match_token_at_35(token, context); end
  def match_token_at_36(token, context); end
  def match_token_at_37(token, context); end
  def match_token_at_38(token, context); end
  def match_token_at_39(token, context); end
  def match_token_at_4(token, context); end
  def match_token_at_40(token, context); end
  def match_token_at_41(token, context); end
  def match_token_at_43(token, context); end
  def match_token_at_44(token, context); end
  def match_token_at_45(token, context); end
  def match_token_at_46(token, context); end
  def match_token_at_47(token, context); end
  def match_token_at_48(token, context); end
  def match_token_at_49(token, context); end
  def match_token_at_5(token, context); end
  def match_token_at_50(token, context); end
  def match_token_at_6(token, context); end
  def match_token_at_7(token, context); end
  def match_token_at_8(token, context); end
  def match_token_at_9(token, context); end
  def parse(token_scanner, token_matcher = nil); end
  def read_token(context); end
  def start_rule(context, rule_type); end
  def stop_at_first_error; end
  def stop_at_first_error=(arg0); end
end
module Gherkin::Pickles
end
class Gherkin::Pickles::Compiler
  def compile(gherkin_document, source); end
  def compile_feature(pickles, language, tags, feature, source); end
  def compile_rule(pickles, language, feature_tags, feature_background_steps, rule, source); end
  def compile_scenario(inherited_tags, background_steps, scenario, language, pickles, source); end
  def compile_scenario_outline(inherited_tags, background_steps, scenario, language, pickles, source); end
  def initialize(id_generator); end
  def interpolate(name, variable_cells, value_cells); end
  def pickle_data_table(data_table, variable_cells, value_cells); end
  def pickle_doc_string(doc_string, variable_cells, value_cells); end
  def pickle_step_props(step, variable_cells, values_row, keyword_type); end
  def pickle_tag(tag); end
  def pickle_tags(tags); end
end
module Gherkin::Stream
end
class Gherkin::Stream::ParserMessageStream
  def build_gherkin_document(source); end
  def initialize(paths, sources, options); end
  def messages; end
  def sources; end
  def yield_parse_errors(y, errors, uri); end
end
class Gherkin::Query
  def initialize; end
  def location(ast_node_id); end
  def scenario_parent_locations(scenario_node_id); end
  def store_node_location(node); end
  def store_nodes_location(nodes); end
  def update(message); end
  def update_background(parent, background); end
  def update_feature(feature); end
  def update_rule(feature, rule); end
  def update_scenario(feature, rule, scenario); end
  def update_steps(steps); end
end
