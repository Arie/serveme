# This file is autogenerated. Do not edit it by hand. Regenerate it with:
#   srb rbi gems

# typed: true
#
# If you would like to make changes to this file, great! Please create the gem's shim here:
#
#   https://github.com/sorbet/sorbet-typed/new/master?filename=lib/cucumber/all/cucumber.rbi
#
# cucumber-9.2.0

module Cucumber
  def self.deprecate(message, method, remove_after_version); end
  def self.file_mode(mode, encoding = nil); end
  def self.logger; end
  def self.logger=(logger); end
  def self.use_full_backtrace; end
  def self.use_full_backtrace=(arg0); end
  def self.use_legacy_autoloader; end
  def self.use_legacy_autoloader=(arg0); end
  def self.wants_to_quit; end
  def self.wants_to_quit=(arg0); end
end
module Cucumber::Constantize
  def constantize(camel_cased_word); end
  def constantize_name(constant, name); end
  def underscore(camel_cased_word); end
end
module Cucumber::Cli
end
class Cucumber::Cli::RerunFile
  def features; end
  def initialize(path); end
  def lines; end
  def path; end
  def self.can_read?(path); end
  def self.real_path(path); end
end
module Cucumber::Events
  def self.make_event_bus; end
  def self.registry; end
end
class Anonymous_Cucumber_Core_Event_643 < Cucumber::Core::Event
  def attributes; end
  def envelope; end
  def event_id; end
  def initialize(*attributes); end
  def to_h; end
end
class Cucumber::Events::Envelope < Anonymous_Cucumber_Core_Event_643
  def envelope; end
end
class Anonymous_Cucumber_Core_Event_644 < Cucumber::Core::Event
  def attributes; end
  def event_id; end
  def gherkin_document; end
  def initialize(*attributes); end
  def to_h; end
end
class Cucumber::Events::GherkinSourceParsed < Anonymous_Cucumber_Core_Event_644
  def gherkin_document; end
end
class Anonymous_Cucumber_Core_Event_645 < Cucumber::Core::Event
  def attributes; end
  def body; end
  def event_id; end
  def initialize(*attributes); end
  def path; end
  def to_h; end
end
class Cucumber::Events::GherkinSourceRead < Anonymous_Cucumber_Core_Event_645
  def body; end
  def path; end
end
class Anonymous_Cucumber_Core_Event_646 < Cucumber::Core::Event
  def attributes; end
  def event_id; end
  def hook; end
  def initialize(*attributes); end
  def test_step; end
  def to_h; end
end
class Cucumber::Events::HookTestStepCreated < Anonymous_Cucumber_Core_Event_646
  def hook; end
  def test_step; end
end
class Anonymous_Cucumber_Core_Event_647 < Cucumber::Core::Event
  def attributes; end
  def event_id; end
  def initialize(*attributes); end
  def step_match; end
  def test_step; end
  def to_h; end
end
class Cucumber::Events::StepActivated < Anonymous_Cucumber_Core_Event_647
  def step_match; end
  def test_step; end
end
class Anonymous_Cucumber_Core_Event_648 < Cucumber::Core::Event
  def attributes; end
  def event_id; end
  def initialize(*attributes); end
  def step_definition; end
  def to_h; end
end
class Cucumber::Events::StepDefinitionRegistered < Anonymous_Cucumber_Core_Event_648
  def step_definition; end
end
class Anonymous_Cucumber_Core_Event_649 < Cucumber::Core::Event
  def attributes; end
  def event_id; end
  def initialize(*attributes); end
  def pickle; end
  def test_case; end
  def to_h; end
end
class Cucumber::Events::TestCaseCreated < Anonymous_Cucumber_Core_Event_649
  def pickle; end
  def test_case; end
end
class Cucumber::Events::TestCaseFinished < Cucumber::Core::Events::TestCaseFinished
  def result; end
  def test_case; end
end
class Anonymous_Cucumber_Core_Event_650 < Cucumber::Core::Event
  def attributes; end
  def event_id; end
  def initialize(*attributes); end
  def test_case; end
  def to_h; end
end
class Cucumber::Events::TestCaseReady < Anonymous_Cucumber_Core_Event_650
  def test_case; end
end
class Cucumber::Events::TestCaseStarted < Cucumber::Core::Events::TestCaseStarted
  def test_case; end
end
class Anonymous_Cucumber_Core_Event_651 < Cucumber::Core::Event
  def attributes; end
  def event_id; end
  def initialize(*attributes); end
  def success; end
  def to_h; end
end
class Cucumber::Events::TestRunFinished < Anonymous_Cucumber_Core_Event_651
  def success; end
end
class Anonymous_Cucumber_Core_Event_652 < Cucumber::Core::Event
  def attributes; end
  def event_id; end
  def initialize(*attributes); end
  def test_cases; end
  def to_h; end
end
class Cucumber::Events::TestRunStarted < Anonymous_Cucumber_Core_Event_652
  def test_cases; end
end
class Anonymous_Cucumber_Core_Event_653 < Cucumber::Core::Event
  def attributes; end
  def event_id; end
  def initialize(*attributes); end
  def pickle_step; end
  def test_step; end
  def to_h; end
end
class Cucumber::Events::TestStepCreated < Anonymous_Cucumber_Core_Event_653
  def pickle_step; end
  def test_step; end
end
class Cucumber::Events::TestStepFinished < Cucumber::Core::Events::TestStepFinished
  def result; end
  def test_step; end
end
class Cucumber::Events::TestStepStarted < Cucumber::Core::Events::TestStepStarted
  def test_step; end
end
class Anonymous_Cucumber_Core_Event_654 < Cucumber::Core::Event
  def attributes; end
  def event_id; end
  def expression; end
  def initialize(*attributes); end
  def to_h; end
  def type_name; end
end
class Cucumber::Events::UndefinedParameterType < Anonymous_Cucumber_Core_Event_654
  def expression; end
  def type_name; end
end
class Cucumber::Configuration
  def all_files_to_load; end
  def autoload_code_paths; end
  def custom_profiles; end
  def default_features_paths; end
  def default_options; end
  def dry_run?; end
  def duration?; end
  def error_stream; end
  def event_bus; end
  def expand?; end
  def fail_fast?; end
  def feature_dirs; end
  def feature_files; end
  def filters; end
  def formats; end
  def formatter_class(format); end
  def formatter_factories; end
  def guess?; end
  def id_generator; end
  def initialize(user_options = nil); end
  def name_regexps; end
  def notify(message, *args); end
  def on_event(*args, **, &block); end
  def out_stream; end
  def paths; end
  def profiles; end
  def publish_enabled?; end
  def publish_quiet?; end
  def randomize?; end
  def register_snippet_generator(generator); end
  def remove_excluded_files_from(files); end
  def require_dirs; end
  def retry_attempts; end
  def retry_total_tests; end
  def seed; end
  def self.default; end
  def skip_profile_information?; end
  def snippet_generators; end
  def snippet_type; end
  def snippets?; end
  def source?; end
  def step_defs_to_load; end
  def strict; end
  def support_to_load; end
  def tag_expressions; end
  def tag_limits; end
  def to_hash; end
  def wip?; end
  def with_default_features_path(paths); end
  def with_options(new_options); end
  extend Forwardable
  include Cucumber::Constantize
end
module Cucumber::Gherkin
end
module Cucumber::Gherkin::Formatter
end
module Cucumber::Gherkin::Formatter::AnsiEscapes
  def comments; end
  def comments_arg; end
  def executing; end
  def executing_arg; end
  def failed; end
  def failed_arg; end
  def outline; end
  def outline_arg; end
  def passed; end
  def passed_arg; end
  def pending; end
  def pending_arg; end
  def reset; end
  def skipped; end
  def skipped_arg; end
  def tag; end
  def tag_arg; end
  def undefined; end
  def undefined_arg; end
  def up(amount); end
end
module Cucumber::LoadPath
  def add_dirs(*dirs); end
  def self.add_dirs(*dirs); end
end
module Cucumber::Formatter
end
module Cucumber::Formatter::Duration
  def format_duration(seconds); end
end
class Cucumber::FileSpecs
  def files; end
  def initialize(file_specs); end
  def locations; end
end
class Cucumber::FileSpecs::FileSpec
  def file; end
  def initialize(spec); end
  def locations; end
end
class Cucumber::Gherkin::DataTableParser
  def feature_header; end
  def gherkin_options; end
  def initialize(builder); end
  def parse(text); end
end
module Cucumber::Gherkin::Formatter::Escaping
  def escape_cell(sym); end
end
module Cucumber::MultilineArgument
  def self.builder; end
  def self.from(argument, location = nil, content_type = nil); end
  def self.from_core(node); end
end
class Cucumber::MultilineArgument::DataTable
  def append_to(array); end
  def build_hashes; end
  def cell_matrix; end
  def cells_rows; end
  def cells_to_hash(cells); end
  def clear_cache!; end
  def col_width(col); end
  def column_names; end
  def columns; end
  def convert_columns!; end
  def convert_headers!; end
  def create_cell_matrix(ast_table); end
  def describe_to(visitor, *args); end
  def diff!(other_table, options = nil); end
  def each_cells_row(&proc); end
  def ensure_table(table_or_array); end
  def file; end
  def file=(arg0); end
  def hashes; end
  def header_cell(col); end
  def headers; end
  def index(cells); end
  def initialize(data, conversion_procs = nil, header_mappings = nil, header_conversion_proc = nil); end
  def location; end
  def map_column(column_name, strict: nil, &conversion_proc); end
  def map_headers(mappings = nil, &block); end
  def match(pattern); end
  def raw; end
  def rows; end
  def rows_hash; end
  def self.default_arg_name; end
  def self.from(data); end
  def self.from_array(data); end
  def self.parse(text); end
  def symbolic_hashes; end
  def symbolize_key(key); end
  def text?(text); end
  def to_hash; end
  def to_json(*args); end
  def to_s(options = nil); end
  def to_step_definition_arg; end
  def transpose; end
  def verify_column(column_name); end
  def verify_table_width(width); end
end
class Cucumber::MultilineArgument::DataTable::DiffMatrices
  def call; end
  def cell_matrix; end
  def cell_matrix=(arg0); end
  def changes; end
  def ensure_2d(array); end
  def fill_in_missing_values; end
  def initialize(cell_matrix, other_table_cell_matrix, options); end
  def insert_row_pos; end
  def inspect_rows(missing_row, inserted_row); end
  def mark_as_missing(col); end
  def misplaced_col; end
  def missing_col; end
  def missing_row_pos; end
  def options; end
  def options=(arg0); end
  def original_header; end
  def original_width; end
  def other_table_cell_matrix; end
  def other_table_cell_matrix=(arg0); end
  def pad_and_match; end
  def padded_width; end
  def perform_diff; end
  def prepare_diff; end
  def raise_error; end
  def row_indices; end
  def should_raise?; end
  def surplus_col; end
end
class Cucumber::MultilineArgument::DataTable::Builder
  def eof; end
  def initialize; end
  def row(row); end
  def rows; end
end
class Cucumber::MultilineArgument::DataTable::Different < StandardError
  def initialize(table); end
  def table; end
end
class Cucumber::MultilineArgument::DataTable::DataTablePrinter
  def data_table; end
  def format_cell(cell, col_width); end
  def format_row(row); end
  def indentation; end
  def initialize(data_table, indentation, prefixes); end
  def prefixes; end
  def to_s; end
  include Cucumber::Gherkin::Formatter::Escaping
end
class Cucumber::MultilineArgument::DataTable::Cells
  def [](index); end
  def accept(visitor); end
  def dom_id; end
  def each(&proc); end
  def exception; end
  def index; end
  def initialize(table, cells); end
  def line; end
  def to_hash; end
  def to_sexp; end
  def value(index); end
  def width; end
  include Cucumber::Gherkin::Formatter::Escaping
  include Enumerable
end
class Cucumber::MultilineArgument::DataTable::Cell
  def ==(other); end
  def eql?(other); end
  def hash; end
  def initialize(value, table, line); end
  def inspect!; end
  def line; end
  def status; end
  def status=(arg0); end
  def table; end
  def to_sexp; end
  def value; end
  def value=(arg0); end
end
class Cucumber::MultilineArgument::DataTable::SurplusCell < Cucumber::MultilineArgument::DataTable::Cell
  def ==(_other); end
  def hash; end
  def status; end
end
class Cucumber::MultilineArgument::DocString < SimpleDelegator
  def append_to(array); end
end
class InvalidName___Class_0x00___Builder_655
  def data_table(node, *_args); end
  def doc_string(node, *_args); end
  def wrap(node); end
end
class Cucumber::MultilineArgument::None
  def append_to(array); end
  def describe_to(visitor); end
end
class Cucumber::StepMatch
  def activate(test_step); end
  def args; end
  def backtrace_line; end
  def file_colon_line; end
  def format_args(format = nil, &proc); end
  def initialize(step_definition, step_name, step_arguments); end
  def inspect; end
  def invoke(multiline_arg); end
  def location; end
  def replace_arguments(string, step_arguments, format); end
  def step_arguments; end
  def step_definition; end
  def text_length; end
end
class Cucumber::SkippingStepMatch
  def activate(test_step); end
end
class Cucumber::NoStepMatch
  def activate(test_step); end
  def backtrace_line; end
  def file_colon_line; end
  def format_args(*_args); end
  def initialize(step, name); end
  def location; end
  def name; end
  def step_arguments; end
  def step_definition; end
  def text_length; end
end
class Cucumber::AmbiguousStepMatch
  def activate(test_step); end
  def initialize(error); end
end
class Cucumber::Undefined < Cucumber::Core::Test::Result::Undefined
  def self.from(result, step_name); end
  def self.with_prefix(step_name); end
end
class Cucumber::UndefinedDynamicStep < StandardError
  def initialize(step_name); end
end
class Cucumber::Pending < Cucumber::Core::Test::Result::Pending
end
class Cucumber::Ambiguous < StandardError
  def initialize(step_name, step_definitions, used_guess); end
end
class Cucumber::TagExcess < StandardError
  def initialize(messages); end
end
module Cucumber::Filters
end
class Anonymous_Object_656
  def configuration; end
  def done; end
  def initialize(*args); end
  def receiver; end
  def step_match_search; end
  def test_case(test_case); end
  def with_receiver(new_receiver); end
end
class Cucumber::Filters::ActivateSteps < Anonymous_Object_656
  def test_case(test_case); end
end
class Cucumber::Filters::ActivateSteps::CaseFilter
  def attempt_to_activate(test_step); end
  def find_match(test_step); end
  def initialize(test_case, step_match_search, configuration); end
  def new_test_steps; end
  def test_case; end
end
class Cucumber::Filters::ActivateSteps::CaseFilter::FindMatch
  def configuration; end
  def initialize(step_match_search, configuration, test_step); end
  def match; end
  def matches; end
  def result; end
  def step_match_search; end
  def test_step; end
end
class Anonymous_Object_657
  def done; end
  def hooks; end
  def initialize(*args); end
  def receiver; end
  def test_case(test_case); end
  def with_receiver(new_receiver); end
end
class Cucumber::Filters::ApplyAfterStepHooks < Anonymous_Object_657
  def test_case(test_case); end
end
class Anonymous_Object_658
  def done; end
  def hooks; end
  def initialize(*args); end
  def receiver; end
  def test_case(test_case); end
  def with_receiver(new_receiver); end
end
class Cucumber::Filters::ApplyBeforeHooks < Anonymous_Object_658
  def test_case(test_case); end
end
class Anonymous_Object_659
  def done; end
  def hooks; end
  def initialize(*args); end
  def receiver; end
  def test_case(test_case); end
  def with_receiver(new_receiver); end
end
class Cucumber::Filters::ApplyAfterHooks < Anonymous_Object_659
  def test_case(test_case); end
end
class Anonymous_Object_660
  def done; end
  def hooks; end
  def initialize(*args); end
  def receiver; end
  def test_case(test_case); end
  def with_receiver(new_receiver); end
end
class Cucumber::Filters::ApplyAroundHooks < Anonymous_Object_660
  def test_case(test_case); end
end
class Anonymous_Object_661
  def config; end
  def done; end
  def initialize(*args); end
  def receiver; end
  def test_case(test_case); end
  def with_receiver(new_receiver); end
end
class Cucumber::Filters::BroadcastTestRunStartedEvent < Anonymous_Object_661
  def done; end
  def initialize(config, receiver = nil); end
  def test_case(test_case); end
end
module Cucumber::RunningTestCase
  def self.new(test_case); end
end
class Cucumber::RunningTestCase::TestCase < SimpleDelegator
  def accept_hook?(hook); end
  def exception; end
  def failed?; end
  def initialize(test_case, result = nil); end
  def passed?; end
  def source_tag_names; end
  def status; end
  def with_result(result); end
end
class Anonymous_Object_662
  def done; end
  def initialize(*args); end
  def receiver; end
  def runtime; end
  def test_case(test_case); end
  def with_receiver(new_receiver); end
end
class Cucumber::Filters::PrepareWorld < Anonymous_Object_662
  def test_case(test_case); end
end
class Cucumber::Filters::PrepareWorld::CaseFilter
  def initialize(runtime, original_test_case); end
  def scenario; end
  def test_case; end
end
class Cucumber::Filters::Quit
  def done; end
  def initialize(receiver = nil); end
  def test_case(test_case); end
  def with_receiver(receiver); end
end
class Cucumber::Filters::Randomizer
  def done; end
  def initialize(seed, receiver = nil); end
  def seed; end
  def shuffled_test_cases; end
  def test_case(test_case); end
  def with_receiver(receiver); end
end
class Anonymous_Object_663
  def configuration; end
  def done; end
  def initialize(*args); end
  def receiver; end
  def test_case(test_case); end
  def with_receiver(new_receiver); end
end
class Cucumber::Filters::Retry < Anonymous_Object_663
  def initialize(*_args); end
  def retry_required?(test_case, event); end
  def test_case(test_case); end
  def test_case_counts; end
end
class Cucumber::Filters::GatedReceiver
  def done; end
  def initialize(receiver); end
  def test_case(test_case); end
end
class Cucumber::Filters::TagLimits
  def done; end
  def gated_receiver; end
  def initialize(tag_limits, receiver = nil); end
  def test_case(test_case); end
  def test_case_index; end
  def verifier; end
  def with_receiver(receiver); end
end
class Cucumber::Filters::TagLimits::TestCaseIndex
  def add(test_case); end
  def count_by_tag_name(tag_name); end
  def index; end
  def index=(arg0); end
  def initialize; end
  def locations_of_tag_name(tag_name); end
end
class Cucumber::Filters::TagLimits::Verifier
  def collect_breaches(test_case_index); end
  def initialize(tag_limits); end
  def tag_limits; end
  def verify!(test_case_index); end
end
class Cucumber::Filters::TagLimits::Verifier::Breach
  def initialize(tag_name, limit, locations); end
  def limit; end
  def locations; end
  def tag_count; end
  def tag_name; end
  def to_s; end
end
class Cucumber::Filters::TagLimitExceededError < StandardError
  def initialize(*limit_breaches); end
end
class Anonymous_Object_664
  def config; end
  def done; end
  def initialize(*args); end
  def receiver; end
  def test_case(test_case); end
  def with_receiver(new_receiver); end
end
class Cucumber::Filters::BroadcastTestCaseReadyEvent < Anonymous_Object_664
  def test_case(test_case); end
end
class Cucumber::Formatter::Fanout < BasicObject
  def initialize(recipients); end
  def method_missing(message, *args); end
  def recipients; end
  def respond_to_missing?(name, include_private = nil); end
end
module Cucumber::Gherkin::I18n
  def self.code_keyword_for(gherkin_keyword); end
  def self.code_keywords_for(gherkin_keywords); end
end
module Cucumber::Glue
  def self.backtrace_line(proc, name); end
end
class Cucumber::Glue::RegistryWrapper
  def create_expression(string_or_regexp); end
  def current_world; end
  def initialize(registry); end
end
module Cucumber::StepMatchSearch
  def self.new(search, configuration); end
end
class Cucumber::StepMatchSearch::AssertUnambiguousMatch
  def call(step_name); end
  def initialize(search, configuration); end
end
class Cucumber::StepMatchSearch::AttemptToGuessAmbiguousMatch
  def best_matches(_step_name, step_matches); end
  def call(step_name); end
  def initialize(search); end
end
class Cucumber::StepMatchSearch::CachesStepMatch < SimpleDelegator
  def call(step_name); end
end
class Cucumber::Runtime
  def accept_options?(factory); end
  def begin_scenario(test_case); end
  def configuration; end
  def configure(new_configuration); end
  def create_formatter(factory, formatter_options, path_or_io); end
  def doc_string(string_without_triple_quotes, content_type = nil, _line_offset = nil); end
  def dry_run?; end
  def end_scenario(_scenario); end
  def fail_fast_report; end
  def failure?; end
  def feature_files; end
  def features; end
  def features_paths; end
  def filespecs; end
  def filters; end
  def fire_after_all_hook; end
  def fire_before_all_hook; end
  def fire_install_plugin_hook; end
  def formatters; end
  def initialize(configuration = nil); end
  def load_step_definitions; end
  def log; end
  def publish_banner_printer; end
  def registry_wrapper; end
  def report; end
  def results; end
  def run!; end
  def summary_report; end
  def support_code; end
  def unmatched_step_definitions; end
  include Cucumber::Core
  include Cucumber::Formatter::Duration
  include Cucumber::Runtime::UserInterface
end
class Cucumber::Runtime::MetaMessageBuilder
  def self.build_meta_message(env = nil); end
  def self.ci(env); end
  def self.cpu; end
  def self.git_info(ci_data); end
  def self.implementation; end
  def self.os; end
  def self.protocol_version; end
  def self.runtime; end
end
module Cucumber::Runtime::UserInterface
  def ask(question, timeout_seconds); end
  def attach(src, media_type, filename); end
  def jruby_gets(timeout_seconds); end
  def mri_gets(timeout_seconds); end
  def visitor=(arg0); end
end
class Cucumber::Runtime::ForProgrammingLanguages
  def ask(*args, **, &block); end
  def attach(*args, **, &block); end
  def embed(*args, **, &block); end
  def features_paths(*args, **, &block); end
  def initialize(support_code, user_interface); end
  def invoke_dynamic_step(*args, **, &block); end
  def invoke_dynamic_steps(*args, **, &block); end
  def puts(*args, **, &block); end
  def step_match(*args, **, &block); end
  def support_code; end
  extend Forwardable
end
class Cucumber::Runtime::StepHooks
  def after_step_hooks(test_step); end
  def apply(test_steps); end
  def initialize(id_generator, hooks, event_bus); end
end
module Cucumber::Hooks
  def self.after_hook(id, location, &block); end
  def self.after_step_hook(id, test_step, location, &block); end
  def self.around_hook(&block); end
  def self.before_hook(id, location, &block); end
  def self.build_hook_step(id, location, block, hook_type, action_type); end
end
class Cucumber::Hooks::AfterHook
  def describe_to(visitor, *args); end
  def initialize(location); end
  def location; end
  def match_locations?(queried_locations); end
  def text; end
  def to_s; end
end
class Cucumber::Hooks::BeforeHook
  def describe_to(visitor, *args); end
  def initialize(location); end
  def location; end
  def match_locations?(queried_locations); end
  def text; end
  def to_s; end
end
class Cucumber::Hooks::AfterStepHook
  def describe_to(visitor, *args); end
  def initialize(location); end
  def location; end
  def match_locations?(queried_locations); end
  def text; end
  def to_s; end
end
class Cucumber::Runtime::BeforeHooks
  def apply_to(test_case); end
  def before_hooks; end
  def initialize(id_generator, hooks, scenario, event_bus); end
end
class Cucumber::Runtime::AfterHooks
  def after_hooks; end
  def apply_to(test_case); end
  def initialize(id_generator, hooks, scenario, event_bus); end
end
class Cucumber::Gherkin::StepsParser
  def feature_header(dialect); end
  def gherkin_options; end
  def initialize(builder, language); end
  def parse(text); end
end
class Cucumber::Runtime::SupportCode
  def apply_after_hooks(test_case); end
  def apply_before_hooks(test_case); end
  def configure(new_configuration); end
  def find_after_step_hooks(test_case); end
  def find_around_hooks(test_case); end
  def fire_hook(name, *args); end
  def initialize(user_interface, configuration = nil); end
  def invoke_dynamic_step(step_name, multiline_argument, _location = nil); end
  def invoke_dynamic_steps(steps_text, iso_code, _location); end
  def load_file(file); end
  def load_files!(files); end
  def load_files_from_paths(paths); end
  def log; end
  def registry; end
  def step_definitions; end
  def step_matches(step_name); end
  def unmatched_step_definitions; end
  include Cucumber::Constantize
end
class Cucumber::Runtime::SupportCode::StepInvoker
  def initialize(support_code); end
  def multiline_arg(step, location); end
  def step(step); end
  def steps(steps); end
end
class Cucumber::Formatter::IgnoreMissingMessages < BasicObject
  def initialize(receiver); end
  def method_missing(message, *args); end
  def respond_to_missing?(name, include_private = nil); end
end
class Cucumber::Formatter::CurlOptionParser
  def self.parse(options); end
  def self.parse_header(header_arg); end
  def self.remove_arg_for(args, arg); end
end
class Cucumber::Formatter::IOHTTPBuffer
  def build_client(uri); end
  def build_request(uri, method, headers); end
  def close; end
  def closed?; end
  def flush; end
  def headers; end
  def initialize(uri, method, headers = nil, https_verify_mode = nil, reporter = nil); end
  def method; end
  def response; end
  def send_content(uri, method, headers, attempts_remaining = nil); end
  def uri; end
  def write(data); end
end
class Cucumber::Formatter::HTTPIO
  def self.open(url, https_verify_mode = nil, reporter = nil); end
end
class Cucumber::Formatter::URLReporter
  def initialize(io); end
  def report(banner); end
end
class Cucumber::Formatter::NoReporter
  def report(_banner); end
end
class Cucumber::Cli::ProfileLoader
  def args_from(profile); end
  def cucumber_file; end
  def cucumber_yml; end
  def cucumber_yml_defined?; end
  def ensure_configuration_file_exists; end
  def initialize; end
  def load_configuration; end
  def process_configuration_file_with_erb; end
  def processed_shellwords(args_from_yml); end
  def profile?(profile); end
end
module Cucumber::Term
end
module Cucumber::Term::ANSIColor
  def attributes; end
  def black(text = nil, &block); end
  def blink(text = nil, &block); end
  def blue(text = nil, &block); end
  def bold(text = nil, &block); end
  def clear(text = nil, &block); end
  def colorize(text, color_code); end
  def concealed(text = nil, &block); end
  def cyan(text = nil, &block); end
  def dark(text = nil, &block); end
  def green(text = nil, &block); end
  def grey(text = nil, &block); end
  def italic(text = nil, &block); end
  def magenta(text = nil, &block); end
  def negative(text = nil, &block); end
  def on_black(text = nil, &block); end
  def on_blue(text = nil, &block); end
  def on_cyan(text = nil, &block); end
  def on_green(text = nil, &block); end
  def on_magenta(text = nil, &block); end
  def on_red(text = nil, &block); end
  def on_white(text = nil, &block); end
  def on_yellow(text = nil, &block); end
  def rapid_blink(text = nil, &block); end
  def red(text = nil, &block); end
  def reset(text = nil, &block); end
  def self.coloring; end
  def self.coloring=(arg0); end
  def self.coloring?; end
  def self.included(klass); end
  def strikethrough(text = nil, &block); end
  def uncolored(text = nil); end
  def uncolorize(string); end
  def underline(text = nil, &block); end
  def underscore(text = nil, &block); end
  def white(text = nil, &block); end
  def yellow(text = nil, &block); end
end
module Cucumber::Formatter::ANSIColor
  def apply_styles(styles, text = nil, &proc); end
  def comment(text = nil, &proc); end
  def comment_param(text = nil, &proc); end
  def cukes(amount); end
  def failed(text = nil, &proc); end
  def failed_param(text = nil, &proc); end
  def flaky(text = nil, &proc); end
  def flaky_param(text = nil, &proc); end
  def green_cukes(amount); end
  def outline(text = nil, &proc); end
  def outline_param(text = nil, &proc); end
  def passed(text = nil, &proc); end
  def passed_param(text = nil, &proc); end
  def pending(text = nil, &proc); end
  def pending_param(text = nil, &proc); end
  def red_cukes(amount); end
  def self.apply_custom_colors(colors); end
  def skipped(text = nil, &proc); end
  def skipped_param(text = nil, &proc); end
  def tag(text = nil, &proc); end
  def tag_param(text = nil, &proc); end
  def undefined(text = nil, &proc); end
  def undefined_param(text = nil, &proc); end
  def yellow_cukes(amount); end
  include Cucumber::Term::ANSIColor
end
module Cucumber::Glue::Dsl
  def 7(regexp, symbol = nil, options = nil, &proc); end
  def A(regexp, symbol = nil, options = nil, &proc); end
  def AN(regexp, symbol = nil, options = nil, &proc); end
  def Aber(regexp, symbol = nil, options = nil, &proc); end
  def Ac(regexp, symbol = nil, options = nil, &proc); end
  def Ach(regexp, symbol = nil, options = nil, &proc); end
  def Adott(regexp, symbol = nil, options = nil, &proc); end
  def After(*tag_expressions, name: nil, &proc); end
  def AfterAll(name: nil, &proc); end
  def AfterStep(*tag_expressions, name: nil, &proc); end
  def Agus(regexp, symbol = nil, options = nil, &proc); end
  def Ak(regexp, symbol = nil, options = nil, &proc); end
  def Akkor(regexp, symbol = nil, options = nil, &proc); end
  def Alavez(regexp, symbol = nil, options = nil, &proc); end
  def Ale(regexp, symbol = nil, options = nil, &proc); end
  def Aleshores(regexp, symbol = nil, options = nil, &proc); end
  def Ali(regexp, symbol = nil, options = nil, &proc); end
  def Allgitout(regexp, symbol = nil, options = nil, &proc); end
  def Allora(regexp, symbol = nil, options = nil, &proc); end
  def Alors(regexp, symbol = nil, options = nil, &proc); end
  def Als(regexp, symbol = nil, options = nil, &proc); end
  def Ama(regexp, symbol = nil, options = nil, &proc); end
  def Amennyiben(regexp, symbol = nil, options = nil, &proc); end
  def Amikor(regexp, symbol = nil, options = nil, &proc); end
  def Amma(regexp, symbol = nil, options = nil, &proc); end
  def Ampak(regexp, symbol = nil, options = nil, &proc); end
  def An(regexp, symbol = nil, options = nil, &proc); end
  def Ananging(regexp, symbol = nil, options = nil, &proc); end
  def Ancaq(regexp, symbol = nil, options = nil, &proc); end
  def And(regexp, symbol = nil, options = nil, &proc); end
  def Angenommen(regexp, symbol = nil, options = nil, &proc); end
  def Anrhegediga(regexp, symbol = nil, options = nil, &proc); end
  def Ansin(regexp, symbol = nil, options = nil, &proc); end
  def Antonces(regexp, symbol = nil, options = nil, &proc); end
  def Apabila(regexp, symbol = nil, options = nil, &proc); end
  def Around(*tag_expressions, name: nil, &proc); end
  def Ataktiež(regexp, symbol = nil, options = nil, &proc); end
  def Ataké(regexp, symbol = nil, options = nil, &proc); end
  def Atesa(regexp, symbol = nil, options = nil, &proc); end
  def Atiež(regexp, symbol = nil, options = nil, &proc); end
  def Atunci(regexp, symbol = nil, options = nil, &proc); end
  def Atès(regexp, symbol = nil, options = nil, &proc); end
  def Avast(regexp, symbol = nil, options = nil, &proc); end
  def Aye(regexp, symbol = nil, options = nil, &proc); end
  def Azároveň(regexp, symbol = nil, options = nil, &proc); end
  def BUT(regexp, symbol = nil, options = nil, &proc); end
  def Bagi(regexp, symbol = nil, options = nil, &proc); end
  def Banjur(regexp, symbol = nil, options = nil, &proc); end
  def Before(*tag_expressions, name: nil, &proc); end
  def BeforeAll(name: nil, &proc); end
  def Belgilangan(regexp, symbol = nil, options = nil, &proc); end
  def Bet(regexp, symbol = nil, options = nil, &proc); end
  def Bila(regexp, symbol = nil, options = nil, &proc); end
  def Biết(regexp, symbol = nil, options = nil, &proc); end
  def Blimey(regexp, symbol = nil, options = nil, &proc); end
  def Buh(regexp, symbol = nil, options = nil, &proc); end
  def But(regexp, symbol = nil, options = nil, &proc); end
  def ButattheendofthedayIreckon(regexp, symbol = nil, options = nil, &proc); end
  def Bæþsealf(regexp, symbol = nil, options = nil, &proc); end
  def Bæþsealfa(regexp, symbol = nil, options = nil, &proc); end
  def Bæþsealfe(regexp, symbol = nil, options = nil, &proc); end
  def Cal(regexp, symbol = nil, options = nil, &proc); end
  def Cand(regexp, symbol = nil, options = nil, &proc); end
  def Cando(regexp, symbol = nil, options = nil, &proc); end
  def Ce(regexp, symbol = nil, options = nil, &proc); end
  def Cho(regexp, symbol = nil, options = nil, &proc); end
  def Ciricæw(regexp, symbol = nil, options = nil, &proc); end
  def Ciricæwa(regexp, symbol = nil, options = nil, &proc); end
  def Ciricæwe(regexp, symbol = nil, options = nil, &proc); end
  def Comehellorhighwater(regexp, symbol = nil, options = nil, &proc); end
  def Cuan(regexp, symbol = nil, options = nil, &proc); end
  def Cuando(regexp, symbol = nil, options = nil, &proc); end
  def Cuirigcásgo(regexp, symbol = nil, options = nil, &proc); end
  def Cuirigcásgur(regexp, symbol = nil, options = nil, &proc); end
  def Cuirigcásnach(regexp, symbol = nil, options = nil, &proc); end
  def Cuirigcásnár(regexp, symbol = nil, options = nil, &proc); end
  def Când(regexp, symbol = nil, options = nil, &proc); end
  def DEN(regexp, symbol = nil, options = nil, &proc); end
  def DaHghubejlu(regexp, symbol = nil, options = nil, &proc); end
  def Dada(regexp, symbol = nil, options = nil, &proc); end
  def Dadas(regexp, symbol = nil, options = nil, &proc); end
  def Dadena(regexp, symbol = nil, options = nil, &proc); end
  def Dadeno(regexp, symbol = nil, options = nil, &proc); end
  def Dado(regexp, symbol = nil, options = nil, &proc); end
  def Dados(regexp, symbol = nil, options = nil, &proc); end
  def Daes(regexp, symbol = nil, options = nil, &proc); end
  def Dan(regexp, symbol = nil, options = nil, &proc); end
  def Dann(regexp, symbol = nil, options = nil, &proc); end
  def Dano(regexp, symbol = nil, options = nil, &proc); end
  def Daos(regexp, symbol = nil, options = nil, &proc); end
  def Dar(regexp, symbol = nil, options = nil, &proc); end
  def Data(regexp, symbol = nil, options = nil, &proc); end
  def Date(regexp, symbol = nil, options = nil, &proc); end
  def Datefiind(regexp, symbol = nil, options = nil, &proc); end
  def Datfiind(regexp, symbol = nil, options = nil, &proc); end
  def Dati(regexp, symbol = nil, options = nil, &proc); end
  def Datifiind(regexp, symbol = nil, options = nil, &proc); end
  def Dato(regexp, symbol = nil, options = nil, &proc); end
  def Datăfiind(regexp, symbol = nil, options = nil, &proc); end
  def Dau(regexp, symbol = nil, options = nil, &proc); end
  def Daus(regexp, symbol = nil, options = nil, &proc); end
  def Daţifiind(regexp, symbol = nil, options = nil, &proc); end
  def Dațifiind(regexp, symbol = nil, options = nil, &proc); end
  def De(regexp, symbol = nil, options = nil, &proc); end
  def Dengan(regexp, symbol = nil, options = nil, &proc); end
  def Denyousegotta(regexp, symbol = nil, options = nil, &proc); end
  def Diasumsikan(regexp, symbol = nil, options = nil, &proc); end
  def Diberi(regexp, symbol = nil, options = nil, &proc); end
  def Diketahui(regexp, symbol = nil, options = nil, &proc); end
  def Diyelimki(regexp, symbol = nil, options = nil, &proc); end
  def Do(regexp, symbol = nil, options = nil, &proc); end
  def Donada(regexp, symbol = nil, options = nil, &proc); end
  def Donat(regexp, symbol = nil, options = nil, &proc); end
  def Donc(regexp, symbol = nil, options = nil, &proc); end
  def Donitaĵo(regexp, symbol = nil, options = nil, &proc); end
  def Dun(regexp, symbol = nil, options = nil, &proc); end
  def Duota(regexp, symbol = nil, options = nil, &proc); end
  def Dáu(regexp, symbol = nil, options = nil, &proc); end
  def E(regexp, symbol = nil, options = nil, &proc); end
  def Ed(regexp, symbol = nil, options = nil, &proc); end
  def Eeldades(regexp, symbol = nil, options = nil, &proc); end
  def Ef(regexp, symbol = nil, options = nil, &proc); end
  def En(regexp, symbol = nil, options = nil, &proc); end
  def Entao(regexp, symbol = nil, options = nil, &proc); end
  def Entonces(regexp, symbol = nil, options = nil, &proc); end
  def Então(regexp, symbol = nil, options = nil, &proc); end
  def Entón(regexp, symbol = nil, options = nil, &proc); end
  def Entós(regexp, symbol = nil, options = nil, &proc); end
  def Epi(regexp, symbol = nil, options = nil, &proc); end
  def Et(regexp, symbol = nil, options = nil, &proc); end
  def Etantdonné(regexp, symbol = nil, options = nil, &proc); end
  def Etantdonnée(regexp, symbol = nil, options = nil, &proc); end
  def Etantdonnées(regexp, symbol = nil, options = nil, &proc); end
  def Etantdonnéqu(regexp, symbol = nil, options = nil, &proc); end
  def Etantdonnéque(regexp, symbol = nil, options = nil, &proc); end
  def Etantdonnés(regexp, symbol = nil, options = nil, &proc); end
  def Etqu(regexp, symbol = nil, options = nil, &proc); end
  def Etque(regexp, symbol = nil, options = nil, &proc); end
  def Eğerki(regexp, symbol = nil, options = nil, &proc); end
  def Fakat(regexp, symbol = nil, options = nil, &proc); end
  def Fixinto(regexp, symbol = nil, options = nil, &proc); end
  def Gangway(regexp, symbol = nil, options = nil, &proc); end
  def Gdy(regexp, symbol = nil, options = nil, &proc); end
  def Gegebensei(regexp, symbol = nil, options = nil, &proc); end
  def Gegebenseien(regexp, symbol = nil, options = nil, &proc); end
  def Gegeven(regexp, symbol = nil, options = nil, &proc); end
  def Gegewe(regexp, symbol = nil, options = nil, &proc); end
  def Gitt(regexp, symbol = nil, options = nil, &proc); end
  def Given(regexp, symbol = nil, options = nil, &proc); end
  def Givet(regexp, symbol = nil, options = nil, &proc); end
  def Givun(regexp, symbol = nil, options = nil, &proc); end
  def Ha(regexp, symbol = nil, options = nil, &proc); end
  def Həm(regexp, symbol = nil, options = nil, &proc); end
  def I(regexp, symbol = nil, options = nil, &proc); end
  def ICANHAZ(regexp, symbol = nil, options = nil, &proc); end
  def In(regexp, symbol = nil, options = nil, &proc); end
  def InstallPlugin(name: nil, &proc); end
  def Ir(regexp, symbol = nil, options = nil, &proc); end
  def Itsjustunbelievable(regexp, symbol = nil, options = nil, &proc); end
  def Ja(regexp, symbol = nil, options = nil, &proc); end
  def Jeśli(regexp, symbol = nil, options = nil, &proc); end
  def Jeżeli(regexp, symbol = nil, options = nil, &proc); end
  def Jika(regexp, symbol = nil, options = nil, &proc); end
  def Kad(regexp, symbol = nil, options = nil, &proc); end
  def Kada(regexp, symbol = nil, options = nil, &proc); end
  def Kadar(regexp, symbol = nil, options = nil, &proc); end
  def Kai(regexp, symbol = nil, options = nil, &proc); end
  def Kaj(regexp, symbol = nil, options = nil, &proc); end
  def Když(regexp, symbol = nil, options = nil, &proc); end
  def Kemudian(regexp, symbol = nil, options = nil, &proc); end
  def Ketika(regexp, symbol = nil, options = nil, &proc); end
  def Keď(regexp, symbol = nil, options = nil, &proc); end
  def Khi(regexp, symbol = nil, options = nil, &proc); end
  def Kiedy(regexp, symbol = nil, options = nil, &proc); end
  def Ko(regexp, symbol = nil, options = nil, &proc); end
  def Koga(regexp, symbol = nil, options = nil, &proc); end
  def Komence(regexp, symbol = nil, options = nil, &proc); end
  def Kui(regexp, symbol = nil, options = nil, &proc); end
  def Kuid(regexp, symbol = nil, options = nil, &proc); end
  def Kun(regexp, symbol = nil, options = nil, &proc); end
  def Lan(regexp, symbol = nil, options = nil, &proc); end
  def Le(regexp, symbol = nil, options = nil, &proc); end
  def Lesaa(regexp, symbol = nil, options = nil, &proc); end
  def Letgoandhaul(regexp, symbol = nil, options = nil, &proc); end
  def Logo(regexp, symbol = nil, options = nil, &proc); end
  def Lorsqu(regexp, symbol = nil, options = nil, &proc); end
  def Lorsque(regexp, symbol = nil, options = nil, &proc); end
  def Lè(regexp, symbol = nil, options = nil, &proc); end
  def Lèsaa(regexp, symbol = nil, options = nil, &proc); end
  def Ma(regexp, symbol = nil, options = nil, &proc); end
  def Maar(regexp, symbol = nil, options = nil, &proc); end
  def Mais(regexp, symbol = nil, options = nil, &proc); end
  def Maisqu(regexp, symbol = nil, options = nil, &proc); end
  def Maisque(regexp, symbol = nil, options = nil, &proc); end
  def Majd(regexp, symbol = nil, options = nil, &proc); end
  def Mając(regexp, symbol = nil, options = nil, &proc); end
  def Maka(regexp, symbol = nil, options = nil, &proc); end
  def Manawa(regexp, symbol = nil, options = nil, &proc); end
  def Mas(regexp, symbol = nil, options = nil, &proc); end
  def Men(regexp, symbol = nil, options = nil, &proc); end
  def Menawa(regexp, symbol = nil, options = nil, &proc); end
  def Mutta(regexp, symbol = nil, options = nil, &proc); end
  def Nalika(regexp, symbol = nil, options = nil, &proc); end
  def Nalikaning(regexp, symbol = nil, options = nil, &proc); end
  def Nanging(regexp, symbol = nil, options = nil, &proc); end
  def Nato(regexp, symbol = nil, options = nil, &proc); end
  def Nhưng(regexp, symbol = nil, options = nil, &proc); end
  def Niin(regexp, symbol = nil, options = nil, &proc); end
  def Njuk(regexp, symbol = nil, options = nil, &proc); end
  def No(regexp, symbol = nil, options = nil, &proc); end
  def Nuaira(regexp, symbol = nil, options = nil, &proc); end
  def Nuairba(regexp, symbol = nil, options = nil, &proc); end
  def Nuairnach(regexp, symbol = nil, options = nil, &proc); end
  def Nuairnár(regexp, symbol = nil, options = nil, &proc); end
  def När(regexp, symbol = nil, options = nil, &proc); end
  def Når(regexp, symbol = nil, options = nil, &proc); end
  def Nəvaxtki(regexp, symbol = nil, options = nil, &proc); end
  def Och(regexp, symbol = nil, options = nil, &proc); end
  def Og(regexp, symbol = nil, options = nil, &proc); end
  def Ohalda(regexp, symbol = nil, options = nil, &proc); end
  def Oletetaan(regexp, symbol = nil, options = nil, &proc); end
  def Ond(regexp, symbol = nil, options = nil, &proc); end
  def Onda(regexp, symbol = nil, options = nil, &proc); end
  def Oraz(regexp, symbol = nil, options = nil, &proc); end
  def Ozaman(regexp, symbol = nil, options = nil, &proc); end
  def Pak(regexp, symbol = nil, options = nil, &proc); end
  def ParameterType(options); end
  def Pero(regexp, symbol = nil, options = nil, &proc); end
  def Peru(regexp, symbol = nil, options = nil, &proc); end
  def Però(regexp, symbol = nil, options = nil, &proc); end
  def Podano(regexp, symbol = nil, options = nil, &proc); end
  def Pokiaľ(regexp, symbol = nil, options = nil, &proc); end
  def Pokud(regexp, symbol = nil, options = nil, &proc); end
  def Potem(regexp, symbol = nil, options = nil, &proc); end
  def Potom(regexp, symbol = nil, options = nil, &proc); end
  def Privzeto(regexp, symbol = nil, options = nil, &proc); end
  def Pryd(regexp, symbol = nil, options = nil, &proc); end
  def Quan(regexp, symbol = nil, options = nil, &proc); end
  def Quand(regexp, symbol = nil, options = nil, &proc); end
  def Quando(regexp, symbol = nil, options = nil, &proc); end
  def Quickoutofthechute(regexp, symbol = nil, options = nil, &proc); end
  def Sachant(regexp, symbol = nil, options = nil, &proc); end
  def Sachantqu(regexp, symbol = nil, options = nil, &proc); end
  def Sachantque(regexp, symbol = nil, options = nil, &proc); end
  def Se(regexp, symbol = nil, options = nil, &proc); end
  def Sed(regexp, symbol = nil, options = nil, &proc); end
  def Si(regexp, symbol = nil, options = nil, &proc); end
  def Siis(regexp, symbol = nil, options = nil, &proc); end
  def Sipoze(regexp, symbol = nil, options = nil, &proc); end
  def SipozeKe(regexp, symbol = nil, options = nil, &proc); end
  def Sipozeke(regexp, symbol = nil, options = nil, &proc); end
  def Soit(regexp, symbol = nil, options = nil, &proc); end
  def Stel(regexp, symbol = nil, options = nil, &proc); end
  def Så(regexp, symbol = nil, options = nil, &proc); end
  def Tad(regexp, symbol = nil, options = nil, &proc); end
  def Tada(regexp, symbol = nil, options = nil, &proc); end
  def Tak(regexp, symbol = nil, options = nil, &proc); end
  def Takrat(regexp, symbol = nil, options = nil, &proc); end
  def Tapi(regexp, symbol = nil, options = nil, &proc); end
  def Ter(regexp, symbol = nil, options = nil, &proc); end
  def Tetapi(regexp, symbol = nil, options = nil, &proc); end
  def Tha(regexp, symbol = nil, options = nil, &proc); end
  def Thathe(regexp, symbol = nil, options = nil, &proc); end
  def Then(regexp, symbol = nil, options = nil, &proc); end
  def Thurh(regexp, symbol = nil, options = nil, &proc); end
  def Thì(regexp, symbol = nil, options = nil, &proc); end
  def Toda(regexp, symbol = nil, options = nil, &proc); end
  def Togash(regexp, symbol = nil, options = nil, &proc); end
  def Tooright(regexp, symbol = nil, options = nil, &proc); end
  def Tutaqki(regexp, symbol = nil, options = nil, &proc); end
  def Ukoliko(regexp, symbol = nil, options = nil, &proc); end
  def Un(regexp, symbol = nil, options = nil, &proc); end
  def Und(regexp, symbol = nil, options = nil, &proc); end
  def Ve(regexp, symbol = nil, options = nil, &proc); end
  def Vendar(regexp, symbol = nil, options = nil, &proc); end
  def Verilir(regexp, symbol = nil, options = nil, &proc); end
  def Và(regexp, symbol = nil, options = nil, &proc); end
  def Və(regexp, symbol = nil, options = nil, &proc); end
  def WEN(regexp, symbol = nil, options = nil, &proc); end
  def Wanneer(regexp, symbol = nil, options = nil, &proc); end
  def WellnowholdonIllyouwhat(regexp, symbol = nil, options = nil, &proc); end
  def Wenn(regexp, symbol = nil, options = nil, &proc); end
  def When(regexp, symbol = nil, options = nil, &proc); end
  def World(*world_modules, **namespaced_world_modules, &proc); end
  def Wtedy(regexp, symbol = nil, options = nil, &proc); end
  def Wun(regexp, symbol = nil, options = nil, &proc); end
  def Y(regexp, symbol = nil, options = nil, &proc); end
  def Ya(regexp, symbol = nil, options = nil, &proc); end
  def Yeahnah(regexp, symbol = nil, options = nil, &proc); end
  def Yknow(regexp, symbol = nil, options = nil, &proc); end
  def Yna(regexp, symbol = nil, options = nil, &proc); end
  def Youseknowlikewhen(regexp, symbol = nil, options = nil, &proc); end
  def Youseknowwhenyousegot(regexp, symbol = nil, options = nil, &proc); end
  def Zadan(regexp, symbol = nil, options = nil, &proc); end
  def Zadani(regexp, symbol = nil, options = nil, &proc); end
  def Zadano(regexp, symbol = nil, options = nil, &proc); end
  def Zadate(regexp, symbol = nil, options = nil, &proc); end
  def Zadati(regexp, symbol = nil, options = nil, &proc); end
  def Zadato(regexp, symbol = nil, options = nil, &proc); end
  def Zakładając(regexp, symbol = nil, options = nil, &proc); end
  def Zakładającże(regexp, symbol = nil, options = nil, &proc); end
  def Zapredpokladu(regexp, symbol = nil, options = nil, &proc); end
  def Zapředpokladu(regexp, symbol = nil, options = nil, &proc); end
  def Zaradi(regexp, symbol = nil, options = nil, &proc); end
  def Zatim(regexp, symbol = nil, options = nil, &proc); end
  def a(regexp, symbol = nil, options = nil, &proc); end
  def ach(regexp, symbol = nil, options = nil, &proc); end
  def an(regexp, symbol = nil, options = nil, &proc); end
  def awer(regexp, symbol = nil, options = nil, &proc); end
  def dann(regexp, symbol = nil, options = nil, &proc); end
  def ej(regexp, symbol = nil, options = nil, &proc); end
  def ghunoblu(regexp, symbol = nil, options = nil, &proc); end
  def if_nil(value, default); end
  def latlh(regexp, symbol = nil, options = nil, &proc); end
  def mä(regexp, symbol = nil, options = nil, &proc); end
  def qaSDI(regexp, symbol = nil, options = nil, &proc); end
  def register_rb_step_definition(regexp, symbol = nil, options = nil, &proc); end
  def self.alias_adverb(adverb); end
  def self.build_rb_world_factory(world_modules, namespaced_world_modules, proc); end
  def self.define_parameter_type(parameter_type); end
  def self.rb_language=(arg0); end
  def self.register_rb_hook(phase, tag_names, proc, name: nil); end
  def self.register_rb_step_definition(regexp, proc_or_sym, options = nil); end
  def ugeholl(regexp, symbol = nil, options = nil, &proc); end
  def vaj(regexp, symbol = nil, options = nil, &proc); end
  def wann(regexp, symbol = nil, options = nil, &proc); end
  def És(regexp, symbol = nil, options = nil, &proc); end
  def Étantdonné(regexp, symbol = nil, options = nil, &proc); end
  def Étantdonnée(regexp, symbol = nil, options = nil, &proc); end
  def Étantdonnées(regexp, symbol = nil, options = nil, &proc); end
  def Étantdonnéqu(regexp, symbol = nil, options = nil, &proc); end
  def Étantdonnéque(regexp, symbol = nil, options = nil, &proc); end
  def Étantdonnés(regexp, symbol = nil, options = nil, &proc); end
  def Ða(regexp, symbol = nil, options = nil, &proc); end
  def Ðaðe(regexp, symbol = nil, options = nil, &proc); end
  def Ðurh(regexp, symbol = nil, options = nil, &proc); end
  def Þa(regexp, symbol = nil, options = nil, &proc); end
  def Þaþe(regexp, symbol = nil, options = nil, &proc); end
  def Þegar(regexp, symbol = nil, options = nil, &proc); end
  def Þurh(regexp, symbol = nil, options = nil, &proc); end
  def Þá(regexp, symbol = nil, options = nil, &proc); end
  def Če(regexp, symbol = nil, options = nil, &proc); end
  def Şi(regexp, symbol = nil, options = nil, &proc); end
  def Əgər(regexp, symbol = nil, options = nil, &proc); end
  def Și(regexp, symbol = nil, options = nil, &proc); end
  def Όταν(regexp, symbol = nil, options = nil, &proc); end
  def Αλλά(regexp, symbol = nil, options = nil, &proc); end
  def Δεδομένου(regexp, symbol = nil, options = nil, &proc); end
  def Και(regexp, symbol = nil, options = nil, &proc); end
  def Τότε(regexp, symbol = nil, options = nil, &proc); end
  def І(regexp, symbol = nil, options = nil, &proc); end
  def Інакш(regexp, symbol = nil, options = nil, &proc); end
  def А(regexp, symbol = nil, options = nil, &proc); end
  def Агар(regexp, symbol = nil, options = nil, &proc); end
  def Але(regexp, symbol = nil, options = nil, &proc); end
  def Али(regexp, symbol = nil, options = nil, &proc); end
  def Аммо(regexp, symbol = nil, options = nil, &proc); end
  def Анх(regexp, symbol = nil, options = nil, &proc); end
  def Атакож(regexp, symbol = nil, options = nil, &proc); end
  def Бирок(regexp, symbol = nil, options = nil, &proc); end
  def Ва(regexp, symbol = nil, options = nil, &proc); end
  def Вә(regexp, symbol = nil, options = nil, &proc); end
  def Гэхдээ(regexp, symbol = nil, options = nil, &proc); end
  def Дадена(regexp, symbol = nil, options = nil, &proc); end
  def Дадено(regexp, symbol = nil, options = nil, &proc); end
  def Дадзена(regexp, symbol = nil, options = nil, &proc); end
  def Дано(regexp, symbol = nil, options = nil, &proc); end
  def Допустим(regexp, symbol = nil, options = nil, &proc); end
  def Ды(regexp, symbol = nil, options = nil, &proc); end
  def Если(regexp, symbol = nil, options = nil, &proc); end
  def Задате(regexp, symbol = nil, options = nil, &proc); end
  def Задати(regexp, symbol = nil, options = nil, &proc); end
  def Задато(regexp, symbol = nil, options = nil, &proc); end
  def Затем(regexp, symbol = nil, options = nil, &proc); end
  def И(regexp, symbol = nil, options = nil, &proc); end
  def Иначе(regexp, symbol = nil, options = nil, &proc); end
  def Кад(regexp, symbol = nil, options = nil, &proc); end
  def Када(regexp, symbol = nil, options = nil, &proc); end
  def Калі(regexp, symbol = nil, options = nil, &proc); end
  def Кога(regexp, symbol = nil, options = nil, &proc); end
  def Когато(regexp, symbol = nil, options = nil, &proc); end
  def Когда(regexp, symbol = nil, options = nil, &proc); end
  def Коли(regexp, symbol = nil, options = nil, &proc); end
  def Ктомуже(regexp, symbol = nil, options = nil, &proc); end
  def Лекин(regexp, symbol = nil, options = nil, &proc); end
  def Ләкин(regexp, symbol = nil, options = nil, &proc); end
  def Мөн(regexp, symbol = nil, options = nil, &proc); end
  def Нехай(regexp, symbol = nil, options = nil, &proc); end
  def Но(regexp, symbol = nil, options = nil, &proc); end
  def Няхай(regexp, symbol = nil, options = nil, &proc); end
  def Нәтиҗәдә(regexp, symbol = nil, options = nil, &proc); end
  def Онда(regexp, symbol = nil, options = nil, &proc); end
  def Припустимо(regexp, symbol = nil, options = nil, &proc); end
  def Припустимощо(regexp, symbol = nil, options = nil, &proc); end
  def Пусть(regexp, symbol = nil, options = nil, &proc); end
  def Та(regexp, symbol = nil, options = nil, &proc); end
  def Тады(regexp, symbol = nil, options = nil, &proc); end
  def Также(regexp, symbol = nil, options = nil, &proc); end
  def Таксама(regexp, symbol = nil, options = nil, &proc); end
  def То(regexp, symbol = nil, options = nil, &proc); end
  def Тогаш(regexp, symbol = nil, options = nil, &proc); end
  def Тогда(regexp, symbol = nil, options = nil, &proc); end
  def Тоді(regexp, symbol = nil, options = nil, &proc); end
  def Тэгэхэд(regexp, symbol = nil, options = nil, &proc); end
  def Тэгээд(regexp, symbol = nil, options = nil, &proc); end
  def Унда(regexp, symbol = nil, options = nil, &proc); end
  def Харин(regexp, symbol = nil, options = nil, &proc); end
  def Хэрэв(regexp, symbol = nil, options = nil, &proc); end
  def Якщо(regexp, symbol = nil, options = nil, &proc); end
  def Үүнийдараа(regexp, symbol = nil, options = nil, &proc); end
  def Һәм(regexp, symbol = nil, options = nil, &proc); end
  def Әгәр(regexp, symbol = nil, options = nil, &proc); end
  def Әйтик(regexp, symbol = nil, options = nil, &proc); end
  def Әмма(regexp, symbol = nil, options = nil, &proc); end
  def Өгөгдсөннь(regexp, symbol = nil, options = nil, &proc); end
  def Ապա(regexp, symbol = nil, options = nil, &proc); end
  def Բայց(regexp, symbol = nil, options = nil, &proc); end
  def Դիցուք(regexp, symbol = nil, options = nil, &proc); end
  def Եթե(regexp, symbol = nil, options = nil, &proc); end
  def Եվ(regexp, symbol = nil, options = nil, &proc); end
  def Երբ(regexp, symbol = nil, options = nil, &proc); end
  def אבל(regexp, symbol = nil, options = nil, &proc); end
  def אז(regexp, symbol = nil, options = nil, &proc); end
  def אזי(regexp, symbol = nil, options = nil, &proc); end
  def בהינתן(regexp, symbol = nil, options = nil, &proc); end
  def וגם(regexp, symbol = nil, options = nil, &proc); end
  def כאשר(regexp, symbol = nil, options = nil, &proc); end
  def آنگاه(regexp, symbol = nil, options = nil, &proc); end
  def اذاً(regexp, symbol = nil, options = nil, &proc); end
  def اما(regexp, symbol = nil, options = nil, &proc); end
  def اور(regexp, symbol = nil, options = nil, &proc); end
  def اگر(regexp, symbol = nil, options = nil, &proc); end
  def بافرض(regexp, symbol = nil, options = nil, &proc); end
  def بالفرض(regexp, symbol = nil, options = nil, &proc); end
  def بفرض(regexp, symbol = nil, options = nil, &proc); end
  def تب(regexp, symbol = nil, options = nil, &proc); end
  def ثم(regexp, symbol = nil, options = nil, &proc); end
  def جب(regexp, symbol = nil, options = nil, &proc); end
  def عندما(regexp, symbol = nil, options = nil, &proc); end
  def فرضکیا(regexp, symbol = nil, options = nil, &proc); end
  def لكن(regexp, symbol = nil, options = nil, &proc); end
  def لیکن(regexp, symbol = nil, options = nil, &proc); end
  def متى(regexp, symbol = nil, options = nil, &proc); end
  def هنگامی(regexp, symbol = nil, options = nil, &proc); end
  def و(regexp, symbol = nil, options = nil, &proc); end
  def پھر(regexp, symbol = nil, options = nil, &proc); end
  def अगर(regexp, symbol = nil, options = nil, &proc); end
  def अनि(regexp, symbol = nil, options = nil, &proc); end
  def अनी(regexp, symbol = nil, options = nil, &proc); end
  def आणि(regexp, symbol = nil, options = nil, &proc); end
  def और(regexp, symbol = nil, options = nil, &proc); end
  def कदा(regexp, symbol = nil, options = nil, &proc); end
  def किन्तु(regexp, symbol = nil, options = nil, &proc); end
  def चूंकि(regexp, symbol = nil, options = nil, &proc); end
  def जब(regexp, symbol = nil, options = nil, &proc); end
  def जर(regexp, symbol = nil, options = nil, &proc); end
  def जेव्हा(regexp, symbol = nil, options = nil, &proc); end
  def तथा(regexp, symbol = nil, options = nil, &proc); end
  def तदा(regexp, symbol = nil, options = nil, &proc); end
  def तब(regexp, symbol = nil, options = nil, &proc); end
  def तर(regexp, symbol = nil, options = nil, &proc); end
  def तसेच(regexp, symbol = nil, options = nil, &proc); end
  def तेव्हा(regexp, symbol = nil, options = nil, &proc); end
  def त्यसपछि(regexp, symbol = nil, options = nil, &proc); end
  def दिइएको(regexp, symbol = nil, options = nil, &proc); end
  def दिएको(regexp, symbol = nil, options = nil, &proc); end
  def दिलेल्याप्रमाणे(regexp, symbol = nil, options = nil, &proc); end
  def पण(regexp, symbol = nil, options = nil, &proc); end
  def पर(regexp, symbol = nil, options = nil, &proc); end
  def परंतु(regexp, symbol = nil, options = nil, &proc); end
  def परन्तु(regexp, symbol = nil, options = nil, &proc); end
  def मग(regexp, symbol = nil, options = nil, &proc); end
  def यदि(regexp, symbol = nil, options = nil, &proc); end
  def र(regexp, symbol = nil, options = nil, &proc); end
  def ਅਤੇ(regexp, symbol = nil, options = nil, &proc); end
  def ਜਦੋਂ(regexp, symbol = nil, options = nil, &proc); end
  def ਜਿਵੇਂਕਿ(regexp, symbol = nil, options = nil, &proc); end
  def ਜੇਕਰ(regexp, symbol = nil, options = nil, &proc); end
  def ਤਦ(regexp, symbol = nil, options = nil, &proc); end
  def ਪਰ(regexp, symbol = nil, options = nil, &proc); end
  def અને(regexp, symbol = nil, options = nil, &proc); end
  def આપેલછે(regexp, symbol = nil, options = nil, &proc); end
  def ક્યારે(regexp, symbol = nil, options = nil, &proc); end
  def પછી(regexp, symbol = nil, options = nil, &proc); end
  def પણ(regexp, symbol = nil, options = nil, &proc); end
  def அப்பொழுது(regexp, symbol = nil, options = nil, &proc); end
  def ஆனால்(regexp, symbol = nil, options = nil, &proc); end
  def எப்போது(regexp, symbol = nil, options = nil, &proc); end
  def கொடுக்கப்பட்ட(regexp, symbol = nil, options = nil, &proc); end
  def மற்றும்(regexp, symbol = nil, options = nil, &proc); end
  def மேலும்(regexp, symbol = nil, options = nil, &proc); end
  def అప్పుడు(regexp, symbol = nil, options = nil, &proc); end
  def ఈపరిస్థితిలో(regexp, symbol = nil, options = nil, &proc); end
  def కాని(regexp, symbol = nil, options = nil, &proc); end
  def చెప్పబడినది(regexp, symbol = nil, options = nil, &proc); end
  def మరియు(regexp, symbol = nil, options = nil, &proc); end
  def ಆದರೆ(regexp, symbol = nil, options = nil, &proc); end
  def ನಂತರ(regexp, symbol = nil, options = nil, &proc); end
  def ನೀಡಿದ(regexp, symbol = nil, options = nil, &proc); end
  def ಮತ್ತು(regexp, symbol = nil, options = nil, &proc); end
  def ಸ್ಥಿತಿಯನ್ನು(regexp, symbol = nil, options = nil, &proc); end
  def എപ്പോൾ(regexp, symbol = nil, options = nil, &proc); end
  def ഒപ്പം(regexp, symbol = nil, options = nil, &proc); end
  def നൽകിയത്(regexp, symbol = nil, options = nil, &proc); end
  def പക്ഷേ(regexp, symbol = nil, options = nil, &proc); end
  def പിന്നെ(regexp, symbol = nil, options = nil, &proc); end
  def กำหนดให้(regexp, symbol = nil, options = nil, &proc); end
  def ดังนั้น(regexp, symbol = nil, options = nil, &proc); end
  def เมื่อ(regexp, symbol = nil, options = nil, &proc); end
  def แต่(regexp, symbol = nil, options = nil, &proc); end
  def และ(regexp, symbol = nil, options = nil, &proc); end
  def ასევე(regexp, symbol = nil, options = nil, &proc); end
  def და(regexp, symbol = nil, options = nil, &proc); end
  def ვთქვათ(regexp, symbol = nil, options = nil, &proc); end
  def თუ(regexp, symbol = nil, options = nil, &proc); end
  def თუმცა(regexp, symbol = nil, options = nil, &proc); end
  def მაგრამ(regexp, symbol = nil, options = nil, &proc); end
  def მაშინ(regexp, symbol = nil, options = nil, &proc); end
  def მოცემული(regexp, symbol = nil, options = nil, &proc); end
  def მოცემულია(regexp, symbol = nil, options = nil, &proc); end
  def როგორცკი(regexp, symbol = nil, options = nil, &proc); end
  def როდესაც(regexp, symbol = nil, options = nil, &proc); end
  def როცა(regexp, symbol = nil, options = nil, &proc); end
  def መቼ(regexp, symbol = nil, options = nil, &proc); end
  def እና(regexp, symbol = nil, options = nil, &proc); end
  def ከዚያ(regexp, symbol = nil, options = nil, &proc); end
  def የተሰጠ(regexp, symbol = nil, options = nil, &proc); end
  def ግን(regexp, symbol = nil, options = nil, &proc); end
  def かつ(regexp, symbol = nil, options = nil, &proc); end
  def しかし(regexp, symbol = nil, options = nil, &proc); end
  def ただし(regexp, symbol = nil, options = nil, &proc); end
  def ならば(regexp, symbol = nil, options = nil, &proc); end
  def もし(regexp, symbol = nil, options = nil, &proc); end
  def 且つ(regexp, symbol = nil, options = nil, &proc); end
  def 並且(regexp, symbol = nil, options = nil, &proc); end
  def 但し(regexp, symbol = nil, options = nil, &proc); end
  def 但是(regexp, symbol = nil, options = nil, &proc); end
  def 假如(regexp, symbol = nil, options = nil, &proc); end
  def 假定(regexp, symbol = nil, options = nil, &proc); end
  def 假設(regexp, symbol = nil, options = nil, &proc); end
  def 假设(regexp, symbol = nil, options = nil, &proc); end
  def 前提(regexp, symbol = nil, options = nil, &proc); end
  def 同时(regexp, symbol = nil, options = nil, &proc); end
  def 同時(regexp, symbol = nil, options = nil, &proc); end
  def 并且(regexp, symbol = nil, options = nil, &proc); end
  def 当(regexp, symbol = nil, options = nil, &proc); end
  def 然し(regexp, symbol = nil, options = nil, &proc); end
  def 當(regexp, symbol = nil, options = nil, &proc); end
  def 而且(regexp, symbol = nil, options = nil, &proc); end
  def 那么(regexp, symbol = nil, options = nil, &proc); end
  def 那麼(regexp, symbol = nil, options = nil, &proc); end
  def 그러면(regexp, symbol = nil, options = nil, &proc); end
  def 그리고(regexp, symbol = nil, options = nil, &proc); end
  def 단(regexp, symbol = nil, options = nil, &proc); end
  def 만약(regexp, symbol = nil, options = nil, &proc); end
  def 만일(regexp, symbol = nil, options = nil, &proc); end
  def 먼저(regexp, symbol = nil, options = nil, &proc); end
  def 조건(regexp, symbol = nil, options = nil, &proc); end
  def 하지만(regexp, symbol = nil, options = nil, &proc); end
end
module Cucumber::Glue::Snippet
end
class Cucumber::Glue::Snippet::Generator
  def call(code_keyword, step_name, multiline_arg, snippet_type); end
  def initialize(cucumber_expression_generator); end
  def self.register_on(configuration); end
  def typed_snippet_class(type); end
end
class Cucumber::Glue::Snippet::BaseSnippet
  def code_keyword; end
  def do_block; end
  def generated_expressions; end
  def initialize(cucumber_expression_generator, code_keyword, step_name, multiline_argument); end
  def multiline_argument; end
  def number_of_arguments; end
  def parameters; end
  def pattern; end
  def replace_and_count_capturing_groups(pattern); end
  def self.cli_option_string(type, cucumber_expression_generator); end
  def self.example(cucumber_expression_generator); end
  def step; end
  def to_s; end
end
class Cucumber::Glue::Snippet::CucumberExpression < Cucumber::Glue::Snippet::BaseSnippet
  def parameters(expr); end
  def self.description; end
  def to_s; end
  def typed_pattern; end
end
class Cucumber::Glue::Snippet::Regexp < Cucumber::Glue::Snippet::BaseSnippet
  def self.description; end
  def typed_pattern; end
end
class Cucumber::Glue::Snippet::Classic < Cucumber::Glue::Snippet::BaseSnippet
  def self.description; end
  def typed_pattern; end
end
class Cucumber::Glue::Snippet::Percent < Cucumber::Glue::Snippet::BaseSnippet
  def self.description; end
  def typed_pattern; end
end
module Cucumber::Glue::Snippet::MultilineArgumentSnippet
  def self.new(multiline_argument); end
end
class Cucumber::Glue::Snippet::MultilineArgumentSnippet::Builder
  def data_table(table, *_args); end
  def doc_string(*_args); end
  def result; end
end
class Cucumber::Glue::Snippet::MultilineArgumentSnippet::DocString
  def append_block_parameter_to(array); end
  def append_comment_to(string); end
end
class Cucumber::Glue::Snippet::MultilineArgumentSnippet::DataTable
  def append_block_parameter_to(array); end
  def append_comment_to(string); end
  def initialize(table); end
end
class Cucumber::Glue::Snippet::MultilineArgumentSnippet::None
  def append_block_parameter_to(array); end
  def append_comment_to(string); end
end
class Cucumber::Glue::InvokeInWorld
  def self.cucumber_compatible_arity?(args, block); end
  def self.cucumber_instance_exec_in(world, check_arity, pseudo_method, *args, &block); end
  def self.cucumber_run_with_backtrace_filtering(pseudo_method); end
  def self.replace_instance_exec_invocation_line!(backtrace, instance_exec_invocation_line, pseudo_method); end
end
class Cucumber::Glue::ArityMismatchError < StandardError
end
class Cucumber::Glue::Hook
  def fail_for_old_style_tag_expressions(tag_expressions); end
  def id; end
  def initialize(id, registry, tag_expressions, proc, name: nil); end
  def invoke(pseudo_method, arguments, &block); end
  def location; end
  def name; end
  def sanitize_tag_expressions(tag_expressions); end
  def tag_expressions; end
  def to_envelope; end
end
module Cucumber::Glue::ProtoWorld
  def ask(question, timeout_seconds = nil); end
  def attach(file, media_type = nil, filename = nil); end
  def inspect; end
  def log(*messages); end
  def pending(message = nil); end
  def self.for(runtime, language); end
  def skip_this_scenario(message = nil); end
  def step(name, raw_multiline_arg = nil); end
  def steps(steps_text); end
  def table(text_or_table); end
  def to_s; end
end
class Cucumber::Glue::StepDefinition
  def ==(other); end
  def arguments_from(step_name); end
  def backtrace_line; end
  def expression; end
  def expression_type; end
  def file; end
  def file_colon_line; end
  def id; end
  def initialize(id, registry, expression, proc); end
  def invoke(args); end
  def location; end
  def registry; end
  def self.create_proc(proc_or_sym, options); end
  def self.new(id, registry, string_or_regexp, proc_or_sym, options); end
  def self.parse_target_proc_from(options); end
  def self.patch_location_onto(block); end
  def to_envelope; end
  def to_hash; end
end
class Cucumber::Glue::StepDefinition::MissingProc < StandardError
  def message; end
end
class Cucumber::Glue::WorldFactory
  def create_world; end
  def initialize(proc); end
  def raise_nil_world; end
end
class Cucumber::StepDefinitionLight
  def eql?(other); end
  def hash; end
  def initialize(regexp_source, location); end
  def location; end
  def regexp_source; end
end
class Cucumber::Glue::NilWorld < StandardError
  def initialize; end
end
class Cucumber::Glue::MultipleWorld < StandardError
  def initialize(first_proc, second_proc); end
end
class Cucumber::Glue::RegistryAndMore
  def add_hook(phase, hook); end
  def after_all; end
  def available_step_definition(regexp_source, file_colon_line); end
  def available_step_definition_hash; end
  def before_all; end
  def begin_scenario(test_case); end
  def build_rb_world_factory(world_modules, namespaced_world_modules, proc); end
  def clear_hooks; end
  def create_expression(string_or_regexp); end
  def current_world; end
  def define_parameter_type(parameter_type); end
  def end_scenario; end
  def hooks; end
  def hooks_for(phase, scenario); end
  def initialize(runtime, configuration); end
  def install_plugin(configuration, registry); end
  def invoked_step_definition(regexp_source, file_colon_line); end
  def invoked_step_definition_hash; end
  def load_code_file(code_file); end
  def parameter_type_envelope(parameter_type); end
  def register_rb_hook(phase, tag_expressions, proc, name: nil); end
  def register_rb_step_definition(string_or_regexp, proc_or_sym, options); end
  def self.cli_snippet_type_options; end
  def step_definitions; end
  def step_matches(name_to_match); end
  def unmatched_step_definitions; end
end
class Cucumber::ProjectInitializer
  def create_directory(dir_name); end
  def create_directory_or_file(file_name, directory); end
  def create_file(file_name); end
  def report_creating(file); end
  def report_exists(file); end
  def run; end
end
class Cucumber::Cli::Options
  def [](key); end
  def []=(key, value); end
  def add_option(option, value); end
  def add_profile(profile); end
  def add_tag(value); end
  def add_tag_limit(tag_limits, tag_name, limit); end
  def add_tag_limits(value); end
  def banner; end
  def check_formatter_stream_conflicts; end
  def color(color); end
  def color_msg; end
  def custom_profiles; end
  def default_options; end
  def default_profile_should_be_used?; end
  def disable_profile_loading; end
  def dry_run_msg; end
  def exclude_msg; end
  def exit_ok(text); end
  def expanded_args; end
  def extract_environment_variables; end
  def filters; end
  def format_msg; end
  def i18n_keywords_msg; end
  def i18n_languages_msg; end
  def indicate_invalid_language_and_exit(lang); end
  def init_msg; end
  def initialize(out_stream = nil, error_stream = nil, options = nil); end
  def initialize_project; end
  def language(lang); end
  def lines_msg; end
  def list_keywords_and_exit(lang); end
  def list_languages_and_exit; end
  def merge_profiles; end
  def merge_tag_limits(option_limits, other_limits); end
  def merge_with_profile(profile); end
  def name_msg; end
  def no_profile_short_flag_msg; end
  def non_stdout_formats; end
  def options; end
  def out_msg; end
  def out_stream(value); end
  def parse!(args); end
  def parse_formats(value); end
  def process_publish_options; end
  def profile_loader; end
  def profile_short_flag_msg; end
  def profiles; end
  def publisher; end
  def require_files(filenames); end
  def require_files_msg; end
  def require_jars(jars); end
  def retry_msg; end
  def retry_total_msg; end
  def reverse_merge(other_options); end
  def self.parse(args, out_stream, error_stream, options = nil); end
  def set_dry_run_and_duration; end
  def set_option(option, value = nil); end
  def set_strict(setting, type = nil); end
  def shut_up; end
  def snippet_type_msg; end
  def stdout_formats; end
  def strict_msg; end
  def tags_msg; end
  def to_code_keywords_string(list); end
  def to_hash; end
  def to_keywords_string(list); end
  def truthy_string?(str); end
end
module Cucumber::Formatter::Io
  def ensure_dir(path, name); end
  def ensure_file(path, name); end
  def ensure_io(path_or_url_or_io, error_stream); end
  def io?(path_or_url_or_io); end
  def self.ensure_dir(path, name); end
  def self.ensure_file(path, name); end
  def self.ensure_io(path_or_url_or_io, error_stream); end
  def self.included(formatter_class); end
  def self.io?(path_or_url_or_io); end
  def self.url?(path_or_url_or_io); end
  def url?(path_or_url_or_io); end
end
module Cucumber::Formatter::Io::ClassMethods
  def new(*args, &block); end
end
module Cucumber::Formatter::Console
  def attach(src, media_type, filename); end
  def collect_snippet_data(test_step, ast_lookup); end
  def collect_undefined_parameter_type_names(undefined_parameter_type); end
  def do_print_passing_wip(passed_messages); end
  def do_print_profile_information(profiles); end
  def do_print_snippets(snippet_text_proc); end
  def do_print_undefined_parameter_type_snippet(type_name); end
  def element_messages(elements, status); end
  def exception_message_string(exception, indent_amount); end
  def format_for(*keys); end
  def format_step(keyword, step_match, status, source_indent); end
  def format_string(input, status); end
  def indent(string, padding); end
  def linebreaks(msg, max); end
  def print_element_messages(element_messages, status, kind); end
  def print_elements(elements, status, kind); end
  def print_exception(exception, status, indent); end
  def print_passing_wip(config, passed_test_cases, ast_lookup); end
  def print_profile_information; end
  def print_snippets(options); end
  def print_statistics(duration, config, counts, issues); end
  def snippet_text(step_keyword, step_name, multiline_arg); end
  extend Cucumber::Formatter::ANSIColor
  include Cucumber::Formatter::Duration
end
class Cucumber::Formatter::Console::SnippetData
  def actual_keyword; end
  def initialize(actual_keyword, step); end
  def step; end
end
class Cucumber::Formatter::FailFast
  def initialize(configuration); end
end
module Cucumber::Term::Banner
  def display_banner(lines, io, border_modifiers = nil); end
end
class Cucumber::Term::Banner::BannerMaker
  def apply_modifiers(str, modifiers); end
  def display_banner(lines, io, border_modifiers); end
  def display_line(line); end
  def display_span(span); end
  def line_length(line); end
  def span_length(span); end
  include Cucumber::Term::ANSIColor
end
class Cucumber::Formatter::PublishBannerPrinter
  def display_publish_ad(io); end
  def highlight(text); end
  def initialize(configuration); end
  def link(text); end
  def pre(text); end
  include Cucumber::Term::Banner
end
module Cucumber::FixRuby21Bug9285
  def message; end
end
class Cucumber::FileException < RuntimeError
  def initialize(original_exception, path); end
  def path; end
end
class Cucumber::FileNotFoundException < Cucumber::FileException
end
class Cucumber::FeatureFolderNotFoundException < RuntimeError
  def initialize(path); end
  def message; end
end
class Cucumber::Runtime::NormalisedEncodingFile
  def initialize(path); end
  def read; end
  def self.read(path); end
  def set_encoding; end
end
class Cucumber::Cli::YmlLoadError < StandardError
end
class Cucumber::Cli::ProfilesNotDefinedError < Cucumber::Cli::YmlLoadError
end
class Cucumber::Cli::ProfileNotFound < StandardError
end
class Cucumber::Cli::Configuration
  def add_default_formatter; end
  def arrange_formats; end
  def dry_run?; end
  def expand?; end
  def fail_fast?; end
  def filters; end
  def formats; end
  def formatter_missing?; end
  def guess?; end
  def initialize(out_stream = nil, error_stream = nil); end
  def log; end
  def name_regexps; end
  def needs_default_formatter?; end
  def out_stream; end
  def parse!(args); end
  def paths; end
  def publish_only?; end
  def randomize?; end
  def retry_attempts; end
  def seed; end
  def set_environment_variables; end
  def snippet_type; end
  def strict; end
  def tag_expressions; end
  def tag_limits; end
  def to_hash; end
  def verbose?; end
  def wip?; end
  include Cucumber::Constantize
end
class Cucumber::Cli::Configuration::LogFormatter < Logger::Formatter
  def call(_severity, _time, _progname, msg); end
end
class Cucumber::Cli::Main
  def configuration; end
  def execute!(existing_runtime = nil); end
  def exit_ok; end
  def exit_tests_failed; end
  def exit_unable_to_finish!; end
  def exit_unable_to_finish; end
  def initialize(args, out = nil, err = nil, kernel = nil); end
  def runtime(existing_runtime); end
  def self.execute(args); end
  def trap_interrupt; end
end
class Cucumber::StepDefinitions
  def initialize(configuration = nil); end
  def to_json(obj = nil); end
end
