# This file is autogenerated. Do not edit it by hand. Regenerate it with:
#   srb rbi gems

# typed: false
#
# If you would like to make changes to this file, great! Please create the gem's shim here:
#
#   https://github.com/sorbet/sorbet-typed/new/master?filename=lib/draper/all/draper.rbi
#
# draper-4.0.2

module Draper
  def self.setup_action_controller(base); end
  def self.setup_action_mailer(base); end
  def self.setup_orm(base); end
  def self.undecorate(object); end
  def self.undecorate_chain(object); end
  extend Draper::Configuration
end
module Draper::Configuration
  def configure; end
  def default_controller; end
  def default_controller=(controller); end
  def default_query_methods_strategy; end
  def default_query_methods_strategy=(strategy); end
end
module Draper::ViewHelpers
  def h; end
  def helpers; end
  def l(*args, **); end
  def localize(*args, **); end
  extend ActiveSupport::Concern
end
module Draper::ViewHelpers::ClassMethods
  def h; end
  def helpers; end
end
module Draper::Compatibility
end
module Draper::Compatibility::ApiOnly
  extend ActiveSupport::Concern
end
module Draper::Delegation
  def delegate(*methods); end
end
module Draper::AutomaticDelegation
  def delegatable?(method); end
  def method_missing(method, *args, **, &block); end
  def respond_to_missing?(method, include_private = nil); end
  extend ActiveSupport::Concern
end
module Draper::AutomaticDelegation::ClassMethods
  def before_remove_const; end
  def delegatable?(method); end
  def method_missing(method, *args, **, &block); end
  def respond_to_missing?(method, include_private = nil); end
end
module Draper::Finders
  def all(options = nil); end
  def find(id, options = nil); end
  def first(options = nil); end
  def last(options = nil); end
  def method_missing(method, *args, &block); end
end
module Draper::Compatibility::GlobalID
  extend ActiveSupport::Concern
end
class Draper::Decorator
  def ==(other); end
  def applied_decorators; end
  def attributes; end
  def blank?(*, **, &); end
  def context; end
  def context=(arg0); end
  def decorated?; end
  def decorated_associations; end
  def decorated_with?(decorator_class); end
  def eql?(other); end
  def handle_multiple_decoration(options); end
  def hash; end
  def include_root_in_json; end
  def include_root_in_json?; end
  def initialize(object, options = nil); end
  def instance_of?(klass); end
  def is_a?(klass); end
  def kind_of?(klass); end
  def model; end
  def model_name(&); end
  def object; end
  def present?(*, **, &); end
  def self.alias_object_to_object_class_name; end
  def self.collection_decorator_class; end
  def self.collection_decorator_name; end
  def self.decorate(*, **); end
  def self.decorate_collection(object, options = nil); end
  def self.decorates(object_class); end
  def self.decorates_association(association, options = nil); end
  def self.decorates_associations(*associations); end
  def self.decorates_finders; end
  def self.delegate_all; end
  def self.include_root_in_json; end
  def self.include_root_in_json=(value); end
  def self.include_root_in_json?; end
  def self.inferred_object_class; end
  def self.inherited(subclass); end
  def self.model_name(*, **, &); end
  def self.object_class; end
  def self.object_class?; end
  def self.object_class_name; end
  def to_global_id(*, **, &); end
  def to_model; end
  def to_param(*, **, &); end
  def to_partial_path(*, **, &); end
  def to_s(*, **, &); end
  def to_signed_global_id(*, **, &); end
  extend ActiveModel::Naming
  extend ActiveModel::Naming
  extend Draper::Delegation
  extend Draper::ViewHelpers::ClassMethods
  include ActiveModel::Serialization
  include ActiveModel::Serializers::JSON
  include ActiveModel::Serializers::Xml
  include Draper::Compatibility::GlobalID
  include Draper::ViewHelpers
  include GlobalID::Identification
end
class Draper::HelperProxy
  def capture(*, **, &); end
  def initialize(view_context); end
  def method_missing(method, *args, **, &block); end
  def respond_to_missing?(method, include_private = nil); end
  def self.define_proxy(name); end
  def view_context; end
end
module Draper::LazyHelpers
  def method_missing(method, *args, **, &block); end
end
module Draper::Decoratable
  def applied_decorators; end
  def decorate(options = nil); end
  def decorated?; end
  def decorated_with?(decorator_class); end
  def decorator_class; end
  def decorator_class?; end
  extend ActiveSupport::Concern
  include Draper::Decoratable::Equality
end
module Draper::Decoratable::Equality
  def ==(other); end
  def self.test(object, other); end
  def self.test_for_decorator(object, other); end
end
module Draper::Decoratable::ClassMethods
  def ===(other); end
  def decorate(options = nil); end
  def decorator_class(called_on = nil); end
  def decorator_class?; end
end
class Draper::Factory
  def decorate(object, options = nil); end
  def decorator_class; end
  def default_options; end
  def initialize(options = nil); end
end
class Draper::Factory::Worker
  def call(options); end
  def collection?; end
  def decoratable?; end
  def decorator; end
  def decorator_class; end
  def decorator_method(klass); end
  def initialize(decorator_class, object); end
  def object; end
  def object_decorator; end
  def update_context(options); end
end
class Draper::DecoratedAssociation
  def association; end
  def call; end
  def decorate; end
  def factory; end
  def initialize(owner, association, options); end
  def owner; end
  def scope; end
end
module Draper::HelperSupport
  def decorate(input, &block); end
end
module Draper::ViewContext
  def activate_draper; end
  def self.build!; end
  def self.build; end
  def self.build_strategy; end
  def self.clear!; end
  def self.controller; end
  def self.controller=(controller); end
  def self.current; end
  def self.current=(view_context); end
  def self.test_strategy(name, &block); end
  def view_context; end
end
module Draper::ViewContext::BuildStrategy
  def self.new(name, &block); end
end
class Draper::ViewContext::BuildStrategy::Fast
  def call; end
  def initialize(&block); end
  def view_context_class; end
end
class Draper::ViewContext::BuildStrategy::Full
  def block; end
  def call; end
  def controller; end
  def initialize(&block); end
  def is_above_rails_5_1; end
  def new_test_request(controller); end
end
module Draper::QueryMethods
  def method_missing(method, *args, **, &block); end
  def respond_to_missing?(method, include_private = nil); end
  def strategy; end
end
module Draper::QueryMethods::LoadStrategy
  def self.new(name); end
end
class Draper::QueryMethods::LoadStrategy::ActiveRecord
  def allowed?(method); end
end
class Draper::QueryMethods::LoadStrategy::Mongoid
  def allowed?(method); end
end
class Draper::CollectionDecorator
  def &(*, **, &); end
  def *(*, **, &); end
  def +(*, **, &); end
  def -(*, **, &); end
  def <<(*, **, &); end
  def ==(arg); end
  def [](*, **, &); end
  def []=(*, **, &); end
  def all?(*, **, &); end
  def any?(*, **, &); end
  def append(*, **, &); end
  def as_json(*, **, &); end
  def assoc(*, **, &); end
  def at(*, **, &); end
  def bsearch(*, **, &); end
  def bsearch_index(*, **, &); end
  def chain(*, **, &); end
  def chunk(*, **, &); end
  def chunk_while(*, **, &); end
  def clear(*, **, &); end
  def collect!(*, **, &); end
  def collect(*, **, &); end
  def collect_concat(*, **, &); end
  def combination(*, **, &); end
  def compact!(*, **, &); end
  def compact(*, **, &); end
  def compact_blank!(*, **, &); end
  def compact_blank(*, **, &); end
  def concat(*, **, &); end
  def context; end
  def context=(value); end
  def count(*, **, &); end
  def cycle(*, **, &); end
  def deconstruct(*, **, &); end
  def decorate_item(item); end
  def decorated?; end
  def decorated_collection; end
  def decorated_with?(arg0); end
  def decorator_class; end
  def delete(*, **, &); end
  def delete_at(*, **, &); end
  def delete_if(*, **, &); end
  def detect(*, **, &); end
  def difference(*, **, &); end
  def dig(*, **, &); end
  def drop(*, **, &); end
  def drop_while(*, **, &); end
  def each(*, **, &); end
  def each_cons(*, **, &); end
  def each_entry(*, **, &); end
  def each_index(*, **, &); end
  def each_slice(*, **, &); end
  def each_with_index(*, **, &); end
  def each_with_object(*, **, &); end
  def empty?(*, **, &); end
  def entries(*, **, &); end
  def exclude?(*, **, &); end
  def excluding(*, **, &); end
  def extract_options!(*, **, &); end
  def fetch(*, **, &); end
  def fifth(*, **, &); end
  def fill(*, **, &); end
  def filter!(*, **, &); end
  def filter(*, **, &); end
  def filter_map(*, **, &); end
  def find(*, **, &); end
  def find_all(*, **, &); end
  def find_index(*, **, &); end
  def first(*, **, &); end
  def flat_map(*, **, &); end
  def flatten!(*, **, &); end
  def flatten(*, **, &); end
  def forty_two(*, **, &); end
  def fourth(*, **, &); end
  def from(*, **, &); end
  def grep(*, **, &); end
  def grep_v(*, **, &); end
  def group_by(*, **, &); end
  def in_order_of(*, **, &); end
  def include?(*, **, &); end
  def including(*, **, &); end
  def index(*, **, &); end
  def index_by(*, **, &); end
  def index_with(*, **, &); end
  def initialize(object, options = nil); end
  def inject(*, **, &); end
  def insert(*, **, &); end
  def intersect?(*, **, &); end
  def intersection(*, **, &); end
  def is_a?(klass); end
  def item_decorator; end
  def join(*, **, &); end
  def keep_if(*, **, &); end
  def kind_of?(klass); end
  def last(*, **, &); end
  def lazy(*, **, &); end
  def length(*, **, &); end
  def many?(*, **, &); end
  def map!(*, **, &); end
  def map(*, **, &); end
  def max(*, **, &); end
  def max_by(*, **, &); end
  def maximum(*, **, &); end
  def member?(*, **, &); end
  def min(*, **, &); end
  def min_by(*, **, &); end
  def minimum(*, **, &); end
  def minmax(*, **, &); end
  def minmax_by(*, **, &); end
  def none?(*, **, &); end
  def object; end
  def one?(*, **, &); end
  def pack(*, **, &); end
  def partition(*, **, &); end
  def permutation(*, **, &); end
  def pick(*, **, &); end
  def pluck(*, **, &); end
  def pop(*, **, &); end
  def prepend(*, **, &); end
  def product(*, **, &); end
  def push(*, **, &); end
  def rassoc(*, **, &); end
  def reduce(*, **, &); end
  def reject!(*, **, &); end
  def reject(*, **, &); end
  def repeated_combination(*, **, &); end
  def repeated_permutation(*, **, &); end
  def replace(other); end
  def reverse!(*, **, &); end
  def reverse(*, **, &); end
  def reverse_each(*, **, &); end
  def rindex(*, **, &); end
  def rotate!(*, **, &); end
  def rotate(*, **, &); end
  def sample(*, **, &); end
  def second(*, **, &); end
  def second_to_last(*, **, &); end
  def select!(*, **, &); end
  def select(*, **, &); end
  def self.decorate(*, **); end
  def shelljoin(*, **, &); end
  def shift(*, **, &); end
  def shuffle!(*, **, &); end
  def shuffle(*, **, &); end
  def size(*, **, &); end
  def slice!(*, **, &); end
  def slice(*, **, &); end
  def slice_after(*, **, &); end
  def slice_before(*, **, &); end
  def slice_when(*, **, &); end
  def sole(*, **, &); end
  def sort!(*, **, &); end
  def sort(*, **, &); end
  def sort_by!(*, **, &); end
  def sort_by(*, **, &); end
  def sum(*, **, &); end
  def take(*, **, &); end
  def take_while(*, **, &); end
  def tally(*, **, &); end
  def third(*, **, &); end
  def third_to_last(*, **, &); end
  def to(*, **, &); end
  def to_a(*, **, &); end
  def to_ary(*, **, &); end
  def to_formatted_s(*, **, &); end
  def to_fs(*, **, &); end
  def to_h(*, **, &); end
  def to_msgpack(*, **, &); end
  def to_s; end
  def to_sentence(*, **, &); end
  def to_set(*, **, &); end
  def to_xml(*, **, &); end
  def transpose(*, **, &); end
  def union(*, **, &); end
  def uniq!(*, **, &); end
  def uniq(*, **, &); end
  def unshift(*, **, &); end
  def values_at(*, **, &); end
  def without(*, **, &); end
  def zip(*, **, &); end
  def |(*, **, &); end
  extend Draper::Delegation
  extend Draper::ViewHelpers::ClassMethods
  include Draper::QueryMethods
  include Draper::ViewHelpers
  include Enumerable
end
module Draper::DecoratesAssigned
  def decorates_assigned(*variables); end
end
module ActiveModel
end
class ActiveModel::Railtie < Rails::Railtie
end
class Draper::Railtie < Rails::Railtie
  def initialize_view_context; end
end
class Draper::UninferrableDecoratorError < NameError
  def initialize(klass); end
end
class Draper::UninferrableObjectError < NameError
  def initialize(klass); end
end
