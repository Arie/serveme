# This file is autogenerated. Do not edit it by hand. Regenerate it with:
#   srb rbi gems

# typed: false
#
# If you would like to make changes to this file, great! Please create the gem's shim here:
#
#   https://github.com/sorbet/sorbet-typed/new/master?filename=lib/drb/all/drb.rbi
#
# drb-2.2.1

module DRb
  def config; end
  def current_server; end
  def fetch_server(uri); end
  def front; end
  def here?(uri); end
  def install_acl(acl); end
  def install_id_conv(idconv); end
  def mutex; end
  def primary_server; end
  def primary_server=(arg0); end
  def regist_server(server); end
  def remove_server(server); end
  def self.config; end
  def self.current_server; end
  def self.fetch_server(uri); end
  def self.front; end
  def self.here?(uri); end
  def self.install_acl(acl); end
  def self.install_id_conv(idconv); end
  def self.mutex; end
  def self.primary_server; end
  def self.primary_server=(arg0); end
  def self.regist_server(server); end
  def self.remove_server(server); end
  def self.start_service(uri = nil, front = nil, config = nil); end
  def self.stop_service; end
  def self.thread; end
  def self.to_id(obj); end
  def self.to_obj(ref); end
  def self.uri; end
  def start_service(uri = nil, front = nil, config = nil); end
  def stop_service; end
  def thread; end
  def to_id(obj); end
  def to_obj(ref); end
  def uri; end
end
class DRb::DRbObject
  def ==(other); end
  def __drbref; end
  def __drburi; end
  def _dump(lv); end
  def eql?(other); end
  def hash; end
  def initialize(obj, uri = nil); end
  def method_missing(msg_id, *a, **, &b); end
  def pretty_print(q); end
  def pretty_print_cycle(q); end
  def respond_to?(msg_id, priv = nil); end
  def self._load(s); end
  def self.new_with(uri, ref); end
  def self.new_with_uri(uri); end
  def self.prepare_backtrace(uri, result); end
  def self.with_friend(uri); end
end
class DRb::DRbServer
  def alive?; end
  def any_to_s(obj); end
  def check_insecure_method(obj, msg_id); end
  def config; end
  def error_print(exception); end
  def front; end
  def here?(uri); end
  def initialize(uri = nil, front = nil, config_or_acl = nil); end
  def insecure_method?(msg_id); end
  def main_loop; end
  def run; end
  def self.default_acl(acl); end
  def self.default_argc_limit(argc); end
  def self.default_id_conv(idconv); end
  def self.default_load_limit(sz); end
  def self.make_config(hash = nil); end
  def self.verbose; end
  def self.verbose=(on); end
  def shutdown; end
  def stop_service; end
  def thread; end
  def to_id(obj); end
  def to_obj(ref); end
  def uri; end
  def verbose; end
  def verbose=(v); end
end
module DRb::DRbServer::InvokeMethod18Mixin
  def block_yield(x); end
  def perform_with_block; end
end
class DRb::DRbError < RuntimeError
end
class DRb::DRbConnError < DRb::DRbError
end
class DRb::DRbIdConv
  def to_id(obj); end
  def to_obj(ref); end
end
module DRb::DRbUndumped
  def _dump(dummy); end
end
class DRb::DRbServerNotFound < DRb::DRbError
end
class DRb::DRbBadURI < DRb::DRbError
end
class DRb::DRbBadScheme < DRb::DRbError
end
class DRb::DRbUnknownError < DRb::DRbError
  def _dump(lv); end
  def initialize(unknown); end
  def self._load(s); end
  def unknown; end
end
class DRb::DRbRemoteError < DRb::DRbError
  def initialize(error); end
  def reason; end
end
class DRb::DRbUnknown
  def _dump(lv); end
  def buf; end
  def exception; end
  def initialize(err, buf); end
  def name; end
  def reload; end
  def self._load(s); end
end
class DRb::DRbArray
  def _dump(lv); end
  def initialize(ary); end
  def self._load(s); end
end
class DRb::DRbMessage
  def dump(obj, error = nil); end
  def initialize(config); end
  def load(soc); end
  def make_proxy(obj, error = nil); end
  def recv_reply(stream); end
  def recv_request(stream); end
  def send_reply(stream, succ, result); end
  def send_request(stream, ref, msg_id, arg, b); end
end
module DRb::DRbProtocol
  def add_protocol(prot); end
  def auto_load(uri); end
  def open(uri, config, first = nil); end
  def open_server(uri, config, first = nil); end
  def self.add_protocol(prot); end
  def self.auto_load(uri); end
  def self.open(uri, config, first = nil); end
  def self.open_server(uri, config, first = nil); end
  def self.uri_option(uri, config, first = nil); end
  def uri_option(uri, config, first = nil); end
end
class DRb::DRbTCPSocket
  def accept; end
  def accept_or_shutdown; end
  def alive?; end
  def close; end
  def close_shutdown_pipe; end
  def initialize(uri, soc, config = nil); end
  def peeraddr; end
  def recv_reply; end
  def recv_request; end
  def self.getservername; end
  def self.open(uri, config); end
  def self.open_server(uri, config); end
  def self.open_server_inaddr_any(host, port); end
  def self.parse_uri(uri); end
  def self.uri_option(uri, config); end
  def send_reply(succ, result); end
  def send_request(ref, msg_id, arg, b); end
  def set_sockopt(soc); end
  def shutdown; end
  def stream; end
  def uri; end
end
class DRb::DRbURIOption
  def ==(other); end
  def eql?(other); end
  def hash; end
  def initialize(option); end
  def option; end
  def to_s; end
end
class DRb::ThreadObject
  def _execute; end
  def alive?; end
  def initialize(&blk); end
  def kill; end
  def method_missing(msg, *arg, &blk); end
  include MonitorMixin
end
class DRb::DRbConn
  def alive?; end
  def close; end
  def initialize(remote_uri); end
  def self.make_pool; end
  def self.open(remote_uri); end
  def self.stop_pool; end
  def send_message(ref, msg_id, arg, block); end
  def uri; end
end
class DRb::DRbServer::InvokeMethod
  def check_insecure_method; end
  def init_with_client; end
  def initialize(drb_server, client); end
  def perform; end
  def perform_without_block; end
  def setup_message; end
  include DRb::DRbServer::InvokeMethod18Mixin
end
class DRb::DRbUNIXSocket < DRb::DRbTCPSocket
  def accept; end
  def close; end
  def initialize(uri, soc, config = nil, server_mode = nil); end
  def self.open(uri, config); end
  def self.open_server(uri, config); end
  def self.parse_uri(uri); end
  def self.temp_server; end
  def self.uri_option(uri, config); end
  def set_sockopt(soc); end
end
