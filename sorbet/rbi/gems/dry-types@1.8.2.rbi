# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `dry-types` gem.
# Please instead update this file by running `bin/tapioca gem dry-types`.


# Main library namespace
#
# @api public
#
# source://dry-types//lib/dry/types/constraints.rb#3
module Dry
  class << self
    # source://dry-configurable/1.3.0/lib/dry/configurable.rb#11
    def Configurable(**options); end

    # source://dry-core/1.1.0/lib/dry/core.rb#52
    def Equalizer(*keys, **options); end

    # Export registered types as a module with constants
    #
    # @api public
    # @example no options
    #
    #   module Types
    #   # imports all types as constants, uses modules for namespaces
    #   include Dry.Types()
    #   end
    #   # strict types are exported by default
    #   Types::Integer
    #   # => #<Dry::Types[Constrained<Nominal<Integer> rule=[type?(Integer)]>]>
    #   Types::Nominal::Integer
    #   # => #<Dry::Types[Nominal<Integer>]>
    # @example changing default types
    #
    #   module Types
    #   include Dry.Types(default: :nominal)
    #   end
    #   Types::Integer
    #   # => #<Dry::Types[Nominal<Integer>]>
    # @example cherry-picking namespaces
    #
    #   module Types
    #   include Dry.Types(:strict, :coercible)
    #   end
    #   # cherry-picking discards default types,
    #   # provide the :default option along with the list of
    #   # namespaces if you want the to be exported
    #   Types.constants # => [:Coercible, :Strict]
    # @example custom names
    #   module Types
    #   include Dry.Types(coercible: :Kernel)
    #   end
    #   Types::Kernel::Integer
    #   # => #<Dry::Types[Constructor<Nominal<Integer> fn=Kernel.Integer>]>
    # @param namespaces [Array<Symbol>] List of type namespaces to export
    # @param default [Symbol] Default namespace to export
    # @param aliases [Hash{Symbol => Symbol}] Optional renamings, like strict: :Draconian
    # @return [Dry::Types::Module]
    # @see Dry::Types::Module
    #
    # source://dry-types//lib/dry/types.rb#253
    def Types(*namespaces, default: T.unsafe(nil), **aliases); end
  end
end

# @api public
# @see Dry.Types
#
# source://dry-types//lib/dry/types/constraints.rb#7
module Dry::Types
  include ::Dry::Core::Constants
  extend ::Dry::Core::Constants
  extend ::Dry::Core::ClassAttributes
  extend ::Dry::Core::Extensions
  extend ::Dry::Core::Deprecations::Interface

  class << self
    # @api public
    # @param options [Hash]
    # @return [Dry::Logic::Rule]
    #
    # source://dry-types//lib/dry/types/constraints.rb#13
    def Rule(options); end

    # Get a built-in type by its name
    #
    # @api public
    # @param name [String, Class]
    # @return [Type, Class]
    #
    # source://dry-types//lib/dry/types.rb#115
    def [](name); end

    # @api private
    #
    # source://dry-types//lib/dry/types.rb#163
    def const_missing(const); end

    # Return container with registered built-in type objects
    #
    # @api private
    # @return [Container{String => Nominal}]
    #
    # source://dry-types//lib/dry/types.rb#82
    def container; end

    # Add a new type builder method. This is a public API for defining custom
    # type constructors
    #
    # @api public
    # @example simple custom type constructor
    #   Dry::Types.define_builder(:or_nil) do |type|
    #   type.optional.fallback(nil)
    #   end
    #
    #   Dry::Types["integer"].or_nil.("foo") # => nil
    # @example fallback alias
    #   Dry::Types.define_builder(:or) do |type, fallback|
    #   type.fallback(fallback)
    #   end
    #
    #   Dry::Types["integer"].or(100).("foo") # => 100
    # @param method [Symbol]
    # @param block [#call]
    #
    # source://dry-types//lib/dry/types.rb#197
    def define_builder(method, &block); end

    # Infer a type identifier from the provided class
    #
    # @api public
    # @param klass [#to_s]
    # @return [String]
    #
    # source://dry-types//lib/dry/types.rb#149
    def identifier(klass); end

    # @api private
    # @private
    #
    # source://dry-types//lib/dry/types.rb#73
    def included(*_arg0); end

    # @api public
    #
    # source://dry-types//lib/dry/types.rb#33
    def loader; end

    # @api public
    #
    # source://dry-core/1.1.0/lib/dry/core/deprecations.rb#202
    def module(*args, &block); end

    # Register a new built-in type
    #
    # @api private
    # @param name [String]
    # @param type [Type]
    # @param block [#call, nil]
    # @return [Container{String => Nominal}]
    #
    # source://dry-types//lib/dry/types.rb#104
    def register(name, type = T.unsafe(nil), &block); end

    # Check if a give type is registered
    #
    # @api private
    # @return [Boolean]
    #
    # source://dry-types//lib/dry/types.rb#91
    def registered?(class_or_identifier); end

    # @api private
    # @return [Dry::Logic::RuleCompiler]
    #
    # source://dry-types//lib/dry/types/constraints.rb#26
    def rule_compiler; end

    # Cached type map
    #
    # @api private
    # @return [Concurrent::Map]
    #
    # source://dry-types//lib/dry/types.rb#158
    def type_map; end
  end
end

# All built-in primitives
#
# @api public
#
# source://dry-types//lib/dry/types/core.rb#38
Dry::Types::ALL_PRIMITIVES = T.let(T.unsafe(nil), Hash)

# source://dry-types//lib/dry/types/any.rb#39
Dry::Types::Any = T.let(T.unsafe(nil), Dry::Types::AnyClass)

# Any is a nominal type that defines Object as the primitive class
#
# This type is useful in places where you can't be specific about the type
# and anything is acceptable.
#
# @api public
#
# source://dry-types//lib/dry/types/any.rb#11
class Dry::Types::AnyClass < ::Dry::Types::Nominal
  # @api private
  # @return [AnyClass] a new instance of AnyClass
  #
  # source://dry-types//lib/dry/types/any.rb#15
  def initialize(**options); end

  # @api public
  # @return [String]
  #
  # source://dry-types//lib/dry/types/any.rb#22
  def name; end

  # @api public
  # @return [Array]
  #
  # source://dry-types//lib/dry/types/any.rb#36
  def to_ast(meta: T.unsafe(nil)); end

  # @api public
  # @param new_options [Hash]
  # @return [Type]
  #
  # source://dry-types//lib/dry/types/any.rb#29
  def with(**new_options); end

  class << self
    # @api public
    #
    # source://dry-types//lib/dry/types/any.rb#12
    def name; end
  end
end

# Array type can be used to define an array with optional member type
#
# @api public
#
# source://dry-types//lib/dry/types/array.rb#8
class Dry::Types::Array < ::Dry::Types::Nominal
  # @api private
  #
  # source://dry-types//lib/dry/types/array.rb#27
  def constructor_type; end

  # Build an array type with a member type
  #
  # @api public
  # @param type [Type, #call]
  # @return [Array::Member]
  #
  # source://dry-types//lib/dry/types/array.rb#16
  def of(type); end
end

# @api private
#
# source://dry-types//lib/dry/types/array/constructor.rb#8
class Dry::Types::Array::Constructor < ::Dry::Types::Constructor
  # @api private
  #
  # source://dry-types//lib/dry/types/array/constructor.rb#10
  def constructor_type; end

  # @api public
  # @return [Lax]
  #
  # source://dry-types//lib/dry/types/array/constructor.rb#15
  def lax; end

  # @api public
  # @see Dry::Types::Array#of
  #
  # source://dry-types//lib/dry/types/array/constructor.rb#20
  def of(member); end
end

# Member arrays define their member type that is applied to each element
#
# @api public
#
# source://dry-types//lib/dry/types/array/member.rb#9
class Dry::Types::Array::Member < ::Dry::Types::Array
  # @api private
  # @option options
  # @param primitive [Class]
  # @param options [Hash]
  # @return [Member] a new instance of Member
  #
  # source://dry-types//lib/dry/types/array/member.rb#19
  def initialize(primitive, **options); end

  # @api private
  # @param input [Object]
  # @return [Array]
  #
  # source://dry-types//lib/dry/types/array/member.rb#45
  def call_safe(input); end

  # @api private
  # @param input [Object]
  # @return [Array]
  #
  # source://dry-types//lib/dry/types/array/member.rb#29
  def call_unsafe(input); end

  # @api private
  #
  # source://dry-types//lib/dry/types/array/member.rb#116
  def constructor_type; end

  # Build a lax type
  #
  # @api public
  # @return [Lax]
  #
  # source://dry-types//lib/dry/types/array/member.rb#100
  def lax; end

  # @api public
  # @return [Type]
  #
  # source://dry-types//lib/dry/types/array/member.rb#11
  def member; end

  # @api public
  # @see Nominal#to_ast
  #
  # source://dry-types//lib/dry/types/array/member.rb#107
  def to_ast(meta: T.unsafe(nil)); end

  # @api public
  # @param input [Array, Object]
  # @param block [#call, nil]
  # @return [Result, Logic::Result]
  # @yieldparam failure [Failure]
  # @yieldreturn [Result]
  #
  # source://dry-types//lib/dry/types/array/member.rb#73
  def try(input, &block); end
end

# Common API for building types and composition
#
# @api public
#
# source://dry-types//lib/dry/types/builder.rb#8
module Dry::Types::Builder
  include ::Dry::Core::Constants

  # Compose two types into an Intersection type
  #
  # @api private
  # @param other [Type]
  # @return [Intersection, Intersection::Constrained]
  #
  # source://dry-types//lib/dry/types/builder.rb#37
  def &(other); end

  # Define a constructor for the type
  #
  # @api public
  # @param constructor [#call, nil]
  # @param options [Hash]
  # @param block [#call, nil]
  # @return [Constructor]
  #
  # source://dry-types//lib/dry/types/builder.rb#138
  def <<(constructor = T.unsafe(nil), **options, &block); end

  # Compose two types into an Implication type
  #
  # @api private
  # @param other [Type]
  # @return [Implication, Implication::Constrained]
  #
  # source://dry-types//lib/dry/types/builder.rb#46
  def >(other); end

  # Define a constructor for the type
  #
  # @api public
  # @param constructor [#call, nil]
  # @param options [Hash]
  # @param block [#call, nil]
  # @return [Constructor]
  #
  # source://dry-types//lib/dry/types/builder.rb#138
  def >>(constructor = T.unsafe(nil), **options, &block); end

  # Define a constructor for the type
  #
  # @api public
  # @param constructor [#call, nil]
  # @param options [Hash]
  # @param block [#call, nil]
  # @return [Constructor]
  #
  # source://dry-types//lib/dry/types/builder.rb#138
  def append(constructor = T.unsafe(nil), **options, &block); end

  # Turn a type into a constrained type
  #
  # @api public
  # @param options [Hash] constraining rule (see {Types.Rule})
  # @return [Constrained]
  #
  # source://dry-types//lib/dry/types/builder.rb#62
  def constrained(*_arg0, **_arg1, &_arg2); end

  # @api private
  # @return [Class]
  #
  # source://dry-types//lib/dry/types/builder.rb#14
  def constrained_type; end

  # Define a constructor for the type
  #
  # @api public
  # @param constructor [#call, nil]
  # @param options [Hash]
  # @param block [#call, nil]
  # @return [Constructor]
  #
  # source://dry-types//lib/dry/types/builder.rb#138
  def constructor(constructor = T.unsafe(nil), **options, &block); end

  # @api private
  # @return [Class]
  #
  # source://dry-types//lib/dry/types/builder.rb#19
  def constructor_type; end

  # Turn a type into a type with a default value
  #
  # @api public
  # @option [Boolean]
  # @param input [Object]
  # @param block [#call, nil]
  # @param [Boolean] [Hash] a customizable set of options
  # @raise [ConstraintError]
  # @return [Default]
  #
  # source://dry-types//lib/dry/types/builder.rb#77
  def default(input = T.unsafe(nil), options = T.unsafe(nil), &block); end

  # Define an enum on top of the existing type
  #
  # @api public
  # @param values [Array]
  # @return [Enum]
  #
  # source://dry-types//lib/dry/types/builder.rb#110
  def enum(*values); end

  # Use the given value on type mismatch
  #
  # @api public
  # @option [Boolean]
  # @param value [Object]
  # @param fallback [#call, nil]
  # @param [Boolean] [Hash] a customizable set of options
  # @return [Constructor]
  #
  # source://dry-types//lib/dry/types/builder.rb#155
  def fallback(value = T.unsafe(nil), shared: T.unsafe(nil), &_fallback); end

  # Turn a type into a lax type that will rescue from type-errors and
  # return the original input
  #
  # @api public
  # @return [Lax]
  #
  # source://dry-types//lib/dry/types/builder.rb#127
  def lax; end

  # Turn a type into an optional type
  #
  # @api public
  # @return [Sum]
  #
  # source://dry-types//lib/dry/types/builder.rb#53
  def optional; end

  # Define a constructor for the type
  #
  # @api public
  # @param constructor [#call, nil]
  # @param options [Hash]
  # @param block [#call, nil]
  # @return [Constructor]
  #
  # source://dry-types//lib/dry/types/builder.rb#138
  def prepend(constructor = T.unsafe(nil), **options, &block); end

  # Compose two types into a Sum type
  #
  # @api private
  # @param other [Type]
  # @return [Sum, Sum::Constrained]
  #
  # source://dry-types//lib/dry/types/builder.rb#28
  def |(other); end

  private

  # @api private
  #
  # source://dry-types//lib/dry/types/builder.rb#193
  def compose(other, composition_class); end
end

# Common API for building type objects in a convenient way
#
# @api public
#
# source://dry-types//lib/dry/types/builder_methods.rb#9
module Dry::Types::BuilderMethods
  # Build an array type.
  #
  # Shortcut for Array#of.
  #
  # @api public
  # @example
  #   Types::Strings = Types.Array(Types::String)
  # @param type [Dry::Types::Type]
  # @return [Dry::Types::Array]
  #
  # source://dry-types//lib/dry/types/builder_methods.rb#26
  def Array(type); end

  # Build a type with a single value
  # The equality check done with `equal?`
  #
  # @api public
  # @param object [Object]
  # @return [Dry::Types::Type]
  #
  # source://dry-types//lib/dry/types/builder_methods.rb#63
  def Constant(object); end

  # Build a constructor type
  # If no constructor block given it uses .new method
  #
  # @api public
  # @param klass [Class]
  # @param cons [#call, nil] Value constructor
  # @param block [#call, nil] Value constructor
  # @return [Dry::Types::Type]
  #
  # source://dry-types//lib/dry/types/builder_methods.rb#73
  def Constructor(klass, cons = T.unsafe(nil), &block); end

  # Build a hash schema
  #
  # @api public
  # @param type_map [Hash{Symbol => Dry::Types::Type}]
  # @return [Dry::Types::Array]
  #
  # source://dry-types//lib/dry/types/builder_methods.rb#33
  def Hash(type_map); end

  # Build a type which values are instances of a given class
  # Values are checked using `is_a?` call
  #
  # @api public
  # @example
  #   Types::Error = Types.Instance(StandardError)
  #   Types::Error = Types.Strict(StandardError)
  #   Types.Strict(Integer) == Types::Strict::Int # => true
  # @param klass [Class, Module] Class or module
  # @return [Dry::Types::Type]
  #
  # source://dry-types//lib/dry/types/builder_methods.rb#46
  def Instance(klass); end

  # Builds a constrained nominal type accepting any value that
  # responds to given methods
  #
  # @api public
  # @example
  #   Types::Callable = Types.Interface(:call)
  #   Types::Contact = Types.Interface(:name, :address)
  # @param methods [Array<String, Symbol>] Method names
  # @return [Dry::Types::Contrained]
  #
  # source://dry-types//lib/dry/types/builder_methods.rb#124
  def Interface(*methods); end

  # Build a map type
  #
  # @api public
  # @example
  #   Types::IntMap = Types.Map(Types::Strict::Integer, 'any')
  #   Types::IntStringMap = Types.Map(Types::Strict::Integer, Types::Strict::String)
  # @param key_type [Type] Key type
  # @param value_type [Type] Value type
  # @return [Dry::Types::Map]
  #
  # source://dry-types//lib/dry/types/builder_methods.rb#110
  def Map(key_type, value_type); end

  # Build a nominal type
  #
  # @api public
  # @param klass [Class]
  # @return [Dry::Types::Type]
  #
  # source://dry-types//lib/dry/types/builder_methods.rb#90
  def Nominal(klass); end

  # Build a type which values are instances of a given class
  # Values are checked using `is_a?` call
  #
  # @api public
  # @example
  #   Types::Error = Types.Instance(StandardError)
  #   Types::Error = Types.Strict(StandardError)
  #   Types.Strict(Integer) == Types::Strict::Int # => true
  # @param klass [Class, Module] Class or module
  # @return [Dry::Types::Type]
  #
  # source://dry-types//lib/dry/types/builder_methods.rb#46
  def Strict(klass); end

  # Build a type with a single value
  # The equality check done with `eql?`
  #
  # @api public
  # @param value [Object]
  # @return [Dry::Types::Type]
  #
  # source://dry-types//lib/dry/types/builder_methods.rb#55
  def Value(value); end

  # @api private
  #
  # source://dry-types//lib/dry/types/builder_methods.rb#11
  def included(base); end
end

# All coercible types
#
# @api public
#
# source://dry-types//lib/dry/types/core.rb#43
Dry::Types::COERCIBLE = T.let(T.unsafe(nil), Hash)

# Base class for coercion errors raise by dry-types
#
# @api public
#
# source://dry-types//lib/dry/types/errors.rb#15
class Dry::Types::CoercionError < ::StandardError
  # @api private
  # @return [CoercionError] a new instance of CoercionError
  #
  # source://dry-types//lib/dry/types/errors.rb#35
  def initialize(message, meta: T.unsafe(nil), backtrace: T.unsafe(nil)); end

  # Metadata associated with the error
  #
  # @api public
  # @return [Object]
  #
  # source://dry-types//lib/dry/types/errors.rb#32
  def meta; end

  class << self
    # @api private
    #
    # source://dry-types//lib/dry/types/errors.rb#17
    def handle(exception, meta: T.unsafe(nil)); end
  end
end

# Common coercion functions used by the built-in `Params` and `JSON` types
#
# @api public
#
# source://dry-types//lib/dry/types/coercions.rb#8
module Dry::Types::Coercions
  include ::Dry::Core::Constants

  # @api public
  # @param input [#to_str, Object]
  # @return [Date, Object]
  # @see Date.parse
  #
  # source://dry-types//lib/dry/types/coercions.rb#18
  def to_date(input, &_arg1); end

  # @api public
  # @param input [#to_str, Object]
  # @return [DateTime, Object]
  # @see DateTime.parse
  #
  # source://dry-types//lib/dry/types/coercions.rb#41
  def to_date_time(input, &_arg1); end

  # @api public
  # @param input [#to_sym, Object]
  # @raise CoercionError
  # @return [Symbol, Object]
  #
  # source://dry-types//lib/dry/types/coercions.rb#87
  def to_symbol(input, &_arg1); end

  # @api public
  # @param input [#to_str, Object]
  # @return [Time, Object]
  # @see Time.parse
  #
  # source://dry-types//lib/dry/types/coercions.rb#64
  def to_time(input, &_arg1); end

  private

  # Checks whether String is empty
  #
  # @api private
  # @param value [String, Object]
  # @return [Boolean]
  #
  # source://dry-types//lib/dry/types/coercions.rb#102
  def empty_str?(value); end
end

# JSON-specific coercions
#
# @api public
#
# source://dry-types//lib/dry/types/coercions/json.rb#14
module Dry::Types::Coercions::JSON
  extend ::Dry::Core::Constants
  extend ::Dry::Types::Coercions

  class << self
    # @api public
    # @param input [#to_d, Object]
    # @raise CoercionError
    # @return [BigDecimal, nil]
    #
    # source://dry-types//lib/dry/types/coercions/json.rb#41
    def to_decimal(input, &_arg1); end

    # @api public
    # @param input [Object]
    # @raise CoercionError
    # @return [nil] if the input is nil
    #
    # source://dry-types//lib/dry/types/coercions/json.rb#24
    def to_nil(input, &_arg1); end
  end
end

# Params-specific coercions
#
# @api public
#
# source://dry-types//lib/dry/types/coercions/params.rb#12
module Dry::Types::Coercions::Params
  extend ::Dry::Core::Constants
  extend ::Dry::Types::Coercions

  class << self
    # @api public
    # @param input [Array, String, Object]
    # @raise CoercionError
    # @return [Array, Object]
    #
    # source://dry-types//lib/dry/types/coercions/params.rb#135
    def to_ary(input, &_arg1); end

    # @api public
    # @param input [#to_d, Object]
    # @raise CoercionError
    # @return [BigDecimal, nil, Object]
    #
    # source://dry-types//lib/dry/types/coercions/params.rb#116
    def to_decimal(input, &_arg1); end

    # @api public
    # @param input [String, Object]
    # @raise CoercionError
    # @return [Boolean, Object]
    # @see TRUE_VALUES
    # @see FALSE_VALUES
    #
    # source://dry-types//lib/dry/types/coercions/params.rb#69
    def to_false(input, &_arg1); end

    # @api public
    # @param input [#to_f, Object]
    # @raise CoercionError
    # @return [Float, nil, Object]
    #
    # source://dry-types//lib/dry/types/coercions/params.rb#103
    def to_float(input, &_arg1); end

    # @api public
    # @param input [Hash, String, Object]
    # @raise CoercionError
    # @return [Hash, Object]
    #
    # source://dry-types//lib/dry/types/coercions/params.rb#154
    def to_hash(input, &_arg1); end

    # @api public
    # @param input [#to_int, #to_i, Object]
    # @raise CoercionError
    # @return [Integer, nil, Object]
    #
    # source://dry-types//lib/dry/types/coercions/params.rb#86
    def to_int(input, &_arg1); end

    # @api public
    # @param input [Object]
    # @raise CoercionError
    # @return [nil] if the input is an empty string or nil
    #
    # source://dry-types//lib/dry/types/coercions/params.rb#29
    def to_nil(input, &_arg1); end

    # @api public
    # @param input [String, Object]
    # @raise CoercionError
    # @return [Boolean, Object]
    # @see TRUE_VALUES
    # @see FALSE_VALUES
    #
    # source://dry-types//lib/dry/types/coercions/params.rb#49
    def to_true(input, &_arg1); end
  end
end

# @api public
#
# source://dry-types//lib/dry/types/coercions/params.rb#15
Dry::Types::Coercions::Params::BOOLEAN_MAP = T.let(T.unsafe(nil), Hash)

# @api public
#
# source://dry-types//lib/dry/types/coercions/params.rb#14
Dry::Types::Coercions::Params::FALSE_VALUES = T.let(T.unsafe(nil), Array)

# @api public
#
# source://dry-types//lib/dry/types/coercions/params.rb#13
Dry::Types::Coercions::Params::TRUE_VALUES = T.let(T.unsafe(nil), Array)

# @api private
#
# source://dry-types//lib/dry/types/compiler.rb#6
class Dry::Types::Compiler
  extend ::Dry::Core::Deprecations::Interface

  # @api private
  # @return [Compiler] a new instance of Compiler
  #
  # source://dry-types//lib/dry/types/compiler.rb#11
  def initialize(registry); end

  # @api private
  #
  # source://dry-types//lib/dry/types/compiler.rb#15
  def call(ast); end

  # @api private
  #
  # source://dry-types//lib/dry/types/compiler.rb#114
  def compile_fn(fn); end

  # @api private
  #
  # source://dry-types//lib/dry/types/compiler.rb#9
  def registry; end

  # @api private
  #
  # source://dry-types//lib/dry/types/compiler.rb#17
  def visit(node); end

  # @api private
  #
  # source://dry-types//lib/dry/types/compiler.rb#110
  def visit_any(meta); end

  # @api private
  #
  # source://dry-types//lib/dry/types/compiler.rb#59
  def visit_array(node); end

  # @api private
  #
  # source://dry-types//lib/dry/types/compiler.rb#22
  def visit_constrained(node); end

  # @api private
  #
  # source://dry-types//lib/dry/types/compiler.rb#28
  def visit_constructor(node); end

  # @api private
  #
  # source://dry-types//lib/dry/types/compiler.rb#100
  def visit_enum(node); end

  # @api private
  #
  # source://dry-types//lib/dry/types/compiler.rb#65
  def visit_hash(node); end

  # @api private
  #
  # source://dry-types//lib/dry/types/compiler.rb#80
  def visit_json_array(node); end

  # @api private
  #
  # source://dry-types//lib/dry/types/compiler.rb#75
  def visit_json_hash(node); end

  # @api private
  #
  # source://dry-types//lib/dry/types/compiler.rb#95
  def visit_key(node); end

  # @api private
  #
  # source://dry-types//lib/dry/types/compiler.rb#34
  def visit_lax(node); end

  # @api private
  #
  # source://dry-types//lib/dry/types/compiler.rb#105
  def visit_map(node); end

  # @api private
  #
  # source://dry-types//lib/dry/types/compiler.rb#39
  def visit_nominal(node); end

  # @api private
  #
  # source://dry-types//lib/dry/types/compiler.rb#90
  def visit_params_array(node); end

  # @api private
  #
  # source://dry-types//lib/dry/types/compiler.rb#85
  def visit_params_hash(node); end

  # @api private
  #
  # source://dry-types//lib/dry/types/compiler.rb#50
  def visit_rule(node); end

  # source://dry-core/1.1.0/lib/dry/core/deprecations.rb#168
  def visit_safe(*args, &block); end

  # @api private
  #
  # source://dry-types//lib/dry/types/compiler.rb#70
  def visit_schema(node); end

  # @api private
  #
  # source://dry-types//lib/dry/types/compiler.rb#54
  def visit_sum(node); end
end

# source://dry-types//lib/dry/types/composition.rb#9
module Dry::Types::Composition
  include ::Dry::Types::Type
  include ::Dry::Core::Constants
  include ::Dry::Types::Builder
  include ::Dry::Types::Options
  include ::Dry::Types::Meta
  include ::Dry::Types::Printable
  include ::Dry::Core::Equalizer::Methods
  include ::Dry::Types::Composition::Constrained

  # @api private
  # @param left [Type]
  # @param right [Type]
  # @param options [Hash]
  #
  # source://dry-types//lib/dry/types/composition.rb#50
  def initialize(left, right, **options); end

  # @api private
  # @param input [Object]
  # @raise [::NotImplementedError]
  # @return [Object]
  #
  # source://dry-types//lib/dry/types/composition.rb#88
  def call_safe(input, &_arg1); end

  # @api private
  # @param input [Object]
  # @raise [::NotImplementedError]
  # @return [Object]
  #
  # source://dry-types//lib/dry/types/composition.rb#81
  def call_unsafe(input); end

  # @api public
  # @return [false]
  #
  # source://dry-types//lib/dry/types/composition.rb#69
  def constrained?; end

  # @api public
  # @return [false]
  #
  # source://dry-types//lib/dry/types/composition.rb#64
  def default?; end

  # @api private
  #
  # source://dry-types//lib/dry/types/composition.rb#106
  def failure(input, _error = T.unsafe(nil)); end

  # @return [Type]
  #
  # source://dry-types//lib/dry/types/composition.rb#22
  def left; end

  # @api public
  # @return [String]
  #
  # source://dry-types//lib/dry/types/composition.rb#59
  def name; end

  # @api public
  # @return [Boolean]
  #
  # source://dry-types//lib/dry/types/composition.rb#74
  def optional?; end

  # @api private
  # @param value [Object]
  # @raise [::NotImplementedError]
  # @return [Boolean]
  #
  # source://dry-types//lib/dry/types/composition.rb#120
  def primitive?(value); end

  # @return [Type]
  #
  # source://dry-types//lib/dry/types/composition.rb#25
  def right; end

  # @api private
  #
  # source://dry-types//lib/dry/types/composition.rb#96
  def success(input); end

  # @api public
  # @see Nominal#to_ast
  #
  # source://dry-types//lib/dry/types/composition.rb#125
  def to_ast(meta: T.unsafe(nil)); end

  # Wrap the type with a proc
  #
  # @api public
  # @return [Proc]
  #
  # source://dry-types//lib/dry/types/composition.rb#135
  def to_proc; end

  # @api public
  # @param input [Object]
  # @raise [::NotImplementedError]
  #
  # source://dry-types//lib/dry/types/composition.rb#93
  def try(input, &_arg1); end

  class << self
    # @private
    #
    # source://dry-types//lib/dry/types/composition.rb#37
    def included(base); end
  end
end

# source://dry-types//lib/dry/types/composition.rb#27
module Dry::Types::Composition::Constrained
  # @return [Boolean]
  #
  # source://dry-types//lib/dry/types/composition.rb#32
  def constrained?; end

  # source://dry-types//lib/dry/types/composition.rb#28
  def rule; end
end

# Constrained types apply rules to the input
#
# @api public
#
# source://dry-types//lib/dry/types/constrained.rb#8
class Dry::Types::Constrained
  include ::Dry::Types::Type
  include ::Dry::Types::Options
  include ::Dry::Types::Decorator
  include ::Dry::Core::Constants
  include ::Dry::Types::Builder
  include ::Dry::Types::Printable
  include ::Dry::Core::Equalizer::Methods

  # @api public
  # @param type [Type]
  # @param options [Hash]
  # @return [Constrained] a new instance of Constrained
  #
  # source://dry-types//lib/dry/types/constrained.rb#23
  def initialize(type, **options); end

  # @api public
  # @param value [Object]
  # @return [Boolean]
  #
  # source://dry-types//lib/dry/types/constrained.rb#108
  def ===(value); end

  # @api private
  # @return [Object]
  #
  # source://dry-types//lib/dry/types/constrained.rb#44
  def call_safe(input, &_arg1); end

  # @api private
  # @return [Object]
  #
  # source://dry-types//lib/dry/types/constrained.rb#31
  def call_unsafe(input); end

  # @api public
  # @param *nullary_rules [Array<Symbol>] a list of rules that do not require an additional
  #   argument (e.g., :odd)
  # @param **unary_rules [Hash] a list of rules that require an additional argument
  #   (e.g., gt: 0)
  #   The parameters are merger to create a rules hash provided to {Types.Rule} and combined
  #   using {&} with previous {#rule}
  # @return [Constrained]
  # @see Dry::Logic::Operators#and
  #
  # source://dry-types//lib/dry/types/constrained.rb#90
  def constrained(*nullary_rules, **unary_rules); end

  # @api public
  # @return [true]
  #
  # source://dry-types//lib/dry/types/constrained.rb#101
  def constrained?; end

  # @api private
  #
  # source://dry-types//lib/dry/types/constrained.rb#123
  def constructor_type; end

  # Build lax type. Constraints are not applicable to lax types hence unwrapping
  #
  # @api public
  # @return [Lax]
  #
  # source://dry-types//lib/dry/types/constrained.rb#114
  def lax; end

  # @api public
  # @return [Dry::Logic::Rule]
  #
  # source://dry-types//lib/dry/types/constrained.rb#16
  def rule; end

  # @api public
  # @see Nominal#to_ast
  #
  # source://dry-types//lib/dry/types/constrained.rb#118
  def to_ast(meta: T.unsafe(nil)); end

  # Safe coercion attempt. It is similar to #call with a
  # block given but returns a Result instance with metadata
  # about errors (if any).
  #
  # @api public
  # @overload try
  # @overload try
  #
  # source://dry-types//lib/dry/types/constrained.rb#67
  def try(input, &_arg1); end

  private

  # @api private
  # @param response [Object]
  # @return [Boolean]
  #
  # source://dry-types//lib/dry/types/constrained.rb#132
  def decorate?(response); end

  # @api private
  # @param positional_args [Array]
  # @return [Hash]
  #
  # source://dry-types//lib/dry/types/constrained.rb#139
  def parse_arguments(positional_arguments); end
end

# Common coercion-related API for constrained types
#
# @api public
#
# source://dry-types//lib/dry/types/constrained/coercible.rb#9
class Dry::Types::Constrained::Coercible < ::Dry::Types::Constrained
  # @api private
  # @return [Object]
  #
  # source://dry-types//lib/dry/types/constrained/coercible.rb#27
  def call_safe(input); end

  # @api private
  # @return [Object]
  #
  # source://dry-types//lib/dry/types/constrained/coercible.rb#13
  def call_unsafe(input); end

  # @api public
  # @see Dry::Types::Constrained#try
  #
  # source://dry-types//lib/dry/types/constrained/coercible.rb#40
  def try(input, &_arg1); end
end

# @api public
#
# source://dry-types//lib/dry/types/errors.rb#112
class Dry::Types::ConstraintError < ::Dry::Types::CoercionError
  # @api public
  # @param result [String, #to_s]
  # @param input [Object]
  # @return [ConstraintError] a new instance of ConstraintError
  #
  # source://dry-types//lib/dry/types/errors.rb#120
  def initialize(result, input); end

  # @api public
  # @return [Object]
  #
  # source://dry-types//lib/dry/types/errors.rb#116
  def input; end

  # @api public
  # @return [String]
  #
  # source://dry-types//lib/dry/types/errors.rb#132
  def message; end

  # @api public
  # @return [String, #to_s]
  #
  # source://dry-types//lib/dry/types/errors.rb#114
  def result; end

  # @api public
  # @return [String]
  #
  # source://dry-types//lib/dry/types/errors.rb#132
  def to_s; end
end

# Constructor types apply a function to the input that is supposed to return
# a new value. Coercion is a common use case for constructor types.
#
# @api public
#
# source://dry-types//lib/dry/types/constructor.rb#9
class Dry::Types::Constructor < ::Dry::Types::Nominal
  # Instantiate a new constructor type instance
  #
  # @api private
  # @param type [Type]
  # @param fn [Function]
  # @param options [Hash]
  # @return [Constructor] a new instance of Constructor
  #
  # source://dry-types//lib/dry/types/constructor.rb#62
  def initialize(type, fn: T.unsafe(nil), **options); end

  # Build a new constructor by prepending a block to the coercion function
  #
  # @api public
  # @param new_fn [#call, nil]
  # @param options [Hash]
  # @param block [#call, nil]
  # @return [Constructor]
  #
  # source://dry-types//lib/dry/types/constructor.rb#140
  def <<(new_fn = T.unsafe(nil), **options, &block); end

  # Build a new constructor by appending a block to the coercion function
  #
  # @api public
  # @param new_fn [#call, nil]
  # @param options [Hash]
  # @param block [#call, nil]
  # @return [Constructor]
  #
  # source://dry-types//lib/dry/types/constructor.rb#107
  def >>(new_fn = T.unsafe(nil), **options, &block); end

  # Build a new constructor by appending a block to the coercion function
  #
  # @api public
  # @param new_fn [#call, nil]
  # @param options [Hash]
  # @param block [#call, nil]
  # @return [Constructor]
  #
  # source://dry-types//lib/dry/types/constructor.rb#107
  def append(new_fn = T.unsafe(nil), **options, &block); end

  # @api private
  # @return [Object]
  #
  # source://dry-types//lib/dry/types/constructor.rb#72
  def call_safe(input); end

  # @api private
  # @return [Object]
  #
  # source://dry-types//lib/dry/types/constructor.rb#80
  def call_unsafe(input); end

  # @api private
  # @return [Class]
  #
  # source://dry-types//lib/dry/types/constructor.rb#122
  def constrained_type; end

  # Build a new constructor by appending a block to the coercion function
  #
  # @api public
  # @param new_fn [#call, nil]
  # @param options [Hash]
  # @param block [#call, nil]
  # @return [Constructor]
  #
  # source://dry-types//lib/dry/types/constructor.rb#107
  def constructor(new_fn = T.unsafe(nil), **options, &block); end

  # @api public
  # @return [#call]
  #
  # source://dry-types//lib/dry/types/constructor.rb#13
  def fn; end

  # Build a lax type
  #
  # @api public
  # @return [Lax]
  #
  # source://dry-types//lib/dry/types/constructor.rb#149
  def lax; end

  # Build a new constructor by prepending a block to the coercion function
  #
  # @api public
  # @param new_fn [#call, nil]
  # @param options [Hash]
  # @param block [#call, nil]
  # @return [Constructor]
  #
  # source://dry-types//lib/dry/types/constructor.rb#140
  def prepend(new_fn = T.unsafe(nil), **options, &block); end

  # @api public
  # @see Nominal#to_ast
  #
  # source://dry-types//lib/dry/types/constructor.rb#127
  def to_ast(meta: T.unsafe(nil)); end

  # Wrap the type with a proc
  #
  # @api public
  # @return [Proc]
  #
  # source://dry-types//lib/dry/types/constructor.rb#156
  def to_proc; end

  # @api public
  # @param input [Object]
  # @param block [#call, nil]
  # @return [Logic::Result, Types::Result]
  # @return [Object] if block given and try fails
  #
  # source://dry-types//lib/dry/types/constructor.rb#89
  def try(input, &_arg1); end

  # @api public
  # @return [Type]
  #
  # source://dry-types//lib/dry/types/constructor.rb#16
  def type; end

  private

  # Delegates missing methods to {#type}
  #
  # @api private
  # @param method [Symbol]
  # @param args [Array]
  # @param block [#call, nil]
  #
  # source://dry-types//lib/dry/types/constructor.rb#176
  def method_missing(method, *_arg1, **_arg2, &_arg3); end

  # @api private
  # @param meth [Symbol]
  # @param include_private [Boolean]
  # @return [Boolean]
  #
  # source://dry-types//lib/dry/types/constructor.rb#165
  def respond_to_missing?(meth, include_private = T.unsafe(nil)); end

  class << self
    # @api public
    # @param input [Builder, Object]
    # @param options [Hash]
    # @param block [#call, nil]
    #
    # source://dry-types//lib/dry/types/constructor.rb#35
    def [](type, fn:, **options); end

    # @api public
    # @param input [Builder, Object]
    # @param options [Hash]
    # @param block [#call, nil]
    #
    # source://dry-types//lib/dry/types/constructor.rb#25
    def new(input, fn: T.unsafe(nil), **options, &block); end

    # @api private
    #
    # source://dry-types//lib/dry/types/constructor.rb#46
    def wrapper_type; end
  end
end

# Function is used internally by Constructor types
#
# @api private
#
# source://dry-types//lib/dry/types/constructor/function.rb#11
class Dry::Types::Constructor::Function
  include ::Dry::Core::Equalizer::Methods

  # @api private
  # @return [Function] a new instance of Function
  #
  # source://dry-types//lib/dry/types/constructor/function.rb#167
  def initialize(fn); end

  # @api private
  # @return [Function]
  #
  # source://dry-types//lib/dry/types/constructor/function.rb#196
  def <<(other); end

  # @api private
  # @return [Function]
  #
  # source://dry-types//lib/dry/types/constructor/function.rb#190
  def >>(other); end

  # @api private
  # @return [Object]
  #
  # source://dry-types//lib/dry/types/constructor/function.rb#172
  def [](input, &_arg1); end

  # @api private
  # @return [Integer]
  #
  # source://dry-types//lib/dry/types/constructor/function.rb#176
  def arity; end

  # @api private
  # @return [Object]
  #
  # source://dry-types//lib/dry/types/constructor/function.rb#172
  def call(input, &_arg1); end

  # @api private
  #
  # source://dry-types//lib/dry/types/constructor/function.rb#165
  def fn; end

  # @api private
  # @return [Array]
  #
  # source://dry-types//lib/dry/types/constructor/function.rb#181
  def to_ast; end

  # @api private
  # @return [Boolean]
  #
  # source://dry-types//lib/dry/types/constructor/function.rb#178
  def wrapper?; end

  class << self
    # Choose or build specialized invokation code for a callable
    #
    # @api private
    # @param fn [#call]
    # @raise [::ArgumentError]
    # @return [Function]
    #
    # source://dry-types//lib/dry/types/constructor/function.rb#135
    def [](fn); end

    # @api private
    # @return [Boolean]
    #
    # source://dry-types//lib/dry/types/constructor/function.rb#152
    def yields_block?(fn); end
  end
end

# Coercion via a method call on a known object
#
# @api private
#
# source://dry-types//lib/dry/types/constructor/function.rb#26
class Dry::Types::Constructor::Function::MethodCall < ::Dry::Types::Constructor::Function
  # @api private
  # @return [MethodCall] a new instance of MethodCall
  #
  # source://dry-types//lib/dry/types/constructor/function.rb#110
  def initialize(fn); end

  # @api private
  #
  # source://dry-types//lib/dry/types/constructor/function.rb#108
  def name; end

  # @api private
  #
  # source://dry-types//lib/dry/types/constructor/function.rb#108
  def target; end

  # @api private
  #
  # source://dry-types//lib/dry/types/constructor/function.rb#116
  def to_ast; end

  class << self
    # @api private
    # @return [MethodCall]
    #
    # source://dry-types//lib/dry/types/constructor/function.rb#103
    def [](fn, safe); end

    # Choose or build the base class
    #
    # @api private
    # @return [Function]
    #
    # source://dry-types//lib/dry/types/constructor/function.rb#32
    def call_class(method, public, safe); end
  end
end

# Coercion via a private method call
#
# @api private
#
# source://dry-types//lib/dry/types/constructor/function.rb#85
class Dry::Types::Constructor::Function::MethodCall::PrivateCall < ::Dry::Types::Constructor::Function::MethodCall
  # @api private
  #
  # source://dry-types//lib/dry/types/constructor/function.rb#86
  def call(input, &_arg1); end
end

# Coercion via an unsafe private method call
#
# @api private
#
# source://dry-types//lib/dry/types/constructor/function.rb#92
class Dry::Types::Constructor::Function::MethodCall::PrivateSafeCall < ::Dry::Types::Constructor::Function::MethodCall::PrivateCall
  # @api private
  #
  # source://dry-types//lib/dry/types/constructor/function.rb#93
  def call(input, &_arg1); end
end

# Coercion with a publicly accessible method call
#
# @api private
#
# source://dry-types//lib/dry/types/constructor/function.rb#53
class Dry::Types::Constructor::Function::MethodCall::PublicCall < ::Dry::Types::Constructor::Function::MethodCall
  class << self
    # Choose or build the interface
    #
    # @api private
    # @return [::Module]
    #
    # source://dry-types//lib/dry/types/constructor/function.rb#59
    def call_interface(method, safe); end
  end
end

# Wrapper for unsafe coercion functions
#
# @api private
#
# source://dry-types//lib/dry/types/constructor/function.rb#15
class Dry::Types::Constructor::Function::Safe < ::Dry::Types::Constructor::Function
  # @api private
  #
  # source://dry-types//lib/dry/types/constructor/function.rb#16
  def call(input, &_arg1); end
end

# @api private
#
# source://dry-types//lib/dry/types/constructor/function.rb#119
class Dry::Types::Constructor::Function::Wrapper < ::Dry::Types::Constructor::Function
  # @api private
  # @return [Object]
  #
  # source://dry-types//lib/dry/types/constructor/function.rb#121
  def [](input, type, &_arg2); end

  # @api private
  #
  # source://dry-types//lib/dry/types/constructor/function.rb#128
  def arity; end

  # @api private
  # @return [Object]
  #
  # source://dry-types//lib/dry/types/constructor/function.rb#121
  def call(input, type, &_arg2); end
end

# @api public
#
# source://dry-types//lib/dry/types/constructor/wrapper.rb#7
module Dry::Types::Constructor::Wrapper
  # Build a new constructor by prepending a block to the coercion function
  #
  # @api public
  # @param new_fn [#call, nil]
  # @param options [Hash]
  # @param block [#call, nil]
  # @return [Constructor]
  #
  # source://dry-types//lib/dry/types/constructor/wrapper.rb#56
  def <<(new_fn = T.unsafe(nil), **options, &block); end

  # Define a constructor for the type
  #
  # @api public
  # @param constructor [#call, nil]
  # @param options [Hash]
  # @param block [#call, nil]
  # @return [Constructor]
  #
  # source://dry-types//lib/dry/types/builder.rb#138
  def >>(constructor = T.unsafe(nil), **options, &block); end

  # Define a constructor for the type
  #
  # @api public
  # @param constructor [#call, nil]
  # @param options [Hash]
  # @param block [#call, nil]
  # @return [Constructor]
  #
  # source://dry-types//lib/dry/types/builder.rb#138
  def append(constructor = T.unsafe(nil), **options, &block); end

  # @api private
  # @return [Object]
  #
  # source://dry-types//lib/dry/types/constructor/wrapper.rb#11
  def call_safe(input, &_arg1); end

  # @api private
  # @return [Object]
  #
  # source://dry-types//lib/dry/types/constructor/wrapper.rb#16
  def call_unsafe(input); end

  # Define a constructor for the type
  #
  # @api public
  # @param constructor [#call, nil]
  # @param options [Hash]
  # @param block [#call, nil]
  # @return [Constructor]
  #
  # source://dry-types//lib/dry/types/builder.rb#138
  def constructor(constructor = T.unsafe(nil), **options, &block); end

  # @api public
  # @return [Constructor]
  #
  # source://dry-types//lib/dry/types/constructor/wrapper.rb#73
  def lax; end

  # Build a new constructor by prepending a block to the coercion function
  #
  # @api public
  # @param new_fn [#call, nil]
  # @param options [Hash]
  # @param block [#call, nil]
  # @return [Constructor]
  #
  # source://dry-types//lib/dry/types/constructor/wrapper.rb#56
  def prepend(new_fn = T.unsafe(nil), **options, &block); end

  # @api public
  # @param input [Object]
  # @param block [#call, nil]
  # @return [Logic::Result, Types::Result]
  # @return [Object] if block given and try fails
  #
  # source://dry-types//lib/dry/types/constructor/wrapper.rb#25
  def try(input, &_arg1); end

  private

  # Replace underlying type
  #
  # @api private
  #
  # source://dry-types//lib/dry/types/constructor/wrapper.rb#84
  def __new__(type); end
end

# Internal container for the built-in types
#
# @api private
#
# source://dry-types//lib/dry/types/container.rb#8
class Dry::Types::Container
  include ::Dry::Core::Container::Mixin::Initializer
  include ::Dry::Core::Container::Mixin
  extend ::Dry::Core::Container::Configuration
  extend ::Dry::Core::Constants
  extend ::Dry::Configurable
  extend ::Dry::Configurable::Methods
  extend ::Dry::Configurable::ClassMethods

  # source://dry-core/1.1.0/lib/dry/core/container/mixin.rb#83
  def config; end
end

# Common API for types
#
# @api public
#
# source://dry-types//lib/dry/types/decorator.rb#8
module Dry::Types::Decorator
  include ::Dry::Types::Options

  # @api public
  # @param type [Type]
  #
  # source://dry-types//lib/dry/types/decorator.rb#15
  def initialize(type, *_arg1, **_arg2); end

  # @api public
  # @return [Boolean]
  #
  # source://dry-types//lib/dry/types/decorator.rb#37
  def constrained?; end

  # @api public
  # @return [Boolean]
  #
  # source://dry-types//lib/dry/types/decorator.rb#32
  def default?; end

  # Wrap the type with a proc
  #
  # @api public
  # @return [Proc]
  #
  # source://dry-types//lib/dry/types/decorator.rb#54
  def to_proc; end

  # @api public
  # @param input [Object]
  # @param block [#call, nil]
  # @return [Result, Logic::Result]
  # @return [Object] if block given and try fails
  #
  # source://dry-types//lib/dry/types/decorator.rb#27
  def try(input, &_arg1); end

  # @api public
  # @return [Type]
  #
  # source://dry-types//lib/dry/types/decorator.rb#12
  def type; end

  private

  # Replace underlying type
  #
  # @api private
  #
  # source://dry-types//lib/dry/types/decorator.rb#89
  def __new__(type); end

  # @api private
  # @param response [Object]
  # @return [Boolean]
  #
  # source://dry-types//lib/dry/types/decorator.rb#63
  def decorate?(response); end

  # Delegates missing methods to {#type}
  #
  # @api private
  # @param meth [Symbol]
  # @param args [Array]
  # @param block [#call, nil]
  #
  # source://dry-types//lib/dry/types/decorator.rb#72
  def method_missing(meth, *_arg1, **_arg2, &_arg3); end

  # @api public
  # @param meth [Symbol]
  # @param include_private [Boolean]
  # @return [Boolean]
  #
  # source://dry-types//lib/dry/types/decorator.rb#45
  def respond_to_missing?(meth, include_private = T.unsafe(nil)); end
end

# Default types are useful when a missing value should be replaced by a default one
#
# @api public
#
# source://dry-types//lib/dry/types/default.rb#8
class Dry::Types::Default
  include ::Dry::Types::Type
  include ::Dry::Types::Options
  include ::Dry::Types::Decorator
  include ::Dry::Core::Constants
  include ::Dry::Types::Builder
  include ::Dry::Types::Printable
  include ::Dry::Core::Equalizer::Methods

  # @api private
  # @param type [Type]
  # @param value [Object]
  # @return [Default] a new instance of Default
  #
  # source://dry-types//lib/dry/types/default.rb#53
  def initialize(type, value, **_arg2); end

  # @api private
  # @param input [Object]
  # @return [Object] value passed through {#type} or {#default} value
  #
  # source://dry-types//lib/dry/types/default.rb#108
  def call_safe(input = T.unsafe(nil), &_arg1); end

  # @api private
  # @param input [Object]
  # @return [Object] value passed through {#type} or {#default} value
  #
  # source://dry-types//lib/dry/types/default.rb#95
  def call_unsafe(input = T.unsafe(nil)); end

  # @api private
  # @return [false]
  #
  # source://dry-types//lib/dry/types/default.rb#119
  def callable?; end

  # Build a constrained type
  #
  # @api public
  # @param args [Array] see {Dry::Types::Builder#constrained}
  # @return [Default]
  #
  # source://dry-types//lib/dry/types/default.rb#65
  def constrained(*_arg0, **_arg1, &_arg2); end

  # @api public
  # @return [true]
  #
  # source://dry-types//lib/dry/types/default.rb#70
  def default?; end

  # @api public
  # @return [Object]
  #
  # source://dry-types//lib/dry/types/default.rb#32
  def evaluate; end

  # @api public
  # @param input [Object]
  # @return [Result::Success]
  #
  # source://dry-types//lib/dry/types/default.rb#77
  def try(input = T.unsafe(nil), &_arg1); end

  # @api public
  # @return [Boolean]
  #
  # source://dry-types//lib/dry/types/default.rb#88
  def valid?(value = T.unsafe(nil)); end

  # @api public
  # @return [Object]
  #
  # source://dry-types//lib/dry/types/default.rb#32
  def value; end

  class << self
    # @api private
    # @param value [Object, #call]
    # @return [Class] {Default} or {Default::Callable}
    #
    # source://dry-types//lib/dry/types/default.rb#41
    def [](value); end
  end
end

# @api private
#
# source://dry-types//lib/dry/types/default.rb#10
class Dry::Types::Default::Callable < ::Dry::Types::Default
  # @api private
  # @return [true]
  #
  # source://dry-types//lib/dry/types/default.rb#20
  def callable?; end

  # Evaluates given callable
  #
  # @api private
  # @return [Object]
  #
  # source://dry-types//lib/dry/types/default.rb#15
  def evaluate; end
end

# @api public
Dry::Types::Definition = Dry::Types::Nominal

# Enum types can be used to define an enum on top of an existing type
#
# @api public
#
# source://dry-types//lib/dry/types/enum.rb#8
class Dry::Types::Enum
  include ::Dry::Types::Type
  include ::Dry::Core::Equalizer::Methods
  include ::Dry::Types::Options
  include ::Dry::Types::Decorator
  include ::Dry::Core::Constants
  include ::Dry::Types::Builder

  # @api private
  # @option options
  # @param type [Type]
  # @param options [Hash]
  # @return [Enum] a new instance of Enum
  #
  # source://dry-types//lib/dry/types/enum.rb#28
  def initialize(type, **options); end

  # @api private
  # @return [Object]
  #
  # source://dry-types//lib/dry/types/enum.rb#44
  def call_safe(input, &_arg1); end

  # @api private
  # @return [Object]
  #
  # source://dry-types//lib/dry/types/enum.rb#39
  def call_unsafe(input); end

  # @api private
  #
  # source://dry-types//lib/dry/types/enum.rb#52
  def default(*_arg0); end

  # Iterate over each enum value
  #
  # @api public
  # @return [Array, Enumerator]
  #
  # source://dry-types//lib/dry/types/enum.rb#77
  def each_value(&_arg0); end

  # Check whether a value is in the enum
  #
  # @api public
  #
  # source://dry-types//lib/dry/types/type.rb#18
  def include?(input = T.unsafe(nil)); end

  # @api public
  # @return [String]
  #
  # source://dry-types//lib/dry/types/enum.rb#70
  def inspect; end

  # @api public
  # @return [Hash]
  #
  # source://dry-types//lib/dry/types/enum.rb#21
  def inverted_mapping; end

  # @api private
  # @return [String]
  #
  # source://dry-types//lib/dry/types/enum.rb#91
  def joined_values; end

  # @api public
  # @return [Hash]
  #
  # source://dry-types//lib/dry/types/enum.rb#18
  def mapping; end

  # @api public
  # @return [String]
  #
  # source://dry-types//lib/dry/types/enum.rb#86
  def name; end

  # @api public
  # @see Nominal#to_ast
  #
  # source://dry-types//lib/dry/types/enum.rb#63
  def to_ast(meta: T.unsafe(nil)); end

  # @api public
  # @return [String]
  #
  # source://dry-types//lib/dry/types/enum.rb#70
  def to_s; end

  # @api public
  # @see Dry::Types::Constrained#try
  #
  # source://dry-types//lib/dry/types/enum.rb#49
  def try(input, &_arg1); end

  # @api public
  # @return [Array]
  #
  # source://dry-types//lib/dry/types/enum.rb#15
  def values; end

  private

  # Maps a value
  #
  # @api private
  # @param input [Object]
  # @return [Object]
  #
  # source://dry-types//lib/dry/types/enum.rb#110
  def map_value(input); end
end

# Internal container for constructor functions used by the built-in types
#
# @api private
#
# source://dry-types//lib/dry/types/fn_container.rb#8
class Dry::Types::FnContainer
  class << self
    # @api private
    #
    # source://dry-types//lib/dry/types/fn_container.rb#23
    def [](fn_name); end

    # @api private
    #
    # source://dry-types//lib/dry/types/fn_container.rb#10
    def container; end

    # @api private
    #
    # source://dry-types//lib/dry/types/fn_container.rb#15
    def register(function = T.unsafe(nil), &block); end

    # @api private
    #
    # source://dry-types//lib/dry/types/fn_container.rb#32
    def register_name(function); end
  end
end

# Hash types can be used to define maps and schemas
#
# @api public
#
# source://dry-types//lib/dry/types/hash.rb#8
class Dry::Types::Hash < ::Dry::Types::Nominal
  # @api private
  #
  # source://dry-types//lib/dry/types/hash.rb#77
  def constructor_type; end

  # Build a map type
  #
  # @api public
  # @param key_type [Type]
  # @param value_type [Type]
  # @return [Map]
  #
  # source://dry-types//lib/dry/types/hash.rb#40
  def map(key_type, value_type); end

  # @api private
  #
  # source://dry-types//lib/dry/types/hash.rb#50
  def permissive(*_arg0); end

  # @api public
  # @overload schema
  # @overload schema
  #
  # source://dry-types//lib/dry/types/hash.rb#22
  def schema(keys_or_map, meta = T.unsafe(nil)); end

  # @api private
  #
  # source://dry-types//lib/dry/types/hash.rb#50
  def strict(*_arg0); end

  # @api private
  #
  # source://dry-types//lib/dry/types/hash.rb#50
  def strict_with_defaults(*_arg0); end

  # @api private
  #
  # source://dry-types//lib/dry/types/hash.rb#50
  def symbolized(*_arg0); end

  # @api public
  # @param meta [Boolean] Whether to dump the meta to the AST
  # @return [Array] An AST representation
  #
  # source://dry-types//lib/dry/types/hash.rb#95
  def to_ast(meta: T.unsafe(nil)); end

  # Whether the type transforms types of schemas created by {Dry::Types::Hash#schema}
  #
  # @api public
  # @return [Boolean]
  #
  # source://dry-types//lib/dry/types/hash.rb#86
  def transform_types?; end

  # @api private
  #
  # source://dry-types//lib/dry/types/hash.rb#50
  def weak(*_arg0); end

  # Injects a type transformation function for building schemas
  #
  # @api public
  # @param proc [#call, nil]
  # @param block [#call, nil]
  # @raise [::ArgumentError]
  # @return [Hash]
  #
  # source://dry-types//lib/dry/types/hash.rb#67
  def with_type_transform(proc = T.unsafe(nil), &block); end

  private

  # @api private
  #
  # source://dry-types//lib/dry/types/hash.rb#104
  def build_keys(type_map); end

  # @api private
  #
  # source://dry-types//lib/dry/types/hash.rb#125
  def key_name(key); end

  # @api private
  #
  # source://dry-types//lib/dry/types/hash.rb#116
  def resolve_type(type); end
end

# @api public
#
# source://dry-types//lib/dry/types/hash/constructor.rb#9
class Dry::Types::Hash::Constructor < ::Dry::Types::Constructor
  # @api private
  #
  # source://dry-types//lib/dry/types/hash/constructor.rb#11
  def constructor_type; end

  # @api public
  # @return [Lax]
  #
  # source://dry-types//lib/dry/types/hash/constructor.rb#16
  def lax; end

  # @api public
  # @see Dry::Types::Array#of
  #
  # source://dry-types//lib/dry/types/hash/constructor.rb#21
  def schema(*_arg0, **_arg1, &_arg2); end
end

# @api public
#
# source://dry-types//lib/dry/types/hash.rb#9
Dry::Types::Hash::NOT_REQUIRED = T.let(T.unsafe(nil), Hash)

# Implication type
#
# @api public
#
# source://dry-types//lib/dry/types/implication.rb#8
class Dry::Types::Implication
  include ::Dry::Types::Type
  include ::Dry::Core::Constants
  include ::Dry::Types::Builder
  include ::Dry::Types::Options
  include ::Dry::Types::Meta
  include ::Dry::Types::Printable
  include ::Dry::Core::Equalizer::Methods
  include ::Dry::Types::Composition

  # @api private
  # @param input [Object]
  # @return [Object]
  #
  # source://dry-types//lib/dry/types/implication.rb#31
  def call_safe(input, &_arg1); end

  # @api private
  # @param input [Object]
  # @return [Object]
  #
  # source://dry-types//lib/dry/types/implication.rb#18
  def call_unsafe(input); end

  # @api private
  # @param value [Object]
  # @return [Boolean]
  #
  # source://dry-types//lib/dry/types/implication.rb#55
  def primitive?(value); end

  # @api public
  # @param input [Object]
  #
  # source://dry-types//lib/dry/types/implication.rb#42
  def try(input, &_arg1); end

  class << self
    # source://dry-types//lib/dry/types/composition.rb#40
    def ast_type; end

    # source://dry-types//lib/dry/types/composition.rb#41
    def composition_name; end

    # @api public
    #
    # source://dry-types//lib/dry/types/implication.rb#11
    def operator; end
  end
end

# source://dry-types//lib/dry/types/implication.rb#0
class Dry::Types::Implication::Constrained < ::Dry::Types::Implication
  include ::Dry::Types::Composition::Constrained
end

# @api public
#
# source://dry-types//lib/dry/types/inflector.rb#7
Dry::Types::Inflector = T.let(T.unsafe(nil), Dry::Inflector)

# Intersection type
#
# @api public
#
# source://dry-types//lib/dry/types/intersection.rb#12
class Dry::Types::Intersection
  include ::Dry::Types::Type
  include ::Dry::Core::Constants
  include ::Dry::Types::Builder
  include ::Dry::Types::Options
  include ::Dry::Types::Meta
  include ::Dry::Types::Printable
  include ::Dry::Core::Equalizer::Methods
  include ::Dry::Types::Composition

  # @api private
  # @param input [Object]
  # @return [Object]
  #
  # source://dry-types//lib/dry/types/intersection.rb#31
  def call_safe(input, &_arg1); end

  # @api private
  # @param input [Object]
  # @return [Object]
  #
  # source://dry-types//lib/dry/types/intersection.rb#22
  def call_unsafe(input); end

  # @api private
  # @param value [Object]
  # @return [Boolean]
  #
  # source://dry-types//lib/dry/types/intersection.rb#51
  def primitive?(value); end

  # @api public
  # @param input [Object]
  #
  # source://dry-types//lib/dry/types/intersection.rb#36
  def try(input); end

  private

  # @api private
  #
  # source://dry-types//lib/dry/types/intersection.rb#90
  def merge_results(left_result, right_result); end

  # @api private
  #
  # source://dry-types//lib/dry/types/intersection.rb#72
  def try_side(side, input); end

  # @api private
  #
  # source://dry-types//lib/dry/types/intersection.rb#58
  def try_sides(input, &block); end

  class << self
    # source://dry-types//lib/dry/types/composition.rb#40
    def ast_type; end

    # source://dry-types//lib/dry/types/composition.rb#41
    def composition_name; end

    # @api public
    #
    # source://dry-types//lib/dry/types/intersection.rb#15
    def operator; end
  end
end

# source://dry-types//lib/dry/types/intersection.rb#0
class Dry::Types::Intersection::Constrained < ::Dry::Types::Intersection
  include ::Dry::Types::Composition::Constrained
end

# Primitives with {Kernel} coercion methods
#
# @api public
#
# source://dry-types//lib/dry/types/core.rb#6
Dry::Types::KERNEL_COERCIBLE = T.let(T.unsafe(nil), Hash)

# Lax types rescue from type-related errors when constructors fail
#
# @api public
#
# source://dry-types//lib/dry/types/lax.rb#8
class Dry::Types::Lax
  include ::Dry::Types::Type
  include ::Dry::Types::Options
  include ::Dry::Types::Decorator
  include ::Dry::Core::Constants
  include ::Dry::Types::Builder
  include ::Dry::Types::Printable
  include ::Dry::Core::Equalizer::Methods

  # @api public
  # @param input [Object]
  # @return [Object]
  #
  # source://dry-types//lib/dry/types/lax.rb#22
  def [](input, &_arg1); end

  # @api public
  # @param input [Object]
  # @return [Object]
  #
  # source://dry-types//lib/dry/types/lax.rb#22
  def call(input, &_arg1); end

  # @api public
  # @param input [Object]
  # @return [Object]
  #
  # source://dry-types//lib/dry/types/lax.rb#22
  def call_safe(input, &_arg1); end

  # @api public
  # @param input [Object]
  # @return [Object]
  #
  # source://dry-types//lib/dry/types/lax.rb#22
  def call_unsafe(input, &_arg1); end

  # @api public
  # @return [Lax]
  #
  # source://dry-types//lib/dry/types/lax.rb#48
  def lax; end

  # @api public
  # @see Nominal#to_ast
  #
  # source://dry-types//lib/dry/types/lax.rb#43
  def to_ast(meta: T.unsafe(nil)); end

  # @api public
  # @param input [Object]
  # @param block [#call, nil]
  # @return [Result, Logic::Result]
  # @yieldparam failure [Failure]
  # @yieldreturn [Result]
  #
  # source://dry-types//lib/dry/types/lax.rb#38
  def try(input, &_arg1); end

  private

  # @api private
  # @param response [Object, Dry::Types::Constructor]
  # @return [Boolean]
  #
  # source://dry-types//lib/dry/types/lax.rb#57
  def decorate?(response); end
end

# Primitives with coercions through by convention `to_*` methods
#
# @api public
#
# source://dry-types//lib/dry/types/core.rb#16
Dry::Types::METHOD_COERCIBLE = T.let(T.unsafe(nil), Hash)

# By convention methods to coerce {METHOD_COERCIBLE} primitives
#
# @api public
#
# source://dry-types//lib/dry/types/core.rb#21
Dry::Types::METHOD_COERCIBLE_METHODS = T.let(T.unsafe(nil), Hash)

# Homogeneous mapping. It describes a hash with unknown keys that match a certain type.
#
# @api public
# @example
#   type = Dry::Types['hash'].map(
#   Dry::Types['integer'].constrained(gteq: 1, lteq: 10),
#   Dry::Types['string']
#   )
#
#   type.(1 => 'right')
#   # => {1 => 'right'}
#
#   type.('1' => 'wrong')
#   # Dry::Types::MapError: "1" violates constraints (type?(Integer, "1")
#   #                                                 AND gteq?(1, "1")
#   #                                                 AND lteq?(10, "1") failed)
#
#   type.(11 => 'wrong')
#   # Dry::Types::MapError: 11 violates constraints (lteq?(10, 11) failed)
#
# source://dry-types//lib/dry/types/map.rb#25
class Dry::Types::Map < ::Dry::Types::Nominal
  # @api public
  # @return [Map] a new instance of Map
  #
  # source://dry-types//lib/dry/types/map.rb#26
  def initialize(primitive, key_type: T.unsafe(nil), value_type: T.unsafe(nil), meta: T.unsafe(nil)); end

  # @api private
  # @param hash [Hash]
  # @return [Hash]
  #
  # source://dry-types//lib/dry/types/map.rb#61
  def call_safe(hash); end

  # @api private
  # @param hash [Hash]
  # @return [Hash]
  #
  # source://dry-types//lib/dry/types/map.rb#50
  def call_unsafe(hash); end

  # @api public
  # @return [Boolean]
  #
  # source://dry-types//lib/dry/types/map.rb#90
  def constrained?; end

  # @api public
  # @return [Type]
  #
  # source://dry-types//lib/dry/types/map.rb#33
  def key_type; end

  # @api public
  # @return [String]
  #
  # source://dry-types//lib/dry/types/map.rb#43
  def name; end

  # @api public
  # @param meta [Boolean] Whether to dump the meta to the AST
  # @return [Array] An AST representation
  #
  # source://dry-types//lib/dry/types/map.rb#80
  def to_ast(meta: T.unsafe(nil)); end

  # @api public
  # @param hash [Hash]
  # @return [Result]
  # @yield [result]
  #
  # source://dry-types//lib/dry/types/map.rb#68
  def try(hash); end

  # @api public
  # @return [Type]
  #
  # source://dry-types//lib/dry/types/map.rb#38
  def value_type; end

  private

  # @api public
  #
  # source://dry-types//lib/dry/types/map.rb#125
  def assert_primitive(input); end

  # @api private
  #
  # source://dry-types//lib/dry/types/map.rb#96
  def coerce(input); end
end

# @api public
#
# source://dry-types//lib/dry/types/errors.rb#85
class Dry::Types::MapError < ::Dry::Types::CoercionError; end

# Storage for meta-data
#
# @api public
#
# source://dry-types//lib/dry/types/meta.rb#8
module Dry::Types::Meta
  # @api public
  #
  # source://dry-types//lib/dry/types/meta.rb#9
  def initialize(*args, meta: T.unsafe(nil), **options); end

  # @api public
  # @overload meta
  # @overload meta
  #
  # source://dry-types//lib/dry/types/meta.rb#29
  def meta(data = T.unsafe(nil)); end

  # Resets meta
  #
  # @api public
  # @return [Dry::Types::Type]
  #
  # source://dry-types//lib/dry/types/meta.rb#44
  def pristine; end

  # @api public
  # @param options [Hash] new_options
  # @return [Type]
  #
  # source://dry-types//lib/dry/types/meta.rb#19
  def with(**options); end
end

# @api public
#
# source://dry-types//lib/dry/types/errors.rb#90
class Dry::Types::MissingKeyError < ::Dry::Types::SchemaKeyError
  # @api public
  # @param key [String, Symbol]
  # @return [MissingKeyError] a new instance of MissingKeyError
  #
  # source://dry-types//lib/dry/types/errors.rb#95
  def initialize(key); end

  # @api public
  # @return [Symbol]
  #
  # source://dry-types//lib/dry/types/errors.rb#92
  def key; end
end

# Export types registered in a container as module constants.
#
# @api public
# @example
#   module Types
#   include Dry.Types(:strict, :coercible, :nominal, default: :strict)
#   end
#
#   Types.constants
#   # => [:Class, :Strict, :Symbol, :Integer, :Float, :String, :Array, :Hash,
#   #     :Decimal, :Nil, :True, :False, :Bool, :Date, :Nominal, :DateTime, :Range,
#   #     :Coercible, :Time]
#
# source://dry-types//lib/dry/types/module.rb#19
class Dry::Types::Module < ::Module
  # @api public
  # @return [Module] a new instance of Module
  #
  # source://dry-types//lib/dry/types/module.rb#20
  def initialize(registry, *args, **kwargs); end

  # @api private
  #
  # source://dry-types//lib/dry/types/module.rb#74
  def registry_tree; end

  # @api private
  #
  # source://dry-types//lib/dry/types/module.rb#42
  def type_constants(*namespaces, default: T.unsafe(nil), **aliases); end

  private

  # @api private
  #
  # source://dry-types//lib/dry/types/module.rb#89
  def check_parameters(*namespaces, default: T.unsafe(nil), **aliases); end

  # @api private
  #
  # source://dry-types//lib/dry/types/module.rb#109
  def define_constants(constants, mod = T.unsafe(nil)); end
end

# Collection of multiple errors
#
# @api public
#
# source://dry-types//lib/dry/types/errors.rb#48
class Dry::Types::MultipleError < ::Dry::Types::CoercionError
  # @api public
  # @param errors [Array<CoercionError>]
  # @return [MultipleError] a new instance of MultipleError
  #
  # source://dry-types//lib/dry/types/errors.rb#53
  def initialize(errors); end

  # @api public
  # @return [Array<CoercionError>]
  #
  # source://dry-types//lib/dry/types/errors.rb#50
  def errors; end

  # @api public
  # @return string
  #
  # source://dry-types//lib/dry/types/errors.rb#59
  def message; end

  # @api public
  # @return [Array]
  #
  # source://dry-types//lib/dry/types/errors.rb#62
  def meta; end
end

# Primitives that are non-coercible
#
# @api public
#
# source://dry-types//lib/dry/types/core.rb#26
Dry::Types::NON_COERCIBLE = T.let(T.unsafe(nil), Hash)

# All built-in primitives except {NilClass}
#
# @api public
#
# source://dry-types//lib/dry/types/core.rb#46
Dry::Types::NON_NIL = T.let(T.unsafe(nil), Hash)

# Nominal types define a primitive class and do not apply any constructors or constraints
#
# Use these types for annotations and the base for building more complex types on top of them.
#
# @api public
#
# source://dry-types//lib/dry/types/nominal.rb#10
class Dry::Types::Nominal
  include ::Dry::Types::Type
  include ::Dry::Types::Options
  include ::Dry::Types::Meta
  include ::Dry::Core::Constants
  include ::Dry::Types::Builder
  include ::Dry::Types::Printable
  include ::Dry::Core::Equalizer::Methods

  # @api private
  # @param primitive [Type, Class]
  # @param options [Hash]
  # @return [Nominal] a new instance of Nominal
  #
  # source://dry-types//lib/dry/types/nominal.rb#42
  def initialize(primitive, **options); end

  # @api private
  # @param input [BasicObject]
  # @return [BasicObject]
  #
  # source://dry-types//lib/dry/types/nominal.rb#80
  def call_safe(input, &_arg1); end

  # @api private
  # @param input [BasicObject]
  # @return [BasicObject]
  #
  # source://dry-types//lib/dry/types/nominal.rb#73
  def call_unsafe(input); end

  # @api private
  #
  # source://dry-types//lib/dry/types/nominal.rb#121
  def coerce(input, &_arg1); end

  # @api public
  # @return [false]
  #
  # source://dry-types//lib/dry/types/nominal.rb#61
  def constrained?; end

  # @api public
  # @return [false]
  #
  # source://dry-types//lib/dry/types/nominal.rb#56
  def default?; end

  # @api public
  # @raise [::ArgumentError]
  # @return [Result::Failure]
  #
  # source://dry-types//lib/dry/types/nominal.rb#105
  def failure(input, error); end

  # Return self. Nominal types are lax by definition
  #
  # @api public
  # @return [Nominal]
  #
  # source://dry-types//lib/dry/types/nominal.rb#163
  def lax; end

  # @api public
  # @return [String]
  #
  # source://dry-types//lib/dry/types/nominal.rb#51
  def name; end

  # @api public
  # @return [false]
  #
  # source://dry-types//lib/dry/types/nominal.rb#66
  def optional?; end

  # @api public
  # @return [Class]
  #
  # source://dry-types//lib/dry/types/nominal.rb#19
  def primitive; end

  # Checks whether value is of a #primitive class
  #
  # @api public
  # @param value [Object]
  # @return [Boolean]
  #
  # source://dry-types//lib/dry/types/nominal.rb#118
  def primitive?(value); end

  # @api public
  # @return [Result::Success]
  #
  # source://dry-types//lib/dry/types/nominal.rb#98
  def success(input); end

  # Return AST representation of a type nominal
  #
  # @api public
  # @return [Array]
  #
  # source://dry-types//lib/dry/types/nominal.rb#154
  def to_ast(meta: T.unsafe(nil)); end

  # Wrap the type with a proc
  #
  # @api public
  # @return [Proc]
  #
  # source://dry-types//lib/dry/types/nominal.rb#170
  def to_proc; end

  # @api public
  # @param input [Object]
  # @return [Result, Logic::Result] when a block is not provided
  # @return [nil] otherwise
  # @yieldparam failure [Failure]
  # @yieldreturn [Result]
  #
  # source://dry-types//lib/dry/types/nominal.rb#91
  def try(input, &_arg1); end

  # @api private
  #
  # source://dry-types//lib/dry/types/nominal.rb#132
  def try_coerce(input); end

  class << self
    # @api private
    # @param primitive [Class]
    # @return [Type]
    #
    # source://dry-types//lib/dry/types/nominal.rb#26
    def [](primitive); end
  end
end

# @api public
#
# source://dry-types//lib/dry/types/nominal.rb#36
Dry::Types::Nominal::ALWAYS = T.let(T.unsafe(nil), Proc)

# Common API for types with options
#
# @api private
#
# source://dry-types//lib/dry/types/options.rb#8
module Dry::Types::Options
  # @api private
  # @see Nominal#initialize
  #
  # source://dry-types//lib/dry/types/options.rb#15
  def initialize(*args, **options); end

  # @api private
  # @return [Hash]
  #
  # source://dry-types//lib/dry/types/options.rb#10
  def options; end

  # @api private
  # @param new_options [Hash]
  # @return [Type]
  #
  # source://dry-types//lib/dry/types/options.rb#25
  def with(**new_options); end
end

# source://dry-types//lib/dry/types/printer.rb#293
Dry::Types::PRINTER = T.let(T.unsafe(nil), Dry::Types::Printer)

# PredicateInferrer returns the list of predicates used by a type.
#
# @api public
#
# source://dry-types//lib/dry/types/predicate_inferrer.rb#8
class Dry::Types::PredicateInferrer
  include ::Dry::Core::Cache::Methods
  extend ::Dry::Core::Cache

  # @api private
  # @return [PredicateInferrer] a new instance of PredicateInferrer
  #
  # source://dry-types//lib/dry/types/predicate_inferrer.rb#212
  def initialize(registry = T.unsafe(nil)); end

  # Infer predicate identifier from the provided type
  #
  # @api private
  # @param type [Type]
  # @return [Symbol]
  #
  # source://dry-types//lib/dry/types/predicate_inferrer.rb#222
  def [](type); end

  # @api private
  # @return [Compiler]
  #
  # source://dry-types//lib/dry/types/predicate_inferrer.rb#209
  def compiler; end
end

# @api public
#
# source://dry-types//lib/dry/types/predicate_inferrer.rb#31
Dry::Types::PredicateInferrer::ARRAY = T.let(T.unsafe(nil), Array)

# Compiler reduces type AST into a list of predicates
#
# @api private
#
# source://dry-types//lib/dry/types/predicate_inferrer.rb#38
class Dry::Types::PredicateInferrer::Compiler
  extend ::Dry::Core::Constants
  extend ::Dry::Core::ClassAttributes

  # @api private
  # @return [Compiler] a new instance of Compiler
  #
  # source://dry-types//lib/dry/types/predicate_inferrer.rb#49
  def initialize(registry); end

  # @api private
  #
  # source://dry-types//lib/dry/types/predicate_inferrer.rb#54
  def infer_predicate(type); end

  # @api private
  # @return [PredicateRegistry]
  #
  # source://dry-types//lib/dry/types/predicate_inferrer.rb#46
  def registry; end

  # @api private
  #
  # source://dry-types//lib/dry/types/predicate_inferrer.rb#89
  def visit(node); end

  # @api private
  #
  # source://dry-types//lib/dry/types/predicate_inferrer.rb#163
  def visit_and(node); end

  # @api private
  #
  # source://dry-types//lib/dry/types/predicate_inferrer.rb#160
  def visit_any(_); end

  # @api private
  #
  # source://dry-types//lib/dry/types/predicate_inferrer.rb#113
  def visit_array(_); end

  # @api private
  #
  # source://dry-types//lib/dry/types/predicate_inferrer.rb#148
  def visit_constrained(node); end

  # @api private
  #
  # source://dry-types//lib/dry/types/predicate_inferrer.rb#123
  def visit_constructor(node); end

  # @api private
  #
  # source://dry-types//lib/dry/types/predicate_inferrer.rb#129
  def visit_enum(node); end

  # @api private
  #
  # source://dry-types//lib/dry/types/predicate_inferrer.rb#107
  def visit_hash(_); end

  # @api private
  #
  # source://dry-types//lib/dry/types/predicate_inferrer.rb#118
  def visit_lax(node); end

  # @api private
  # @raise [::NotImplementedError]
  #
  # source://dry-types//lib/dry/types/predicate_inferrer.rb#187
  def visit_map(_node); end

  # @api private
  #
  # source://dry-types//lib/dry/types/predicate_inferrer.rb#95
  def visit_nominal(node); end

  # @api private
  #
  # source://dry-types//lib/dry/types/predicate_inferrer.rb#169
  def visit_predicate(node); end

  # @api private
  #
  # source://dry-types//lib/dry/types/predicate_inferrer.rb#107
  def visit_schema(_); end

  # @api private
  #
  # source://dry-types//lib/dry/types/predicate_inferrer.rb#135
  def visit_sum(node); end

  private

  # @api private
  #
  # source://dry-types//lib/dry/types/predicate_inferrer.rb#194
  def merge_predicates(nodes); end
end

# @api public
#
# source://dry-types//lib/dry/types/predicate_inferrer.rb#29
Dry::Types::PredicateInferrer::HASH = T.let(T.unsafe(nil), Array)

# @api public
#
# source://dry-types//lib/dry/types/predicate_inferrer.rb#33
Dry::Types::PredicateInferrer::NIL = T.let(T.unsafe(nil), Array)

# @api public
#
# source://dry-types//lib/dry/types/predicate_inferrer.rb#25
Dry::Types::PredicateInferrer::REDUCED_TYPES = T.let(T.unsafe(nil), Hash)

# @api public
#
# source://dry-types//lib/dry/types/predicate_inferrer.rb#11
Dry::Types::PredicateInferrer::TYPE_TO_PREDICATE = T.let(T.unsafe(nil), Hash)

# A registry with predicate objects from `Dry::Logic::Predicates`
#
# @api private
#
# source://dry-types//lib/dry/types/predicate_registry.rb#8
class Dry::Types::PredicateRegistry
  # @api private
  # @return [PredicateRegistry] a new instance of PredicateRegistry
  #
  # source://dry-types//lib/dry/types/predicate_registry.rb#19
  def initialize(predicates = T.unsafe(nil)); end

  # @api private
  #
  # source://dry-types//lib/dry/types/predicate_registry.rb#29
  def [](name); end

  # @api private
  #
  # source://dry-types//lib/dry/types/predicate_registry.rb#13
  def has_predicate; end

  # @api private
  # @return [Boolean]
  #
  # source://dry-types//lib/dry/types/predicate_registry.rb#24
  def key?(name); end

  # @api private
  #
  # source://dry-types//lib/dry/types/predicate_registry.rb#10
  def predicates; end
end

# @api private
#
# source://dry-types//lib/dry/types/predicate_registry.rb#15
Dry::Types::PredicateRegistry::KERNEL_RESPOND_TO = T.let(T.unsafe(nil), UnboundMethod)

# PrimitiveInferrer returns the list of classes matching a type.
#
# @api public
#
# source://dry-types//lib/dry/types/primitive_inferrer.rb#8
class Dry::Types::PrimitiveInferrer
  include ::Dry::Core::Cache::Methods
  extend ::Dry::Core::Cache

  # @api private
  # @return [PrimitiveInferrer] a new instance of PrimitiveInferrer
  #
  # source://dry-types//lib/dry/types/primitive_inferrer.rb#71
  def initialize; end

  # Infer primitives from the provided type
  #
  # @api private
  # @return [Array[Class]]
  #
  # source://dry-types//lib/dry/types/primitive_inferrer.rb#80
  def [](type); end

  # @api private
  # @return [Compiler]
  #
  # source://dry-types//lib/dry/types/primitive_inferrer.rb#68
  def compiler; end
end

# Compiler reduces type AST into a list of primitives
#
# @api private
#
# source://dry-types//lib/dry/types/primitive_inferrer.rb#14
class Dry::Types::PrimitiveInferrer::Compiler
  # @api private
  #
  # source://dry-types//lib/dry/types/primitive_inferrer.rb#16
  def visit(node); end

  # @api private
  #
  # source://dry-types//lib/dry/types/primitive_inferrer.rb#63
  def visit_any(_); end

  # @api private
  #
  # source://dry-types//lib/dry/types/primitive_inferrer.rb#32
  def visit_array(_); end

  # @api private
  #
  # source://dry-types//lib/dry/types/primitive_inferrer.rb#57
  def visit_constrained(node); end

  # @api private
  #
  # source://dry-types//lib/dry/types/primitive_inferrer.rb#38
  def visit_constructor(node); end

  # @api private
  #
  # source://dry-types//lib/dry/types/primitive_inferrer.rb#44
  def visit_enum(node); end

  # @api private
  #
  # source://dry-types//lib/dry/types/primitive_inferrer.rb#28
  def visit_hash(_); end

  # @api private
  #
  # source://dry-types//lib/dry/types/primitive_inferrer.rb#35
  def visit_lax(node); end

  # @api private
  #
  # source://dry-types//lib/dry/types/primitive_inferrer.rb#22
  def visit_nominal(node); end

  # @api private
  #
  # source://dry-types//lib/dry/types/primitive_inferrer.rb#28
  def visit_schema(_); end

  # @api private
  #
  # source://dry-types//lib/dry/types/primitive_inferrer.rb#50
  def visit_sum(node); end
end

# @api private
#
# source://dry-types//lib/dry/types/printable.rb#6
module Dry::Types::Printable
  # @api private
  # @return [String]
  #
  # source://dry-types//lib/dry/types/printable.rb#10
  def inspect; end

  # @api private
  # @return [String]
  #
  # source://dry-types//lib/dry/types/printable.rb#10
  def to_s; end
end

# @api private
#
# source://dry-types//lib/dry/types/printer/composition.rb#6
class Dry::Types::Printer
  # @api private
  # @return [Printer] a new instance of Printer
  #
  # source://dry-types//lib/dry/types/printer.rb#38
  def initialize; end

  # @api private
  #
  # source://dry-types//lib/dry/types/printer.rb#43
  def call(type); end

  # @api private
  #
  # source://dry-types//lib/dry/types/printer.rb#49
  def visit(type, &_arg1); end

  # @api private
  # @yield ["Any"]
  #
  # source://dry-types//lib/dry/types/printer.rb#62
  def visit_any(_); end

  # @api private
  #
  # source://dry-types//lib/dry/types/printer.rb#64
  def visit_array(type); end

  # @api private
  #
  # source://dry-types//lib/dry/types/printer.rb#70
  def visit_array_member(array); end

  # @api private
  #
  # source://dry-types//lib/dry/types/printer.rb#152
  def visit_callable(callable); end

  # @api private
  #
  # source://dry-types//lib/dry/types/printer.rb#102
  def visit_composition(composition, &_arg1); end

  # @api private
  #
  # source://dry-types//lib/dry/types/printer.rb#91
  def visit_constrained(constrained); end

  # @api private
  #
  # source://dry-types//lib/dry/types/printer.rb#78
  def visit_constructor(constructor); end

  # @api private
  #
  # source://dry-types//lib/dry/types/printer.rb#126
  def visit_default(default); end

  # @api private
  #
  # source://dry-types//lib/dry/types/printer.rb#108
  def visit_enum(enum); end

  # @api private
  #
  # source://dry-types//lib/dry/types/printer.rb#250
  def visit_hash(hash); end

  # @api private
  #
  # source://dry-types//lib/dry/types/printer.rb#240
  def visit_key(key); end

  # @api private
  #
  # source://dry-types//lib/dry/types/printer.rb#146
  def visit_lax(lax); end

  # @api private
  #
  # source://dry-types//lib/dry/types/printer.rb#226
  def visit_map(map); end

  # @api private
  #
  # source://dry-types//lib/dry/types/printer.rb#140
  def visit_nominal(type); end

  # @api private
  #
  # source://dry-types//lib/dry/types/printer.rb#269
  def visit_options(options, meta = T.unsafe(nil)); end

  # @api private
  #
  # source://dry-types//lib/dry/types/printer.rb#187
  def visit_schema(schema); end
end

# @api private
#
# source://dry-types//lib/dry/types/printer/composition.rb#8
class Dry::Types::Printer::Composition
  # @api private
  # @return [Composition] a new instance of Composition
  #
  # source://dry-types//lib/dry/types/printer/composition.rb#9
  def initialize(printer, composition_class); end

  # @api private
  #
  # source://dry-types//lib/dry/types/printer/composition.rb#15
  def visit(composition); end

  private

  # @api private
  #
  # source://dry-types//lib/dry/types/printer/composition.rb#33
  def visit_constructor(type, &_arg1); end

  # @api private
  #
  # source://dry-types//lib/dry/types/printer/composition.rb#25
  def visit_constructors(composition); end
end

# @api private
#
# source://dry-types//lib/dry/types/printer.rb#11
Dry::Types::Printer::MAPPING = T.let(T.unsafe(nil), Hash)

# Result class used by {Type#try}
#
# @api public
#
# source://dry-types//lib/dry/types/result.rb#8
class Dry::Types::Result
  include ::Dry::Core::Equalizer::Methods

  # @api private
  # @param input [Object]
  # @return [Result] a new instance of Result
  #
  # source://dry-types//lib/dry/types/result.rb#17
  def initialize(input); end

  # @api public
  # @return [Object]
  #
  # source://dry-types//lib/dry/types/result.rb#12
  def input; end
end

# Failure result
#
# @api public
#
# source://dry-types//lib/dry/types/result.rb#39
class Dry::Types::Result::Failure < ::Dry::Types::Result
  # @api private
  # @param input [Object]
  # @param error [#to_s]
  # @return [Failure] a new instance of Failure
  #
  # source://dry-types//lib/dry/types/result.rb#50
  def initialize(input, error); end

  # @api public
  # @return [#to_s]
  #
  # source://dry-types//lib/dry/types/result.rb#43
  def error; end

  # @api public
  # @return [true]
  #
  # source://dry-types//lib/dry/types/result.rb#68
  def failure?; end

  # @api public
  # @return [false]
  #
  # source://dry-types//lib/dry/types/result.rb#63
  def success?; end

  # @api private
  # @return [String]
  #
  # source://dry-types//lib/dry/types/result.rb#58
  def to_s; end
end

# Success result
#
# @api public
#
# source://dry-types//lib/dry/types/result.rb#24
class Dry::Types::Result::Success < ::Dry::Types::Result
  # @api public
  # @return [false]
  #
  # source://dry-types//lib/dry/types/result.rb#33
  def failure?; end

  # @api public
  # @return [true]
  #
  # source://dry-types//lib/dry/types/result.rb#28
  def success?; end
end

# @api public
Dry::Types::Safe = Dry::Types::Lax

# The built-in Hash type can be defined in terms of keys and associated types
# its values can contain. Such definitions are named {Schema}s and defined
# as lists of {Key} types.
#
# {Schema} evaluates default values for keys missing in input hash
#
# {Schema} implements Enumerable using its keys as collection.
#
# @api public
# @see Dry::Types::Schema::Key
# @see Dry::Types::Default#evaluate
# @see Dry::Types::Default::Callable#evaluate
#
# source://dry-types//lib/dry/types/schema.rb#19
class Dry::Types::Schema < ::Dry::Types::Hash
  include ::Enumerable

  # @api private
  # @option options
  # @option options
  # @param _primitive [Class]
  # @param options [Hash]
  # @return [Schema] a new instance of Schema
  #
  # source://dry-types//lib/dry/types/schema.rb#41
  def initialize(_primitive, **options); end

  # @api public
  # @option options
  # @option options
  # @param hash [Hash]
  # @param options [Hash] a customizable set of options
  # @return [Hash{Symbol => Object}]
  #
  # source://dry-types//lib/dry/types/schema.rb#80
  def apply(hash, options = T.unsafe(nil)); end

  # @api private
  # @param hash [Hash]
  # @return [Hash{Symbol => Object}]
  #
  # source://dry-types//lib/dry/types/schema.rb#68
  def call_safe(hash, options = T.unsafe(nil)); end

  # @api private
  # @param hash [Hash]
  # @return [Hash{Symbol => Object}]
  #
  # source://dry-types//lib/dry/types/schema.rb#59
  def call_unsafe(hash, options = T.unsafe(nil)); end

  # Empty schema with the same options
  #
  # @api public
  # @return [Schema]
  #
  # source://dry-types//lib/dry/types/schema.rb#296
  def clear; end

  # @api public
  # @return [Boolean]
  #
  # source://dry-types//lib/dry/types/schema.rb#268
  def constrained?; end

  # Iterate over each key type
  #
  # @api public
  # @return [Array<Dry::Types::Schema::Key>, Enumerator]
  #
  # source://dry-types//lib/dry/types/schema.rb#227
  def each(&_arg0); end

  # Fetch key type by a key name
  #
  # Behaves as ::Hash#fetch
  #
  # @api public
  # @overload key
  # @overload key
  #
  # source://dry-types//lib/dry/types/schema.rb#257
  def key(name, fallback = T.unsafe(nil), &_arg2); end

  # Whether the schema has the given key
  #
  # @api public
  # @param name [Symbol] Key name
  # @return [Boolean]
  #
  # source://dry-types//lib/dry/types/schema.rb#238
  def key?(name); end

  # @api public
  # @return [Array[Dry::Types::Schema::Key]]
  #
  # source://dry-types//lib/dry/types/schema.rb#26
  def keys; end

  # @api public
  # @return [Lax]
  #
  # source://dry-types//lib/dry/types/schema.rb#275
  def lax; end

  # Merge given schema keys into current schema
  #
  # A new instance is returned.
  #
  # @api public
  # @param other [Schema] schema
  # @return [Schema]
  #
  # source://dry-types//lib/dry/types/schema.rb#287
  def merge(other); end

  # @api public
  # @return [Hash[Symbol, Dry::Types::Schema::Key]]
  #
  # source://dry-types//lib/dry/types/schema.rb#29
  def name_key_map; end

  # @api public
  # @overload schema
  # @overload schema
  #
  # source://dry-types//lib/dry/types/schema.rb#211
  def schema(keys_or_map); end

  # Make the schema intolerant to unknown keys
  #
  # @api public
  # @return [Schema]
  #
  # source://dry-types//lib/dry/types/schema.rb#170
  def strict(strict = T.unsafe(nil)); end

  # Whether the schema rejects unknown keys
  #
  # @api public
  # @return [Boolean]
  #
  # source://dry-types//lib/dry/types/schema.rb#161
  def strict?; end

  # @api public
  # @param meta [Boolean] Whether to dump the meta to the AST
  # @return [Array] An AST representation
  #
  # source://dry-types//lib/dry/types/schema.rb#147
  def to_ast(meta: T.unsafe(nil)); end

  # @api public
  # @return [#call]
  #
  # source://dry-types//lib/dry/types/schema.rb#32
  def transform_key; end

  # Whether the schema transforms input keys
  #
  # @api public
  # @return [Boolean]
  #
  # source://dry-types//lib/dry/types/schema.rb#196
  def transform_keys?; end

  # @api public
  # @param input [Hash] hash
  # @return [Logic::Result]
  # @return [Object] if coercion fails and a block is given
  # @yieldparam failure [Failure]
  # @yieldreturn [Result]
  #
  # source://dry-types//lib/dry/types/schema.rb#93
  def try(input); end

  # Inject a key transformation function
  #
  # @api public
  # @param proc [#call, nil]
  # @param block [#call, nil]
  # @raise [::ArgumentError]
  # @return [Schema]
  #
  # source://dry-types//lib/dry/types/schema.rb#182
  def with_key_transform(proc = T.unsafe(nil), &block); end

  private

  # @api private
  # @param keys [Array<Dry::Types::Schema::Keys>]
  # @return [Dry::Types::Schema]
  #
  # source://dry-types//lib/dry/types/schema.rb#307
  def merge_keys(*keys); end

  # @api private
  # @return [MissingKeyError]
  #
  # source://dry-types//lib/dry/types/schema.rb#403
  def missing_key(key); end

  # Try to add missing keys to the hash
  #
  # @api private
  #
  # source://dry-types//lib/dry/types/schema.rb#371
  def resolve_missing_keys(hash, options); end

  # Validate and coerce a hash. Call a block and halt on any error
  #
  # @api private
  # @return [Hash]
  #
  # source://dry-types//lib/dry/types/schema.rb#349
  def resolve_safe(hash, options = T.unsafe(nil), &block); end

  # Validate and coerce a hash. Raise an exception on any error
  #
  # @api private
  # @return [Hash]
  #
  # source://dry-types//lib/dry/types/schema.rb#319
  def resolve_unsafe(hash, options = T.unsafe(nil)); end

  # @api private
  # @param hash_keys [Array<Symbol>]
  # @return [UnknownKeysError]
  #
  # source://dry-types//lib/dry/types/schema.rb#395
  def unexpected_keys(hash_keys); end
end

# Proxy type for schema keys. Contains only key name and
# whether it's required or not. All other calls deletaged
# to the wrapped type.
#
# @api public
# @see Dry::Types::Schema
#
# source://dry-types//lib/dry/types/schema/key.rb#14
class Dry::Types::Schema::Key
  include ::Dry::Types::Type
  include ::Dry::Core::Equalizer::Methods
  include ::Dry::Types::Options
  include ::Dry::Types::Decorator
  include ::Dry::Core::Constants
  include ::Dry::Types::Builder
  include ::Dry::Types::Printable
  extend ::Dry::Core::Deprecations::Interface

  # @api private
  # @return [Key] a new instance of Key
  #
  # source://dry-types//lib/dry/types/schema/key.rb#26
  def initialize(type, name, required: T.unsafe(nil), **options); end

  # @api private
  #
  # source://dry-types//lib/dry/types/schema/key.rb#41
  def call_safe(input, &_arg1); end

  # @api private
  #
  # source://dry-types//lib/dry/types/schema/key.rb#44
  def call_unsafe(input); end

  # Turn key into a lax type. Lax types are not strict hence such keys are not required
  #
  # @api public
  # @return [Lax]
  #
  # source://dry-types//lib/dry/types/schema/key.rb#90
  def lax; end

  # @api public
  # @see Dry::Types::Meta#meta
  #
  # source://dry-types//lib/dry/types/schema/key.rb#118
  def meta(data = T.unsafe(nil)); end

  # @api public
  # @return [Symbol]
  #
  # source://dry-types//lib/dry/types/schema/key.rb#23
  def name; end

  # Make key not required
  #
  # @api public
  # @return [Dry::Types::Schema::Key]
  #
  # source://dry-types//lib/dry/types/schema/key.rb#83
  def omittable; end

  # Make wrapped type optional
  #
  # @api public
  # @return [Key]
  #
  # source://dry-types//lib/dry/types/schema/key.rb#97
  def optional; end

  # Control whether the key is required
  #
  # @api public
  # @overload required
  # @overload required
  #
  # source://dry-types//lib/dry/types/schema/key.rb#70
  def required(required = T.unsafe(nil)); end

  # Whether the key is required in schema input
  #
  # @api public
  # @return [Boolean]
  #
  # source://dry-types//lib/dry/types/schema/key.rb#56
  def required?; end

  # Dump to internal AST representation
  #
  # @api public
  # @return [Array]
  #
  # source://dry-types//lib/dry/types/schema/key.rb#104
  def to_ast(meta: T.unsafe(nil)); end

  # @api public
  # @see Dry::Types::Nominal#try
  #
  # source://dry-types//lib/dry/types/schema/key.rb#49
  def try(input, &_arg1); end

  private

  # @api private
  # @return [Boolean]
  #
  # source://dry-types//lib/dry/types/schema/key.rb#134
  def decorate?(response); end
end

# @api public
#
# source://dry-types//lib/dry/types/schema.rb#20
Dry::Types::Schema::NO_TRANSFORM = T.let(T.unsafe(nil), String)

# @api public
#
# source://dry-types//lib/dry/types/schema.rb#21
Dry::Types::Schema::SYMBOLIZE_KEY = T.let(T.unsafe(nil), String)

# @api public
#
# source://dry-types//lib/dry/types/errors.rb#65
class Dry::Types::SchemaError < ::Dry::Types::CoercionError
  # @api public
  # @param key [String, Symbol]
  # @param value [Object]
  # @param result [String, #to_s]
  # @return [SchemaError] a new instance of SchemaError
  #
  # source://dry-types//lib/dry/types/errors.rb#75
  def initialize(key, value, result); end

  # @api public
  # @return [String, Symbol]
  #
  # source://dry-types//lib/dry/types/errors.rb#67
  def key; end

  # @api public
  # @return [Object]
  #
  # source://dry-types//lib/dry/types/errors.rb#70
  def value; end
end

# @api public
#
# source://dry-types//lib/dry/types/errors.rb#87
class Dry::Types::SchemaKeyError < ::Dry::Types::CoercionError; end

# Sum type
#
# @api public
#
# source://dry-types//lib/dry/types/sum.rb#8
class Dry::Types::Sum
  include ::Dry::Types::Type
  include ::Dry::Core::Constants
  include ::Dry::Types::Builder
  include ::Dry::Types::Options
  include ::Dry::Types::Meta
  include ::Dry::Types::Printable
  include ::Dry::Core::Equalizer::Methods
  include ::Dry::Types::Composition

  # @api private
  # @param input [Object]
  # @return [Object]
  #
  # source://dry-types//lib/dry/types/sum.rb#32
  def call_safe(input, &block); end

  # @api private
  # @param input [Object]
  # @return [Object]
  #
  # source://dry-types//lib/dry/types/sum.rb#23
  def call_unsafe(input); end

  # @api public
  # @param options [Hash]
  # @return [Constrained, Sum]
  # @see Builder#constrained
  #
  # source://dry-types//lib/dry/types/sum.rb#83
  def constrained(*_arg0, **_arg1, &_arg2); end

  # Manage metadata to the type. If the type is an optional, #meta delegates
  # to the right branch
  #
  # @api public
  # @see [Meta#meta]
  #
  # source://dry-types//lib/dry/types/sum.rb#66
  def meta(data = T.unsafe(nil)); end

  # @api public
  # @return [Boolean]
  #
  # source://dry-types//lib/dry/types/sum.rb#16
  def optional?; end

  # @api private
  # @param value [Object]
  # @return [Boolean]
  #
  # source://dry-types//lib/dry/types/sum.rb#56
  def primitive?(value); end

  # @api public
  # @param input [Object]
  #
  # source://dry-types//lib/dry/types/sum.rb#39
  def try(input); end

  class << self
    # source://dry-types//lib/dry/types/composition.rb#40
    def ast_type; end

    # source://dry-types//lib/dry/types/composition.rb#41
    def composition_name; end

    # @api public
    #
    # source://dry-types//lib/dry/types/sum.rb#11
    def operator; end
  end
end

# source://dry-types//lib/dry/types/sum.rb#0
class Dry::Types::Sum::Constrained < ::Dry::Types::Sum
  include ::Dry::Types::Composition::Constrained
end

# @api public
#
# source://dry-types//lib/dry/types.rb#31
Dry::Types::TYPE_SPEC_REGEX = T.let(T.unsafe(nil), Regexp)

# Common Type module denoting an object is a Type
#
# @api public
#
# source://dry-types//lib/dry/types/type.rb#8
module Dry::Types::Type
  extend ::Dry::Core::Deprecations::Interface

  # Whether a value is a valid member of the type
  # Anything can be coerced matches
  #
  # @api private
  # @return [Boolean]
  #
  # source://dry-types//lib/dry/types/type.rb#18
  def ===(input = T.unsafe(nil)); end

  # Apply type to a value
  #
  # @api public
  # @overload call
  # @overload call
  #
  # source://dry-types//lib/dry/types/type.rb#43
  def [](input = T.unsafe(nil), &_arg1); end

  # Apply type to a value
  #
  # @api public
  # @overload call
  # @overload call
  #
  # source://dry-types//lib/dry/types/type.rb#43
  def call(input = T.unsafe(nil), &_arg1); end

  # source://dry-core/1.1.0/lib/dry/core/deprecations.rb#168
  def safe(*args, &block); end

  # Whether a value is a valid member of the type
  #
  # @api private
  # @return [Boolean]
  #
  # source://dry-types//lib/dry/types/type.rb#18
  def valid?(input = T.unsafe(nil)); end
end

# @api public
#
# source://dry-types//lib/dry/types/errors.rb#101
class Dry::Types::UnknownKeysError < ::Dry::Types::SchemaKeyError
  # @api public
  # @param keys [<String, Symbol>]
  # @return [UnknownKeysError] a new instance of UnknownKeysError
  #
  # source://dry-types//lib/dry/types/errors.rb#106
  def initialize(keys); end

  # @api public
  # @return [Array<Symbol>]
  #
  # source://dry-types//lib/dry/types/errors.rb#103
  def keys; end
end

# source://dry-types//lib/dry/types/version.rb#5
Dry::Types::VERSION = T.let(T.unsafe(nil), String)
