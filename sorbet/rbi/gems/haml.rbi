# This file is autogenerated. Do not edit it by hand. Regenerate it with:
#   srb rbi gems

# typed: true
#
# If you would like to make changes to this file, great! Please create the gem's shim here:
#
#   https://github.com/sorbet/sorbet-typed/new/master?filename=lib/haml/all/haml.rbi
#
# haml-6.3.0

module Haml
end
class Haml::Error < StandardError
  def initialize(message = nil, line = nil); end
  def line; end
  def self.message(key, *args); end
end
class Haml::SyntaxError < Haml::Error
end
class Haml::FilterNotFound < Haml::Error
end
class Haml::InternalError < Haml::Error
end
module Haml::Util
  def balance(scanner, start, finish, count = nil); end
  def check_encoding(str); end
  def check_haml_encoding(str, &block); end
  def contains_interpolation?(str); end
  def handle_interpolation(str); end
  def human_indentation(indentation); end
  def inspect_obj(obj); end
  def parse_haml_magic_comment(str); end
  def rails_xss_safe?; end
  def self.escape_html(arg0); end
  def self.escape_html_safe(html); end
  def silence_warnings; end
  def try_parse_haml_emacs_magic_comment(scanner); end
  def unescape_interpolation(str, escape_html = nil); end
  extend Haml::Util
end
class Haml::Parser
  def balance(*args); end
  def balance_tokens(buf, start, finish, count: nil); end
  def block_keyword(text); end
  def block_opened?; end
  def call(template); end
  def check_push_script_stack(keyword); end
  def close; end
  def close_filter(_); end
  def close_flat_section; end
  def close_haml_comment(_); end
  def close_script(node); end
  def close_silent_script(node); end
  def closes_flat?(line); end
  def comment(text); end
  def compute_tabs(line); end
  def continuation_script?(text); end
  def div(line); end
  def doctype(text); end
  def error_with_lineno(error); end
  def filter(name); end
  def filter_opened?; end
  def flat?; end
  def flat_script(line, escape_html = nil); end
  def haml_comment(text); end
  def handle_multiline(line); end
  def handle_ruby_multiline(line); end
  def initialize(options); end
  def is_multiline?(text); end
  def is_ruby_multiline?(text); end
  def mid_block_keyword?(text); end
  def next_line; end
  def parse_new_attribute(scanner); end
  def parse_new_attributes(text); end
  def parse_old_attributes(text); end
  def parse_static_hash(text); end
  def parse_tag(text); end
  def plain(line, escape_html = nil); end
  def process_indent(line); end
  def process_line(line); end
  def push(node); end
  def root; end
  def script(line, escape_html = nil, preserve = nil); end
  def self.parse_class_and_id(list); end
  def silent_script(line); end
  def tag(line); end
  include Haml::Util
end
class Haml::Parser::Line < Struct
  def eod; end
  def eod=(_); end
  def eod?; end
  def full; end
  def full=(_); end
  def index; end
  def index=(_); end
  def parser; end
  def parser=(_); end
  def self.[](*arg0); end
  def self.inspect; end
  def self.keyword_init?; end
  def self.members; end
  def self.new(*arg0); end
  def strip!(from); end
  def tabs; end
  def text; end
  def text=(_); end
  def whitespace; end
  def whitespace=(_); end
end
class Haml::Parser::ParseNode < Struct
  def children; end
  def children=(_); end
  def initialize(*args); end
  def inspect; end
  def line; end
  def line=(_); end
  def parent; end
  def parent=(_); end
  def self.[](*arg0); end
  def self.inspect; end
  def self.keyword_init?; end
  def self.members; end
  def self.new(*arg0); end
  def type; end
  def type=(_); end
  def value; end
  def value=(_); end
end
class Haml::Parser::DynamicAttributes < Struct
  def new; end
  def new=(_); end
  def old; end
  def old=(value); end
  def self.[](*arg0); end
  def self.inspect; end
  def self.keyword_init?; end
  def self.members; end
  def self.new(*arg0); end
  def stripped_old; end
  def to_literal; end
end
class Haml::Parser::ParserOptions
  def autoclose; end
  def escape_html; end
  def filename; end
  def initialize(values = nil); end
  def line; end
  def mime_type; end
  def preserve; end
  def remove_whitespace; end
  def suppress_eval; end
end
module Haml::TempleLineCounter
  def self.count_lines(exp); end
end
class Haml::TempleLineCounter::UnexpectedExpression < StandardError
end
class Haml::Compiler
  def call(ast); end
  def compile(node); end
  def compile_children(node); end
  def compile_comment(node); end
  def compile_doctype(node); end
  def compile_filter(node); end
  def compile_plain(node); end
  def compile_script(node); end
  def compile_silent_script(node); end
  def compile_tag(node); end
  def initialize(options = nil); end
  def runtime_error(error); end
end
class Haml::Compiler::ChildrenCompiler
  def compile(node, &block); end
  def find_else_index(temple); end
  def initialize; end
  def insert_newlines!(temple, node); end
  def insert_whitespace?(node); end
  def moving_lineno(node, &block); end
  def nuke_inner_whitespace?(node); end
  def nuke_outer_whitespace?(node); end
  def nuke_prev_whitespace?(node); end
  def prepend_whitespace?(node); end
  def rstrip_whitespace!(temple); end
end
class Haml::Compiler::CommentCompiler
  def compile(node, &block); end
  def compile_conditional_comment(node, &block); end
  def compile_html_comment(node, &block); end
  def compile_text(node); end
end
class Haml::Compiler::DoctypeCompiler
  def compile(node); end
  def html_doctype(node); end
  def initialize(options = nil); end
  def rdfa_doctype; end
  def xml_doctype; end
end
class Haml::RubyExpression < Ripper
  def on_parse_error(*); end
  def self.string_literal?(code); end
  def self.syntax_error?(code); end
end
class Haml::RubyExpression::ParseError < StandardError
end
class Haml::StringSplitter < Temple::Filter
  def on_dynamic(code); end
  def self.compile(code); end
  def self.compile_tokens!(exps, tokens); end
  def self.escape_quotes(beg_str, end_str); end
  def self.shift_balanced_embexpr(tokens); end
  def self.strip_quotes!(tokens); end
  def string_literal?(code); end
end
class Haml::StringSplitter::SyntaxChecker < Ripper
  def on_parse_error(*); end
  def self.syntax_error?(code); end
end
class Haml::StringSplitter::SyntaxChecker::ParseError < StandardError
end
class Haml::Compiler::ScriptCompiler
  def compile(node, &block); end
  def compile_interpolated_plain(node); end
  def compile_script_assign(var, node, &block); end
  def compile_script_result(result, node); end
  def delegate_optimization(node); end
  def dynamic_compile(node, &block); end
  def escape_html(temple); end
  def find_and_preserve(code); end
  def initialize(identity, options); end
  def self.find_and_preserve(input, tags); end
  def static_compile(node); end
end
class Haml::Compiler::SilentScriptCompiler
  def compile(node, &block); end
  def compile_with_children(node, &block); end
end
module Haml::ObjectRef
  def self.parse(args); end
  def self.underscore(camel_cased_word); end
end
module Haml::AttributeBuilder
  def self.build(escape_attrs, quote, format, object_ref, *hashes); end
  def self.build_aria(escape_attrs, quote, *hashes); end
  def self.build_boolean!(escape_attrs, quote, format, buf, key, value); end
  def self.build_class(escape_attrs, *values); end
  def self.build_data(escape_attrs, quote, *hashes); end
  def self.build_data_attribute(key, escape_attrs, quote, *hashes); end
  def self.build_id(escape_attrs, *values); end
  def self.escape_html(escape_attrs, str); end
  def self.flatten_attributes(attributes); end
  def self.merge_all_attrs(hashes); end
end
class Haml::AttributeParser
  def assert_type!(token, type); end
  def each_attr(tokens); end
  def parse(text); end
  def parse_key!(tokens); end
  def self.available?; end
  def self.parse(text); end
  def skip_until_hash_rocket!(tokens); end
  def wrap_bracket(text); end
end
class Haml::AttributeParser::ParseSkip < StandardError
end
class Haml::AttributeCompiler
  def attribute_builder(type, values); end
  def compile(node); end
  def compile_boolean!(temple, key, values); end
  def compile_class!(temple, key, values); end
  def compile_common!(temple, key, values); end
  def compile_data!(temple, key, values); end
  def compile_id!(temple, key, values); end
  def initialize(identity, options); end
  def literal_for(value); end
  def runtime_compile(node); end
  def static_compile(static_hash, dynamic_hashes); end
end
class Haml::Compiler::TagCompiler
  def compile(node, &block); end
  def compile_contents(node, &block); end
  def compile_interpolated_plain(node); end
  def delegate_optimization(node); end
  def initialize(identity, options); end
  def self_closing?(node); end
end
class Haml::Filters
  def compile(node); end
  def find_compiler(node); end
  def initialize(options = nil); end
  def self.register(name, compiler); end
  def self.registered; end
  def self.remove_filter(name); end
end
class Haml::Filters::Base
  def initialize(options = nil); end
end
class Haml::Filters::TextBase < Haml::Filters::Base
  def compile_text!(temple, node, prefix); end
end
class Haml::Filters::TiltBase < Haml::Filters::Base
  def compile_with_tilt(node, name, indent_width: nil); end
  def dynamic_compile(node, name, indent_width: nil); end
  def explicit_require?(needed_registration); end
  def precompiled_with_tilt(node, name); end
  def self.render(name, source, indent_width: nil); end
  def static_compile(node, name, indent_width: nil); end
end
class Haml::Filters::Coffee < Haml::Filters::TiltBase
  def compile(node); end
end
class Haml::Filters::Css < Haml::Filters::TextBase
  def compile(node); end
  def compile_html(node); end
  def compile_xhtml(node); end
end
class Haml::Filters::Erb < Haml::Filters::TiltBase
  def compile(node); end
end
class Haml::Filters::Escaped < Haml::Filters::Base
  def compile(node); end
  def compile_text(text); end
end
class Haml::Filters::Javascript < Haml::Filters::TextBase
  def compile(node); end
  def compile_html(node); end
  def compile_xhtml(node); end
end
class Haml::Filters::Less < Haml::Filters::TiltBase
  def compile(node); end
end
class Haml::Filters::Markdown < Haml::Filters::TiltBase
  def compile(node); end
end
class Haml::Filters::Plain < Haml::Filters::Base
  def compile(node); end
  def compile_plain(text); end
end
class Haml::Filters::Preserve < Haml::Filters::Base
  def compile(node); end
  def compile_text(text); end
end
class Haml::Filters::Ruby < Haml::Filters::Base
  def compile(node); end
end
class Haml::Filters::Sass < Haml::Filters::TiltBase
  def compile(node); end
end
class Haml::Filters::Scss < Haml::Filters::TiltBase
  def compile(node); end
end
class Haml::Filters::Cdata < Haml::Filters::TextBase
  def compile(node); end
  def compile_cdata(node); end
end
class Haml::Identity
  def generate; end
  def initialize; end
end
class Haml::HTML < Temple::HTML::Fast
  def initialize(opts = nil); end
  def on_html_condcomment(condition, content, revealed = nil); end
end
class Haml::Escape < Temple::Filters::Escapable
  def initialize(opts = nil); end
end
module Haml::EscapeanyDispathcer
  def on_escapeany(flag, exp); end
end
class Temple::Filter
  include Haml::EscapeanyDispathcer
  include Haml::FescapeDispathcer
end
class Haml::EscapeAny < Haml::Escape
  def on_dynamic(value); end
  def on_escapeany(flag, exp); end
end
module Haml::FescapeDispathcer
  def on_fescape(flag, exp); end
end
class Haml::ForceEscape < Haml::Escape
  def initialize(opts = nil); end
  def on_escape(flag, exp); end
  def on_fescape(flag, exp); end
end
class Haml::DynamicMerger < Temple::Filter
  def count_newline(exps); end
  def merge_dynamic(exps); end
  def on_multi(*exps); end
end
class Haml::Ambles < Temple::Filter
  def call(ast); end
  def initialize(*); end
end
class Haml::Whitespace < Temple::Filter
  def on_whitespace; end
end
class Haml::Engine < Temple::Engine
end
class Haml::TempleEngine < Haml::Engine
  def compile(template); end
  def precompiled_with_ambles(_local_names, after_preamble:); end
end
module Haml::Helpers
  def preserve(input); end
  def self.preserve(input); end
end
class Haml::Template < Temple::Templates::Tilt
  extend Haml::TemplateExtension
end
module Haml::TemplateExtension
  def compile(*); end
end
class Haml::Railtie < Rails::Railtie
end
module Haml::RailsHelpers
  def capture_haml(*args, &block); end
  def find_and_preserve(input = nil, tags = nil, &block); end
  def precede(str, &block); end
  def preserve(input = nil, &block); end
  def succeed(str, &block); end
  def surround(front, back = nil, &block); end
  extend Haml::RailsHelpers
  include Haml::Helpers
end
class Haml::RailsTemplate
  def call(template, source = nil); end
  def self.options; end
  def self.set_options(opts); end
  def supports_streaming?; end
end
