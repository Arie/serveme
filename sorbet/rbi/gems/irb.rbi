# This file is autogenerated. Do not edit it by hand. Regenerate it with:
#   srb rbi gems

# typed: false
#
# If you would like to make changes to this file, great! Please create the gem's shim here:
#
#   https://github.com/sorbet/sorbet-typed/new/master?filename=lib/irb/all/irb.rbi
#
# irb-1.14.0

module IRB
  def self.CurrentContext; end
  def self.Inspector(inspect, init = nil); end
  def self.conf; end
  def self.easter_egg(type = nil); end
  def self.easter_egg_logo(type); end
  def self.generate_current_dir_irbrc_files; end
  def self.init_config(ap_path); end
  def self.init_error; end
  def self.initialized?; end
  def self.irb_abort(irb, exception = nil); end
  def self.irb_exit(*); end
  def self.irbrc_files; end
  def self.load_modules; end
  def self.parse_opts(argv: nil); end
  def self.prepare_irbrc_name_generators; end
  def self.raise_validation_error(msg); end
  def self.rc_file(ext); end
  def self.rc_file_generators; end
  def self.run_config; end
  def self.set_encoding(extern, intern = nil, override: nil); end
  def self.set_measure_callback(type = nil, arg = nil, &block); end
  def self.setup(ap_path, argv: nil); end
  def self.start(ap_path = nil); end
  def self.unset_measure_callback(type = nil); end
  def self.validate_config; end
  def self.version; end
end
module IRB::HelperMethod
  def self.all_helper_methods_info; end
  def self.helper_methods; end
  def self.register(name, helper_class); end
end
class IRB::HelperMethod::Base
  def self.allocate; end
  def self.description(description = nil); end
  def self.new(*, **); end
  extend Singleton::SingletonClassMethods
  include Singleton
end
class IRB::HelperMethod::Conf < IRB::HelperMethod::Base
  def execute; end
end
class IRB::WorkSpace
  def binding; end
  def code_around_binding; end
  def evaluate(statements, file = nil, line = nil); end
  def filter_backtrace(bt); end
  def initialize(*main); end
  def load_helper_methods_to_main; end
  def local_variable_get(name); end
  def local_variable_set(name, value); end
  def main; end
end
module IRB::HelpersContainer
  def conf(*args, **opts, &block); end
  def self.install_helper_methods; end
end
class IRB::Inspector
  def init; end
  def initialize(inspect_proc, init_proc = nil); end
  def inspect_value(v); end
  def self.def_inspector(key, arg = nil, &block); end
  def self.keys_with_inspector(inspector); end
end
module IRB::NestingParser
  def self.open_tokens(tokens); end
  def self.parse_by_line(tokens); end
  def self.scan_opens(tokens); end
end
class IRB::RubyLex
  def assignment_expression?(code, local_variables:); end
  def calc_indent_level(opens); end
  def check_code_state(code, local_variables:); end
  def check_code_syntax(code, local_variables:); end
  def check_termination_in_prev_line(code, local_variables:); end
  def code_terminated?(code, tokens, opens, local_variables:); end
  def free_indent_token?(token); end
  def indent_difference(lines, line_results, line_index); end
  def ltype_from_open_tokens(opens); end
  def process_indent_level(tokens, lines, line_index, is_newline); end
  def self.compile_with_errors_suppressed(code, line_no: nil); end
  def self.generate_local_variables_assign_code(local_variables); end
  def self.interpolate_ripper_ignored_tokens(code, tokens); end
  def self.ripper_lex_without_warning(code, local_variables: nil); end
  def should_continue?(tokens); end
end
class IRB::RubyLex::TerminateLineInput < StandardError
  def initialize; end
end
class IRB::BaseCompletor
  def command_candidates(target); end
  def completion_candidates(preposing, target, postposing, bind:); end
  def doc_namespace(preposing, matched, postposing, bind:); end
  def retrieve_files_to_require_from_load_path; end
  def retrieve_files_to_require_relative_from_current_dir; end
  def retrieve_gem_and_system_load_path; end
end
class IRB::TypeCompletor < IRB::BaseCompletor
  def completion_candidates(preposing, target, _postposing, bind:); end
  def doc_namespace(preposing, matched, _postposing, bind:); end
  def initialize(context); end
  def inspect; end
end
class IRB::RegexpCompletor < IRB::BaseCompletor
  def complete_require_path(target, preposing, postposing); end
  def completion_candidates(preposing, target, postposing, bind:); end
  def doc_namespace(_preposing, matched, _postposing, bind:); end
  def inspect; end
  def retrieve_completion_data(input, bind:, doc_namespace:); end
  def select_message(receiver, message, candidates, sep = nil); end
end
module IRB::InputCompletor
  def self.regexp_completor; end
  def self.retrieve_completion_data(input, bind: nil, doc_namespace: nil); end
end
module IRB::HistorySavingAbility
  def load_history; end
  def reset_history_counter; end
  def save_history; end
  def support_history_saving?; end
end
class IRB::InputMethod
  def gets; end
  def inspect; end
  def prompt; end
  def prompt=(arg0); end
  def prompting?; end
  def readable_after_eof?; end
  def support_history_saving?; end
  def winsize; end
end
class IRB::StdioInputMethod < IRB::InputMethod
  def encoding; end
  def eof?; end
  def gets; end
  def initialize; end
  def inspect; end
  def line(line_no); end
  def prompting?; end
  def readable_after_eof?; end
end
class IRB::FileInputMethod < IRB::InputMethod
  def close; end
  def encoding; end
  def eof?; end
  def gets; end
  def initialize(file); end
  def inspect; end
  def self.open(file, &block); end
end
class IRB::ReadlineInputMethod < IRB::StdioInputMethod
  def completion_info; end
  def eof?; end
  def gets; end
  def initialize; end
  def inspect; end
  def prompting?; end
  def self.initialize_readline; end
  include IRB::HistorySavingAbility
end
class IRB::RelineInputMethod < IRB::StdioInputMethod
  def auto_indent(&block); end
  def check_termination(&block); end
  def completion_info; end
  def display_document(matched); end
  def dynamic_prompt(&block); end
  def eof?; end
  def gets; end
  def initialize(completor); end
  def inspect; end
  def prompting?; end
  def rdoc_ri_driver; end
  def retrieve_doc_namespace(matched); end
  def show_doc_dialog_proc; end
  include IRB::HistorySavingAbility
end
class IRB::ReidlineInputMethod < IRB::RelineInputMethod
  def initialize; end
end
class IRB::OutputMethod
  def parse_printf_format(format, opts); end
  def pp(*objs); end
  def ppx(prefix, *objs); end
  def print(*opts); end
  def printf(format, *opts); end
  def printn(*opts); end
  def puts(*objs); end
end
class IRB::StdioOutputMethod < IRB::OutputMethod
  def print(*opts); end
end
class IRB::Context
  def __inspect__; end
  def __to_s__; end
  def ap_name; end
  def ap_name=(arg0); end
  def auto_indent_mode; end
  def auto_indent_mode=(arg0); end
  def back_trace_limit; end
  def back_trace_limit=(arg0); end
  def build_completor; end
  def build_type_completor; end
  def change_workspace(*_main); end
  def command_aliases; end
  def command_aliases=(arg0); end
  def echo; end
  def echo=(arg0); end
  def echo?; end
  def echo_on_assignment; end
  def echo_on_assignment=(arg0); end
  def echo_on_assignment?; end
  def eval_history=(val); end
  def evaluate(statement, line_no); end
  def evaluate_expression(code, line_no); end
  def extra_doc_dirs; end
  def extra_doc_dirs=(arg0); end
  def file_input?; end
  def from_binding?; end
  def history_file; end
  def history_file=(hist); end
  def home_workspace; end
  def ignore_eof; end
  def ignore_eof=(arg0); end
  def ignore_eof?; end
  def ignore_sigint; end
  def ignore_sigint=(arg0); end
  def ignore_sigint?; end
  def initialize(irb, workspace = nil, input_method = nil); end
  def inspect; end
  def inspect?; end
  def inspect_last_value; end
  def inspect_mode; end
  def inspect_mode=(opt); end
  def io; end
  def io=(arg0); end
  def irb; end
  def irb=(arg0); end
  def irb_name; end
  def irb_name=(arg0); end
  def irb_path; end
  def irb_path=(path); end
  def last_value; end
  def load_modules; end
  def load_modules=(arg0); end
  def local_variables; end
  def main; end
  def newline_before_multiline_output; end
  def newline_before_multiline_output=(arg0); end
  def newline_before_multiline_output?; end
  def pop_workspace; end
  def prompt_c; end
  def prompt_c=(arg0); end
  def prompt_i; end
  def prompt_i=(arg0); end
  def prompt_mode; end
  def prompt_mode=(mode); end
  def prompt_n; end
  def prompt_n=(_); end
  def prompt_s; end
  def prompt_s=(arg0); end
  def prompting?; end
  def push_workspace(*_main); end
  def rc; end
  def rc=(arg0); end
  def rc?; end
  def replace_workspace(workspace); end
  def return_format; end
  def return_format=(arg0); end
  def save_history; end
  def save_history=(val); end
  def set_last_value(value); end
  def term_interactive?; end
  def thread; end
  def to_s; end
  def use_autocomplete; end
  def use_autocomplete?; end
  def use_loader=(val); end
  def use_multiline; end
  def use_multiline?; end
  def use_readline; end
  def use_readline?; end
  def use_reline; end
  def use_reline?; end
  def use_singleline; end
  def use_singleline?; end
  def use_tracer=(val); end
  def verbose; end
  def verbose=(arg0); end
  def verbose?; end
  def with_debugger; end
  def with_debugger=(arg0); end
  def workspace; end
  def workspace_home; end
end
module IRB::Command
  def self._register_with_aliases(name, command_class, *aliases); end
  def self.all_commands_info; end
  def self.command_names; end
  def self.command_override_policies; end
  def self.commands; end
  def self.execute_as_command?(name, public_method:, private_method:); end
  def self.extract_ruby_args(*args, **kwargs); end
  def self.load_command(command); end
  def self.register(name, command_class); end
end
class IRB::Command::CommandArgumentError < StandardError
end
class IRB::Command::Base
  def execute(arg); end
  def initialize(irb_context); end
  def irb_context; end
  def self.category(category = nil); end
  def self.description(description = nil); end
  def self.execute(irb_context, arg); end
  def self.help_message(help_message = nil); end
  def self.highlight(text); end
end
module IRB::Command::RubyArgsExtractor
  def ruby_args(arg); end
  def unwrap_string_literal(str); end
end
module IRB::Debug
  def self.configure_irb_for_debugger(irb); end
  def self.insert_debug_break(pre_cmds: nil, do_cmds: nil); end
  def self.load_bundled_debug_gem; end
  def self.setup(irb); end
end
module InvalidName___Class_0x00___SkipPathHelperForIRB_95
  def skip_internal_path?(path); end
end
class IRB::Command::Debug < IRB::Command::Base
  def execute(_arg); end
  def execute_debug_command(pre_cmds: nil, do_cmds: nil); end
end
class IRB::Command::DebugCommand < IRB::Command::Debug
  def self.category; end
  def self.description; end
end
class IRB::Command::Backtrace < IRB::Command::DebugCommand
  def execute(arg); end
end
class IRB::Command::Break < IRB::Command::DebugCommand
  def execute(arg); end
end
class IRB::Command::Catch < IRB::Command::DebugCommand
  def execute(arg); end
end
class IRB::Command::CD < IRB::Command::Base
  def execute(arg); end
end
class IRB::Command::CurrentWorkingWorkspace < IRB::Command::Base
  def execute(_arg); end
end
class IRB::Command::ChangeWorkspace < IRB::Command::Base
  def execute(arg); end
end
class IRB::Command::Context < IRB::Command::Base
  def execute(_arg); end
end
class IRB::Command::Continue < IRB::Command::DebugCommand
  def execute(arg); end
end
class IRB::Command::Delete < IRB::Command::DebugCommand
  def execute(arg); end
end
class IRB::Command::DisableIrb < IRB::Command::Base
  def execute(*); end
end
module IRB::Color
  def self.clear(colorable: nil); end
  def self.colorable?; end
  def self.colorize(text, seq, colorable: nil); end
  def self.colorize_code(code, complete: nil, ignore_error: nil, colorable: nil, local_variables: nil); end
  def self.dispatch_seq(token, expr, str, in_symbol:); end
  def self.inspect_colorable?(obj, seen: nil); end
  def self.scan(code, allow_last_error:); end
  def self.without_circular_ref(obj, seen:, &block); end
end
class IRB::Color::SymbolState
  def initialize; end
  def scan_token(token); end
end
class IRB::SourceFinder
  def eval_receiver_or_owner(code); end
  def find_const_owner(name); end
  def find_source(signature, super_level = nil); end
  def initialize(irb_context); end
  def method_target(owner_receiver, super_level, method, type); end
end
class IRB::SourceFinder::EvaluationError < StandardError
end
class IRB::SourceFinder::Source
  def binary_file?; end
  def colorized_content; end
  def file; end
  def file_content; end
  def file_exist?; end
  def find_end; end
  def initialize(file, line, ast_source = nil); end
  def line; end
end
class IRB::Command::Edit < IRB::Command::Base
  def execute(arg); end
  include IRB::Command::RubyArgsExtractor
end
class IRB::Command::Exit < IRB::Command::Base
  def execute(_arg); end
end
class IRB::Command::Finish < IRB::Command::DebugCommand
  def execute(arg); end
end
class IRB::Command::ForceExit < IRB::Command::Base
  def execute(_arg); end
end
class IRB::Command::Help < IRB::Command::Base
  def add_category_to_output(category, cmds, output, longest_cmd_name_length); end
  def execute(command_name); end
  def help_message; end
end
class IRB::Pager
  def self.content_exceeds_screen_height?(content); end
  def self.page(retain_content: nil); end
  def self.page_content(content, **options); end
  def self.setup_pager(retain_content:); end
  def self.should_page?; end
end
class IRB::Command::History < IRB::Command::Base
  def execute(arg); end
end
class IRB::Command::Info < IRB::Command::DebugCommand
  def execute(arg); end
end
class IRB::Command::IrbInfo < IRB::Command::Base
  def execute(_arg); end
end
class IRB::LoadAbort < Exception
end
module IRB::IrbLoader
  def irb_load(fn, priv = nil); end
  def load_file(path, priv = nil); end
  def old; end
  def ruby_load(*arg0); end
  def ruby_require(path); end
  def search_file_from_ruby_path(fn); end
  def source_file(path); end
end
class IRB::Command::LoaderCommand < IRB::Command::Base
  def raise_cmd_argument_error; end
  include IRB::Command::RubyArgsExtractor
  include IRB::IrbLoader
end
class IRB::Command::Load < IRB::Command::LoaderCommand
  def execute(arg); end
  def execute_internal(file_name = nil, priv = nil); end
end
class IRB::Command::Require < IRB::Command::LoaderCommand
  def execute(arg); end
  def execute_internal(file_name = nil); end
end
class IRB::Command::Source < IRB::Command::LoaderCommand
  def execute(arg); end
  def execute_internal(file_name = nil); end
end
class IRB::Command::Ls < IRB::Command::Base
  def class_method_map(classes, dumped_mods); end
  def dump_methods(o, klass, obj); end
  def execute(arg); end
  include IRB::Command::RubyArgsExtractor
end
class IRB::Command::Ls::Output
  def col_widths(strs, cols:); end
  def dump(name, strs); end
  def fits_on_line?(strs, cols:, offset: nil); end
  def initialize(grep: nil); end
  def print_result; end
  def screen_width; end
end
class IRB::Command::Measure < IRB::Command::Base
  def execute(arg); end
  def execute_internal(type = nil, arg = nil); end
  def initialize(*args); end
  include IRB::Command::RubyArgsExtractor
end
class IRB::Command::Next < IRB::Command::DebugCommand
  def execute(arg); end
end
class IRB::Command::Workspaces < IRB::Command::Base
  def execute(_arg); end
  def truncated_inspect(obj); end
end
class IRB::Command::PushWorkspace < IRB::Command::Workspaces
  def execute(arg); end
end
class IRB::Command::PopWorkspace < IRB::Command::Workspaces
  def execute(_arg); end
end
class IRB::Command::ShowDoc < IRB::Command::Base
  def execute(arg); end
  include IRB::Command::RubyArgsExtractor
end
class IRB::Command::ShowSource < IRB::Command::Base
  def bold(str); end
  def execute(arg); end
  def show_source(source); end
  include IRB::Command::RubyArgsExtractor
end
class IRB::Command::Step < IRB::Command::DebugCommand
  def execute(arg); end
end
class IRB::Command::MultiIRBCommand < IRB::Command::Base
  def extend_irb_context; end
  def print_debugger_warning; end
  def print_deprecated_warning; end
  include IRB::Command::RubyArgsExtractor
end
class IRB::Command::IrbCommand < IRB::Command::MultiIRBCommand
  def execute(arg); end
  def execute_internal(*obj); end
end
class IRB::Command::Jobs < IRB::Command::MultiIRBCommand
  def execute(_arg); end
end
class IRB::Command::Foreground < IRB::Command::MultiIRBCommand
  def execute(arg); end
  def execute_internal(key = nil); end
end
class IRB::Command::Kill < IRB::Command::MultiIRBCommand
  def execute(arg); end
  def execute_internal(*keys); end
end
class IRB::Command::Whereami < IRB::Command::Base
  def execute(_arg); end
end
module IRB::ExtendCommandBundle
  def self.def_extend_command(cmd_name, cmd_class, _, *aliases); end
end
class IRB::Statement
  def code; end
  def is_assignment?; end
  def should_be_handled_by_debugger?; end
  def suppresses_echo?; end
end
class IRB::Statement::EmptyInput < IRB::Statement
  def code; end
  def is_assignment?; end
  def should_be_handled_by_debugger?; end
  def suppresses_echo?; end
end
class IRB::Statement::Expression < IRB::Statement
  def initialize(code, is_assignment); end
  def is_assignment?; end
  def should_be_handled_by_debugger?; end
  def suppresses_echo?; end
end
class IRB::Statement::Command < IRB::Statement
  def arg; end
  def command_class; end
  def initialize(original_code, command_class, arg); end
  def is_assignment?; end
  def should_be_handled_by_debugger?; end
  def suppresses_echo?; end
end
class IRB::Locale
  def String(mes); end
  def each_localized_path(dir, file); end
  def each_sublocale; end
  def encoding; end
  def find(file, paths = nil); end
  def format(*opts); end
  def gets(*rs); end
  def initialize(locale = nil); end
  def lang; end
  def load(file); end
  def modifier; end
  def print(*opts); end
  def printf(*opts); end
  def puts(*opts); end
  def readline(*rs); end
  def search_file(lib_paths, dir, file); end
  def territory; end
end
class InvalidName___Class_0x00___Vec_96
  def cross(other); end
  def dot(other); end
  def initialize(x, y, z); end
  def normalize; end
  def sub(other); end
  def x; end
  def y; end
  def z; end
end
class InvalidName___Class_0x00___Canvas_97
  def draw; end
  def initialize(arg0); end
  def line(arg0, arg1); end
  def line0(p1, p2); end
end
class InvalidName___Class_0x00___RubyModel_98
  def init_ruby_model; end
  def initialize; end
  def render_frame(i); end
end
class IRB::Abort < Exception
end
class IRB::Irb
  def build_statement(code); end
  def command?(code); end
  def configure_io; end
  def context; end
  def convert_invalid_byte_sequence(str, enc); end
  def debug_break; end
  def debug_readline(binding); end
  def each_top_level_statement; end
  def encode_with_invalid_byte_sequence(str, enc); end
  def eval_input; end
  def format_prompt(format, ltype, indent, line_no); end
  def from_binding; end
  def generate_prompt(opens, continue, line_offset); end
  def handle_exception(exc); end
  def initialize(workspace = nil, input_method = nil, from_binding: nil); end
  def inspect; end
  def output_value(omit = nil); end
  def parse_command(code); end
  def read_input(prompt); end
  def readmultiline; end
  def run(conf = nil); end
  def scanner; end
  def scanner=(arg0); end
  def signal_handle; end
  def signal_status(status); end
  def suspend_input_method(input_method); end
  def suspend_name(path = nil, name = nil); end
  def suspend_workspace(workspace); end
  def truncate_prompt_main(str); end
end
class Binding
end
