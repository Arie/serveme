# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `mechanize` gem.
# Please instead update this file by running `bin/tapioca gem mechanize`.

# source://mechanize//lib/mechanize/cookie.rb#54
class HTTP::Cookie
  include ::Mechanize::CookieDeprecated
  include ::Mechanize::CookieIMethods
  extend ::Mechanize::CookieDeprecated
  extend ::Mechanize::CookieCMethods
end

# source://mechanize//lib/mechanize/cookie_jar.rb#191
class HTTP::CookieJar
  include ::Mechanize::CookieDeprecated
  include ::Mechanize::CookieJarIMethods

  # source://http-cookie/1.0.5/lib/http/cookie_jar.rb#69
  def initialize(options = T.unsafe(nil)); end

  # source://http-cookie/1.0.5/lib/http/cookie_jar.rb#105
  def <<(cookie); end

  # source://mechanize//lib/mechanize/cookie_jar.rb#12
  def add(arg1, arg2 = T.unsafe(nil)); end

  # source://http-cookie/1.0.5/lib/http/cookie_jar.rb#340
  def cleanup(session = T.unsafe(nil)); end

  # source://http-cookie/1.0.5/lib/http/cookie_jar.rb#333
  def clear; end

  # source://http-cookie/1.0.5/lib/http/cookie_jar.rb#130
  def cookies(url = T.unsafe(nil)); end

  # source://http-cookie/1.0.5/lib/http/cookie_jar.rb#122
  def delete(cookie); end

  # source://http-cookie/1.0.5/lib/http/cookie_jar.rb#155
  def each(uri = T.unsafe(nil), &block); end

  # source://http-cookie/1.0.5/lib/http/cookie_jar.rb#136
  def empty?(url = T.unsafe(nil)); end

  # source://http-cookie/1.0.5/lib/http/cookie_jar.rb#294
  def load(readable, *options); end

  # source://http-cookie/1.0.5/lib/http/cookie_jar.rb#183
  def parse(set_cookie, origin, options = T.unsafe(nil)); end

  # source://http-cookie/1.0.5/lib/http/cookie_jar.rb#231
  def save(writable, *options); end

  # source://http-cookie/1.0.5/lib/http/cookie_jar.rb#30
  def store; end

  private

  # source://http-cookie/1.0.5/lib/http/cookie_jar.rb#32
  def get_impl(base, value, *args); end

  # source://http-cookie/1.0.5/lib/http/cookie_jar.rb#78
  def initialize_copy(other); end

  class << self
    # source://http-cookie/1.0.5/lib/http/cookie_jar.rb#10
    def const_missing(name); end
  end
end

# The Mechanize library is used for automating interactions with a website.  It
# can follow links and submit forms.  Form fields can be populated and
# submitted.  A history of URLs is maintained and can be queried.
#
# == Example
#
#   require 'mechanize'
#   require 'logger'
#
#   agent = Mechanize.new
#   agent.log = Logger.new "mech.log"
#   agent.user_agent_alias = 'Mac Safari'
#
#   page = agent.get "http://www.google.com/"
#   search_form = page.form_with :name => "f"
#   search_form.field_with(:name => "q").value = "Hello"
#
#   search_results = agent.submit search_form
#   puts search_results.body
#
# == Issues with mechanize
#
# If you think you have a bug with mechanize, but aren't sure, please file a
# ticket at https://github.com/sparklemotion/mechanize/issues
#
# Here are some common problems you may experience with mechanize
#
# === Problems connecting to SSL sites
#
# Mechanize defaults to validating SSL certificates using the default CA
# certificates for your platform.  At this time, Windows users do not have
# integration between the OS default CA certificates and OpenSSL.  #cert_store
# explains how to download and use Mozilla's CA certificates to allow SSL
# sites to work.
#
# === Problems with content-length
#
# Some sites return an incorrect content-length value.  Unlike a browser,
# mechanize raises an error when the content-length header does not match the
# response length since it does not know if there was a connection problem or
# if the mismatch is a server bug.
#
# The error raised, Mechanize::ResponseReadError, can be converted to a parsed
# Page, File, etc. depending upon the content-type:
#
#   agent = Mechanize.new
#   uri = URI 'http://example/invalid_content_length'
#
#   begin
#     page = agent.get uri
#   rescue Mechanize::ResponseReadError => e
#     page = e.force_parse
#   end
#
# source://mechanize//lib/mechanize/version.rb#2
class Mechanize
  # Creates a new mechanize instance.  If a block is given, the created
  # instance is yielded to the block for setting up pre-connection state such
  # as SSL parameters or proxies:
  #
  #   agent = Mechanize.new do |a|
  #     a.proxy_addr = 'proxy.example'
  #     a.proxy_port = 8080
  #   end
  #
  # If you need segregated SSL connections give each agent a unique
  # name.  Otherwise the connections will be shared.  This is
  # particularly important if you are using certifcates.
  #
  #    agent_1 = Mechanize.new 'conn1'
  #    agent_2 = Mechanize.new 'conn2'
  #
  # @return [Mechanize] a new instance of Mechanize
  # @yield [_self]
  # @yieldparam _self [Mechanize] the object that the method was called on
  #
  # source://mechanize//lib/mechanize.rb#210
  def initialize(connection_name = T.unsafe(nil)); end

  # Adds credentials +user+, +pass+ for +uri+.  If +realm+ is set the
  # credentials are used only for that realm.  If +realm+ is not set the
  # credentials become the default for any realm on that URI.
  #
  # +domain+ and +realm+ are exclusive as NTLM does not follow RFC 2617.  If
  # +domain+ is given it is only used for NTLM authentication.
  #
  # source://mechanize//lib/mechanize.rb#743
  def add_auth(uri, user, password, realm = T.unsafe(nil), domain = T.unsafe(nil)); end

  # :section: Utilities
  #
  # source://mechanize//lib/mechanize.rb#1254
  def agent; end

  # *NOTE*: These credentials will be used as a default for any challenge
  # exposing your password to disclosure to malicious servers.  Use of this
  # method will warn.  This method is deprecated and will be removed in
  # mechanize 3.
  #
  # Sets the +user+ and +password+ as the default credentials to be used for
  # HTTP authentication for any server.  The +domain+ is used for NTLM
  # authentication.
  #
  # source://mechanize//lib/mechanize.rb#720
  def auth(user, password, domain = T.unsafe(nil)); end

  # Equivalent to the browser back button.  Returns the previous page visited.
  #
  # source://mechanize//lib/mechanize.rb#251
  def back; end

  # *NOTE*: These credentials will be used as a default for any challenge
  # exposing your password to disclosure to malicious servers.  Use of this
  # method will warn.  This method is deprecated and will be removed in
  # mechanize 3.
  #
  # Sets the +user+ and +password+ as the default credentials to be used for
  # HTTP authentication for any server.  The +domain+ is used for NTLM
  # authentication.
  #
  # source://mechanize//lib/mechanize.rb#720
  def basic_auth(user, password, domain = T.unsafe(nil)); end

  # Path to an OpenSSL server certificate file
  #
  # source://mechanize//lib/mechanize.rb#1103
  def ca_file; end

  # Sets the certificate file used for SSL connections
  #
  # source://mechanize//lib/mechanize.rb#1110
  def ca_file=(ca_file); end

  # An OpenSSL client certificate or the path to a certificate file.
  #
  # source://mechanize//lib/mechanize.rb#1117
  def cert; end

  # Sets the OpenSSL client certificate +cert+ to the given path or
  # certificate instance
  #
  # source://mechanize//lib/mechanize.rb#1125
  def cert=(cert); end

  # An OpenSSL certificate store for verifying server certificates.  This
  # defaults to the default certificate store for your system.
  #
  # If your system does not ship with a default set of certificates you can
  # retrieve a copy of the set from Mozilla here:
  # http://curl.haxx.se/docs/caextract.html
  #
  # (Note that this set does not have an HTTPS download option so you may
  # wish to use the firefox-db2pem.sh script to extract the certificates
  # from a local install to avoid man-in-the-middle attacks.)
  #
  # After downloading or generating a cacert.pem from the above link you
  # can create a certificate store from the pem file like this:
  #
  #   cert_store = OpenSSL::X509::Store.new
  #   cert_store.add_file 'cacert.pem'
  #
  # And have mechanize use it with:
  #
  #   agent.cert_store = cert_store
  #
  # source://mechanize//lib/mechanize.rb#1151
  def cert_store; end

  # Sets the OpenSSL certificate store to +store+.
  #
  # See also #cert_store
  #
  # source://mechanize//lib/mechanize.rb#1160
  def cert_store=(cert_store); end

  # What is this?
  #
  # Why is it different from #cert?
  #
  # source://mechanize//lib/mechanize.rb#1169
  def certificate; end

  # If the parameter is a string, finds the button or link with the
  # value of the string on the current page and clicks it.  Otherwise, clicks
  # the Mechanize::Page::Link object passed in.  Returns the page fetched.
  #
  # source://mechanize//lib/mechanize.rb#352
  def click(link); end

  # Are If-Modified-Since conditional requests enabled?
  #
  # source://mechanize//lib/mechanize.rb#750
  def conditional_requests; end

  # Disables If-Modified-Since conditional requests (enabled by default)
  #
  # source://mechanize//lib/mechanize.rb#757
  def conditional_requests=(enabled); end

  # A list of hooks to call before reading response header 'content-encoding'.
  #
  # The hook is called with the agent making the request, the URI of the
  # request, the response an IO containing the response body.
  #
  # source://mechanize//lib/mechanize.rb#318
  def content_encoding_hooks; end

  # A Mechanize::CookieJar which stores cookies
  #
  # source://mechanize//lib/mechanize.rb#764
  def cookie_jar; end

  # Replaces the cookie jar with +cookie_jar+
  #
  # source://mechanize//lib/mechanize.rb#771
  def cookie_jar=(cookie_jar); end

  # Returns a list of cookies stored in the cookie jar.
  #
  # source://mechanize//lib/mechanize.rb#778
  def cookies; end

  # Returns the latest page loaded by Mechanize
  #
  # source://mechanize//lib/mechanize.rb#258
  def current_page; end

  # A default encoding name used when parsing HTML parsing.  When set it is
  # used after any other encoding.  The default is nil.
  #
  # source://mechanize//lib/mechanize.rb#658
  def default_encoding; end

  # A default encoding name used when parsing HTML parsing.  When set it is
  # used after any other encoding.  The default is nil.
  #
  # source://mechanize//lib/mechanize.rb#658
  def default_encoding=(_arg0); end

  # DELETE +uri+ with +query_params+, and setting +headers+:
  #
  # +query_params+ is formatted into a query string using
  # Mechanize::Util.build_query_string, which see.
  #
  #   delete('http://example/', {'q' => 'foo'}, {})
  #
  # source://mechanize//lib/mechanize.rb#446
  def delete(uri, query_params = T.unsafe(nil), headers = T.unsafe(nil)); end

  # GETs +uri+ and writes it to +io_or_filename+ without recording the request
  # in the history.  If +io_or_filename+ does not respond to #write it will be
  # used as a file name.  +parameters+, +referer+ and +headers+ are used as in
  # #get.
  #
  # By default, if the Content-type of the response matches a Mechanize::File
  # or Mechanize::Page parser, the response body will be loaded into memory
  # before being saved.  See #pluggable_parser for details on changing this
  # default.
  #
  # For alternate ways of downloading files see Mechanize::FileSaver and
  # Mechanize::DirectorySaver.
  #
  # source://mechanize//lib/mechanize.rb#411
  def download(uri, io_or_filename, parameters = T.unsafe(nil), referer = T.unsafe(nil), headers = T.unsafe(nil)); end

  # Follow HTML meta refresh and HTTP Refresh headers.  If set to +:anywhere+
  # meta refresh tags outside of the head element will be followed.
  #
  # source://mechanize//lib/mechanize.rb#786
  def follow_meta_refresh; end

  # Controls following of HTML meta refresh and HTTP Refresh headers in
  # responses.
  #
  # source://mechanize//lib/mechanize.rb#794
  def follow_meta_refresh=(follow); end

  # Follow an HTML meta refresh and HTTP Refresh headers that have no "url="
  # in the content attribute.
  #
  # Defaults to false to prevent infinite refresh loops.
  #
  # source://mechanize//lib/mechanize.rb#804
  def follow_meta_refresh_self; end

  # Alters the following of HTML meta refresh and HTTP Refresh headers that
  # point to the same page.
  #
  # source://mechanize//lib/mechanize.rb#812
  def follow_meta_refresh_self=(follow); end

  # Sets the mechanize redirect handling policy.  See redirect_ok for allowed
  # values
  #
  # source://mechanize//lib/mechanize.rb#973
  def follow_redirect=(follow); end

  # Controls how mechanize deals with redirects.  The following values are
  # allowed:
  #
  # :all, true:: All 3xx redirects are followed (default)
  # :permanent:: Only 301 Moved Permanantly redirects are followed
  # false:: No redirects are followed
  #
  # source://mechanize//lib/mechanize.rb#963
  def follow_redirect?; end

  # Overrides the encodings given by the HTTP server and the HTML page with
  # the default_encoding when set to true.
  #
  # source://mechanize//lib/mechanize.rb#664
  def force_default_encoding; end

  # Overrides the encodings given by the HTTP server and the HTML page with
  # the default_encoding when set to true.
  #
  # source://mechanize//lib/mechanize.rb#664
  def force_default_encoding=(_arg0); end

  # GET the +uri+ with the given request +parameters+, +referer+ and
  # +headers+.
  #
  # The +referer+ may be a URI or a page.
  #
  # +parameters+ is formatted into a query string using
  # Mechanize::Util.build_query_string, which see.
  #
  # @yield [page]
  #
  # source://mechanize//lib/mechanize.rb#461
  def get(uri, parameters = T.unsafe(nil), referer = T.unsafe(nil), headers = T.unsafe(nil)); end

  # GET +url+ and return only its contents
  #
  # source://mechanize//lib/mechanize.rb#493
  def get_file(url); end

  # Is gzip compression of responses enabled?
  #
  # source://mechanize//lib/mechanize.rb#819
  def gzip_enabled; end

  # Disables HTTP/1.1 gzip compression (enabled by default)
  #
  # source://mechanize//lib/mechanize.rb#826
  def gzip_enabled=(enabled); end

  # HEAD +uri+ with +query_params+ and +headers+:
  #
  # +query_params+ is formatted into a query string using
  # Mechanize::Util.build_query_string, which see.
  #
  #   head('http://example/', {'q' => 'foo'}, {})
  #
  # @yield [page]
  #
  # source://mechanize//lib/mechanize.rb#505
  def head(uri, query_params = T.unsafe(nil), headers = T.unsafe(nil)); end

  # The history of this mechanize run
  #
  # source://mechanize//lib/mechanize.rb#267
  def history; end

  # Callback which is invoked with the page that was added to history.
  #
  # source://mechanize//lib/mechanize.rb#325
  def history_added; end

  # Callback which is invoked with the page that was added to history.
  #
  # source://mechanize//lib/mechanize.rb#325
  def history_added=(_arg0); end

  # The HTML parser to be used when parsing documents
  #
  # source://mechanize//lib/mechanize.rb#669
  def html_parser; end

  # The HTML parser to be used when parsing documents
  #
  # source://mechanize//lib/mechanize.rb#669
  def html_parser=(_arg0); end

  # Connections that have not been used in this many seconds will be reset.
  #
  # source://mechanize//lib/mechanize.rb#833
  def idle_timeout; end

  # Sets the idle timeout to +idle_timeout+.  The default timeout is 5
  # seconds.  If you experience "too many connection resets", reducing this
  # value may help.
  #
  # source://mechanize//lib/mechanize.rb#841
  def idle_timeout=(idle_timeout); end

  # When set to true mechanize will ignore an EOF during chunked transfer
  # encoding so long as at least one byte was received.  Be careful when
  # enabling this as it may cause data loss.
  #
  # Net::HTTP does not inform mechanize of where in the chunked stream the EOF
  # occurred.  Usually it is after the last-chunk but before the terminating
  # CRLF (invalid termination) but it may occur earlier.  In the second case
  # your response body may be incomplete.
  #
  # source://mechanize//lib/mechanize.rb#855
  def ignore_bad_chunking; end

  # When set to true mechanize will ignore an EOF during chunked transfer
  # encoding.  See ignore_bad_chunking for further details
  #
  # source://mechanize//lib/mechanize.rb#863
  def ignore_bad_chunking=(ignore_bad_chunking); end

  # Are HTTP/1.1 keep-alive connections enabled?
  #
  # source://mechanize//lib/mechanize.rb#870
  def keep_alive; end

  # Disable HTTP/1.1 keep-alive connections if +enable+ is set to false.  If
  # you are experiencing "too many connection resets" errors setting this to
  # false will eliminate them.
  #
  # You should first investigate reducing idle_timeout.
  #
  # source://mechanize//lib/mechanize.rb#881
  def keep_alive=(enable); end

  # HTTP/1.0 keep-alive time.  This is no longer supported by mechanize as it
  # now uses net-http-persistent which only supports HTTP/1.1 persistent
  # connections
  #
  # source://mechanize//lib/mechanize.rb#676
  def keep_alive_time; end

  # HTTP/1.0 keep-alive time.  This is no longer supported by mechanize as it
  # now uses net-http-persistent which only supports HTTP/1.1 persistent
  # connections
  #
  # source://mechanize//lib/mechanize.rb#676
  def keep_alive_time=(_arg0); end

  # An OpenSSL private key or the path to a private key
  #
  # source://mechanize//lib/mechanize.rb#1176
  def key; end

  # Sets the OpenSSL client +key+ to the given path or key instance.  If a
  # path is given, the path must contain an RSA key file.
  #
  # source://mechanize//lib/mechanize.rb#1184
  def key=(key); end

  # The current logger.  If no logger has been set Mechanize.log is used.
  #
  # source://mechanize//lib/mechanize.rb#888
  def log; end

  # Sets the +logger+ used by this instance of mechanize
  #
  # source://mechanize//lib/mechanize.rb#895
  def log=(logger); end

  # Responses larger than this will be written to a Tempfile instead of stored
  # in memory.  The default is 100,000 bytes.
  #
  # A value of nil disables creation of Tempfiles.
  #
  # source://mechanize//lib/mechanize.rb#905
  def max_file_buffer; end

  # Sets the maximum size of a response body that will be stored in memory to
  # +bytes+.  A value of nil causes all response bodies to be stored in
  # memory.
  #
  # Note that for Mechanize::Download subclasses, the maximum buffer size
  # multiplied by the number of pages stored in history (controlled by
  # #max_history) is an approximate upper limit on the amount of memory
  # Mechanize will use.  By default, Mechanize can use up to ~5MB to store
  # response bodies for non-File and non-Page (HTML) responses.
  #
  # See also the discussion under #max_history=
  #
  # source://mechanize//lib/mechanize.rb#922
  def max_file_buffer=(bytes); end

  # Maximum number of items allowed in the history.  The default setting is 50
  # pages.  Note that the size of the history multiplied by the maximum
  # response body size
  #
  # source://mechanize//lib/mechanize.rb#276
  def max_history; end

  # Sets the maximum number of items allowed in the history to +length+.
  #
  # Setting the maximum history length to nil will make the history size
  # unlimited.  Take care when doing this, mechanize stores response bodies in
  # memory for pages and in the temporary files directory for other responses.
  # For a long-running mechanize program this can be quite large.
  #
  # See also the discussion under #max_file_buffer=
  #
  # source://mechanize//lib/mechanize.rb#290
  def max_history=(length); end

  # Length of time to wait until a connection is opened in seconds
  #
  # source://mechanize//lib/mechanize.rb#929
  def open_timeout; end

  # Sets the connection open timeout to +open_timeout+
  #
  # source://mechanize//lib/mechanize.rb#936
  def open_timeout=(open_timeout); end

  # Returns the latest page loaded by Mechanize
  #
  # source://mechanize//lib/mechanize.rb#258
  def page; end

  # Parses the +body+ of the +response+ from +uri+ using the pluggable parser
  # that matches its content type
  #
  # source://mechanize//lib/mechanize.rb#1260
  def parse(uri, response, body); end

  # OpenSSL client key password
  #
  # source://mechanize//lib/mechanize.rb#1191
  def pass; end

  # Sets the client key password to +pass+
  #
  # source://mechanize//lib/mechanize.rb#1198
  def pass=(pass); end

  # The pluggable parser maps a response Content-Type to a parser class.  The
  # registered Content-Type may be either a full content type like 'image/png'
  # or a media type 'text'.  See Mechanize::PluggableParser for further
  # details.
  #
  # Example:
  #
  #   agent.pluggable_parser['application/octet-stream'] = Mechanize::Download
  #
  # source://mechanize//lib/mechanize.rb#688
  def pluggable_parser; end

  # POST to the given +uri+ with the given +query+.
  #
  # +query+ is processed using Mechanize::Util.each_parameter (which
  # see), and then encoded into an entity body.  If any IO/FileUpload
  # object is specified as a field value the "enctype" will be
  # multipart/form-data, or application/x-www-form-urlencoded
  # otherwise.
  #
  # Examples:
  #   agent.post 'http://example.com/', "foo" => "bar"
  #
  #   agent.post 'http://example.com/', [%w[foo bar]]
  #
  #   agent.post('http://example.com/', "<message>hello</message>",
  #              'Content-Type' => 'application/xml')
  #
  # source://mechanize//lib/mechanize.rb#530
  def post(uri, query = T.unsafe(nil), headers = T.unsafe(nil)); end

  # A list of hooks to call after retrieving a response. Hooks are called with
  # the agent, the URI, the response, and the response body.
  #
  # source://mechanize//lib/mechanize.rb#331
  def post_connect_hooks; end

  # A list of hooks to call before retrieving a response. Hooks are called
  # with the agent, the URI, the response, and the response body.
  #
  # source://mechanize//lib/mechanize.rb#339
  def pre_connect_hooks; end

  # source://mechanize//lib/mechanize.rb#1287
  def pretty_print(q); end

  # The HTTP proxy address
  #
  # source://mechanize//lib/mechanize.rb#693
  def proxy_addr; end

  # The HTTP proxy password
  #
  # source://mechanize//lib/mechanize.rb#698
  def proxy_pass; end

  # The HTTP proxy port
  #
  # source://mechanize//lib/mechanize.rb#703
  def proxy_port; end

  # The HTTP proxy username
  #
  # source://mechanize//lib/mechanize.rb#708
  def proxy_user; end

  # PUT to +uri+ with +entity+, and setting +headers+:
  #
  #   put('http://example/', 'new content', {'Content-Type' => 'text/plain'})
  #
  # source://mechanize//lib/mechanize.rb#564
  def put(uri, entity, headers = T.unsafe(nil)); end

  # Length of time to wait for data from the server
  #
  # source://mechanize//lib/mechanize.rb#943
  def read_timeout; end

  # Sets the timeout for each chunk of data read from the server to
  # +read_timeout+.  A single request may read many chunks of data.
  #
  # source://mechanize//lib/mechanize.rb#951
  def read_timeout=(read_timeout); end

  # Controls how mechanize deals with redirects.  The following values are
  # allowed:
  #
  # :all, true:: All 3xx redirects are followed (default)
  # :permanent:: Only 301 Moved Permanantly redirects are followed
  # false:: No redirects are followed
  #
  # source://mechanize//lib/mechanize.rb#963
  def redirect_ok; end

  # Sets the mechanize redirect handling policy.  See redirect_ok for allowed
  # values
  #
  # source://mechanize//lib/mechanize.rb#973
  def redirect_ok=(follow); end

  # Maximum number of redirections to follow
  #
  # source://mechanize//lib/mechanize.rb#982
  def redirection_limit; end

  # Sets the maximum number of redirections to follow to +limit+
  #
  # source://mechanize//lib/mechanize.rb#989
  def redirection_limit=(limit); end

  # A hash of custom request headers that will be sent on every request
  #
  # source://mechanize//lib/mechanize.rb#1002
  def request_headers; end

  # Replaces the custom request headers that will be sent on every request
  # with +request_headers+
  #
  # source://mechanize//lib/mechanize.rb#1010
  def request_headers=(request_headers); end

  # Makes an HTTP request to +url+ using HTTP method +verb+.  +entity+ is used
  # as the request body, if allowed.
  #
  # source://mechanize//lib/mechanize.rb#572
  def request_with_entity(verb, uri, entity, headers = T.unsafe(nil)); end

  # Clears history and cookies.
  #
  # source://mechanize//lib/mechanize.rb#1311
  def reset; end

  # Resolve the full path of a link / uri
  #
  # source://mechanize//lib/mechanize.rb#995
  def resolve(link); end

  # Retry POST and other non-idempotent requests.  See RFC 2616 9.1.2.
  #
  # source://mechanize//lib/mechanize.rb#1017
  def retry_change_requests; end

  # When setting +retry_change_requests+ to true you are stating that, for all
  # the URLs you access with mechanize, making POST and other non-idempotent
  # requests is safe and will not cause data duplication or other harmful
  # results.
  #
  # If you are experiencing "too many connection resets" errors you should
  # instead investigate reducing the idle_timeout or disabling keep_alive
  # connections.
  #
  # source://mechanize//lib/mechanize.rb#1031
  def retry_change_requests=(retry_change_requests); end

  # Will <code>/robots.txt</code> files be obeyed?
  #
  # source://mechanize//lib/mechanize.rb#1038
  def robots; end

  # When +enabled+ mechanize will retrieve and obey <code>robots.txt</code>
  # files
  #
  # source://mechanize//lib/mechanize.rb#1046
  def robots=(enabled); end

  # The handlers for HTTP and other URI protocols.
  #
  # source://mechanize//lib/mechanize.rb#1053
  def scheme_handlers; end

  # Replaces the URI scheme handler table with +scheme_handlers+
  #
  # source://mechanize//lib/mechanize.rb#1060
  def scheme_handlers=(scheme_handlers); end

  # Sets the proxy +address+ at +port+ with an optional +user+ and +password+
  #
  # source://mechanize//lib/mechanize.rb#1299
  def set_proxy(address, port, user = T.unsafe(nil), password = T.unsafe(nil)); end

  # Shuts down this session by clearing browsing state and closing all
  # persistent connections.
  #
  # source://mechanize//lib/mechanize.rb#1319
  def shutdown; end

  # SSL version to use.
  #
  # source://mechanize//lib/mechanize.rb#1205
  def ssl_version; end

  # Sets the SSL version to use to +version+ without client/server
  # negotiation.
  #
  # source://mechanize//lib/mechanize.rb#1213
  def ssl_version=(ssl_version); end

  # Submits +form+ with an optional +button+.
  #
  # Without a button:
  #
  #   page = agent.get('http://example.com')
  #   agent.submit(page.forms.first)
  #
  # With a button:
  #
  #   agent.submit(page.forms.first, page.forms.first.buttons.first)
  #
  # source://mechanize//lib/mechanize.rb#599
  def submit(form, button = T.unsafe(nil), headers = T.unsafe(nil)); end

  # Runs given block, then resets the page history as it was before. self is
  # given as a parameter to the block.  Returns the value of the block.
  #
  # source://mechanize//lib/mechanize.rb#619
  def transact; end

  # The identification string for the client initiating a web request
  #
  # source://mechanize//lib/mechanize.rb#1067
  def user_agent; end

  # Sets the User-Agent used by mechanize to +user_agent+.  See also
  # user_agent_alias
  #
  # source://mechanize//lib/mechanize.rb#1075
  def user_agent=(user_agent); end

  # Set the user agent for the Mechanize object based on the given +name+.
  #
  # See also AGENT_ALIASES
  #
  # source://mechanize//lib/mechanize.rb#1084
  def user_agent_alias=(name); end

  # A callback for additional certificate verification.  See
  # OpenSSL::SSL::SSLContext#verify_callback
  #
  # The callback can be used for debugging or to ignore errors by always
  # returning +true+.  Specifying nil uses the default method that was valid
  # when the SSLContext was created
  #
  # source://mechanize//lib/mechanize.rb#1225
  def verify_callback; end

  # Sets the OpenSSL certificate verification callback
  #
  # source://mechanize//lib/mechanize.rb#1232
  def verify_callback=(verify_callback); end

  # the OpenSSL server certificate verification method.  The default is
  # OpenSSL::SSL::VERIFY_PEER and certificate verification uses the default
  # system certificates.  See also cert_store
  #
  # source://mechanize//lib/mechanize.rb#1241
  def verify_mode; end

  # Sets the OpenSSL server certificate verification method.
  #
  # source://mechanize//lib/mechanize.rb#1248
  def verify_mode=(verify_mode); end

  # Returns a visited page for the +url+ passed in, otherwise nil
  #
  # @return [Boolean]
  #
  # source://mechanize//lib/mechanize.rb#297
  def visited?(url); end

  # Returns a visited page for the +url+ passed in, otherwise nil
  # Returns whether or not a url has been visited
  #
  # @return [Boolean]
  #
  # source://mechanize//lib/mechanize.rb#297
  def visited_page(url); end

  # The value of watch_for_set is passed to pluggable parsers for retrieved
  # content
  #
  # source://mechanize//lib/mechanize.rb#1093
  def watch_for_set; end

  # The value of watch_for_set is passed to pluggable parsers for retrieved
  # content
  #
  # source://mechanize//lib/mechanize.rb#1093
  def watch_for_set=(_arg0); end

  private

  # Adds +page+ to the history
  #
  # source://mechanize//lib/mechanize.rb#1351
  def add_to_history(page); end

  # Posts +form+ to +uri+
  #
  # source://mechanize//lib/mechanize.rb#1329
  def post_form(uri, form, headers = T.unsafe(nil)); end

  class << self
    # Default HTML parser for all mechanize instances
    #
    #   Mechanize.html_parser = Nokogiri::XML
    #
    # source://mechanize//lib/mechanize.rb#643
    def html_parser; end

    # Default HTML parser for all mechanize instances
    #
    #   Mechanize.html_parser = Nokogiri::XML
    #
    # source://mechanize//lib/mechanize.rb#643
    def html_parser=(_arg0); end

    # source://mechanize//lib/mechanize.rb#169
    def inherited(child); end

    # Default logger for all mechanize instances
    #
    #   Mechanize.log = Logger.new $stderr
    #
    # source://mechanize//lib/mechanize.rb#650
    def log; end

    # Default logger for all mechanize instances
    #
    #   Mechanize.log = Logger.new $stderr
    #
    # source://mechanize//lib/mechanize.rb#650
    def log=(_arg0); end

    # Creates a new Mechanize instance and yields it to the given block.
    #
    # After the block executes, the instance is cleaned up. This includes
    # closing all open connections.
    #
    #   Mechanize.start do |m|
    #     m.get("http://example.com")
    #   end
    #
    # source://mechanize//lib/mechanize.rb#185
    def start; end
  end
end

# Supported User-Agent aliases for use with user_agent_alias=.  The
# description in parenthesis is for informative purposes and is not part of
# the alias name.
#
# The default User-Agent alias:
#
# * "Mechanize"
#
# Linux User-Agent aliases:
#
# * "Linux Firefox"
# * "Linux Konqueror"
# * "Linux Mozilla"
#
# Mac User-Agent aliases:
#
# * "Mac Firefox"
# * "Mac Mozilla"
# * "Mac Safari 4"
# * "Mac Safari"
#
# Windows User-Agent aliases:
#
# * "Windows Edge"
# * "Windows Firefox"
# * "Windows IE 6"
# * "Windows IE 7"
# * "Windows IE 8"
# * "Windows IE 9"
# * "Windows IE 10"
# * "Windows IE 11"
# * "Windows Mozilla"
#
# Mobile User-Agent aliases:
#
# * "Android"
# * "iPad"
# * "iPhone"
#
# Example:
#
#   agent = Mechanize.new
#   agent.user_agent_alias = 'Mac Safari'
#
# source://mechanize//lib/mechanize.rb#130
Mechanize::AGENT_ALIASES = T.let(T.unsafe(nil), Hash)

# Raised when Mechanize detects the chunked transfer-encoding may be
# incorrectly terminated.
#
# source://mechanize//lib/mechanize/chunked_termination_error.rb#6
class Mechanize::ChunkedTerminationError < ::Mechanize::ResponseReadError; end

# This error is raised when a pluggable parser tries to parse a content type
# that it does not know how to handle.  For example if Mechanize::Page were to
# try to parse a PDF, a ContentTypeError would be thrown.
#
# source://mechanize//lib/mechanize/content_type_error.rb#7
class Mechanize::ContentTypeError < ::Mechanize::Error
  # @return [ContentTypeError] a new instance of ContentTypeError
  #
  # source://mechanize//lib/mechanize/content_type_error.rb#10
  def initialize(content_type); end

  # Returns the value of attribute content_type.
  #
  # source://mechanize//lib/mechanize/content_type_error.rb#8
  def content_type; end
end

# source://mechanize//lib/mechanize/cookie.rb#52
Mechanize::Cookie = HTTP::Cookie

# source://mechanize//lib/mechanize/cookie.rb#29
module Mechanize::CookieCMethods
  include ::Mechanize::CookieDeprecated

  # source://mechanize//lib/mechanize/cookie.rb#32
  def parse(arg1, arg2, arg3 = T.unsafe(nil), &block); end
end

# source://mechanize//lib/mechanize/cookie.rb#7
module Mechanize::CookieDeprecated
  private

  # source://mechanize//lib/mechanize/cookie.rb#8
  def __deprecated__(to = T.unsafe(nil)); end
end

# source://mechanize//lib/mechanize/cookie.rb#43
module Mechanize::CookieIMethods
  include ::Mechanize::CookieDeprecated

  # source://mechanize//lib/mechanize/cookie.rb#46
  def set_domain(domain); end
end

# source://mechanize//lib/mechanize/cookie_jar.rb#66
class Mechanize::CookieJar < ::HTTP::CookieJar
  # source://mechanize//lib/mechanize/cookie_jar.rb#121
  def load(input, *options); end

  # source://mechanize//lib/mechanize/cookie_jar.rb#67
  def save(output, *options); end

  private

  # source://mechanize//lib/mechanize/cookie_jar.rb#181
  def load_yaml(yaml); end
end

# source://mechanize//lib/mechanize/cookie_jar.rb#9
module Mechanize::CookieJarIMethods
  include ::Mechanize::CookieDeprecated

  # source://mechanize//lib/mechanize/cookie_jar.rb#12
  def add(arg1, arg2 = T.unsafe(nil)); end

  # See HTTP::CookieJar#add.
  #
  # source://mechanize//lib/mechanize/cookie_jar.rb#28
  def add!(cookie); end

  # See HTTP::CookieJar#clear.
  #
  # source://mechanize//lib/mechanize/cookie_jar.rb#42
  def clear!; end

  # See HTTP::CookieJar#save.
  #
  # source://mechanize//lib/mechanize/cookie_jar.rb#60
  def dump_cookiestxt(io); end

  # See HTTP::CookieJar#store.
  #
  # source://mechanize//lib/mechanize/cookie_jar.rb#48
  def jar; end

  # See HTTP::CookieJar#load.
  #
  # source://mechanize//lib/mechanize/cookie_jar.rb#54
  def load_cookiestxt(io); end

  # See HTTP::CookieJar#save.
  #
  # source://mechanize//lib/mechanize/cookie_jar.rb#36
  def save_as(filename, *options); end
end

# Unlike Mechanize::FileSaver, the directory saver places all downloaded files
# in a single pre-specified directory.
#
# You must register the directory to save to before using the directory saver:
#
#   agent.pluggable_parser['image'] = \
#     Mechanize::DirectorySaver.save_to 'images'
#
# source://mechanize//lib/mechanize/directory_saver.rb#11
class Mechanize::DirectorySaver < ::Mechanize::Download
  # Saves the +body_io+ into the directory specified for this DirectorySaver
  # by save_to.  The filename is chosen by Mechanize::Parser#extract_filename.
  #
  # @raise [Mechanize::Error]
  # @return [DirectorySaver] a new instance of DirectorySaver
  #
  # source://mechanize//lib/mechanize/directory_saver.rb#57
  def initialize(uri = T.unsafe(nil), response = T.unsafe(nil), body_io = T.unsafe(nil), code = T.unsafe(nil)); end

  class << self
    # True if downloaded files should have their names decoded before saving.
    #
    # @return [Boolean]
    #
    # source://mechanize//lib/mechanize/directory_saver.rb#42
    def decode_filename?; end

    # The directory downloaded files will be saved to.
    #
    # source://mechanize//lib/mechanize/directory_saver.rb#35
    def directory; end

    # Checks if +overwrite+ parameter is set to true
    #
    # @return [Boolean]
    #
    # source://mechanize//lib/mechanize/directory_saver.rb#49
    def overwrite?; end

    # Creates a DirectorySaver subclass that will save responses to the given
    # +directory+. If +options+ includes a +decode_filename+ value set to +true+
    # then the downloaded filename will be ran through +CGI.unescape+ before
    # being saved. If +options+ includes a +overwrite+ value set to +true+ then
    # downloaded file will be overwritten if two files with the same names exist.
    #
    # source://mechanize//lib/mechanize/directory_saver.rb#23
    def save_to(directory, options = T.unsafe(nil)); end
  end
end

# Download is a pluggable parser for downloading files without loading them
# into memory first.  You may subclass this class to handle content types you
# do not wish to load into memory first.
#
# See Mechanize::PluggableParser for instructions on using this class.
#
# source://mechanize//lib/mechanize/download.rb#9
class Mechanize::Download
  include ::Mechanize::Parser

  # Creates a new download retrieved from the given +uri+ and +response+
  # object.  The +body_io+ is an IO-like containing the HTTP response body and
  # +code+ is the HTTP status.
  #
  # @return [Download] a new instance of Download
  # @yield [_self]
  # @yieldparam _self [Mechanize::Download] the object that the method was called on
  #
  # source://mechanize//lib/mechanize/download.rb#31
  def initialize(uri = T.unsafe(nil), response = T.unsafe(nil), body_io = T.unsafe(nil), code = T.unsafe(nil)); end

  # The body of this response as a String.
  #
  # Take care, this may use lots of memory if the response body is large.
  #
  # source://mechanize//lib/mechanize/download.rb#49
  def body; end

  # Accessor for the IO-like that contains the body
  #
  # source://mechanize//lib/mechanize/download.rb#22
  def body_io; end

  # Accessor for the IO-like that contains the body
  #
  # source://mechanize//lib/mechanize/download.rb#22
  def content; end

  # The filename for this file based on the content-disposition of the
  # response or the basename of the URL
  #
  # source://mechanize//lib/mechanize/download.rb#17
  def filename; end

  # The filename for this file based on the content-disposition of the
  # response or the basename of the URL
  #
  # source://mechanize//lib/mechanize/download.rb#17
  def filename=(_arg0); end

  # Saves a copy of the body_io to +filename+
  # returns the filename
  #
  # source://mechanize//lib/mechanize/download.rb#57
  def save(filename = T.unsafe(nil)); end

  # Use this method to save the content of body_io to +filename+.
  # This method will overwrite any existing filename that exists with the
  # same name.
  # returns the filename
  #
  # source://mechanize//lib/mechanize/download.rb#70
  def save!(filename = T.unsafe(nil)); end

  # Saves a copy of the body_io to +filename+
  # returns the filename
  #
  # source://mechanize//lib/mechanize/download.rb#57
  def save_as(filename = T.unsafe(nil)); end
end

# source://mechanize//lib/mechanize/element_matcher.rb#2
module Mechanize::ElementMatcher
  # source://mechanize//lib/mechanize/element_matcher.rb#4
  def elements_with(singular, plural = T.unsafe(nil)); end
end

# Raised when an an element was not found on the Page
#
# source://mechanize//lib/mechanize/element_not_found_error.rb#5
class Mechanize::ElementNotFoundError < ::Mechanize::Error
  # @return [ElementNotFoundError] a new instance of ElementNotFoundError
  #
  # source://mechanize//lib/mechanize/element_not_found_error.rb#11
  def initialize(source, element, conditions); end

  # Returns the value of attribute conditions.
  #
  # source://mechanize//lib/mechanize/element_not_found_error.rb#9
  def conditions; end

  # Returns the value of attribute element.
  #
  # source://mechanize//lib/mechanize/element_not_found_error.rb#8
  def element; end

  # Returns the value of attribute source.
  #
  # source://mechanize//lib/mechanize/element_not_found_error.rb#7
  def source; end
end

# Base mechanize error class
#
# source://mechanize//lib/mechanize.rb#76
class Mechanize::Error < ::RuntimeError; end

# This is the base class for the Pluggable Parsers.  If Mechanize cannot find
# an appropriate class to use for the content type, this class will be used.
# For example, if you download an image/jpeg, Mechanize will not know how to
# parse it, so this class will be instantiated.
#
# This is a good class to use as the base class for building your own
# pluggable parsers.
#
# == Example
#
#   require 'mechanize'
#
#   agent = Mechanize.new
#   agent.get('http://example.com/foo.jpg').class  #=> Mechanize::File
#
# source://mechanize//lib/mechanize/file.rb#18
class Mechanize::File
  include ::Mechanize::Parser

  # Creates a new file retrieved from the given +uri+ and +response+ object.
  # The +body+ is the HTTP response body and +code+ is the HTTP status.
  #
  # @return [File] a new instance of File
  # @yield [_self]
  # @yieldparam _self [Mechanize::File] the object that the method was called on
  #
  # source://mechanize//lib/mechanize/file.rb#39
  def initialize(uri = T.unsafe(nil), response = T.unsafe(nil), body = T.unsafe(nil), code = T.unsafe(nil)); end

  # The HTTP response body, the raw file contents
  #
  # source://mechanize//lib/mechanize/file.rb#25
  def body; end

  # The HTTP response body, the raw file contents
  #
  # source://mechanize//lib/mechanize/file.rb#25
  def body=(_arg0); end

  # The HTTP response body, the raw file contents
  #
  # source://mechanize//lib/mechanize/file.rb#25
  def content; end

  # The filename for this file based on the content-disposition of the
  # response or the basename of the URL
  #
  # source://mechanize//lib/mechanize/file.rb#31
  def filename; end

  # The filename for this file based on the content-disposition of the
  # response or the basename of the URL
  #
  # source://mechanize//lib/mechanize/file.rb#31
  def filename=(_arg0); end

  # Use this method to save the content of this object to +filename+.
  # returns the filename
  #
  #   file.save 'index.html'
  #   file.save 'index.html' # saves to index.html.1
  #
  #   uri = URI 'http://localhost/test.html'
  #   file = Mechanize::File.new uri, nil, ''
  #   filename = file.save  # saves to test.html
  #   puts filename         # test.html
  #
  # source://mechanize//lib/mechanize/file.rb#64
  def save(filename = T.unsafe(nil)); end

  # Use this method to save the content of this object to +filename+.
  # This method will overwrite any existing filename that exists with the
  # same name.
  # returns the filename
  #
  #   file.save 'index.html'
  #   file.save! 'index.html' # overwrite original file
  #   filename = file.save! 'index.html' # overwrite original file with filename 'index.html'
  #
  # source://mechanize//lib/mechanize/file.rb#81
  def save!(filename = T.unsafe(nil)); end

  # Use this method to save the content of this object to +filename+.
  # returns the filename
  #
  #   file.save 'index.html'
  #   file.save 'index.html' # saves to index.html.1
  #
  #   uri = URI 'http://localhost/test.html'
  #   file = Mechanize::File.new uri, nil, ''
  #   filename = file.save  # saves to test.html
  #   puts filename         # test.html
  #
  # source://mechanize//lib/mechanize/file.rb#64
  def save_as(filename = T.unsafe(nil)); end
end

# Wrapper to make a file URI work like an http URI
#
# source://mechanize//lib/mechanize/file_connection.rb#5
class Mechanize::FileConnection
  # @yield [Mechanize::FileResponse.new(Mechanize::Util.uri_unescape(file_path))]
  #
  # source://mechanize//lib/mechanize/file_connection.rb#13
  def request(uri, request); end

  class << self
    # source://mechanize//lib/mechanize/file_connection.rb#9
    def new(*a); end
  end
end

# A wrapper for a file URI that makes a request that works like a
# Net::HTTPRequest
#
# source://mechanize//lib/mechanize/file_request.rb#6
class Mechanize::FileRequest
  # @return [FileRequest] a new instance of FileRequest
  #
  # source://mechanize//lib/mechanize/file_request.rb#10
  def initialize(uri); end

  # source://mechanize//lib/mechanize/file_request.rb#14
  def []=(*a); end

  # source://mechanize//lib/mechanize/file_request.rb#14
  def add_field(*a); end

  # source://mechanize//lib/mechanize/file_request.rb#23
  def each_header; end

  # source://mechanize//lib/mechanize/file_request.rb#19
  def path; end

  # @return [Boolean]
  #
  # source://mechanize//lib/mechanize/file_request.rb#26
  def response_body_permitted?; end

  # Returns the value of attribute uri.
  #
  # source://mechanize//lib/mechanize/file_request.rb#8
  def uri; end

  # Sets the attribute uri
  #
  # @param value the value to set the attribute uri to.
  #
  # source://mechanize//lib/mechanize/file_request.rb#8
  def uri=(_arg0); end
end

# Fake response for dealing with file:/// requests
#
# source://mechanize//lib/mechanize/file_response.rb#5
class Mechanize::FileResponse
  # @return [FileResponse] a new instance of FileResponse
  #
  # source://mechanize//lib/mechanize/file_response.rb#9
  def initialize(file_path); end

  # source://mechanize//lib/mechanize/file_response.rb#38
  def [](key); end

  # source://mechanize//lib/mechanize/file_response.rb#27
  def code; end

  # source://mechanize//lib/mechanize/file_response.rb#31
  def content_length; end

  # source://mechanize//lib/mechanize/file_response.rb#47
  def each; end

  # source://mechanize//lib/mechanize/file_response.rb#36
  def each_header; end

  # Returns the value of attribute file_path.
  #
  # source://mechanize//lib/mechanize/file_response.rb#7
  def file_path; end

  # source://mechanize//lib/mechanize/file_response.rb#50
  def get_fields(key); end

  # source://mechanize//lib/mechanize/file_response.rb#54
  def http_version; end

  # source://mechanize//lib/mechanize/file_response.rb#58
  def message; end

  # @raise [Mechanize::ResponseCodeError]
  #
  # source://mechanize//lib/mechanize/file_response.rb#14
  def read_body; end

  # source://mechanize//lib/mechanize/file_response.rb#62
  def uri; end

  private

  # source://mechanize//lib/mechanize/file_response.rb#68
  def dir_body; end

  # @return [Boolean]
  #
  # source://mechanize//lib/mechanize/file_response.rb#78
  def directory?; end
end

# This is a pluggable parser that automatically saves every file it
# encounters.  Unlike Mechanize::DirectorySaver, the file saver saves the
# responses as a tree, reflecting the host and file path.
#
# == Example
#
# This example saves all .pdf files
#
#   require 'mechanize'
#
#   agent = Mechanize.new
#   agent.pluggable_parser.pdf = Mechanize::FileSaver
#   agent.get 'http://example.com/foo.pdf'
#
#   Dir['example.com/*'] # => foo.pdf
#
# source://mechanize//lib/mechanize/file_saver.rb#19
class Mechanize::FileSaver < ::Mechanize::Download
  # @return [FileSaver] a new instance of FileSaver
  #
  # source://mechanize//lib/mechanize/file_saver.rb#23
  def initialize(uri = T.unsafe(nil), response = T.unsafe(nil), body_io = T.unsafe(nil), code = T.unsafe(nil)); end

  # Returns the value of attribute filename.
  #
  # source://mechanize//lib/mechanize/file_saver.rb#21
  def filename; end

  # The save_as alias is provided for backwards compatibility with mechanize
  # 2.0.  It will be removed in mechanize 3.
  # --
  # TODO remove in mechanize 3
  #
  # source://mechanize//lib/mechanize/download.rb#57
  def save_as(filename = T.unsafe(nil)); end
end

# This class encapsulates a form parsed out of an HTML page.  Each type of
# input field available in a form can be accessed through this object.
#
# == Examples
#
# Find a form and print out its fields
#
#   form = page.forms.first # => Mechanize::Form
#   form.fields.each { |f| puts f.name }
#
# Set the input field 'name' to "Aaron"
#
#   form['name'] = 'Aaron'
#   puts form['name']
#
# source://mechanize//lib/mechanize/form.rb#19
class Mechanize::Form
  extend ::Forwardable
  extend ::Mechanize::ElementMatcher

  # @return [Form] a new instance of Form
  #
  # source://mechanize//lib/mechanize/form.rb#43
  def initialize(node, mech = T.unsafe(nil), page = T.unsafe(nil)); end

  # Fetch the value of the first input field with the name passed in. Example:
  #  puts form['name']
  #
  # source://mechanize//lib/mechanize/form.rb#241
  def [](field_name); end

  # Set the value of the first input field with the name passed in. Example:
  #  form['name'] = 'Aaron'
  #
  # source://mechanize//lib/mechanize/form.rb#248
  def []=(field_name, value); end

  # Returns the value of attribute action.
  #
  # source://mechanize//lib/mechanize/form.rb#23
  def action; end

  # Sets the attribute action
  #
  # @param value the value to set the attribute action to.
  #
  # source://mechanize//lib/mechanize/form.rb#23
  def action=(_arg0); end

  # This method adds a button to the query.  If the form needs to be
  # submitted with multiple buttons, pass each button to this method.
  #
  # source://mechanize//lib/mechanize/form.rb#370
  def add_button_to_query(button); end

  # Add a field with +field_name+ and +value+
  #
  # source://mechanize//lib/mechanize/form.rb#201
  def add_field!(field_name, value = T.unsafe(nil)); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def at(*args, **_arg1, &block); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def at_css(*args, **_arg1, &block); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def at_xpath(*args, **_arg1, &block); end

  # This method builds an array of arrays that represent the query
  # parameters to be used with this form.  The return value can then
  # be used to create a query string for this form.
  #
  # source://mechanize//lib/mechanize/form.rb#300
  def build_query(buttons = T.unsafe(nil)); end

  # :method: buttons_with(criteria)
  #
  # Find all buttons that match +criteria+
  # Example:
  #   form.buttons_with(:value => /submit/).each do |button|
  #     button.value = 'hello!'
  #   end
  def button(criteria = T.unsafe(nil)); end

  def button_with(criteria = T.unsafe(nil)); end
  def button_with!(criteria = T.unsafe(nil)); end

  # Returns the value of attribute buttons.
  #
  # source://mechanize//lib/mechanize/form.rb#25
  def buttons; end

  def buttons_with(criteria = T.unsafe(nil)); end

  # :method: checkboxes_with(criteria)
  #
  # Find all checkboxes that match +criteria+
  # Example:
  #   form.checkboxes_with(:name => /woo/).each do |field|
  #     field.check
  #   end
  def checkbox(criteria = T.unsafe(nil)); end

  def checkbox_with(criteria = T.unsafe(nil)); end
  def checkbox_with!(criteria = T.unsafe(nil)); end

  # Returns the value of attribute checkboxes.
  #
  # source://mechanize//lib/mechanize/form.rb#25
  def checkboxes; end

  def checkboxes_with(criteria = T.unsafe(nil)); end

  # Submit form using +button+. Defaults
  # to the first button.
  #
  # source://mechanize//lib/mechanize/form.rb#277
  def click_button(button = T.unsafe(nil)); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def css(*args, **_arg1, &block); end

  # Removes all fields with name +field_name+.
  #
  # source://mechanize//lib/mechanize/form.rb#425
  def delete_field!(field_name); end

  # This method is a shortcut to get form's DOM class.
  # Common usage:
  #   page.form_with(:dom_class => "foorm")
  # Note that you can also use +:class+ to get to this method:
  #   page.form_with(:class => "foorm")
  # However, attribute values are compared literally as string, so
  # form_with(class: "a") does not match a form with class="a b".
  # Use form_with(css: "form.a") instead.
  #
  # source://mechanize//lib/mechanize/form.rb#152
  def dom_class; end

  # This method is a shortcut to get form's DOM id.
  # Common usage:
  #   page.form_with(:dom_id => "foorm")
  # Note that you can also use +:id+ to get to this method:
  #   page.form_with(:id => "foorm")
  #
  # source://mechanize//lib/mechanize/form.rb#140
  def dom_id; end

  # Returns the value of attribute fields.
  #
  # source://mechanize//lib/mechanize/form.rb#25
  def elements; end

  # Character encoding of form data (i.e. UTF-8)
  #
  # source://mechanize//lib/mechanize/form.rb#31
  def encoding; end

  # Character encoding of form data (i.e. UTF-8)
  #
  # source://mechanize//lib/mechanize/form.rb#31
  def encoding=(_arg0); end

  # Content-Type for form data (i.e. application/x-www-form-urlencoded)
  #
  # source://mechanize//lib/mechanize/form.rb#28
  def enctype; end

  # Content-Type for form data (i.e. application/x-www-form-urlencoded)
  #
  # source://mechanize//lib/mechanize/form.rb#28
  def enctype=(_arg0); end

  # :method: fields_with(criteria)
  #
  # Find all fields that match +criteria+
  # Example:
  #   form.fields_with(:value => /foo/).each do |field|
  #     field.value = 'hello!'
  #   end
  def field(criteria = T.unsafe(nil)); end

  def field_with(criteria = T.unsafe(nil)); end
  def field_with!(criteria = T.unsafe(nil)); end

  # Returns the value of attribute fields.
  #
  # source://mechanize//lib/mechanize/form.rb#25
  def fields; end

  def fields_with(criteria = T.unsafe(nil)); end

  # :method: file_uploads_with(criteria)
  #
  # Find all file upload fields that match +criteria+
  # Example:
  #   form.file_uploads_with(:file_name => /picutre/).each do |field|
  #     field.value = 'foo!'
  #   end
  def file_upload(criteria = T.unsafe(nil)); end

  def file_upload_with(criteria = T.unsafe(nil)); end
  def file_upload_with!(criteria = T.unsafe(nil)); end

  # Returns the value of attribute file_uploads.
  #
  # source://mechanize//lib/mechanize/form.rb#25
  def file_uploads; end

  def file_uploads_with(criteria = T.unsafe(nil)); end

  # Returns the value of attribute node.
  # for backward compatibility
  #
  # source://mechanize//lib/mechanize/form.rb#39
  def form_node; end

  # Returns whether or not the form contains a field with +field_name+
  #
  # @return [Boolean]
  #
  # source://mechanize//lib/mechanize/form.rb#59
  def has_field?(field_name); end

  # Returns whether or not the form contains a field with +field_name+
  #
  # @return [Boolean]
  #
  # source://mechanize//lib/mechanize/form.rb#59
  def has_key?(field_name); end

  # Returns whether or not the form contains a field with +value+
  #
  # @return [Boolean]
  #
  # source://mechanize//lib/mechanize/form.rb#66
  def has_value?(value); end

  # Returns whether or not the form contains a Hidden field named +field_name+
  #
  # @return [Boolean]
  #
  # source://mechanize//lib/mechanize/form.rb#126
  def hidden_field?(field_name); end

  # Returns all fields of type Hidden
  #
  # source://mechanize//lib/mechanize/form.rb#96
  def hiddens; end

  # When true, character encoding errors will never be never raised on form
  # submission.  Default is false
  #
  # source://mechanize//lib/mechanize/form.rb#35
  def ignore_encoding_error; end

  # When true, character encoding errors will never be never raised on form
  # submission.  Default is false
  #
  # source://mechanize//lib/mechanize/form.rb#35
  def ignore_encoding_error=(_arg0); end

  # source://pp/0.4.0/pp.rb#637
  def inspect; end

  # Returns all fields of type Keygen
  #
  # source://mechanize//lib/mechanize/form.rb#106
  def keygens; end

  # Returns all field names (keys) for this form
  #
  # source://mechanize//lib/mechanize/form.rb#71
  def keys; end

  # Returns the value of attribute method.
  #
  # source://mechanize//lib/mechanize/form.rb#23
  def method; end

  # Sets the attribute method
  #
  # @param value the value to set the attribute method to.
  #
  # source://mechanize//lib/mechanize/form.rb#23
  def method=(_arg0); end

  # Treat form fields like accessors.
  #
  # source://mechanize//lib/mechanize/form.rb#258
  def method_missing(meth, *args); end

  # Returns the value of attribute name.
  #
  # source://mechanize//lib/mechanize/form.rb#23
  def name; end

  # Sets the attribute name
  #
  # @param value the value to set the attribute name to.
  #
  # source://mechanize//lib/mechanize/form.rb#23
  def name=(_arg0); end

  # :method: at_xpath
  #
  # Shorthand for +node.at_xpath+.
  #
  # See also Nokogiri::XML::Node#at_xpath for details.
  #
  # source://mechanize//lib/mechanize/form.rb#39
  def node; end

  # Returns the value of attribute page.
  #
  # source://mechanize//lib/mechanize/form.rb#41
  def page; end

  # source://mechanize//lib/mechanize/form.rb#549
  def pretty_print(q); end

  # :method: radiobuttons_with(criteria)
  #
  # Find all radio buttons that match +criteria+
  # Example:
  #   form.radiobuttons_with(:name => /woo/).each do |field|
  #     field.check
  #   end
  def radiobutton(criteria = T.unsafe(nil)); end

  def radiobutton_with(criteria = T.unsafe(nil)); end
  def radiobutton_with!(criteria = T.unsafe(nil)); end

  # Returns the value of attribute radiobuttons.
  #
  # source://mechanize//lib/mechanize/form.rb#25
  def radiobuttons; end

  def radiobuttons_with(criteria = T.unsafe(nil)); end

  # This method calculates the request data to be sent back to the server
  # for this form, depending on if this is a regular post, get, or a
  # multi-part post,
  #
  # source://mechanize//lib/mechanize/form.rb#394
  def request_data; end

  # This method allows the same form to be submitted second time
  # with the different submit button being clicked.
  #
  # source://mechanize//lib/mechanize/form.rb#384
  def reset; end

  # Returns whether or not the form contains a Reset button named +button_name+
  #
  # @return [Boolean]
  #
  # source://mechanize//lib/mechanize/form.rb#116
  def reset_button?(button_name); end

  # Returns all buttons of type Reset
  #
  # source://mechanize//lib/mechanize/form.rb#86
  def resets; end

  # This method adds an index to all fields that have Hash nodes. This
  # enables field sorting to maintain order.
  #
  # source://mechanize//lib/mechanize/form.rb#357
  def save_hash_field_order; end

  # source://forwardable/1.3.3/forwardable.rb#231
  def search(*args, **_arg1, &block); end

  def select_buttons(selector, method = T.unsafe(nil)); end
  def select_checkboxes(selector, method = T.unsafe(nil)); end
  def select_fields(selector, method = T.unsafe(nil)); end
  def select_file_uploads(selector, method = T.unsafe(nil)); end
  def select_radiobuttons(selector, method = T.unsafe(nil)); end

  # This method sets multiple fields on the form.  It takes a list of +fields+
  # which are name, value pairs.
  #
  # If there is more than one field found with the same name, this method will
  # set the first one found.  If you want to set the value of a duplicate
  # field, use a value which is a Hash with the key as the index in to the
  # form.  The index is zero based.
  #
  # For example, to set the second field named 'foo', you could do the
  # following:
  #
  #   form.set_fields :foo => { 1 => 'bar' }
  #
  # source://mechanize//lib/mechanize/form.rb#218
  def set_fields(fields = T.unsafe(nil)); end

  # Submit the form. Does not include the +button+ as a form parameter.
  # Use +click_button+ or provide button as a parameter.
  #
  # source://mechanize//lib/mechanize/form.rb#271
  def submit(button = T.unsafe(nil), headers = T.unsafe(nil)); end

  # Returns whether or not the form contains a Submit button named +button_name+
  #
  # @return [Boolean]
  #
  # source://mechanize//lib/mechanize/form.rb#111
  def submit_button?(button_name); end

  # Returns all buttons of type Submit
  #
  # source://mechanize//lib/mechanize/form.rb#81
  def submits; end

  # Returns whether or not the form contains a Text field named +field_name+
  #
  # @return [Boolean]
  #
  # source://mechanize//lib/mechanize/form.rb#121
  def text_field?(field_name); end

  # Returns whether or not the form contains a Textarea named +field_name+
  #
  # @return [Boolean]
  #
  # source://mechanize//lib/mechanize/form.rb#131
  def textarea_field?(field_name); end

  # Returns all fields of type Textarea
  #
  # source://mechanize//lib/mechanize/form.rb#101
  def textareas; end

  # Returns all fields of type Text
  #
  # source://mechanize//lib/mechanize/form.rb#91
  def texts; end

  # Returns all field values for this form
  #
  # source://mechanize//lib/mechanize/form.rb#76
  def values; end

  # source://forwardable/1.3.3/forwardable.rb#231
  def xpath(*args, **_arg1, &block); end

  private

  # source://mechanize//lib/mechanize/form.rb#667
  def file_to_multipart(file, buf = T.unsafe(nil)); end

  # source://mechanize//lib/mechanize/form.rb#291
  def from_native_charset(str); end

  # source://mechanize//lib/mechanize/form.rb#654
  def mime_value_quote(str); end

  # source://mechanize//lib/mechanize/form.rb#658
  def param_to_multipart(name, value, buf = T.unsafe(nil)); end

  # source://mechanize//lib/mechanize/form.rb#579
  def parse; end

  # This method is sub-method of build_query.
  # It converts charset of query value of fields into expected one.
  #
  # source://mechanize//lib/mechanize/form.rb#283
  def proc_query(field); end

  # source://mechanize//lib/mechanize/form.rb#647
  def rand_string(len = T.unsafe(nil)); end
end

# A Submit button in a Form
#
# source://mechanize//lib/mechanize/form/button.rb#5
class Mechanize::Form::Button < ::Mechanize::Form::Field; end

# source://mechanize//lib/mechanize/form.rb#389
Mechanize::Form::CRLF = T.let(T.unsafe(nil), String)

# This class represents a check box found in a Form.  To activate the CheckBox
# in the Form, set the checked method to true.
#
# source://mechanize//lib/mechanize/form/check_box.rb#6
class Mechanize::Form::CheckBox < ::Mechanize::Form::RadioButton
  # source://mechanize//lib/mechanize/form/check_box.rb#12
  def inspect; end

  # source://mechanize//lib/mechanize/form/check_box.rb#8
  def query_value; end
end

# This class represents a field in a form.  It handles the following input
# tags found in a form:
#
# * text
# * password
# * hidden
# * int
# * textarea
# * keygen
#
# To set the value of a field, just use the value method:
#
#   field.value = "foo"
#
# source://mechanize//lib/mechanize/form/field.rb#17
class Mechanize::Form::Field
  extend ::Forwardable

  # @return [Field] a new instance of Field
  #
  # source://mechanize//lib/mechanize/form/field.rb#28
  def initialize(node, value = T.unsafe(nil)); end

  # source://mechanize//lib/mechanize/form/field.rb#45
  def <=>(other); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def at(*args, **_arg1, &block); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def at_css(*args, **_arg1, &block); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def at_xpath(*args, **_arg1, &block); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def css(*args, **_arg1, &block); end

  # This method is a shortcut to get field's DOM class.
  # Common usage: form.field_with(:dom_class => "foo")
  #
  # source://mechanize//lib/mechanize/form/field.rb#69
  def dom_class; end

  # This method is a shortcut to get field's DOM id.
  # Common usage: form.field_with(:dom_id => "foo")
  #
  # source://mechanize//lib/mechanize/form/field.rb#63
  def dom_id; end

  # index is used to maintain order for fields with Hash nodes
  #
  # source://mechanize//lib/mechanize/form/field.rb#26
  def index; end

  # index is used to maintain order for fields with Hash nodes
  #
  # source://mechanize//lib/mechanize/form/field.rb#26
  def index=(_arg0); end

  # source://mechanize//lib/mechanize/form/field.rb#117
  def inspect; end

  # Returns the value of attribute name.
  #
  # source://mechanize//lib/mechanize/form/field.rb#20
  def name; end

  # Sets the attribute name
  #
  # @param value the value to set the attribute name to.
  #
  # source://mechanize//lib/mechanize/form/field.rb#20
  def name=(_arg0); end

  # :method: at_xpath
  #
  # Shorthand for +node.at_xpath+.
  #
  # See also Nokogiri::XML::Node#at_xpath for details.
  #
  # source://mechanize//lib/mechanize/form/field.rb#20
  def node; end

  # Sets the attribute node
  #
  # @param value the value to set the attribute node to.
  #
  # source://mechanize//lib/mechanize/form/field.rb#20
  def node=(_arg0); end

  # source://mechanize//lib/mechanize/form/field.rb#41
  def query_value; end

  # This fields value before it's sent through Util.html_unescape.
  #
  # source://mechanize//lib/mechanize/form/field.rb#23
  def raw_value; end

  # source://forwardable/1.3.3/forwardable.rb#231
  def search(*args, **_arg1, &block); end

  # Returns the value of attribute type.
  #
  # source://mechanize//lib/mechanize/form/field.rb#20
  def type; end

  # Sets the attribute type
  #
  # @param value the value to set the attribute type to.
  #
  # source://mechanize//lib/mechanize/form/field.rb#20
  def type=(_arg0); end

  # Returns the value of attribute value.
  #
  # source://mechanize//lib/mechanize/form/field.rb#20
  def value; end

  # Sets the attribute value
  #
  # @param value the value to set the attribute value to.
  #
  # source://mechanize//lib/mechanize/form/field.rb#20
  def value=(_arg0); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def xpath(*args, **_arg1, &block); end
end

# This class represents a file upload field found in a form.  To use this
# class, set FileUpload#file_data= to the data of the file you want to upload
# and FileUpload#mime_type= to the appropriate mime type of the file.
#
# See the example in EXAMPLES
#
# source://mechanize//lib/mechanize/form/file_upload.rb#8
class Mechanize::Form::FileUpload < ::Mechanize::Form::Field
  # @return [FileUpload] a new instance of FileUpload
  #
  # source://mechanize//lib/mechanize/form/file_upload.rb#15
  def initialize(node, file_name); end

  # source://mechanize//lib/mechanize/form/field.rb#20
  def file_data; end

  # source://mechanize//lib/mechanize/form/field.rb#20
  def file_data=(_arg0); end

  # File name
  #
  # source://mechanize//lib/mechanize/form/file_upload.rb#9
  def file_name; end

  # File name
  #
  # source://mechanize//lib/mechanize/form/file_upload.rb#9
  def file_name=(_arg0); end

  # Mime Type (Optional)
  #
  # source://mechanize//lib/mechanize/form/file_upload.rb#10
  def mime_type; end

  # Mime Type (Optional)
  #
  # source://mechanize//lib/mechanize/form/file_upload.rb#10
  def mime_type=(_arg0); end
end

# source://mechanize//lib/mechanize/form/hidden.rb#2
class Mechanize::Form::Hidden < ::Mechanize::Form::Field; end

# This class represents an image button in a form.  Use the x and y methods to
# set the x and y positions for where the mouse "clicked".
#
# source://mechanize//lib/mechanize/form/image_button.rb#6
class Mechanize::Form::ImageButton < ::Mechanize::Form::Button
  # @return [ImageButton] a new instance of ImageButton
  #
  # source://mechanize//lib/mechanize/form/image_button.rb#9
  def initialize(*args); end

  # source://mechanize//lib/mechanize/form/image_button.rb#15
  def query_value; end

  # Returns the value of attribute x.
  #
  # source://mechanize//lib/mechanize/form/image_button.rb#7
  def x; end

  # Sets the attribute x
  #
  # @param value the value to set the attribute x to.
  #
  # source://mechanize//lib/mechanize/form/image_button.rb#7
  def x=(_arg0); end

  # Returns the value of attribute y.
  #
  # source://mechanize//lib/mechanize/form/image_button.rb#7
  def y; end

  # Sets the attribute y
  #
  # @param value the value to set the attribute y to.
  #
  # source://mechanize//lib/mechanize/form/image_button.rb#7
  def y=(_arg0); end
end

# This class represents a keygen (public / private key generator) found in a
# Form. The field will automatically generate a key pair and compute its own
# value to match the challenge. Call key to access the public/private key
# pair.
#
# source://mechanize//lib/mechanize/form/keygen.rb#8
class Mechanize::Form::Keygen < ::Mechanize::Form::Field
  # @return [Keygen] a new instance of Keygen
  #
  # source://mechanize//lib/mechanize/form/keygen.rb#15
  def initialize(node, value = T.unsafe(nil)); end

  # The challenge for this <keygen>.
  #
  # source://mechanize//lib/mechanize/form/keygen.rb#10
  def challenge; end

  # Generates a key pair and sets the field's value.
  #
  # source://mechanize//lib/mechanize/form/keygen.rb#27
  def generate_key(key_size = T.unsafe(nil)); end

  # The key associated with this <keygen> tag.
  #
  # source://mechanize//lib/mechanize/form/keygen.rb#13
  def key; end
end

# This class represents a select list where multiple values can be selected.
# MultiSelectList#value= accepts an array, and those values are used as
# values for the select list.  For example, to select multiple values,
# simply do this:
#
#   list.value = ['one', 'two']
#
# Single values are still supported, so these two are the same:
#
#   list.value = ['one']
#   list.value = 'one'
#
# source://mechanize//lib/mechanize/form/multi_select_list.rb#15
class Mechanize::Form::MultiSelectList < ::Mechanize::Form::Field
  extend ::Mechanize::ElementMatcher

  # @return [MultiSelectList] a new instance of MultiSelectList
  #
  # source://mechanize//lib/mechanize/form/multi_select_list.rb#20
  def initialize(node); end

  # :method: options_with
  #
  # Find all options on this select list with +criteria+
  #
  # Example:
  #
  #   select_list.options_with(:value => /1|2/).each do |field|
  #     field.value = '20'
  #   end
  def option(criteria = T.unsafe(nil)); end

  def option_with(criteria = T.unsafe(nil)); end
  def option_with!(criteria = T.unsafe(nil)); end

  # Returns the value of attribute options.
  #
  # source://mechanize//lib/mechanize/form/multi_select_list.rb#18
  def options; end

  # Sets the attribute options
  #
  # @param value the value to set the attribute options to.
  #
  # source://mechanize//lib/mechanize/form/multi_select_list.rb#18
  def options=(_arg0); end

  def options_with(criteria = T.unsafe(nil)); end

  # source://mechanize//lib/mechanize/form/multi_select_list.rb#57
  def query_value; end

  # Select all options
  #
  # source://mechanize//lib/mechanize/form/multi_select_list.rb#68
  def select_all; end

  # Select no options
  #
  # source://mechanize//lib/mechanize/form/multi_select_list.rb#62
  def select_none; end

  def select_options(selector, method = T.unsafe(nil)); end

  # Get a list of all selected options
  #
  # source://mechanize//lib/mechanize/form/multi_select_list.rb#74
  def selected_options; end

  # source://mechanize//lib/mechanize/form/multi_select_list.rb#90
  def value; end

  # source://mechanize//lib/mechanize/form/multi_select_list.rb#78
  def value=(values); end
end

# This class contains an option found within SelectList.  A SelectList can
# have many Option classes associated with it.  An option can be selected by
# calling Option#tick, or Option#click.
#
# To select the first option in a list:
#
#   select_list.first.tick
#
# source://mechanize//lib/mechanize/form/option.rb#11
class Mechanize::Form::Option
  # @return [Option] a new instance of Option
  #
  # source://mechanize//lib/mechanize/form/option.rb#17
  def initialize(node, select_list); end

  # Toggle the selection value of this option
  #
  # source://mechanize//lib/mechanize/form/option.rb#40
  def click; end

  # Returns the value of attribute node.
  #
  # source://mechanize//lib/mechanize/form/option.rb#12
  def node; end

  # Select this option
  #
  # source://mechanize//lib/mechanize/form/option.rb#26
  def select; end

  # Returns the value of attribute select_list.
  #
  # source://mechanize//lib/mechanize/form/option.rb#12
  def select_list; end

  # Returns the value of attribute selected.
  #
  # source://mechanize//lib/mechanize/form/option.rb#12
  def selected; end

  # Returns the value of attribute selected.
  #
  # source://mechanize//lib/mechanize/form/option.rb#12
  def selected?; end

  # Returns the value of attribute text.
  #
  # source://mechanize//lib/mechanize/form/option.rb#12
  def text; end

  # Select this option
  #
  # source://mechanize//lib/mechanize/form/option.rb#26
  def tick; end

  # Returns the value of attribute value.
  #
  # source://mechanize//lib/mechanize/form/option.rb#12
  def to_s; end

  # Unselect this option
  #
  # source://mechanize//lib/mechanize/form/option.rb#32
  def unselect; end

  # Unselect this option
  #
  # source://mechanize//lib/mechanize/form/option.rb#32
  def untick; end

  # Returns the value of attribute value.
  #
  # source://mechanize//lib/mechanize/form/option.rb#12
  def value; end

  private

  # source://mechanize//lib/mechanize/form/option.rb#46
  def unselect_peers; end
end

# This class represents a radio button found in a Form.  To activate the
# RadioButton in the Form, set the checked method to true.
#
# source://mechanize//lib/mechanize/form/radio_button.rb#6
class Mechanize::Form::RadioButton < ::Mechanize::Form::Field
  # @return [RadioButton] a new instance of RadioButton
  #
  # source://mechanize//lib/mechanize/form/radio_button.rb#10
  def initialize(node, form); end

  # source://mechanize//lib/mechanize/form/radio_button.rb#16
  def ==(other); end

  # source://mechanize//lib/mechanize/form/radio_button.rb#52
  def [](key); end

  # source://mechanize//lib/mechanize/form/radio_button.rb#25
  def check; end

  # Returns the value of attribute checked.
  #
  # source://mechanize//lib/mechanize/form/radio_button.rb#7
  def checked; end

  # Sets the attribute checked
  #
  # @param value the value to set the attribute checked to.
  #
  # source://mechanize//lib/mechanize/form/radio_button.rb#7
  def checked=(_arg0); end

  # Returns the value of attribute checked.
  #
  # source://mechanize//lib/mechanize/form/radio_button.rb#7
  def checked?; end

  # source://mechanize//lib/mechanize/form/radio_button.rb#36
  def click; end

  # source://mechanize//lib/mechanize/form/radio_button.rb#16
  def eql?(other); end

  # Returns the value of attribute form.
  #
  # source://mechanize//lib/mechanize/form/radio_button.rb#8
  def form; end

  # source://mechanize//lib/mechanize/form/radio_button.rb#40
  def hash; end

  # source://mechanize//lib/mechanize/form/radio_button.rb#44
  def label; end

  # source://mechanize//lib/mechanize/form/radio_button.rb#56
  def pretty_print_instance_variables; end

  # source://mechanize//lib/mechanize/form/radio_button.rb#48
  def text; end

  # source://mechanize//lib/mechanize/form/radio_button.rb#32
  def uncheck; end

  private

  # source://mechanize//lib/mechanize/form/radio_button.rb#62
  def uncheck_peers; end
end

# source://mechanize//lib/mechanize/form/reset.rb#2
class Mechanize::Form::Reset < ::Mechanize::Form::Button; end

# This class represents a select list or drop down box in a Form.  Set the
# value for the list by calling SelectList#value=.  SelectList contains a list
# of Option that were found.  After finding the correct option, set the select
# lists value to the option value:
#
#   selectlist.value = selectlist.options.first.value
#
# Options can also be selected by "clicking" or selecting them.  See Option
#
# source://mechanize//lib/mechanize/form/select_list.rb#10
class Mechanize::Form::SelectList < ::Mechanize::Form::MultiSelectList
  # @return [SelectList] a new instance of SelectList
  #
  # source://mechanize//lib/mechanize/form/select_list.rb#12
  def initialize(node); end

  # source://mechanize//lib/mechanize/form/select_list.rb#40
  def query_value; end

  # source://mechanize//lib/mechanize/form/select_list.rb#21
  def value; end

  # source://mechanize//lib/mechanize/form/select_list.rb#32
  def value=(new_value); end
end

# source://mechanize//lib/mechanize/form/submit.rb#2
class Mechanize::Form::Submit < ::Mechanize::Form::Button; end

# source://mechanize//lib/mechanize/form/text.rb#2
class Mechanize::Form::Text < ::Mechanize::Form::Field; end

# source://mechanize//lib/mechanize/form/textarea.rb#2
class Mechanize::Form::Textarea < ::Mechanize::Form::Field; end

# Mechanize::HTTP contains classes for communicated with HTTP servers.  All
# API under this namespace is considered private and is subject to change at
# any time.
#
# source://mechanize//lib/mechanize/http.rb#7
class Mechanize::HTTP; end

# An HTTP (and local disk access) user agent.  This class is an implementation
# detail and is subject to change at any time.
#
# source://mechanize//lib/mechanize/http/agent.rb#10
class Mechanize::HTTP::Agent
  # The connection_name can be used to segregate SSL connections.
  # Agents with different names will not share the same persistent connection.
  #
  # @return [Agent] a new instance of Agent
  #
  # source://mechanize//lib/mechanize/http/agent.rb#140
  def initialize(connection_name = T.unsafe(nil)); end

  # Adds credentials +user+, +pass+ for +uri+.  If +realm+ is set the
  # credentials are used only for that realm.  If +realm+ is not set the
  # credentials become the default for any realm on that URI.
  #
  # +domain+ and +realm+ are exclusive as NTLM does not follow RFC 2617.  If
  # +domain+ is given it is only used for NTLM authentication.
  #
  # source://mechanize//lib/mechanize/http/agent.rb#209
  def add_auth(uri, user, password, realm = T.unsafe(nil), domain = T.unsafe(nil)); end

  # USE OF add_default_auth IS NOT RECOMMENDED AS IT MAY EXPOSE PASSWORDS TO
  # THIRD PARTIES
  #
  # Adds credentials +user+, +pass+ as the default authentication credentials.
  # If no other credentials are available  these will be returned from
  # credentials_for.
  #
  # If +domain+ is given it is only used for NTLM authentication.
  #
  # source://mechanize//lib/mechanize/http/agent.rb#223
  def add_default_auth(user, password, domain = T.unsafe(nil)); end

  # List of error codes (in String or Integer) to handle without
  # raising Mechanize::ResponseCodeError, defaulted to an empty array.
  # Note that 2xx, 3xx and 401 status codes will be handled without
  # checking this list.
  #
  # source://mechanize//lib/mechanize/http/agent.rb#83
  def allowed_error_codes; end

  # List of error codes (in String or Integer) to handle without
  # raising Mechanize::ResponseCodeError, defaulted to an empty array.
  # Note that 2xx, 3xx and 401 status codes will be handled without
  # checking this list.
  #
  # source://mechanize//lib/mechanize/http/agent.rb#83
  def allowed_error_codes=(_arg0); end

  # :section: HTTP Authentication
  #
  # source://mechanize//lib/mechanize/http/agent.rb#50
  def auth_store; end

  # source://mechanize//lib/mechanize/http/agent.rb#51
  def authenticate_methods; end

  # Creates a new output IO by reading +input_io+ in +read_size+ chunks.  If
  # the output is over the max_file_buffer size a Tempfile with +name+ is
  # created.
  #
  # If a block is provided, each chunk of +input_io+ is yielded for further
  # processing.
  #
  # source://mechanize//lib/mechanize/http/agent.rb#1194
  def auto_io(name, read_size, input_io); end

  # Equivalent to the browser back button.  Returns the most recent page
  # visited.
  #
  # source://mechanize//lib/mechanize/http/agent.rb#366
  def back; end

  # Path to an OpenSSL CA certificate file
  #
  # source://mechanize//lib/mechanize/http/agent.rb#1085
  def ca_file; end

  # Sets the path to an OpenSSL CA certificate file
  #
  # source://mechanize//lib/mechanize/http/agent.rb#1090
  def ca_file=(ca_file); end

  # The SSL certificate store used for validating connections
  #
  # source://mechanize//lib/mechanize/http/agent.rb#1095
  def cert_store; end

  # Sets the SSL certificate store used for validating connections
  #
  # source://mechanize//lib/mechanize/http/agent.rb#1100
  def cert_store=(cert_store); end

  # The client X509 certificate
  #
  # source://mechanize//lib/mechanize/http/agent.rb#1105
  def certificate; end

  # Sets the client certificate to given X509 certificate.  If a path is given
  # the certificate will be loaded and set.
  #
  # source://mechanize//lib/mechanize/http/agent.rb#1111
  def certificate=(certificate); end

  # Disables If-Modified-Since conditional requests (enabled by default)
  #
  # source://mechanize//lib/mechanize/http/agent.rb#19
  def conditional_requests; end

  # Disables If-Modified-Since conditional requests (enabled by default)
  #
  # source://mechanize//lib/mechanize/http/agent.rb#19
  def conditional_requests=(_arg0); end

  # :section: Request
  #
  # source://mechanize//lib/mechanize/http/agent.rb#429
  def connection_for(uri); end

  # Decodes a gzip-encoded +body_io+.  If it cannot be decoded, inflate is
  # tried followed by raising an error.
  #
  # source://mechanize//lib/mechanize/http/agent.rb#447
  def content_encoding_gunzip(body_io); end

  # A list of hooks to call to handle the content-encoding of a request.
  #
  # source://mechanize//lib/mechanize/http/agent.rb#46
  def content_encoding_hooks; end

  # Decodes a deflate-encoded +body_io+.  If it cannot be decoded, raw inflate
  # is tried followed by raising an error.
  #
  # source://mechanize//lib/mechanize/http/agent.rb#479
  def content_encoding_inflate(body_io); end

  # The context parses responses into pages
  #
  # source://mechanize//lib/mechanize/http/agent.rb#121
  def context; end

  # The context parses responses into pages
  #
  # source://mechanize//lib/mechanize/http/agent.rb#121
  def context=(_arg0); end

  # The cookies for this agent
  #
  # source://mechanize//lib/mechanize/http/agent.rb#112
  def cookie_jar; end

  # The cookies for this agent
  #
  # source://mechanize//lib/mechanize/http/agent.rb#112
  def cookie_jar=(_arg0); end

  # Returns the latest page loaded by the agent
  #
  # source://mechanize//lib/mechanize/http/agent.rb#373
  def current_page; end

  # source://mechanize//lib/mechanize/http/agent.rb#52
  def digest_challenges; end

  # source://mechanize//lib/mechanize/http/agent.rb#498
  def disable_keep_alive(request); end

  # source://mechanize//lib/mechanize/http/agent.rb#502
  def enable_gzip(request); end

  # Retrieves +uri+ and parses it into a page or other object according to
  # PluggableParser.  If the URI is an HTTP or HTTPS scheme URI the given HTTP
  # +method+ is used to retrieve it, along with the HTTP +headers+, request
  # +params+ and HTTP +referer+.
  #
  # The final URI to access is built with +uri+ and +params+, the
  # latter of which is formatted into a string using
  # Mechanize::Util.build_query_string, which see.
  #
  # +redirects+ tracks the number of redirects experienced when retrieving the
  # page.  If it is over the redirection_limit an error will be raised.
  #
  # source://mechanize//lib/mechanize/http/agent.rb#240
  def fetch(uri, method = T.unsafe(nil), headers = T.unsafe(nil), params = T.unsafe(nil), referer = T.unsafe(nil), redirects = T.unsafe(nil)); end

  # Follow HTML meta refresh and HTTP Refresh.  If set to +:anywhere+ meta
  # refresh tags outside of the head element will be followed.
  #
  # source://mechanize//lib/mechanize/http/agent.rb#58
  def follow_meta_refresh; end

  # Follow HTML meta refresh and HTTP Refresh.  If set to +:anywhere+ meta
  # refresh tags outside of the head element will be followed.
  #
  # source://mechanize//lib/mechanize/http/agent.rb#58
  def follow_meta_refresh=(_arg0); end

  # Follow an HTML meta refresh that has no "url=" in the content attribute.
  #
  # Defaults to false to prevent infinite refresh loops.
  #
  # source://mechanize//lib/mechanize/http/agent.rb#63
  def follow_meta_refresh_self; end

  # Follow an HTML meta refresh that has no "url=" in the content attribute.
  #
  # Defaults to false to prevent infinite refresh loops.
  #
  # source://mechanize//lib/mechanize/http/agent.rb#63
  def follow_meta_refresh_self=(_arg0); end

  # :section: Response
  #
  # source://mechanize//lib/mechanize/http/agent.rb#725
  def get_meta_refresh(response, uri, page); end

  # source://mechanize//lib/mechanize/http/agent.rb#1019
  def get_robots(uri); end

  # Is gzip compression of requests enabled?
  #
  # source://mechanize//lib/mechanize/http/agent.rb#22
  def gzip_enabled; end

  # Is gzip compression of requests enabled?
  #
  # source://mechanize//lib/mechanize/http/agent.rb#22
  def gzip_enabled=(_arg0); end

  # history of requests made
  #
  # source://mechanize//lib/mechanize/http/agent.rb#33
  def history; end

  # history of requests made
  #
  # source://mechanize//lib/mechanize/http/agent.rb#33
  def history=(_arg0); end

  # :section: Hooks
  #
  # source://mechanize//lib/mechanize/http/agent.rb#394
  def hook_content_encoding(response, uri, response_body_io); end

  # source://mechanize//lib/mechanize/http/agent.rb#123
  def http; end

  # source://mechanize//lib/mechanize/http/agent.rb#510
  def http_request(uri, method, params = T.unsafe(nil)); end

  # Reset connections that have not been used in this many seconds
  #
  # source://mechanize//lib/mechanize/http/agent.rb#1175
  def idle_timeout; end

  # Sets the connection idle timeout for persistent connections
  #
  # source://mechanize//lib/mechanize/http/agent.rb#1180
  def idle_timeout=(timeout); end

  # When set to true mechanize will ignore an EOF during chunked transfer
  # encoding so long as at least one byte was received.  Be careful when
  # enabling this as it may cause data loss.
  #
  # source://mechanize//lib/mechanize/http/agent.rb#128
  def ignore_bad_chunking; end

  # When set to true mechanize will ignore an EOF during chunked transfer
  # encoding so long as at least one byte was received.  Be careful when
  # enabling this as it may cause data loss.
  #
  # source://mechanize//lib/mechanize/http/agent.rb#128
  def ignore_bad_chunking=(_arg0); end

  # source://mechanize//lib/mechanize/http/agent.rb#1215
  def inflate(compressed, window_bits = T.unsafe(nil)); end

  # Set to false to disable HTTP/1.1 keep-alive requests
  #
  # source://mechanize//lib/mechanize/http/agent.rb#101
  def keep_alive; end

  # Set to false to disable HTTP/1.1 keep-alive requests
  #
  # source://mechanize//lib/mechanize/http/agent.rb#101
  def keep_alive=(_arg0); end

  # source://mechanize//lib/mechanize/http/agent.rb#1229
  def log; end

  # source://mechanize//lib/mechanize/http/agent.rb#1273
  def make_tempfile(name); end

  # Responses larger than this will be written to a Tempfile instead of stored
  # in memory.  Setting this to nil disables creation of Tempfiles.
  #
  # source://mechanize//lib/mechanize/http/agent.rb#116
  def max_file_buffer; end

  # Responses larger than this will be written to a Tempfile instead of stored
  # in memory.  Setting this to nil disables creation of Tempfiles.
  #
  # source://mechanize//lib/mechanize/http/agent.rb#116
  def max_file_buffer=(_arg0); end

  # Returns the maximum size for the history stack.
  #
  # source://mechanize//lib/mechanize/http/agent.rb#378
  def max_history; end

  # Set the maximum size for the history stack.
  #
  # source://mechanize//lib/mechanize/http/agent.rb#383
  def max_history=(length); end

  # Length of time to wait until a connection is opened in seconds
  #
  # source://mechanize//lib/mechanize/http/agent.rb#104
  def open_timeout; end

  # Length of time to wait until a connection is opened in seconds
  #
  # source://mechanize//lib/mechanize/http/agent.rb#104
  def open_timeout=(_arg0); end

  # OpenSSL key password
  #
  # source://mechanize//lib/mechanize/http/agent.rb#96
  def pass; end

  # OpenSSL key password
  #
  # source://mechanize//lib/mechanize/http/agent.rb#96
  def pass=(_arg0); end

  # Invokes hooks added to post_connect_hooks after a +response+ is returned
  # and the response +body+ is handled.
  #
  # Yields the +context+, the +uri+ for the request, the +response+ and the
  # response +body+.
  #
  # source://mechanize//lib/mechanize/http/agent.rb#407
  def post_connect(uri, response, body_io); end

  # A list of hooks to call after retrieving a response.  Hooks are called with
  # the agent and the response returned.
  #
  # source://mechanize//lib/mechanize/http/agent.rb#39
  def post_connect_hooks; end

  # Invokes hooks added to pre_connect_hooks before a +request+ is made.
  # Yields the +agent+ and the +request+ that will be performed to each hook.
  #
  # source://mechanize//lib/mechanize/http/agent.rb#421
  def pre_connect(request); end

  # A list of hooks to call before making a request.  Hooks are called with
  # the agent and the request to be performed.
  #
  # source://mechanize//lib/mechanize/http/agent.rb#43
  def pre_connect_hooks; end

  # An OpenSSL private key or the path to a private key
  #
  # source://mechanize//lib/mechanize/http/agent.rb#1122
  def private_key; end

  # Sets the client's private key
  #
  # source://mechanize//lib/mechanize/http/agent.rb#1127
  def private_key=(private_key); end

  # URI for a proxy connection
  #
  # source://mechanize//lib/mechanize/http/agent.rb#340
  def proxy_uri; end

  # Length of time to attempt to read data from the server
  #
  # source://mechanize//lib/mechanize/http/agent.rb#107
  def read_timeout; end

  # Length of time to attempt to read data from the server
  #
  # source://mechanize//lib/mechanize/http/agent.rb#107
  def read_timeout=(_arg0); end

  # Controls how this agent deals with redirects.  The following values are
  # allowed:
  #
  # :all, true:: All 3xx redirects are followed (default)
  # :permanent:: Only 301 Moved Permanantly redirects are followed
  # false:: No redirects are followed
  #
  # source://mechanize//lib/mechanize/http/agent.rb#71
  def redirect_ok; end

  # Controls how this agent deals with redirects.  The following values are
  # allowed:
  #
  # :all, true:: All 3xx redirects are followed (default)
  # :permanent:: Only 301 Moved Permanantly redirects are followed
  # false:: No redirects are followed
  #
  # source://mechanize//lib/mechanize/http/agent.rb#71
  def redirect_ok=(_arg0); end

  # Maximum number of redirects to follow
  #
  # source://mechanize//lib/mechanize/http/agent.rb#74
  def redirection_limit; end

  # Maximum number of redirects to follow
  #
  # source://mechanize//lib/mechanize/http/agent.rb#74
  def redirection_limit=(_arg0); end

  # source://mechanize//lib/mechanize/http/agent.rb#524
  def request_add_headers(request, headers = T.unsafe(nil)); end

  # source://mechanize//lib/mechanize/http/agent.rb#541
  def request_auth(request, uri); end

  # source://mechanize//lib/mechanize/http/agent.rb#557
  def request_auth_digest(request, uri, realm, base_uri, iis); end

  # source://mechanize//lib/mechanize/http/agent.rb#566
  def request_cookies(request, uri); end

  # A hash of request headers to be used for every request
  #
  # source://mechanize//lib/mechanize/http/agent.rb#25
  def request_headers; end

  # A hash of request headers to be used for every request
  #
  # source://mechanize//lib/mechanize/http/agent.rb#25
  def request_headers=(_arg0); end

  # source://mechanize//lib/mechanize/http/agent.rb#576
  def request_host(request, uri); end

  # source://mechanize//lib/mechanize/http/agent.rb#583
  def request_language_charset(request); end

  # Log specified headers for the request
  #
  # source://mechanize//lib/mechanize/http/agent.rb#589
  def request_log(request); end

  # Sets a Referer header.  Fragment part is removed as demanded by
  # RFC 2616 14.36, and user information part is removed just like
  # major browsers do.
  #
  # source://mechanize//lib/mechanize/http/agent.rb#602
  def request_referer(request, uri, referer); end

  # source://mechanize//lib/mechanize/http/agent.rb#613
  def request_user_agent(request); end

  # source://mechanize//lib/mechanize/http/agent.rb#1287
  def reset; end

  # source://mechanize//lib/mechanize/http/agent.rb#617
  def resolve(uri, referer = T.unsafe(nil)); end

  # source://mechanize//lib/mechanize/http/agent.rb#708
  def resolve_parameters(uri, method, parameters); end

  # source://mechanize//lib/mechanize/http/agent.rb#740
  def response_authenticate(response, page, uri, request, headers, params, referer); end

  # source://mechanize//lib/mechanize/http/agent.rb#817
  def response_content_encoding(response, body_io); end

  # source://mechanize//lib/mechanize/http/agent.rb#859
  def response_cookies(response, uri, page); end

  # @raise [Mechanize::RedirectLimitReachedError]
  #
  # source://mechanize//lib/mechanize/http/agent.rb#887
  def response_follow_meta_refresh(response, uri, page, redirects); end

  # source://mechanize//lib/mechanize/http/agent.rb#901
  def response_log(response); end

  # source://mechanize//lib/mechanize/http/agent.rb#912
  def response_parse(response, body_io, uri); end

  # @raise [Mechanize::ResponseCodeError]
  #
  # source://mechanize//lib/mechanize/http/agent.rb#916
  def response_read(response, request, uri); end

  # @raise [Mechanize::RedirectLimitReachedError]
  #
  # source://mechanize//lib/mechanize/http/agent.rb#975
  def response_redirect(response, method, page, redirects, headers, referer = T.unsafe(nil)); end

  # Retry non-idempotent requests?
  #
  # source://mechanize//lib/mechanize/http/agent.rb#345
  def retry_change_requests; end

  # Retry non-idempotent requests
  #
  # source://mechanize//lib/mechanize/http/agent.rb#351
  def retry_change_requests=(retri); end

  # When true, this agent will consult the site's robots.txt for each access.
  #
  # source://mechanize//lib/mechanize/http/agent.rb#88
  def robots; end

  # source://mechanize//lib/mechanize/http/agent.rb#1039
  def robots=(value); end

  # Tests if this agent is allowed to access +url+, consulting the site's
  # robots.txt.
  #
  # @return [Boolean]
  #
  # source://mechanize//lib/mechanize/http/agent.rb#1049
  def robots_allowed?(uri); end

  # Opposite of robots_allowed?
  #
  # @return [Boolean]
  #
  # source://mechanize//lib/mechanize/http/agent.rb#1057
  def robots_disallowed?(url); end

  # Returns an error object if there is an error in fetching or parsing
  # robots.txt of the site +url+.
  #
  # source://mechanize//lib/mechanize/http/agent.rb#1063
  def robots_error(url); end

  # Raises the error if there is an error in fetching or parsing robots.txt of
  # the site +url+.
  #
  # source://mechanize//lib/mechanize/http/agent.rb#1069
  def robots_error!(url); end

  # Mutex used when fetching robots.txt
  #
  # source://mechanize//lib/mechanize/http/agent.rb#91
  def robots_mutex; end

  # Removes robots.txt cache for the site +url+.
  #
  # source://mechanize//lib/mechanize/http/agent.rb#1074
  def robots_reset(url); end

  # source://mechanize//lib/mechanize/http/agent.rb#875
  def save_cookies(uri, set_cookie); end

  # Handlers for various URI schemes
  #
  # source://mechanize//lib/mechanize/http/agent.rb#131
  def scheme_handlers; end

  # Handlers for various URI schemes
  #
  # source://mechanize//lib/mechanize/http/agent.rb#131
  def scheme_handlers=(_arg0); end

  # source://mechanize//lib/mechanize/http/agent.rb#696
  def secure_resolve!(uri, referer = T.unsafe(nil)); end

  # Sets the proxy address, port, user, and password. +addr+ may be
  # an HTTP URL/URI or a host name, +port+ may be a port number, service
  # name or port number string.
  #
  # source://mechanize//lib/mechanize/http/agent.rb#1238
  def set_proxy(addr, port = T.unsafe(nil), user = T.unsafe(nil), pass = T.unsafe(nil)); end

  # Closes all open connections for this agent.
  #
  # source://mechanize//lib/mechanize/http/agent.rb#439
  def shutdown; end

  # SSL version to use
  #
  # source://mechanize//lib/mechanize/http/agent.rb#1138
  def ssl_version; end

  # Sets the SSL version to use
  #
  # source://mechanize//lib/mechanize/http/agent.rb#1143
  def ssl_version=(ssl_version); end

  # @return [Boolean]
  #
  # source://mechanize//lib/mechanize/http/agent.rb#1280
  def use_tempfile?(size); end

  # The User-Agent header to send
  #
  # source://mechanize//lib/mechanize/http/agent.rb#28
  def user_agent; end

  # :section: Headers
  #
  # source://mechanize//lib/mechanize/http/agent.rb#357
  def user_agent=(user_agent); end

  # A callback for additional certificate verification.  See
  # OpenSSL::SSL::SSLContext#verify_callback
  #
  # The callback can be used for debugging or to ignore errors by always
  # returning +true+.  Specifying nil uses the default method that was valid
  # when the SSLContext was created
  #
  # source://mechanize//lib/mechanize/http/agent.rb#1153
  def verify_callback; end

  # Sets the certificate verify callback
  #
  # source://mechanize//lib/mechanize/http/agent.rb#1158
  def verify_callback=(verify_callback); end

  # How to verify SSL connections.  Defaults to VERIFY_PEER
  #
  # source://mechanize//lib/mechanize/http/agent.rb#1163
  def verify_mode; end

  # Sets the mode for verifying SSL connections
  #
  # source://mechanize//lib/mechanize/http/agent.rb#1168
  def verify_mode=(verify_mode); end

  # Returns a visited page for the url passed in, otherwise nil
  #
  # source://mechanize//lib/mechanize/http/agent.rb#388
  def visited_page(url); end

  # source://mechanize//lib/mechanize/http/agent.rb#1078
  def webrobots; end
end

# source://mechanize//lib/mechanize/http/agent.rb#13
Mechanize::HTTP::Agent::COOKIE_HEADERS = T.let(T.unsafe(nil), Array)

# source://mechanize//lib/mechanize/http/agent.rb#12
Mechanize::HTTP::Agent::CREDENTIAL_HEADERS = T.let(T.unsafe(nil), Array)

# source://mechanize//lib/mechanize/http/agent.rb#14
Mechanize::HTTP::Agent::POST_HEADERS = T.let(T.unsafe(nil), Array)

# :section: Robots
#
# source://mechanize//lib/mechanize/http/agent.rb#1017
Mechanize::HTTP::Agent::RobotsKey = T.let(T.unsafe(nil), Symbol)

# A parsed WWW-Authenticate header
#
# source://mechanize//lib/mechanize/http/auth_challenge.rb#4
class Mechanize::HTTP::AuthChallenge < ::Struct
  # Retrieves +param+ from the params list
  #
  # source://mechanize//lib/mechanize/http/auth_challenge.rb#32
  def [](param); end

  # Returns the value of attribute params
  #
  # @return [Object] the current value of params
  def params; end

  # Sets the attribute params
  #
  # @param value [Object] the value to set the attribute params to.
  # @return [Object] the newly set value
  def params=(_); end

  # Returns the value of attribute raw
  #
  # @return [Object] the current value of raw
  def raw; end

  # Sets the attribute raw
  #
  # @param value [Object] the value to set the attribute raw to.
  # @return [Object] the newly set value
  def raw=(_); end

  # Constructs an AuthRealm for this challenge
  #
  # source://mechanize//lib/mechanize/http/auth_challenge.rb#39
  def realm(uri); end

  # The name of the realm for this challenge
  #
  # source://mechanize//lib/mechanize/http/auth_challenge.rb#54
  def realm_name; end

  # Returns the value of attribute scheme
  #
  # @return [Object] the current value of scheme
  def scheme; end

  # Sets the attribute scheme
  #
  # @param value [Object] the value to set the attribute scheme to.
  # @return [Object] the newly set value
  def scheme=(_); end

  # Returns the value of attribute raw
  # The raw authentication challenge
  #
  # @return [Object] the current value of raw
  def to_s; end

  class << self
    def [](*_arg0); end
    def inspect; end
    def keyword_init?; end
    def members; end
    def new(*_arg0); end
  end
end

# source://mechanize//lib/mechanize/http/auth_realm.rb#2
class Mechanize::HTTP::AuthRealm
  # @return [AuthRealm] a new instance of AuthRealm
  #
  # source://mechanize//lib/mechanize/http/auth_realm.rb#8
  def initialize(scheme, uri, realm); end

  # source://mechanize//lib/mechanize/http/auth_realm.rb#14
  def ==(other); end

  # source://mechanize//lib/mechanize/http/auth_realm.rb#14
  def eql?(other); end

  # source://mechanize//lib/mechanize/http/auth_realm.rb#23
  def hash; end

  # source://mechanize//lib/mechanize/http/auth_realm.rb#27
  def inspect; end

  # Returns the value of attribute realm.
  #
  # source://mechanize//lib/mechanize/http/auth_realm.rb#6
  def realm; end

  # Returns the value of attribute scheme.
  #
  # source://mechanize//lib/mechanize/http/auth_realm.rb#4
  def scheme; end

  # Returns the value of attribute uri.
  #
  # source://mechanize//lib/mechanize/http/auth_realm.rb#5
  def uri; end
end

# A credential store for HTTP authentication.
#
#   uri = URI 'http://example'
#
#   store = Mechanize::HTTP::AuthStore.new
#   store.add_auth uri, 'user1', 'pass'
#   store.add_auth uri, 'user2', 'pass', 'realm'
#
#   user, pass = store.credentials_for uri, 'realm' #=> 'user2', 'pass'
#   user, pass = store.credentials_for uri, 'other' #=> 'user1', 'pass'
#
#   store.remove_auth uri # removes all credentials
#
# source://mechanize//lib/mechanize/http/auth_store.rb#16
class Mechanize::HTTP::AuthStore
  # Creates a new AuthStore
  #
  # @return [AuthStore] a new instance of AuthStore
  #
  # source://mechanize//lib/mechanize/http/auth_store.rb#25
  def initialize; end

  # Adds credentials +user+, +pass+ for the server at +uri+.  If +realm+ is
  # set the credentials are used only for that realm.  If +realm+ is not set
  # the credentials become the default for any realm on that URI.
  #
  # +domain+ and +realm+ are exclusive as NTLM does not follow RFC
  # 2617.  If +domain+ is given it is only used for NTLM authentication.
  #
  # @raise [ArgumentError]
  #
  # source://mechanize//lib/mechanize/http/auth_store.rb#41
  def add_auth(uri, user, pass, realm = T.unsafe(nil), domain = T.unsafe(nil)); end

  # USE OF add_default_auth IS NOT RECOMMENDED AS IT MAY EXPOSE PASSWORDS TO
  # THIRD PARTIES
  #
  # Adds credentials +user+, +pass+ as the default authentication credentials.
  # If no other credentials are available  these will be returned from
  # credentials_for.
  #
  # If +domain+ is given it is only used for NTLM authentication.
  #
  # source://mechanize//lib/mechanize/http/auth_store.rb#65
  def add_default_auth(user, pass, domain = T.unsafe(nil)); end

  # source://mechanize//lib/mechanize/http/auth_store.rb#18
  def auth_accounts; end

  # Returns true if credentials exist for the +challenges+ from the server at
  # +uri+.
  #
  # @return [Boolean]
  #
  # source://mechanize//lib/mechanize/http/auth_store.rb#84
  def credentials?(uri, challenges); end

  # Retrieves credentials for +realm+ on the server at +uri+.
  #
  # source://mechanize//lib/mechanize/http/auth_store.rb#93
  def credentials_for(uri, realm); end

  # source://mechanize//lib/mechanize/http/auth_store.rb#20
  def default_auth; end

  # Removes credentials for +realm+ on the server at +uri+.  If +realm+ is not
  # set all credentials for the server at +uri+ are removed.
  #
  # source://mechanize//lib/mechanize/http/auth_store.rb#109
  def remove_auth(uri, realm = T.unsafe(nil)); end
end

# source://mechanize//lib/mechanize/http/content_disposition_parser.rb#8
class Mechanize::HTTP::ContentDisposition < ::Struct
  # Returns the value of attribute creation_date
  #
  # @return [Object] the current value of creation_date
  def creation_date; end

  # Sets the attribute creation_date
  #
  # @param value [Object] the value to set the attribute creation_date to.
  # @return [Object] the newly set value
  def creation_date=(_); end

  # Returns the value of attribute filename
  #
  # @return [Object] the current value of filename
  def filename; end

  # Sets the attribute filename
  #
  # @param value [Object] the value to set the attribute filename to.
  # @return [Object] the newly set value
  def filename=(_); end

  # Returns the value of attribute modification_date
  #
  # @return [Object] the current value of modification_date
  def modification_date; end

  # Sets the attribute modification_date
  #
  # @param value [Object] the value to set the attribute modification_date to.
  # @return [Object] the newly set value
  def modification_date=(_); end

  # Returns the value of attribute parameters
  #
  # @return [Object] the current value of parameters
  def parameters; end

  # Sets the attribute parameters
  #
  # @param value [Object] the value to set the attribute parameters to.
  # @return [Object] the newly set value
  def parameters=(_); end

  # Returns the value of attribute read_date
  #
  # @return [Object] the current value of read_date
  def read_date; end

  # Sets the attribute read_date
  #
  # @param value [Object] the value to set the attribute read_date to.
  # @return [Object] the newly set value
  def read_date=(_); end

  # Returns the value of attribute size
  #
  # @return [Object] the current value of size
  def size; end

  # Sets the attribute size
  #
  # @param value [Object] the value to set the attribute size to.
  # @return [Object] the newly set value
  def size=(_); end

  # Returns the value of attribute type
  #
  # @return [Object] the current value of type
  def type; end

  # Sets the attribute type
  #
  # @param value [Object] the value to set the attribute type to.
  # @return [Object] the newly set value
  def type=(_); end

  class << self
    def [](*_arg0); end
    def inspect; end
    def keyword_init?; end
    def members; end
    def new(*_arg0); end
  end
end

# Parser Content-Disposition headers that loosely follows RFC 2183.
#
# Beyond RFC 2183, this parser allows:
#
# * Missing disposition-type
# * Multiple semicolons
# * Whitespace around semicolons
# * Dates in ISO 8601 format
#
# source://mechanize//lib/mechanize/http/content_disposition_parser.rb#22
class Mechanize::HTTP::ContentDispositionParser
  # Creates a new parser Content-Disposition headers
  #
  # @return [ContentDispositionParser] a new instance of ContentDispositionParser
  #
  # source://mechanize//lib/mechanize/http/content_disposition_parser.rb#40
  def initialize; end

  # Parses the +content_disposition+ header.  If +header+ is set to true the
  # "Content-Disposition:" portion will be parsed
  #
  # source://mechanize//lib/mechanize/http/content_disposition_parser.rb#48
  def parse(content_disposition, header = T.unsafe(nil)); end

  # Extracts disposition-parm and returns a Hash.
  #
  # source://mechanize//lib/mechanize/http/content_disposition_parser.rb#86
  def parse_parameters; end

  # quoted-string = <"> *(qtext/quoted-pair) <">
  #   qtext         = <any CHAR excepting <">, "\" & CR,
  #                    and including linear-white-space
  #   quoted-pair   = "\" CHAR
  #
  # Parses an RFC 2045 quoted-string
  #
  # source://mechanize//lib/mechanize/http/content_disposition_parser.rb#137
  def rfc_2045_quoted_string; end

  # token := 1*<any (US-ASCII) CHAR except SPACE, CTLs, or tspecials>
  #
  # Parses an RFC 2045 token
  #
  # source://mechanize//lib/mechanize/http/content_disposition_parser.rb#176
  def rfc_2045_token; end

  # value := token / quoted-string
  #
  # Parses an RFC 2045 value
  #
  # source://mechanize//lib/mechanize/http/content_disposition_parser.rb#185
  def rfc_2045_value; end

  # source://mechanize//lib/mechanize/http/content_disposition_parser.rb#24
  def scanner; end

  # source://mechanize//lib/mechanize/http/content_disposition_parser.rb#24
  def scanner=(_arg0); end

  # 1*SP
  #
  # Parses spaces
  #
  # source://mechanize//lib/mechanize/http/content_disposition_parser.rb#198
  def spaces; end

  class << self
    # Parses the disposition type and params in the +content_disposition+
    # string.  The "Content-Disposition:" must be removed.
    #
    # source://mechanize//lib/mechanize/http/content_disposition_parser.rb#32
    def parse(content_disposition); end
  end
end

# Parses the WWW-Authenticate HTTP header into separate challenges.
#
# source://mechanize//lib/mechanize/http/www_authenticate_parser.rb#8
class Mechanize::HTTP::WWWAuthenticateParser
  # Creates a new header parser for WWW-Authenticate headers
  #
  # @return [WWWAuthenticateParser] a new instance of WWWAuthenticateParser
  #
  # source://mechanize//lib/mechanize/http/www_authenticate_parser.rb#15
  def initialize; end

  # auth-param = token "=" ( token | quoted-string )
  #
  # Parses an auth parameter
  #
  # source://mechanize//lib/mechanize/http/www_authenticate_parser.rb#129
  def auth_param; end

  # token = 1*<any CHAR except CTLs or separators>
  #
  # Parses a token
  #
  #   auth-scheme = token
  #
  # Parses an auth scheme (a token)
  #
  # source://mechanize//lib/mechanize/http/www_authenticate_parser.rb#113
  def auth_scheme; end

  # Parsers the header.  Returns an Array of challenges as strings
  #
  # source://mechanize//lib/mechanize/http/www_authenticate_parser.rb#22
  def parse(www_authenticate); end

  # quoted-string = ( <"> *(qdtext | quoted-pair ) <"> )
  #   qdtext        = <any TEXT except <">>
  #   quoted-pair   = "\" CHAR
  #
  # For TEXT, the rules of RFC 2047 are ignored.
  #
  # source://mechanize//lib/mechanize/http/www_authenticate_parser.rb#151
  def quoted_string; end

  # scans a comma followed by spaces
  # needed for Negotiation, NTLM
  #
  # source://mechanize//lib/mechanize/http/www_authenticate_parser.rb#104
  def scan_comma_spaces; end

  # source://mechanize//lib/mechanize/http/www_authenticate_parser.rb#10
  def scanner; end

  # source://mechanize//lib/mechanize/http/www_authenticate_parser.rb#10
  def scanner=(_arg0); end

  # 1*SP
  #
  # Parses spaces
  #
  # source://mechanize//lib/mechanize/http/www_authenticate_parser.rb#95
  def spaces; end

  # token = 1*<any CHAR except CTLs or separators>
  #
  # Parses a token
  #
  # source://mechanize//lib/mechanize/http/www_authenticate_parser.rb#113
  def token; end
end

# source://mechanize//lib/mechanize/headers.rb#2
class Mechanize::Headers < ::Hash
  # source://mechanize//lib/mechanize/headers.rb#3
  def [](key); end

  # source://mechanize//lib/mechanize/headers.rb#7
  def []=(key, value); end

  # source://mechanize//lib/mechanize/headers.rb#15
  def canonical_each; end

  # @return [Boolean]
  #
  # source://mechanize//lib/mechanize/headers.rb#11
  def key?(key); end
end

# This class manages history for your mechanize object.
#
# source://mechanize//lib/mechanize/history.rb#5
class Mechanize::History < ::Array
  # @return [History] a new instance of History
  #
  # source://mechanize//lib/mechanize/history.rb#9
  def initialize(max_size = T.unsafe(nil)); end

  # source://mechanize//lib/mechanize/history.rb#25
  def <<(page, uri = T.unsafe(nil)); end

  # source://mechanize//lib/mechanize/history.rb#51
  def clear; end

  # source://mechanize//lib/mechanize/history.rb#19
  def inspect; end

  # Returns the value of attribute max_size.
  #
  # source://mechanize//lib/mechanize/history.rb#7
  def max_size; end

  # Sets the attribute max_size
  #
  # @param value the value to set the attribute max_size to.
  #
  # source://mechanize//lib/mechanize/history.rb#7
  def max_size=(_arg0); end

  # source://mechanize//lib/mechanize/history.rb#67
  def pop; end

  # source://mechanize//lib/mechanize/history.rb#25
  def push(page, uri = T.unsafe(nil)); end

  # source://mechanize//lib/mechanize/history.rb#56
  def shift; end

  # @return [Boolean]
  #
  # source://mechanize//lib/mechanize/history.rb#38
  def visited?(uri); end

  # @return [Boolean]
  #
  # source://mechanize//lib/mechanize/history.rb#38
  def visited_page(uri); end

  private

  # source://mechanize//lib/mechanize/history.rb#14
  def initialize_copy(orig); end

  # source://mechanize//lib/mechanize/history.rb#76
  def remove_from_index(page); end
end

# An Image holds downloaded data for an image/* response.
#
# source://mechanize//lib/mechanize/image.rb#5
class Mechanize::Image < ::Mechanize::Download; end

# This class encapsulates an HTML page.  If Mechanize finds a content
# type of 'text/html', this class will be instantiated and returned.
#
# Example:
#
#   require 'mechanize'
#
#   agent = Mechanize.new
#   agent.get('http://google.com/').class # => Mechanize::Page
#
# source://mechanize//lib/mechanize/page.rb#13
class Mechanize::Page < ::Mechanize::File
  extend ::Forwardable
  extend ::Mechanize::ElementMatcher

  # @return [Page] a new instance of Page
  #
  # source://mechanize//lib/mechanize/page.rb#28
  def initialize(uri = T.unsafe(nil), response = T.unsafe(nil), body = T.unsafe(nil), code = T.unsafe(nil), mech = T.unsafe(nil)); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def %(*args, **_arg1, &block); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def /(*args, **_arg1, &block); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def at(*args, **_arg1, &block); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def at_css(*args, **_arg1, &block); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def at_xpath(*args, **_arg1, &block); end

  # :method: bases_with
  #
  # :call-seq: bases_with(criteria)
  #
  # Find all base tags matching +criteria+.  See +forms_with+ for
  # details of +criteria+, where for "form(s)" read "base tag(s)".
  #
  # Example:
  #   page.bases_with(href: /foo/).each do |base|
  #     puts base.href
  #   end
  def base(criteria = T.unsafe(nil)); end

  def base_with(criteria = T.unsafe(nil)); end
  def base_with!(criteria = T.unsafe(nil)); end

  # Return a list of all base tags
  #
  # source://mechanize//lib/mechanize/page.rb#526
  def bases; end

  def bases_with(criteria = T.unsafe(nil)); end

  # Return the canonical URI for the page if there is a link tag
  # with href="canonical".
  #
  # source://mechanize//lib/mechanize/page.rb#178
  def canonical_uri; end

  # Get the content type
  #
  # source://mechanize//lib/mechanize/page.rb#189
  def content_type; end

  # source://forwardable/1.3.3/forwardable.rb#231
  def css(*args, **_arg1, &block); end

  # source://mechanize//lib/mechanize/page.rb#71
  def detected_encoding; end

  # source://mechanize//lib/mechanize/page.rb#91
  def encoding; end

  # source://mechanize//lib/mechanize/page.rb#75
  def encoding=(encoding); end

  # Return whether parser result has errors related to encoding or not.
  # false indicates just parser has no encoding errors, not encoding is vaild.
  #
  # @return [Boolean]
  #
  # source://mechanize//lib/mechanize/page.rb#99
  def encoding_error?(parser = T.unsafe(nil)); end

  # Possible encodings for this page based on HTTP headers and meta elements
  #
  # source://mechanize//lib/mechanize/page.rb#26
  def encodings; end

  # :method: forms_with
  #
  # :call-seq:
  #   forms_with(name)
  #   forms_with(name: name_matcher, id: id_matcher, class: class_matcher,
  #              search: search_expression, xpath: xpath_expression, css: css_expression,
  #              action: action_matcher, ...)
  #
  # Find all forms form matching criteria.  If a string is given, it
  # is taken as a name attribute value.  If a hash is given, forms
  # are narrowed by the key-value pairs as follows.
  #
  # :id, :dom_id: selects forms with a #dom_id value that matches this
  # value.
  #
  # :class, :dom_class: selects forms with a #dom_class value that
  # matches this value.  Note that class attribute values are compared
  # literally as string, so forms_with(class: "a") does not match a
  # form with class="a b".  Use forms_with(css: "form.a") instead.
  #
  # :search: only selects forms matching this selector expression.
  #
  # :xpath: only selects forms matching this XPath expression.
  #
  # :css: only selects forms matching this CSS selector expression.
  #
  # :action, :method, etc.: narrows forms by a given attribute value
  # using the === operator.
  #
  # Example:
  #   page.forms_with(css: '#content table.login_box form', method: /\APOST\z/i, ).each do |f|
  #     ...
  #   end
  def form(criteria = T.unsafe(nil)); end

  def form_with(criteria = T.unsafe(nil)); end
  def form_with!(criteria = T.unsafe(nil)); end

  # Return a list of all form tags
  #
  # source://mechanize//lib/mechanize/page.rb#505
  def forms; end

  def forms_with(criteria = T.unsafe(nil)); end

  # :method: frames_with
  #
  # :call-seq: frames_with(criteria)
  #
  # Find all frame tags matching +criteria+.  See +forms_with+ for
  # details of +criteria+, where for "form(s)" read "frame tag(s)".
  #
  # Example:
  #   page.frames_with(src: /foo/).each do |frame|
  #     p frame.src
  #   end
  def frame(criteria = T.unsafe(nil)); end

  def frame_with(criteria = T.unsafe(nil)); end
  def frame_with!(criteria = T.unsafe(nil)); end

  # Return a list of all frame tags
  #
  # source://mechanize//lib/mechanize/page.rb#533
  def frames; end

  def frames_with(criteria = T.unsafe(nil)); end

  # :method: iframes_with
  #
  # :call-seq: iframes_with(criteria)
  #
  # Find all iframe tags matching +criteria+.  See +forms_with+ for
  # details of +criteria+, where for "form(s)" read "iframe tag(s)".
  #
  # Example:
  #   page.iframes_with(src: /foo/).each do |iframe|
  #     p iframe.src
  #   end
  def iframe(criteria = T.unsafe(nil)); end

  def iframe_with(criteria = T.unsafe(nil)); end
  def iframe_with!(criteria = T.unsafe(nil)); end

  # Return a list of all iframe tags
  #
  # source://mechanize//lib/mechanize/page.rb#540
  def iframes; end

  def iframes_with(criteria = T.unsafe(nil)); end

  # :method: images_with
  #
  # :call-seq: images_with(criteria)
  #
  # Find all images matching +criteria+.  See +forms_with+ for
  # details of +criteria+, where for "form(s)" read "image(s)".
  #
  # Example:
  #   page.images_with(src: /jpg\Z/).each do |img|
  #     img.fetch.save
  #   end
  def image(criteria = T.unsafe(nil)); end

  # source://mechanize//lib/mechanize/page.rb#552
  def image_urls; end

  def image_with(criteria = T.unsafe(nil)); end
  def image_with!(criteria = T.unsafe(nil)); end

  # Return a list of all img tags
  #
  # source://mechanize//lib/mechanize/page.rb#547
  def images; end

  def images_with(criteria = T.unsafe(nil)); end

  # source://pp/0.4.0/pp.rb#637
  def inspect; end

  # Return a list of all label tags
  #
  # source://mechanize//lib/mechanize/page.rb#558
  def labels; end

  # source://mechanize//lib/mechanize/page.rb#563
  def labels_hash; end

  # :method: links_with
  #
  # :call-seq:
  #   links_with(criteria)
  #
  # Find all links matching +criteria+.  See +forms_with+ for details
  # of +criteria+, where for "form(s)" read "link(s)".
  #
  # Example:
  #   page.links_with(href: /foo/).each do |link|
  #     puts link.href
  #   end
  def link(criteria = T.unsafe(nil)); end

  def link_with(criteria = T.unsafe(nil)); end
  def link_with!(criteria = T.unsafe(nil)); end

  # Return a list of all link and area tags
  #
  # source://mechanize//lib/mechanize/page.rb#495
  def links; end

  def links_with(criteria = T.unsafe(nil)); end

  # Returns the value of attribute mech.
  #
  # source://mechanize//lib/mechanize/page.rb#21
  def mech; end

  # Sets the attribute mech
  #
  # @param value the value to set the attribute mech to.
  #
  # source://mechanize//lib/mechanize/page.rb#21
  def mech=(_arg0); end

  # source://mechanize//lib/mechanize/page.rb#67
  def meta_charset; end

  # Return a list of all meta refresh elements
  #
  # source://mechanize//lib/mechanize/page.rb#516
  def meta_refresh; end

  # :method: at_xpath
  #
  # Shorthand for +parser.at_xpath+.
  #
  # See also Nokogiri::XML::Node#at_xpath for details.
  #
  # source://mechanize//lib/mechanize/page.rb#109
  def parser; end

  # source://mechanize//lib/mechanize/page.rb#132
  def pretty_print(q); end

  # source://mechanize//lib/mechanize/page.rb#163
  def reset; end

  # source://mechanize//lib/mechanize/page.rb#63
  def response_header_charset; end

  # source://mechanize//lib/mechanize/page.rb#109
  def root; end

  # source://forwardable/1.3.3/forwardable.rb#231
  def search(*args, **_arg1, &block); end

  def select_bases(selector, method = T.unsafe(nil)); end
  def select_forms(selector, method = T.unsafe(nil)); end
  def select_frames(selector, method = T.unsafe(nil)); end
  def select_iframes(selector, method = T.unsafe(nil)); end
  def select_images(selector, method = T.unsafe(nil)); end
  def select_links(selector, method = T.unsafe(nil)); end

  # source://mechanize//lib/mechanize/page.rb#55
  def title; end

  # source://forwardable/1.3.3/forwardable.rb#231
  def xpath(*args, **_arg1, &block); end

  private

  # source://mechanize//lib/mechanize/page.rb#629
  def html_body; end

  class << self
    # source://mechanize//lib/mechanize/page.rb#575
    def charset(content_type); end

    # source://mechanize//lib/mechanize/page.rb#575
    def charset_from_content_type(content_type); end

    # Retrieves all charsets from +meta+ tags in +body+
    #
    # source://mechanize//lib/mechanize/page.rb#597
    def meta_charset(body); end

    # Retrieves the last <tt>content-type</tt> set by a +meta+ tag in +body+
    #
    # source://mechanize//lib/mechanize/page.rb#615
    def meta_content_type(body); end

    # source://mechanize//lib/mechanize/page.rb#584
    def response_header_charset(response); end
  end
end

# A base element on an HTML page.  Mechanize treats base tags just like 'a'
# tags.  Base objects will contain links, but most likely will have no text.
#
# source://mechanize//lib/mechanize/page/base.rb#6
class Mechanize::Page::Base < ::Mechanize::Page::Link; end

# source://mechanize//lib/mechanize/page.rb#17
Mechanize::Page::DEFAULT_RESPONSE = T.let(T.unsafe(nil), Hash)

# A Frame object wraps a frame HTML element.  Frame objects can be treated
# just like Link objects.  They contain #src, the #link they refer to and a
# #name, the name of the frame they refer to.  #src and #name are aliased to
# #href and #text respectively so that a Frame object can be treated just like
# a Link.
#
# source://mechanize//lib/mechanize/page/frame.rb#8
class Mechanize::Page::Frame < ::Mechanize::Page::Link
  # @return [Frame] a new instance of Frame
  #
  # source://mechanize//lib/mechanize/page/frame.rb#17
  def initialize(node, mech, referer); end

  # source://mechanize//lib/mechanize/page/frame.rb#25
  def content; end

  # Returns the value of attribute text.
  #
  # source://mechanize//lib/mechanize/page/frame.rb#12
  def name; end

  # Returns the value of attribute node.
  #
  # source://mechanize//lib/mechanize/page/frame.rb#15
  def node; end

  # source://mechanize//lib/mechanize/page/link.rb#16
  def src; end

  # Returns the value of attribute text.
  #
  # source://mechanize//lib/mechanize/page/frame.rb#12
  def text; end
end

# An image element on an HTML page
#
# source://mechanize//lib/mechanize/page/image.rb#5
class Mechanize::Page::Image
  # Creates a new Mechanize::Page::Image from an image +node+ and source
  # +page+.
  #
  # @return [Image] a new instance of Image
  #
  # source://mechanize//lib/mechanize/page/image.rb#15
  def initialize(node, page); end

  # The alt attribute of the image
  #
  # source://mechanize//lib/mechanize/page/image.rb#24
  def alt; end

  # The caption of the image.  In order of preference, the #title, #alt, or
  # empty string "".
  #
  # source://mechanize//lib/mechanize/page/image.rb#32
  def caption; end

  # The class attribute of the image
  #
  # source://mechanize//lib/mechanize/page/image.rb#41
  def dom_class; end

  # The id attribute of the image
  #
  # source://mechanize//lib/mechanize/page/image.rb#48
  def dom_id; end

  # The suffix of the #url. The dot is a part of suffix, not a delimiter.
  #
  #   p image.url     # => "http://example/test.jpg"
  #   p image.extname # => ".jpg"
  #
  # Returns an empty string if #url has no suffix:
  #
  #   p image.url     # => "http://example/sampleimage"
  #   p image.extname # => ""
  #
  # source://mechanize//lib/mechanize/page/image.rb#63
  def extname; end

  # Downloads the image.
  #
  #   agent.page.image_with(:src => /logo/).fetch.save
  #
  # The referer is:
  #
  # #page("parent") ::
  #   all images on http html, relative #src images on https html
  # (no referer)    ::
  #   absolute #src images on https html
  # user specified  ::
  #   img.fetch(nil, my_referer_uri_or_page)
  #
  # source://mechanize//lib/mechanize/page/image.rb#83
  def fetch(parameters = T.unsafe(nil), referer = T.unsafe(nil), headers = T.unsafe(nil)); end

  # The height attribute of the image
  #
  # source://mechanize//lib/mechanize/page/image.rb#90
  def height; end

  # source://mechanize//lib/mechanize/page/image.rb#94
  def image_referer; end

  # source://pp/0.4.0/pp.rb#637
  def inspect; end

  # Returns the value of attribute mech.
  #
  # source://mechanize//lib/mechanize/page/image.rb#9
  def mech; end

  # Sets the attribute mech
  #
  # @param value the value to set the attribute mech to.
  #
  # source://mechanize//lib/mechanize/page/image.rb#9
  def mech=(_arg0); end

  # MIME type guessed from the image url suffix
  #
  #   p image.extname   # => ".jpg"
  #   p image.mime_type # => "image/jpeg"
  #   page.images_with(:mime_type => /gif|jpeg|png/).each do ...
  #
  # Returns nil if url has no (well-known) suffix:
  #
  #   p image.url       # => "http://example/sampleimage"
  #   p image.mime_type # => nil
  #
  # source://mechanize//lib/mechanize/page/image.rb#118
  def mime_type; end

  # Returns the value of attribute node.
  #
  # source://mechanize//lib/mechanize/page/image.rb#7
  def node; end

  # Returns the value of attribute page.
  #
  # source://mechanize//lib/mechanize/page/image.rb#8
  def page; end

  # Sets the attribute page
  #
  # @param value the value to set the attribute page to.
  #
  # source://mechanize//lib/mechanize/page/image.rb#8
  def page=(_arg0); end

  # source://mechanize//lib/mechanize/page/image.rb#124
  def pretty_print(q); end

  # @return [Boolean]
  #
  # source://mechanize//lib/mechanize/page/image.rb#133
  def relative?; end

  # The src attribute of the image
  #
  # source://mechanize//lib/mechanize/page/image.rb#140
  def src; end

  # The caption of the image.  In order of preference, the #title, #alt, or
  # empty string "".
  #
  # source://mechanize//lib/mechanize/page/image.rb#32
  def text; end

  # The title attribute of the image
  #
  # source://mechanize//lib/mechanize/page/image.rb#147
  def title; end

  # The URL string of this image
  #
  # source://mechanize//lib/mechanize/page/image.rb#154
  def to_s; end

  # URI for this image
  #
  # source://mechanize//lib/mechanize/page/image.rb#161
  def uri; end

  # URI for this image
  #
  # source://mechanize//lib/mechanize/page/image.rb#161
  def url; end

  # The width attribute of the image
  #
  # source://mechanize//lib/mechanize/page/image.rb#178
  def width; end
end

# A form label on an HTML page
#
# source://mechanize//lib/mechanize/page/label.rb#5
class Mechanize::Page::Label
  # @return [Label] a new instance of Label
  #
  # source://mechanize//lib/mechanize/page/label.rb#11
  def initialize(node, page); end

  # source://mechanize//lib/mechanize/page/label.rb#17
  def for; end

  # Returns the value of attribute node.
  #
  # source://mechanize//lib/mechanize/page/label.rb#6
  def node; end

  # Returns the value of attribute page.
  #
  # source://mechanize//lib/mechanize/page/label.rb#8
  def page; end

  # Returns the value of attribute text.
  #
  # source://mechanize//lib/mechanize/page/label.rb#7
  def text; end

  # Returns the value of attribute text.
  #
  # source://mechanize//lib/mechanize/page/label.rb#7
  def to_s; end
end

# source://mechanize//lib/mechanize/page/link.rb#14
class Mechanize::Page::Link
  # @return [Link] a new instance of Link
  #
  # source://mechanize//lib/mechanize/page/link.rb#21
  def initialize(node, mech, page); end

  # Returns the value of attribute attributes.
  #
  # source://mechanize//lib/mechanize/page/link.rb#17
  def attributes; end

  # Click on this link
  #
  # source://mechanize//lib/mechanize/page/link.rb#32
  def click; end

  # This method is a shorthand to get a link's DOM class
  # Common usage:
  #   page.link_with(:dom_class => "links_exact_class")
  #
  # source://mechanize//lib/mechanize/page/link.rb#46
  def dom_class; end

  # This method is a shorthand to get link's DOM id.
  # Common usage:
  #   page.link_with(:dom_id => "links_exact_id")
  #
  # source://mechanize//lib/mechanize/page/link.rb#39
  def dom_id; end

  # Returns the value of attribute href.
  #
  # source://mechanize//lib/mechanize/page/link.rb#16
  def href; end

  # source://pp/0.4.0/pp.rb#637
  def inspect; end

  # Returns the value of attribute node.
  #
  # source://mechanize//lib/mechanize/page/link.rb#15
  def node; end

  # Test if this link should not be traced.
  #
  # @return [Boolean]
  #
  # source://mechanize//lib/mechanize/page/link.rb#70
  def noreferrer?; end

  # Returns the value of attribute page.
  #
  # source://mechanize//lib/mechanize/page/link.rb#18
  def page; end

  # source://mechanize//lib/mechanize/page/link.rb#50
  def pretty_print(q); end

  # Returns the value of attribute page.
  #
  # source://mechanize//lib/mechanize/page/link.rb#18
  def referer; end

  # A list of words in the rel attribute, all lower-cased.
  #
  # source://mechanize//lib/mechanize/page/link.rb#60
  def rel; end

  # Test if the rel attribute includes +kind+.
  #
  # @return [Boolean]
  #
  # source://mechanize//lib/mechanize/page/link.rb#65
  def rel?(kind); end

  # A fully resolved URI for the #href for this link.
  #
  # source://mechanize//lib/mechanize/page/link.rb#110
  def resolved_uri; end

  # The text content of this link
  #
  # source://mechanize//lib/mechanize/page/link.rb#75
  def text; end

  # The text content of this link
  #
  # source://mechanize//lib/mechanize/page/link.rb#75
  def to_s; end

  # A URI for the #href for this link.  The link is first parsed as a raw
  # link.  If that fails parsing an escaped link is attepmted.
  #
  # source://mechanize//lib/mechanize/page/link.rb#95
  def uri; end
end

# This class encapsulates a meta element with a refresh http-equiv.  Mechanize
# treats meta refresh elements just like 'a' tags.  MetaRefresh objects will
# contain links, but most likely will have no text.
#
# source://mechanize//lib/mechanize/page/meta_refresh.rb#7
class Mechanize::Page::MetaRefresh < ::Mechanize::Page::Link
  # @return [MetaRefresh] a new instance of MetaRefresh
  #
  # source://mechanize//lib/mechanize/page/meta_refresh.rb#67
  def initialize(node, page, delay, href, link_self = T.unsafe(nil)); end

  # Time to wait before next refresh
  #
  # source://mechanize//lib/mechanize/page/meta_refresh.rb#12
  def delay; end

  # This MetaRefresh links did not contain a url= in the content attribute and
  # links to itself.
  #
  # source://mechanize//lib/mechanize/page/meta_refresh.rb#18
  def link_self; end

  # @return [Boolean]
  #
  # source://mechanize//lib/mechanize/page/meta_refresh.rb#75
  def noreferrer?; end

  class << self
    # source://mechanize//lib/mechanize/page/meta_refresh.rb#56
    def from_node(node, page, uri = T.unsafe(nil)); end

    # Parses the delay and url from the content attribute of a meta
    # refresh element.
    #
    # Returns an array of [delay, url, link_self], where the first two
    # are strings containing the respective parts of the refresh value,
    # and link_self is a boolean value that indicates whether the url
    # part is missing or empty.  If base_uri, the URI of the current
    # page is given, the value of url becomes an absolute URI.
    #
    # source://mechanize//lib/mechanize/page/meta_refresh.rb#43
    def parse(content, base_uri = T.unsafe(nil)); end
  end
end

# Matches the content attribute of a meta refresh element.  After the match:
#
#   $1:: delay
#   $3:: url
#
# source://mechanize//lib/mechanize/page/meta_refresh.rb#26
Mechanize::Page::MetaRefresh::CONTENT_REGEXP = T.let(T.unsafe(nil), Regexp)

# Regexp of unsafe URI characters that excludes % for Issue #177
#
# source://mechanize//lib/mechanize/page/meta_refresh.rb#31
Mechanize::Page::MetaRefresh::UNSAFE = T.let(T.unsafe(nil), Regexp)

# The parser module provides standard methods for accessing the headers and
# content of a response that are shared across pluggable parsers.
#
# source://mechanize//lib/mechanize/parser.rb#6
module Mechanize::Parser
  extend ::Forwardable

  # source://forwardable/1.3.3/forwardable.rb#231
  def [](*args, **_arg1, &block); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def []=(*args, **_arg1, &block); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def canonical_each(*args, **_arg1, &block); end

  # The HTTP response code
  #
  # source://mechanize//lib/mechanize/parser.rb#55
  def code; end

  # The HTTP response code
  #
  # source://mechanize//lib/mechanize/parser.rb#55
  def code=(_arg0); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def each(*args, **_arg1, &block); end

  # Extracts the filename from a Content-Disposition header in the #response
  # or from the URI.  If +full_path+ is true the filename will include the
  # host name and path to the resource, otherwise a filename in the current
  # directory is given.
  #
  # source://mechanize//lib/mechanize/parser.rb#107
  def extract_filename(full_path = T.unsafe(nil)); end

  # Creates a Mechanize::Header from the Net::HTTPResponse +response+.
  #
  # This allows the Net::HTTPResponse to be garbage collected sooner.
  #
  # source://mechanize//lib/mechanize/parser.rb#156
  def fill_header(response); end

  # Finds a free filename based on +filename+, but is not race-free
  #
  # source://mechanize//lib/mechanize/parser.rb#169
  def find_free_name(filename); end

  # :method: each
  #
  # Enumerate HTTP headers in capitalized (canonical) form
  def header; end

  # source://forwardable/1.3.3/forwardable.rb#231
  def key?(*args, **_arg1, &block); end

  # The Mechanize::Headers for this file
  #
  # source://mechanize//lib/mechanize/parser.rb#48
  def response; end

  # The Mechanize::Headers for this file
  #
  # source://mechanize//lib/mechanize/parser.rb#48
  def response=(_arg0); end

  # The URI this file was retrieved from
  #
  # source://mechanize//lib/mechanize/parser.rb#43
  def uri; end

  # The URI this file was retrieved from
  #
  # source://mechanize//lib/mechanize/parser.rb#43
  def uri=(_arg0); end
end

# Special filenames that must be escaped
#
# source://mechanize//lib/mechanize/parser.rb#38
Mechanize::Parser::SPECIAL_FILENAMES = T.let(T.unsafe(nil), Regexp)

# Mechanize allows different parsers for different content types.  Mechanize
# uses PluggableParser to determine which parser to use for any content type.
# To use your own parser or to change the default parsers, register them with
# this class through Mechanize#pluggable_parser.
#
# The default parser for unregistered content types is Mechanize::File.
#
# The module Mechanize::Parser provides basic functionality for any content
# type, so you may use it in custom parsers you write.  For small files you
# wish to perform in-memory operations on, you should subclass
# Mechanize::File.  For large files you should subclass Mechanize::Download as
# the content is only loaded into memory in small chunks.
#
# When writing your own pluggable parser, be sure to provide a method #body
# that returns a String containing the response body for compatibility with
# Mechanize#get_file.
#
# == Example
#
# To create your own parser, just create a class that takes four parameters in
# the constructor.  Here is an example of registering a parser that handles
# CSV files:
#
#   require 'csv'
#
#   class CSVParser < Mechanize::File
#     attr_reader :csv
#
#     def initialize uri = nil, response = nil, body = nil, code = nil
#       super uri, response, body, code
#       @csv = CSV.parse body
#     end
#   end
#
#   agent = Mechanize.new
#   agent.pluggable_parser.csv = CSVParser
#   agent.get('http://example.com/test.csv')  # => CSVParser
#
# Now any response with a content type of 'text/csv' will initialize a
# CSVParser and return that object to the caller.
#
# To register a parser for a content type that Mechanize does not know about,
# use the hash syntax:
#
#   agent.pluggable_parser['text/something'] = SomeClass
#
# To set the default parser, use #default:
#
#   agent.pluggable_parser.default = Mechanize::Download
#
# Now all unknown content types will be saved to disk and not loaded into
# memory.
#
# source://mechanize//lib/mechanize/pluggable_parsers.rb#62
class Mechanize::PluggableParser
  # @return [PluggableParser] a new instance of PluggableParser
  #
  # source://mechanize//lib/mechanize/pluggable_parsers.rb#84
  def initialize; end

  # Retrieves the parser for +content_type+ content
  #
  # source://mechanize//lib/mechanize/pluggable_parsers.rb#165
  def [](content_type); end

  # Sets the parser for +content_type+ content to +klass+
  #
  # The +content_type+ may either be a full MIME type a simplified MIME type
  # ('text/x-csv' simplifies to 'text/csv') or a media type like 'image'.
  #
  # source://mechanize//lib/mechanize/pluggable_parsers.rb#175
  def []=(content_type, klass); end

  # Registers +klass+ as the parser for text/csv content
  #
  # source://mechanize//lib/mechanize/pluggable_parsers.rb#149
  def csv=(klass); end

  # Returns the value of attribute default.
  #
  # source://mechanize//lib/mechanize/pluggable_parsers.rb#82
  def default; end

  # Sets the attribute default
  #
  # @param value the value to set the attribute default to.
  #
  # source://mechanize//lib/mechanize/pluggable_parsers.rb#82
  def default=(_arg0); end

  # Registers +klass+ as the parser for text/html and application/xhtml+xml
  # content
  #
  # source://mechanize//lib/mechanize/pluggable_parsers.rb#127
  def html=(klass); end

  # Returns the parser registered for the given +content_type+
  #
  # source://mechanize//lib/mechanize/pluggable_parsers.rb#100
  def parser(content_type); end

  # Registers +klass+ as the parser for application/pdf content
  #
  # source://mechanize//lib/mechanize/pluggable_parsers.rb#142
  def pdf=(klass); end

  # source://mechanize//lib/mechanize/pluggable_parsers.rb#119
  def register_parser(content_type, klass); end

  # Registers +klass+ as the parser for application/xhtml+xml content
  #
  # source://mechanize//lib/mechanize/pluggable_parsers.rb#135
  def xhtml=(klass); end

  # Registers +klass+ as the parser for text/xml content
  #
  # source://mechanize//lib/mechanize/pluggable_parsers.rb#156
  def xml=(klass); end
end

# source://mechanize//lib/mechanize/pluggable_parsers.rb#64
Mechanize::PluggableParser::CONTENT_TYPES = T.let(T.unsafe(nil), Hash)

# source://mechanize//lib/mechanize/pluggable_parsers.rb#73
Mechanize::PluggableParser::InvalidContentTypeError = MIME::Type::InvalidContentType

# Raised when too many redirects are sent
#
# source://mechanize//lib/mechanize/redirect_limit_reached_error.rb#5
class Mechanize::RedirectLimitReachedError < ::Mechanize::Error
  # @return [RedirectLimitReachedError] a new instance of RedirectLimitReachedError
  #
  # source://mechanize//lib/mechanize/redirect_limit_reached_error.rb#11
  def initialize(page, redirects); end

  # Returns the value of attribute page.
  #
  # source://mechanize//lib/mechanize/redirect_limit_reached_error.rb#7
  def page; end

  # Returns the value of attribute redirects.
  #
  # source://mechanize//lib/mechanize/redirect_limit_reached_error.rb#8
  def redirects; end

  # Returns the value of attribute response_code.
  #
  # source://mechanize//lib/mechanize/redirect_limit_reached_error.rb#9
  def response_code; end
end

# Raised when a POST, PUT, or DELETE request results in a redirect
# see RFC 2616 10.3.2, 10.3.3 http://www.ietf.org/rfc/rfc2616.txt
#
# source://mechanize//lib/mechanize/redirect_not_get_or_head_error.rb#6
class Mechanize::RedirectNotGetOrHeadError < ::Mechanize::Error
  # @return [RedirectNotGetOrHeadError] a new instance of RedirectNotGetOrHeadError
  #
  # source://mechanize//lib/mechanize/redirect_not_get_or_head_error.rb#8
  def initialize(page, verb); end

  # source://mechanize//lib/mechanize/redirect_not_get_or_head_error.rb#15
  def inspect; end

  # Returns the value of attribute page.
  #
  # source://mechanize//lib/mechanize/redirect_not_get_or_head_error.rb#7
  def page; end

  # Returns the value of attribute response_code.
  #
  # source://mechanize//lib/mechanize/redirect_not_get_or_head_error.rb#7
  def response_code; end

  # source://mechanize//lib/mechanize/redirect_not_get_or_head_error.rb#15
  def to_s; end

  # Returns the value of attribute uri.
  #
  # source://mechanize//lib/mechanize/redirect_not_get_or_head_error.rb#7
  def uri; end

  # Returns the value of attribute verb.
  #
  # source://mechanize//lib/mechanize/redirect_not_get_or_head_error.rb#7
  def verb; end
end

# This error is raised when Mechanize encounters a response code it does not
# know how to handle.  Currently, this exception will be thrown if Mechanize
# encounters response codes other than 200, 301, or 302.  Any other response
# code is up to the user to handle.
#
# source://mechanize//lib/mechanize/response_code_error.rb#7
class Mechanize::ResponseCodeError < ::Mechanize::Error
  # @return [ResponseCodeError] a new instance of ResponseCodeError
  #
  # source://mechanize//lib/mechanize/response_code_error.rb#11
  def initialize(page, message = T.unsafe(nil)); end

  # source://mechanize//lib/mechanize/response_code_error.rb#18
  def inspect; end

  # Returns the value of attribute page.
  #
  # source://mechanize//lib/mechanize/response_code_error.rb#9
  def page; end

  # Returns the value of attribute response_code.
  #
  # source://mechanize//lib/mechanize/response_code_error.rb#8
  def response_code; end

  # source://mechanize//lib/mechanize/response_code_error.rb#18
  def to_s; end
end

# Raised when Mechanize encounters an error while reading the response body
# from the server.  Contains the response headers and the response body up to
# the error along with the initial error.
#
# source://mechanize//lib/mechanize/response_read_error.rb#7
class Mechanize::ResponseReadError < ::Mechanize::Error
  # Creates a new ResponseReadError with the +error+ raised, the +response+
  # and the +body_io+ for content read so far.
  #
  # @return [ResponseReadError] a new instance of ResponseReadError
  #
  # source://mechanize//lib/mechanize/response_read_error.rb#19
  def initialize(error, response, body_io, uri, mechanize); end

  # Returns the value of attribute body_io.
  #
  # source://mechanize//lib/mechanize/response_read_error.rb#9
  def body_io; end

  # Returns the value of attribute error.
  #
  # source://mechanize//lib/mechanize/response_read_error.rb#10
  def error; end

  # Converts this error into a Page, File, etc. based on the content-type
  #
  # source://mechanize//lib/mechanize/response_read_error.rb#30
  def force_parse; end

  # Returns the value of attribute mechanize.
  #
  # source://mechanize//lib/mechanize/response_read_error.rb#11
  def mechanize; end

  # source://mechanize//lib/mechanize/response_read_error.rb#34
  def message; end

  # Returns the value of attribute response.
  #
  # source://mechanize//lib/mechanize/response_read_error.rb#12
  def response; end

  # Returns the value of attribute uri.
  #
  # source://mechanize//lib/mechanize/response_read_error.rb#13
  def uri; end
end

# Exception that is raised when an access to a resource is disallowed by
# robots.txt or by HTML document itself.
#
# source://mechanize//lib/mechanize/robots_disallowed_error.rb#5
class Mechanize::RobotsDisallowedError < ::Mechanize::Error
  # @return [RobotsDisallowedError] a new instance of RobotsDisallowedError
  #
  # source://mechanize//lib/mechanize/robots_disallowed_error.rb#6
  def initialize(url); end

  # source://mechanize//lib/mechanize/robots_disallowed_error.rb#25
  def inspect; end

  # source://mechanize//lib/mechanize/robots_disallowed_error.rb#25
  def to_s; end

  # Returns the URL (URI object) of the resource that caused this
  # error.  URI::InvalidURIError may be raised if the URL happens to
  # be invalid or not understood by the URI library.
  #
  # source://mechanize//lib/mechanize/robots_disallowed_error.rb#21
  def uri; end

  # Returns the URL (string) of the resource that caused this error.
  #
  # source://mechanize//lib/mechanize/robots_disallowed_error.rb#16
  def url; end
end

# source://mechanize//lib/mechanize/unauthorized_error.rb#2
class Mechanize::UnauthorizedError < ::Mechanize::ResponseCodeError
  # @return [UnauthorizedError] a new instance of UnauthorizedError
  #
  # source://mechanize//lib/mechanize/unauthorized_error.rb#6
  def initialize(page, challenges, message); end

  # Returns the value of attribute challenges.
  #
  # source://mechanize//lib/mechanize/unauthorized_error.rb#4
  def challenges; end

  # source://mechanize//lib/mechanize/unauthorized_error.rb#11
  def to_s; end
end

# source://mechanize//lib/mechanize/unsupported_scheme_error.rb#2
class Mechanize::UnsupportedSchemeError < ::Mechanize::Error
  # @return [UnsupportedSchemeError] a new instance of UnsupportedSchemeError
  #
  # source://mechanize//lib/mechanize/unsupported_scheme_error.rb#5
  def initialize(scheme, uri); end

  # Returns the value of attribute scheme.
  #
  # source://mechanize//lib/mechanize/unsupported_scheme_error.rb#3
  def scheme; end

  # Sets the attribute scheme
  #
  # @param value the value to set the attribute scheme to.
  #
  # source://mechanize//lib/mechanize/unsupported_scheme_error.rb#3
  def scheme=(_arg0); end

  # Returns the value of attribute uri.
  #
  # source://mechanize//lib/mechanize/unsupported_scheme_error.rb#3
  def uri; end

  # Sets the attribute uri
  #
  # @param value the value to set the attribute uri to.
  #
  # source://mechanize//lib/mechanize/unsupported_scheme_error.rb#3
  def uri=(_arg0); end
end

# source://mechanize//lib/mechanize/util.rb#5
class Mechanize::Util
  class << self
    # Builds a query string from a given enumerable object
    # +parameters+.  This method uses Mechanize::Util.each_parameter
    # as preprocessor, which see.
    #
    # source://mechanize//lib/mechanize/util.rb#16
    def build_query_string(parameters, enc = T.unsafe(nil)); end

    # source://mechanize//lib/mechanize/util.rb#128
    def detect_charset(src); end

    # Parses an enumerable object +parameters+ and iterates over the
    # key-value pairs it contains.
    #
    # +parameters+ may be a hash, or any enumerable object which
    # iterates over [key, value] pairs, typically an array of arrays.
    #
    # If a key is paired with an array-like object, the pair is
    # expanded into multiple occurrences of the key, one for each
    # element of the array.  e.g. { a: [1, 2] } => [:a, 1], [:a, 2]
    #
    # If a key is paired with a hash-like object, the pair is expanded
    # into hash-like multiple pairs, one for each pair of the hash.
    # e.g. { a: { x: 1, y: 2 } } => ['a[x]', 1], ['a[y]', 2]
    #
    # An array-like value is allowed to be specified as hash value.
    # e.g. { a: { q: [1, 2] } } => ['a[q]', 1], ['a[q]', 2]
    #
    # For a non-array-like, non-hash-like value, the key-value pair is
    # yielded as is.
    #
    # source://mechanize//lib/mechanize/util.rb#42
    def each_parameter(parameters, &block); end

    # Converts string +s+ from +code+ to UTF-8.
    #
    # source://mechanize//lib/mechanize/util.rb#73
    def from_native_charset(s, code, ignore_encoding_error = T.unsafe(nil), log = T.unsafe(nil)); end

    # source://mechanize//lib/mechanize/util.rb#105
    def guess_encoding(src); end

    # source://mechanize//lib/mechanize/util.rb#89
    def html_unescape(s); end

    # source://mechanize//lib/mechanize/util.rb#136
    def uri_escape(str, unsafe = T.unsafe(nil)); end

    # source://mechanize//lib/mechanize/util.rb#152
    def uri_unescape(str); end

    private

    # source://mechanize//lib/mechanize/util.rb#52
    def each_parameter_1(key, value, &block); end
  end
end

# default mime type data for Page::Image#mime_type.
# You can use another Apache-compatible mimetab.
#   mimetab = WEBrick::HTTPUtils.load_mime_types('/etc/mime.types')
#   Mechanize::Util::DefaultMimeTypes.replace(mimetab)
#
# source://mechanize//lib/mechanize/util.rb#10
Mechanize::Util::DefaultMimeTypes = T.let(T.unsafe(nil), Hash)

# source://mechanize//lib/mechanize/version.rb#3
Mechanize::VERSION = T.let(T.unsafe(nil), String)

# This class encapsulates an XML file. If Mechanize finds a content-type
# of 'text/xml' or 'application/xml' this class will be instantiated and
# returned. This class also opens up the +search+ and +at+ methods available
# on the underlying Nokogiri::XML::Document object.
#
# Example:
#
#   require 'mechanize'
#
#   agent = Mechanize.new
#   xml = agent.get('http://example.org/some-xml-file.xml')
#   xml.class #=> Mechanize::XmlFile
#   xml.search('//foo[@attr="bar"]/etc')
#
# source://mechanize//lib/mechanize/xml_file.rb#17
class Mechanize::XmlFile < ::Mechanize::File
  extend ::Forwardable

  # @return [XmlFile] a new instance of XmlFile
  #
  # source://mechanize//lib/mechanize/xml_file.rb#24
  def initialize(uri = T.unsafe(nil), response = T.unsafe(nil), body = T.unsafe(nil), code = T.unsafe(nil)); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def at(*args, **_arg1, &block); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def search(*args, **_arg1, &block); end

  # :method: at
  #
  # Search through the page for +path+ under +namespace+ using Nokogiri's #at.
  # The +path+ may be either a CSS or XPath expression.
  #
  # See also Nokogiri::XML::Node#at
  #
  # source://mechanize//lib/mechanize/xml_file.rb#22
  def xml; end
end
