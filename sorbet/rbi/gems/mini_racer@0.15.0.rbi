# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `mini_racer` gem.
# Please instead update this file by running `bin/tapioca gem mini_racer`.


# source://mini_racer//lib/mini_racer/version.rb#3
module MiniRacer; end

# eval is defined in the C class
#
# source://mini_racer//lib/mini_racer.rb#125
class MiniRacer::Context
  # @return [Context] a new instance of Context
  #
  # source://mini_racer//lib/mini_racer.rb#160
  def initialize(max_memory: T.unsafe(nil), timeout: T.unsafe(nil), isolate: T.unsafe(nil), ensure_gc_after_idle: T.unsafe(nil), snapshot: T.unsafe(nil), marshal_stack_depth: T.unsafe(nil)); end

  # @raise [ContextDisposedError]
  #
  # source://mini_racer//lib/mini_racer.rb#270
  def attach(name, callback); end

  # source://mini_racer//lib/mini_racer.rb#245
  def call(function_name, *arguments); end

  # source://mini_racer//lib/mini_racer.rb#259
  def dispose; end

  def dispose_unsafe; end

  # source://mini_racer//lib/mini_racer.rb#228
  def eval(str, options = T.unsafe(nil)); end

  def heap_stats; end

  # source://mini_racer//lib/mini_racer.rb#195
  def isolate; end

  # source://mini_racer//lib/mini_racer.rb#201
  def load(filename); end

  def stop; end

  # source://mini_racer//lib/mini_racer.rb#206
  def write_heap_snapshot(file_or_io); end

  def write_heap_snapshot_unsafe(_arg0); end

  private

  # source://mini_racer//lib/mini_racer.rb#412
  def assert_numeric_or_nil(option_name, object, min_value:, max_value: T.unsafe(nil)); end

  # source://mini_racer//lib/mini_racer.rb#426
  def assert_option_is_nil_or_a(option_name, object, klass); end

  def call_unsafe(*_arg0); end

  # source://mini_racer//lib/mini_racer.rb#398
  def check_init_options!(isolate:, snapshot:, max_memory:, marshal_stack_depth:, ensure_gc_after_idle:, timeout:); end

  def create_isolate_value; end

  # source://mini_racer//lib/mini_racer.rb#315
  def ensure_gc_thread; end

  def eval_unsafe(_arg0, _arg1); end
  def init_unsafe(_arg0, _arg1); end
  def isolate_mutex; end

  # source://mini_racer//lib/mini_racer.rb#348
  def stop_attached; end

  # source://mini_racer//lib/mini_racer.rb#357
  def timeout(&blk); end
end

# source://mini_racer//lib/mini_racer.rb#127
class MiniRacer::Context::ExternalFunction
  # @return [ExternalFunction] a new instance of ExternalFunction
  #
  # source://mini_racer//lib/mini_racer.rb#128
  def initialize(name, callback, parent); end

  private

  def notify_v8; end
end

# source://mini_racer//lib/mini_racer.rb#37
class MiniRacer::ContextDisposedError < ::MiniRacer::Error; end

# source://mini_racer//lib/mini_racer.rb#35
class MiniRacer::Error < ::StandardError; end

# source://mini_racer//lib/mini_racer.rb#41
class MiniRacer::EvalError < ::MiniRacer::Error; end

# source://mini_racer//lib/mini_racer.rb#46
class MiniRacer::FailedV8Conversion
  # @return [FailedV8Conversion] a new instance of FailedV8Conversion
  #
  # source://mini_racer//lib/mini_racer.rb#48
  def initialize(info); end

  # Returns the value of attribute info.
  #
  # source://mini_racer//lib/mini_racer.rb#47
  def info; end
end

# source://mini_racer//lib/mini_racer.rb#83
class MiniRacer::Isolate
  # @return [Isolate] a new instance of Isolate
  #
  # source://mini_racer//lib/mini_racer.rb#84
  def initialize(snapshot = T.unsafe(nil)); end

  def idle_notification(_arg0); end
  def low_memory_notification; end
  def pump_message_loop; end

  private

  def init_with_snapshot(_arg0); end
end

# helper class returned when we have a JavaScript function
#
# source://mini_racer//lib/mini_racer.rb#77
class MiniRacer::JavaScriptFunction
  # source://mini_racer//lib/mini_racer.rb#78
  def to_s; end
end

# source://mini_racer//lib/mini_racer/version.rb#5
MiniRacer::LIBV8_NODE_VERSION = T.let(T.unsafe(nil), String)

module MiniRacer::Loader
  class << self
    def load(_arg0); end
  end
end

# source://mini_racer//lib/mini_racer.rb#32
MiniRacer::MARSHAL_STACKDEPTH_DEFAULT = T.let(T.unsafe(nil), Integer)

# source://mini_racer//lib/mini_racer.rb#33
MiniRacer::MARSHAL_STACKDEPTH_MAX_VALUE = T.let(T.unsafe(nil), Integer)

# source://mini_racer//lib/mini_racer.rb#42
class MiniRacer::ParseError < ::MiniRacer::EvalError; end

# source://mini_racer//lib/mini_racer.rb#94
class MiniRacer::Platform
  class << self
    # @raise [TypeError]
    def set_flag_as_str!(_arg0); end

    # source://mini_racer//lib/mini_racer.rb#96
    def set_flags!(*args, **kwargs); end

    private

    # normalize flags to strings, and adds leading dashes if needed
    #
    # source://mini_racer//lib/mini_racer.rb#110
    def flag_to_string(flag); end

    # source://mini_racer//lib/mini_racer.rb#105
    def flags_to_strings(flags); end
  end
end

# source://mini_racer//lib/mini_racer.rb#39
class MiniRacer::PlatformAlreadyInitialized < ::MiniRacer::Error; end

# source://mini_racer//lib/mini_racer.rb#53
class MiniRacer::RuntimeError < ::MiniRacer::EvalError
  # @return [RuntimeError] a new instance of RuntimeError
  #
  # source://mini_racer//lib/mini_racer.rb#54
  def initialize(message); end

  # source://mini_racer//lib/mini_racer.rb#65
  def backtrace; end
end

# source://mini_racer//lib/mini_racer.rb#43
class MiniRacer::ScriptTerminatedError < ::MiniRacer::EvalError; end

# `size` and `warmup!` public methods are defined in the C class
#
# source://mini_racer//lib/mini_racer.rb#434
class MiniRacer::Snapshot
  # @return [Snapshot] a new instance of Snapshot
  #
  # source://mini_racer//lib/mini_racer.rb#435
  def initialize(str = T.unsafe(nil)); end

  def dump; end
  def size; end

  # source://mini_racer//lib/mini_racer.rb#450
  def warmup!(src); end

  # @raise [TypeError]
  def warmup_unsafe!(_arg0); end

  private

  # @raise [TypeError]
  def load(_arg0); end
end

# source://mini_racer//lib/mini_racer.rb#38
class MiniRacer::SnapshotError < ::MiniRacer::Error; end

# source://mini_racer//lib/mini_racer.rb#44
class MiniRacer::V8OutOfMemoryError < ::MiniRacer::EvalError; end

# source://mini_racer//lib/mini_racer/version.rb#4
MiniRacer::VERSION = T.let(T.unsafe(nil), String)
