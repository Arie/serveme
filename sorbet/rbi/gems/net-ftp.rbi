# This file is autogenerated. Do not edit it by hand. Regenerate it with:
#   srb rbi gems

# typed: false
#
# If you would like to make changes to this file, great! Please create the gem's shim here:
#
#   https://github.com/sorbet/sorbet-typed/new/master?filename=lib/net-ftp/all/net-ftp.rbi
#
# net-ftp-0.3.7

module Net
end
class Net::FTPError < StandardError
end
class Net::FTPReplyError < Net::FTPError
end
class Net::FTPTempError < Net::FTPError
end
class Net::FTPPermError < Net::FTPError
end
class Net::FTPProtoError < Net::FTPError
end
class Net::FTPConnectionError < Net::FTPError
end
class Net::FTP < Net::Protocol
  def abort; end
  def acct(account); end
  def binary; end
  def binary=(newmode); end
  def chdir(dirname); end
  def close; end
  def closed?; end
  def connect(host, port = nil); end
  def debug_mode; end
  def debug_mode=(arg0); end
  def debug_output; end
  def debug_output=(arg0); end
  def debug_print(msg); end
  def delete(filename); end
  def dir(*args, &block); end
  def features; end
  def get(remotefile, localfile = nil, blocksize = nil, &block); end
  def get_body(resp); end
  def getbinaryfile(remotefile, localfile = nil, blocksize = nil, &block); end
  def getdir; end
  def getline; end
  def getmultiline; end
  def getresp; end
  def gettextfile(remotefile, localfile = nil, &block); end
  def help(arg = nil); end
  def initialize(host = nil, user_or_options = nil, passwd = nil, acct = nil); end
  def last_response; end
  def last_response_code; end
  def lastresp; end
  def list(*args, &block); end
  def literal(arguments); end
  def login(user = nil, passwd = nil, acct = nil); end
  def ls(*args, &block); end
  def makepasv; end
  def makeport; end
  def mdtm(filename); end
  def mkdir(dirname); end
  def mlsd(pathname = nil, &block); end
  def mlst(pathname = nil); end
  def mtime(filename, local = nil); end
  def nlst(dir = nil); end
  def noop; end
  def open_socket(host, port); end
  def open_timeout; end
  def open_timeout=(arg0); end
  def option(name, params = nil); end
  def parse227(resp); end
  def parse229(resp); end
  def parse257(resp); end
  def parse_mlsx_entry(entry); end
  def parse_pasv_ipv4_host(s); end
  def parse_pasv_ipv6_host(s); end
  def parse_pasv_port(s); end
  def passive; end
  def passive=(arg0); end
  def put(localfile, remotefile = nil, blocksize = nil, &block); end
  def putbinaryfile(localfile, remotefile = nil, blocksize = nil, &block); end
  def putline(line); end
  def puttextfile(localfile, remotefile = nil, &block); end
  def pwd; end
  def quit; end
  def quote(arguments); end
  def read_timeout; end
  def read_timeout=(sec); end
  def rename(fromname, toname); end
  def resume; end
  def resume=(arg0); end
  def retrbinary(cmd, blocksize, rest_offset = nil); end
  def retrlines(cmd); end
  def return_code; end
  def return_code=(s); end
  def rmdir(dirname); end
  def sanitize(s); end
  def self.default_passive; end
  def self.default_passive=(value); end
  def self.open(host, *args); end
  def send_type_command; end
  def sendcmd(cmd); end
  def sendport(host, port); end
  def set_socket(sock, get_greeting = nil); end
  def site(arg); end
  def size(filename); end
  def ssl_handshake_timeout; end
  def ssl_handshake_timeout=(arg0); end
  def start_tls_session(sock); end
  def status(pathname = nil); end
  def storbinary(cmd, file, blocksize, rest_offset = nil); end
  def storlines(cmd, file); end
  def system; end
  def transfercmd(cmd, rest_offset = nil); end
  def use_pasv_ip; end
  def use_pasv_ip=(arg0); end
  def voidcmd(cmd); end
  def voidresp; end
  def welcome; end
  def with_binary(newmode); end
  include MonitorMixin
  include OpenSSL
  include OpenSSL::SSL
end
class Net::FTP::MLSxEntry
  def appendable?; end
  def charset; end
  def creatable?; end
  def create; end
  def deletable?; end
  def directory?; end
  def directory_makable?; end
  def enterable?; end
  def facts; end
  def file?; end
  def initialize(facts, pathname); end
  def lang; end
  def listable?; end
  def media_type; end
  def modify; end
  def pathname; end
  def perm; end
  def purgeable?; end
  def readable?; end
  def renamable?; end
  def size; end
  def type; end
  def unique; end
  def writable?; end
end
class Net::FTP::NullSocket
  def close; end
  def closed?; end
  def method_missing(mid, *args); end
  def read_timeout=(sec); end
end
class Net::FTP::BufferedSocket < Net::BufferedIO
  def addr(*args); end
  def gets; end
  def local_address(*args); end
  def peeraddr(*args); end
  def read(len = nil); end
  def readline; end
  def remote_address(*args); end
  def send(*args); end
  def shutdown(*args); end
end
class Net::FTP::BufferedSSLSocket < Net::FTP::BufferedSocket
  def initialize(*args, **options); end
  def rbuf_fill; end
  def send(mesg, flags, dest = nil); end
  def shutdown(*args); end
end
