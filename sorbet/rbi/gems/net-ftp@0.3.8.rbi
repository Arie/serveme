# typed: false

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `net-ftp` gem.
# Please instead update this file by running `bin/tapioca gem net-ftp`.


# This class implements the File Transfer Protocol.  If you have used a
# command-line FTP program, and are familiar with the commands, you will be
# able to use this class easily.  Some extra features are included to take
# advantage of Ruby's style and strengths.
#
# == Example
#
#   require 'net/ftp'
#
# === Example 1
#
#   ftp = Net::FTP.new('example.com')
#   ftp.login
#   files = ftp.chdir('pub/lang/ruby/contrib')
#   files = ftp.list('n*')
#   ftp.getbinaryfile('nif.rb-0.91.gz', 'nif.gz', 1024)
#   ftp.close
#
# === Example 2
#
#   Net::FTP.open('example.com') do |ftp|
#     ftp.login
#     files = ftp.chdir('pub/lang/ruby/contrib')
#     files = ftp.list('n*')
#     ftp.getbinaryfile('nif.rb-0.91.gz', 'nif.gz', 1024)
#   end
#
# == Major Methods
#
# The following are the methods most likely to be useful to users:
# - FTP.open
# - #getbinaryfile
# - #gettextfile
# - #putbinaryfile
# - #puttextfile
# - #chdir
# - #nlst
# - #size
# - #rename
# - #delete
#
# == Mainframe User Support
# - #literal
# - #quote
#
# source://net-ftp//lib/net/ftp.rb#84
class Net::FTP < ::Net::Protocol
  include ::MonitorMixin
  include ::OpenSSL
  include ::OpenSSL::SSL

  # :call-seq:
  #    Net::FTP.new(host = nil, options = {})
  #
  # Creates and returns a new +FTP+ object. If a +host+ is given, a connection
  # is made.
  #
  # +options+ is an option hash, each key of which is a symbol.
  #
  # The available options are:
  #
  # port::      Port number (default value is 21)
  # ssl::       If +options+[:ssl] is true, then an attempt will be made
  #             to use SSL (now TLS) to connect to the server.  For this
  #             to work OpenSSL [OSSL] and the Ruby OpenSSL [RSSL]
  #             extensions need to be installed.  If +options+[:ssl] is a
  #             hash, it's passed to OpenSSL::SSL::SSLContext#set_params
  #             as parameters.
  # private_data_connection::  If true, TLS is used for data connections.
  #                            Default: +true+ when +options+[:ssl] is true.
  # implicit_ftps::  If true, TLS is established on initial connection.
  #                  Default: +false+
  # username::  Username for login.  If +options+[:username] is the string
  #             "anonymous" and the +options+[:password] is +nil+,
  #             "anonymous@" is used as a password.
  # password::  Password for login.
  # account::   Account information for ACCT.
  # passive::   When +true+, the connection is in passive mode. Default:
  #             +true+.
  # open_timeout::  Number of seconds to wait for the connection to open.
  #                 See Net::FTP#open_timeout for details.  Default: +nil+.
  # read_timeout::  Number of seconds to wait for one block to be read.
  #                 See Net::FTP#read_timeout for details.  Default: +60+.
  # ssl_handshake_timeout::  Number of seconds to wait for the TLS
  #                          handshake.
  #                          See Net::FTP#ssl_handshake_timeout for
  #                          details.  Default: +nil+.
  # use_pasv_ip::  When +true+, use the IP address in PASV responses.
  #                Otherwise, it uses the same IP address for the control
  #                connection.  Default: +false+.
  # debug_mode::  When +true+, all traffic to and from the server is
  #               written to +$stdout+.  Default: +false+.
  #
  # @return [FTP] a new instance of FTP
  #
  # source://net-ftp//lib/net/ftp.rb#230
  def initialize(host = T.unsafe(nil), user_or_options = T.unsafe(nil), passwd = T.unsafe(nil), acct = T.unsafe(nil)); end

  # Aborts the previous command (ABOR command).
  #
  # source://net-ftp//lib/net/ftp.rb#1283
  def abort; end

  # Sends the ACCT command.
  #
  # This is a less common FTP command, to send account
  # information if the destination host requires it.
  #
  # source://net-ftp//lib/net/ftp.rb#925
  def acct(account); end

  # When +true+, transfers are performed in binary mode.  Default: +true+.
  #
  # source://net-ftp//lib/net/ftp.rb#100
  def binary; end

  # A setter to toggle transfers in binary mode.
  # +newmode+ is either +true+ or +false+
  #
  # source://net-ftp//lib/net/ftp.rb#314
  def binary=(newmode); end

  # Changes the (remote) directory.
  #
  # source://net-ftp//lib/net/ftp.rb#1194
  def chdir(dirname); end

  # Closes the connection.  Further operations are impossible until you open
  # a new connection with #connect.
  #
  # source://net-ftp//lib/net/ftp.rb#1397
  def close; end

  # Returns +true+ if and only if the connection is closed.
  #
  # @return [Boolean]
  #
  # source://net-ftp//lib/net/ftp.rb#1413
  def closed?; end

  # Establishes an FTP connection to host, optionally overriding the default
  # port. If the environment variable +SOCKS_SERVER+ is set, sets up the
  # connection through a SOCKS proxy. Raises an exception (typically
  # <tt>Errno::ECONNREFUSED</tt>) if the connection cannot be established.
  #
  # source://net-ftp//lib/net/ftp.rb#402
  def connect(host, port = T.unsafe(nil)); end

  # When +true+, all traffic to and from the server is written
  # to +$stdout+.  Default: +false+.
  #
  # source://net-ftp//lib/net/ftp.rb#111
  def debug_mode; end

  # When +true+, all traffic to and from the server is written
  # to +$stdout+.  Default: +false+.
  #
  # source://net-ftp//lib/net/ftp.rb#111
  def debug_mode=(_arg0); end

  # Sets or retrieves the output stream for debugging.
  # Output stream will be used only when +debug_mode+ is set to true.
  # The default value is +$stdout+.
  #
  # source://net-ftp//lib/net/ftp.rb#116
  def debug_output; end

  # Sets or retrieves the output stream for debugging.
  # Output stream will be used only when +debug_mode+ is set to true.
  # The default value is +$stdout+.
  #
  # source://net-ftp//lib/net/ftp.rb#116
  def debug_output=(_arg0); end

  # Writes debug message to the debug output stream
  #
  # source://net-ftp//lib/net/ftp.rb#1488
  def debug_print(msg); end

  # Deletes a file on the server.
  #
  # source://net-ftp//lib/net/ftp.rb#1180
  def delete(filename); end

  # Returns an array of file information in the directory (the output is like
  # `ls -l`).  If a block is given, it iterates through the listing.
  #
  # source://net-ftp//lib/net/ftp.rb#949
  def dir(*args, &block); end

  # Issues a FEAT command
  #
  # Returns an array of supported optional features
  #
  # source://net-ftp//lib/net/ftp.rb#1363
  def features; end

  # Retrieves +remotefile+ in whatever mode the session is set (text or
  # binary).  See #gettextfile and #getbinaryfile.
  #
  # source://net-ftp//lib/net/ftp.rb#849
  def get(remotefile, localfile = T.unsafe(nil), blocksize = T.unsafe(nil), &block); end

  # Retrieves +remotefile+ in binary mode, storing the result in +localfile+.
  # If +localfile+ is nil, returns retrieved data.
  # If a block is supplied, it is passed the retrieved data in +blocksize+
  # chunks.
  #
  # source://net-ftp//lib/net/ftp.rb#788
  def getbinaryfile(remotefile, localfile = T.unsafe(nil), blocksize = T.unsafe(nil), &block); end

  # Returns the current remote directory.
  #
  # source://net-ftp//lib/net/ftp.rb#1263
  def getdir; end

  # Retrieves +remotefile+ in ASCII (text) mode, storing the result in
  # +localfile+.
  # If +localfile+ is nil, returns retrieved data.
  # If a block is supplied, it is passed the retrieved data one
  # line at a time.
  #
  # source://net-ftp//lib/net/ftp.rb#823
  def gettextfile(remotefile, localfile = T.unsafe(nil), &block); end

  # Issues the HELP command.
  #
  # source://net-ftp//lib/net/ftp.rb#1326
  def help(arg = T.unsafe(nil)); end

  # The server's last response.
  #
  # source://net-ftp//lib/net/ftp.rb#155
  def last_response; end

  # The server's last response code.
  #
  # source://net-ftp//lib/net/ftp.rb#151
  def last_response_code; end

  # The server's last response code.
  #
  # source://net-ftp//lib/net/ftp.rb#151
  def lastresp; end

  # Returns an array of file information in the directory (the output is like
  # `ls -l`).  If a block is given, it iterates through the listing.
  #
  # source://net-ftp//lib/net/ftp.rb#949
  def list(*args, &block); end

  # The "quote" subcommand sends arguments verbatim to the remote ftp server.
  # The "literal" subcommand is an alias for "quote".
  #
  # @param arguments Array[String] to be sent verbatim to the remote ftp server
  #
  # source://net-ftp//lib/net/ftp.rb#1248
  def literal(arguments); end

  # Logs in to the remote host.  The session must have been
  # previously connected.  If +user+ is the string "anonymous" and
  # the +password+ is +nil+, "anonymous@" is used as a password.  If
  # the +acct+ parameter is not +nil+, an FTP ACCT command is sent
  # following the successful login.  Raises an exception on error
  # (typically <tt>Net::FTPPermError</tt>).
  #
  # source://net-ftp//lib/net/ftp.rb#635
  def login(user = T.unsafe(nil), passwd = T.unsafe(nil), acct = T.unsafe(nil)); end

  # Returns an array of file information in the directory (the output is like
  # `ls -l`).  If a block is given, it iterates through the listing.
  #
  # source://net-ftp//lib/net/ftp.rb#949
  def ls(*args, &block); end

  # Returns the raw last modification time of the (remote) file in the format
  # "YYYYMMDDhhmmss" (MDTM command).
  #
  # Use +mtime+ if you want a parsed Time instance.
  #
  # source://net-ftp//lib/net/ftp.rb#1316
  def mdtm(filename); end

  # Creates a remote directory.
  #
  # source://net-ftp//lib/net/ftp.rb#1238
  def mkdir(dirname); end

  # Returns an array of the entries of the directory specified by
  # +pathname+.
  # Each entry has the facts (e.g., size, last modification time, etc.)
  # and the pathname.
  # If a block is given, it iterates through the listing.
  # If +pathname+ is omitted, the current directory is assumed.
  #
  # source://net-ftp//lib/net/ftp.rb#1154
  def mlsd(pathname = T.unsafe(nil), &block); end

  # Returns data (e.g., size, last modification time, entry type, etc.)
  # about the file or directory specified by +pathname+.
  # If +pathname+ is omitted, the current directory is assumed.
  #
  # source://net-ftp//lib/net/ftp.rb#1132
  def mlst(pathname = T.unsafe(nil)); end

  # Returns the last modification time of the (remote) file.  If +local+ is
  # +true+, it is returned as a local time, otherwise it's a UTC time.
  #
  # source://net-ftp//lib/net/ftp.rb#1231
  def mtime(filename, local = T.unsafe(nil)); end

  # Returns an array of filenames in the remote directory.
  #
  # source://net-ftp//lib/net/ftp.rb#933
  def nlst(dir = T.unsafe(nil)); end

  # Issues a NOOP command.
  #
  # Does nothing except return a response.
  #
  # source://net-ftp//lib/net/ftp.rb#1346
  def noop; end

  # Number of seconds to wait for the connection to open. Any number
  # may be used, including Floats for fractional seconds. If the FTP
  # object cannot open a connection in this many seconds, it raises a
  # Net::OpenTimeout exception. The default value is +nil+.
  #
  # source://net-ftp//lib/net/ftp.rb#126
  def open_timeout; end

  # Number of seconds to wait for the connection to open. Any number
  # may be used, including Floats for fractional seconds. If the FTP
  # object cannot open a connection in this many seconds, it raises a
  # Net::OpenTimeout exception. The default value is +nil+.
  #
  # source://net-ftp//lib/net/ftp.rb#126
  def open_timeout=(_arg0); end

  # Issues an OPTS command
  # - name Should be the name of the option to set
  # - params is any optional parameters to supply with the option
  #
  # example: option('UTF8', 'ON') => 'OPTS UTF8 ON'
  #
  # source://net-ftp//lib/net/ftp.rb#1386
  def option(name, params = T.unsafe(nil)); end

  # When +true+, the connection is in passive mode.  Default: +true+.
  #
  # source://net-ftp//lib/net/ftp.rb#103
  def passive; end

  # When +true+, the connection is in passive mode.  Default: +true+.
  #
  # source://net-ftp//lib/net/ftp.rb#103
  def passive=(_arg0); end

  # Transfers +localfile+ to the server in whatever mode the session is set
  # (text or binary).  See #puttextfile and #putbinaryfile.
  #
  # source://net-ftp//lib/net/ftp.rb#910
  def put(localfile, remotefile = T.unsafe(nil), blocksize = T.unsafe(nil), &block); end

  # Transfers +localfile+ to the server in binary mode, storing the result in
  # +remotefile+. If a block is supplied, calls it, passing in the transmitted
  # data in +blocksize+ chunks.
  #
  # source://net-ftp//lib/net/ftp.rb#863
  def putbinaryfile(localfile, remotefile = T.unsafe(nil), blocksize = T.unsafe(nil), &block); end

  # Transfers +localfile+ to the server in ASCII (text) mode, storing the result
  # in +remotefile+. If callback or an associated block is supplied, calls it,
  # passing in the transmitted data one line at a time.
  #
  # Returns the response which will contain a job number if the user was communicating with a mainframe in ASCII mode
  # after issuing 'quote site filetype=jes'
  #
  # source://net-ftp//lib/net/ftp.rb#895
  def puttextfile(localfile, remotefile = T.unsafe(nil), &block); end

  # Returns the current remote directory.
  #
  # source://net-ftp//lib/net/ftp.rb#1263
  def pwd; end

  # Exits the FTP session.
  #
  # source://net-ftp//lib/net/ftp.rb#1337
  def quit; end

  # The "quote" subcommand sends arguments verbatim to the remote ftp server.
  # The "literal" subcommand is an alias for "quote".
  #
  # @param arguments Array[String] to be sent verbatim to the remote ftp server
  #
  # source://net-ftp//lib/net/ftp.rb#1248
  def quote(arguments); end

  # Number of seconds to wait for one block to be read (via one read(2)
  # call). Any number may be used, including Floats for fractional
  # seconds. If the FTP object cannot read data in this many seconds,
  # it raises a Timeout::Error exception. The default value is 60 seconds.
  #
  # source://net-ftp//lib/net/ftp.rb#139
  def read_timeout; end

  # Setter for the read_timeout attribute.
  #
  # source://net-ftp//lib/net/ftp.rb#142
  def read_timeout=(sec); end

  # Renames a file on the server.
  #
  # source://net-ftp//lib/net/ftp.rb#1169
  def rename(fromname, toname); end

  # Sets or retrieves the +resume+ status, which decides whether incomplete
  # transfers are resumed or restarted.  Default: +false+.
  #
  # source://net-ftp//lib/net/ftp.rb#120
  def resume; end

  # Sets or retrieves the +resume+ status, which decides whether incomplete
  # transfers are resumed or restarted.  Default: +false+.
  #
  # source://net-ftp//lib/net/ftp.rb#120
  def resume=(_arg0); end

  # Puts the connection into binary (image) mode, issues the given command,
  # and fetches the data returned, passing it to the associated block in
  # chunks of +blocksize+ characters. Note that +cmd+ is a server command
  # (such as "RETR myfile").
  #
  # source://net-ftp//lib/net/ftp.rb#666
  def retrbinary(cmd, blocksize, rest_offset = T.unsafe(nil)); end

  # Puts the connection into ASCII (text) mode, issues the given command, and
  # passes the resulting data, one line at a time, to the associated block. If
  # no block is given, prints the lines. Note that +cmd+ is a server command
  # (such as "RETR myfile").
  #
  # source://net-ftp//lib/net/ftp.rb#691
  def retrlines(cmd); end

  # Obsolete
  #
  # source://net-ftp//lib/net/ftp.rb#352
  def return_code; end

  # Obsolete
  #
  # source://net-ftp//lib/net/ftp.rb#358
  def return_code=(s); end

  # Removes a remote directory.
  #
  # source://net-ftp//lib/net/ftp.rb#1256
  def rmdir(dirname); end

  # Sends a command and returns the response.
  #
  # source://net-ftp//lib/net/ftp.rb#523
  def sendcmd(cmd); end

  # Set the socket used to connect to the FTP server.
  #
  # May raise FTPReplyError if +get_greeting+ is false.
  #
  # source://net-ftp//lib/net/ftp.rb#432
  def set_socket(sock, get_greeting = T.unsafe(nil)); end

  # Issues a SITE command.
  #
  # source://net-ftp//lib/net/ftp.rb#1353
  def site(arg); end

  # Returns the size of the given (remote) filename.
  #
  # source://net-ftp//lib/net/ftp.rb#1217
  def size(filename); end

  # Number of seconds to wait for the TLS handshake. Any number
  # may be used, including Floats for fractional seconds. If the FTP
  # object cannot complete the TLS handshake in this many seconds, it
  # raises a Net::OpenTimeout exception. The default value is +nil+.
  # If +ssl_handshake_timeout+ is +nil+, +open_timeout+ is used instead.
  #
  # source://net-ftp//lib/net/ftp.rb#133
  def ssl_handshake_timeout; end

  # Number of seconds to wait for the TLS handshake. Any number
  # may be used, including Floats for fractional seconds. If the FTP
  # object cannot complete the TLS handshake in this many seconds, it
  # raises a Net::OpenTimeout exception. The default value is +nil+.
  # If +ssl_handshake_timeout+ is +nil+, +open_timeout+ is used instead.
  #
  # source://net-ftp//lib/net/ftp.rb#133
  def ssl_handshake_timeout=(_arg0); end

  # Returns the status (STAT command).
  #
  # pathname:: when stat is invoked with pathname as a parameter it acts like
  #            list but a lot faster and over the same tcp session.
  #
  # source://net-ftp//lib/net/ftp.rb#1300
  def status(pathname = T.unsafe(nil)); end

  # Puts the connection into binary (image) mode, issues the given server-side
  # command (such as "STOR myfile"), and sends the contents of the file named
  # +file+ to the server. If the optional block is given, it also passes it
  # the data, in chunks of +blocksize+ characters.
  #
  # source://net-ftp//lib/net/ftp.rb#716
  def storbinary(cmd, file, blocksize, rest_offset = T.unsafe(nil)); end

  # Puts the connection into ASCII (text) mode, issues the given server-side
  # command (such as "STOR myfile"), and sends the contents of the file
  # named +file+ to the server, one line at a time. If the optional block is
  # given, it also passes it the lines.
  #
  # source://net-ftp//lib/net/ftp.rb#752
  def storlines(cmd, file); end

  # Returns system information.
  #
  # source://net-ftp//lib/net/ftp.rb#1272
  def system; end

  # When +true+, use the IP address in PASV responses.  Otherwise, it uses
  # the same IP address for the control connection.  Default: +false+.
  #
  # source://net-ftp//lib/net/ftp.rb#107
  def use_pasv_ip; end

  # When +true+, use the IP address in PASV responses.  Otherwise, it uses
  # the same IP address for the control connection.  Default: +false+.
  #
  # source://net-ftp//lib/net/ftp.rb#107
  def use_pasv_ip=(_arg0); end

  # Sends a command and expect a response beginning with '2'.
  #
  # source://net-ftp//lib/net/ftp.rb#533
  def voidcmd(cmd); end

  # The server's welcome message.
  #
  # source://net-ftp//lib/net/ftp.rb#148
  def welcome; end

  private

  # source://net-ftp//lib/net/ftp.rb#1209
  def get_body(resp); end

  # Reads a line from the sock.  If EOF, then it will raise EOFError
  #
  # source://net-ftp//lib/net/ftp.rb#465
  def getline; end

  # Receive a section of lines until the response code's match.
  #
  # source://net-ftp//lib/net/ftp.rb#474
  def getmultiline; end

  # Receives a response from the destination host.
  #
  # Returns the response code or raises FTPTempError, FTPPermError, or
  # FTPProtoError
  #
  # source://net-ftp//lib/net/ftp.rb#492
  def getresp; end

  # sends the appropriate command to enable a passive connection
  #
  # source://net-ftp//lib/net/ftp.rb#561
  def makepasv; end

  # Constructs a TCPServer socket
  #
  # source://net-ftp//lib/net/ftp.rb#555
  def makeport; end

  # Constructs a socket with +host+ and +port+.
  #
  # If SOCKSSocket is defined and the environment (ENV) defines
  # SOCKS_SERVER, then a SOCKSSocket is returned, else a Socket is
  # returned.
  #
  # source://net-ftp//lib/net/ftp.rb#367
  def open_socket(host, port); end

  # handler for response code 227
  # (Entering Passive Mode (h1,h2,h3,h4,p1,p2))
  #
  # Returns host and port.
  #
  # source://net-ftp//lib/net/ftp.rb#1421
  def parse227(resp); end

  # handler for response code 229
  # (Extended Passive Mode Entered)
  #
  # Returns host and port.
  #
  # source://net-ftp//lib/net/ftp.rb#1461
  def parse229(resp); end

  # handler for response code 257
  # ("PATHNAME" created)
  #
  # Returns host and port.
  #
  # source://net-ftp//lib/net/ftp.rb#1477
  def parse257(resp); end

  # source://net-ftp//lib/net/ftp.rb#1112
  def parse_mlsx_entry(entry); end

  # source://net-ftp//lib/net/ftp.rb#1438
  def parse_pasv_ipv4_host(s); end

  # source://net-ftp//lib/net/ftp.rb#1443
  def parse_pasv_ipv6_host(s); end

  # source://net-ftp//lib/net/ftp.rb#1450
  def parse_pasv_port(s); end

  # Ensures that +line+ has a control return / line feed (CRLF) and writes
  # it to the socket.
  #
  # source://net-ftp//lib/net/ftp.rb#454
  def putline(line); end

  # If string +s+ includes the PASS command (password), then the contents of
  # the password are cleaned from the string using "*"
  #
  # source://net-ftp//lib/net/ftp.rb#443
  def sanitize(s); end

  # Sends a command to destination host, with the current binary sendmode
  # type.
  #
  # If binary mode is +true+, then "TYPE I" (image) is sent, otherwise "TYPE
  # A" (ascii) is sent.
  #
  # source://net-ftp//lib/net/ftp.rb#326
  def send_type_command; end

  # Constructs and send the appropriate PORT (or EPRT) command
  #
  # source://net-ftp//lib/net/ftp.rb#541
  def sendport(host, port); end

  # source://net-ftp//lib/net/ftp.rb#379
  def start_tls_session(sock); end

  # Constructs a connection for transferring data
  #
  # source://net-ftp//lib/net/ftp.rb#572
  def transfercmd(cmd, rest_offset = T.unsafe(nil)); end

  # Receives a response.
  #
  # Raises FTPReplyError if the first position of the response code is not
  # equal 2.
  #
  # source://net-ftp//lib/net/ftp.rb#512
  def voidresp; end

  # Toggles transfers in binary mode and yields to a block.
  # This preserves your current binary send mode, but allows a temporary
  # transaction with binary sendmode of +newmode+.
  #
  # +newmode+ is either +true+ or +false+
  #
  # source://net-ftp//lib/net/ftp.rb#340
  def with_binary(newmode); end

  class << self
    # When +true+, connections are in passive mode per default.
    # Default: +true+.
    #
    # source://net-ftp//lib/net/ftp.rb#165
    def default_passive; end

    # When +true+, connections are in passive mode per default.
    # Default: +true+.
    #
    # source://net-ftp//lib/net/ftp.rb#159
    def default_passive=(value); end

    # A synonym for <tt>FTP.new</tt>, but with a mandatory host parameter.
    #
    # If a block is given, it is passed the +FTP+ object, which will be closed
    # when the block finishes, or when an exception is raised.
    #
    # source://net-ftp//lib/net/ftp.rb#175
    def open(host, *args); end
  end
end

# source://net-ftp//lib/net/ftp.rb#1545
class Net::FTP::BufferedSSLSocket < ::Net::FTP::BufferedSocket
  # @return [BufferedSSLSocket] a new instance of BufferedSSLSocket
  #
  # source://net-ftp//lib/net/ftp.rb#1546
  def initialize(*args, **options); end

  # source://net-ftp//lib/net/ftp.rb#1558
  def send(mesg, flags, dest = T.unsafe(nil)); end

  # source://net-ftp//lib/net/ftp.rb#1551
  def shutdown(*args); end

  private

  # source://net-ftp//lib/net/ftp.rb#1565
  def rbuf_fill; end
end

# source://net-ftp//lib/net/ftp.rb#1509
class Net::FTP::BufferedSocket < ::Net::BufferedIO
  # source://net-ftp//lib/net/ftp.rb#1511
  def addr(*args); end

  # source://net-ftp//lib/net/ftp.rb#1530
  def gets; end

  # source://net-ftp//lib/net/ftp.rb#1511
  def local_address(*args); end

  # source://net-ftp//lib/net/ftp.rb#1511
  def peeraddr(*args); end

  # source://net-ftp//lib/net/ftp.rb#1516
  def read(len = T.unsafe(nil)); end

  # source://net-ftp//lib/net/ftp.rb#1535
  def readline; end

  # source://net-ftp//lib/net/ftp.rb#1511
  def remote_address(*args); end

  # source://net-ftp//lib/net/ftp.rb#1511
  def send(*args); end

  # source://net-ftp//lib/net/ftp.rb#1511
  def shutdown(*args); end
end

# MLSxEntry represents an entry in responses of MLST/MLSD.
# Each entry has the facts (e.g., size, last modification time, etc.)
# and the pathname.
#
# source://net-ftp//lib/net/ftp.rb#971
class Net::FTP::MLSxEntry
  # @return [MLSxEntry] a new instance of MLSxEntry
  #
  # source://net-ftp//lib/net/ftp.rb#974
  def initialize(facts, pathname); end

  # Returns +true+ if the APPE command may be applied to the file.
  #
  # @return [Boolean]
  #
  # source://net-ftp//lib/net/ftp.rb#1010
  def appendable?; end

  # source://net-ftp//lib/net/ftp.rb#982
  def charset; end

  # Returns +true+ if files may be created in the directory by STOU,
  # STOR, APPE, and RNTO.
  #
  # @return [Boolean]
  #
  # source://net-ftp//lib/net/ftp.rb#1018
  def creatable?; end

  # source://net-ftp//lib/net/ftp.rb#982
  def create; end

  # Returns +true+ if the file or directory may be deleted by DELE/RMD.
  #
  # @return [Boolean]
  #
  # source://net-ftp//lib/net/ftp.rb#1025
  def deletable?; end

  # Returns +true+ if the entry is a directory (i.e., the value of the
  # type fact is dir, cdir, or pdir).
  #
  # @return [Boolean]
  #
  # source://net-ftp//lib/net/ftp.rb#999
  def directory?; end

  # Returns +true+ if the MKD command may be used to create a new
  # directory within the directory.
  #
  # @return [Boolean]
  #
  # source://net-ftp//lib/net/ftp.rb#1055
  def directory_makable?; end

  # Returns +true+ if the directory may be entered by CWD/CDUP.
  #
  # @return [Boolean]
  #
  # source://net-ftp//lib/net/ftp.rb#1032
  def enterable?; end

  # Returns the value of attribute facts.
  #
  # source://net-ftp//lib/net/ftp.rb#972
  def facts; end

  # Returns +true+ if the entry is a file (i.e., the value of the type
  # fact is file).
  #
  # @return [Boolean]
  #
  # source://net-ftp//lib/net/ftp.rb#991
  def file?; end

  # source://net-ftp//lib/net/ftp.rb#982
  def lang; end

  # Returns +true+ if the listing commands, LIST, NLST, and MLSD are
  # applied to the directory.
  #
  # @return [Boolean]
  #
  # source://net-ftp//lib/net/ftp.rb#1047
  def listable?; end

  # source://net-ftp//lib/net/ftp.rb#982
  def media_type; end

  # source://net-ftp//lib/net/ftp.rb#982
  def modify; end

  # Returns the value of attribute pathname.
  #
  # source://net-ftp//lib/net/ftp.rb#972
  def pathname; end

  # source://net-ftp//lib/net/ftp.rb#982
  def perm; end

  # Returns +true+ if the objects in the directory may be deleted, or
  # the directory may be purged.
  #
  # @return [Boolean]
  #
  # source://net-ftp//lib/net/ftp.rb#1063
  def purgeable?; end

  # Returns +true+ if the RETR command may be applied to the file.
  #
  # @return [Boolean]
  #
  # source://net-ftp//lib/net/ftp.rb#1070
  def readable?; end

  # Returns +true+ if the file or directory may be renamed by RNFR.
  #
  # @return [Boolean]
  #
  # source://net-ftp//lib/net/ftp.rb#1039
  def renamable?; end

  # source://net-ftp//lib/net/ftp.rb#982
  def size; end

  # source://net-ftp//lib/net/ftp.rb#982
  def type; end

  # source://net-ftp//lib/net/ftp.rb#982
  def unique; end

  # Returns +true+ if the STOR command may be applied to the file.
  #
  # @return [Boolean]
  #
  # source://net-ftp//lib/net/ftp.rb#1077
  def writable?; end
end

# :stopdoc:
#
# source://net-ftp//lib/net/ftp.rb#1493
class Net::FTP::NullSocket
  # source://net-ftp//lib/net/ftp.rb#1501
  def close; end

  # @return [Boolean]
  #
  # source://net-ftp//lib/net/ftp.rb#1497
  def closed?; end

  # @raise [FTPConnectionError]
  #
  # source://net-ftp//lib/net/ftp.rb#1504
  def method_missing(mid, *args); end

  # source://net-ftp//lib/net/ftp.rb#1494
  def read_timeout=(sec); end
end

# :stopdoc:
#
# source://net-ftp//lib/net/ftp.rb#92
Net::FTP::VERSION = T.let(T.unsafe(nil), String)
