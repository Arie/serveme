# This file is autogenerated. Do not edit it by hand. Regenerate it with:
#   srb rbi gems

# typed: false
#
# If you would like to make changes to this file, great! Please create the gem's shim here:
#
#   https://github.com/sorbet/sorbet-typed/new/master?filename=lib/net-imap/all/net-imap.rbi
#
# net-imap-0.4.14

module Net
end
class Net::IMAP < Net::Protocol
  def add_response_handler(handler = nil, &block); end
  def append(mailbox, message, flags = nil, date_time = nil); end
  def auth_capable?(mechanism); end
  def auth_mechanisms; end
  def authenticate(mechanism, *creds, sasl_ir: nil, **props, &callback); end
  def build_ssl_ctx(ssl); end
  def capabilities; end
  def capabilities_cached?; end
  def capabilities_from_resp_code(resp); end
  def capability; end
  def capability?(capability); end
  def capable?(capability); end
  def check; end
  def clear_cached_capabilities; end
  def clear_responses(type = nil); end
  def client_thread; end
  def close; end
  def config; end
  def copy(set, mailbox); end
  def copy_internal(cmd, set, mailbox); end
  def create(mailbox); end
  def delete(mailbox); end
  def disconnect; end
  def disconnected?; end
  def enable(*capabilities); end
  def examine(mailbox, condstore: nil); end
  def expunge; end
  def fetch(set, attr, mod = nil, changedsince: nil); end
  def fetch_internal(cmd, set, attr, mod = nil, changedsince: nil); end
  def generate_tag; end
  def get_response; end
  def get_server_greeting; end
  def get_tagged_response(tag, cmd, timeout = nil); end
  def getacl(mailbox); end
  def getquota(mailbox); end
  def getquotaroot(mailbox); end
  def greeting; end
  def host; end
  def id(client_id = nil); end
  def idle(timeout = nil, &response_handler); end
  def idle_done; end
  def idle_response_timeout; end
  def initialize(host, port_or_options = nil, *deprecated, **options); end
  def list(refname, mailbox); end
  def login(user, password); end
  def logout!; end
  def logout; end
  def lsub(refname, mailbox); end
  def move(set, mailbox); end
  def namespace; end
  def noop; end
  def normalize_searching_criteria(keys); end
  def open_timeout; end
  def port; end
  def put_string(str); end
  def receive_responses; end
  def record_untagged_response(resp); end
  def record_untagged_response_code(resp); end
  def remove_response_handler(handler); end
  def rename(mailbox, newname); end
  def response_handlers; end
  def responses(type = nil); end
  def sasl_adapter; end
  def search(keys, charset = nil); end
  def search_internal(cmd, keys, charset); end
  def select(mailbox, condstore: nil); end
  def self.config; end
  def self.debug; end
  def self.debug=(val); end
  def self.decode_date(string); end
  def self.decode_datetime(string); end
  def self.decode_time(string); end
  def self.decode_utf7(s); end
  def self.default_imap_port; end
  def self.default_imaps_port; end
  def self.default_port; end
  def self.default_ssl_port; end
  def self.default_tls_port; end
  def self.encode_date(date); end
  def self.encode_datetime(time); end
  def self.encode_time(time); end
  def self.encode_utf7(s); end
  def self.format_date(date); end
  def self.format_datetime(time); end
  def self.format_time(time); end
  def self.parse_date(string); end
  def self.parse_datetime(string); end
  def self.parse_time(string); end
  def self.saslprep(string, **opts); end
  def send_command(cmd, *args, &block); end
  def send_command_with_continuations(cmd, *args); end
  def send_data(data, tag = nil); end
  def send_date_data(date); end
  def send_list_data(list, tag = nil); end
  def send_literal(str, tag = nil); end
  def send_number_data(num); end
  def send_quoted_string(str); end
  def send_string_data(str, tag = nil); end
  def send_symbol_data(symbol); end
  def send_time_data(time); end
  def setacl(mailbox, user, rights); end
  def setquota(mailbox, quota); end
  def sort(sort_keys, search_keys, charset); end
  def sort_internal(cmd, sort_keys, search_keys, charset); end
  def ssl_ctx; end
  def ssl_ctx_params; end
  def start_imap_connection; end
  def start_receiver_thread; end
  def start_tls_session; end
  def starttls(*deprecated, **options); end
  def status(mailbox, attr); end
  def store(set, attr, flags, unchangedsince: nil); end
  def store_internal(cmd, set, attr, flags, unchangedsince: nil); end
  def subscribe(mailbox); end
  def tcp_socket(host, port); end
  def thread(algorithm, search_keys, charset); end
  def thread_internal(cmd, algorithm, search_keys, charset); end
  def tls_verified?; end
  def uid_copy(set, mailbox); end
  def uid_expunge(uid_set); end
  def uid_fetch(set, attr, mod = nil, changedsince: nil); end
  def uid_move(set, mailbox); end
  def uid_search(keys, charset = nil); end
  def uid_sort(sort_keys, search_keys, charset); end
  def uid_store(set, attr, flags, unchangedsince: nil); end
  def uid_thread(algorithm, search_keys, charset); end
  def unselect; end
  def unsubscribe(mailbox); end
  def validate_data(data); end
  def xlist(refname, mailbox); end
  extend Net::IMAP::Authenticators
  include MonitorMixin
  include OpenSSL
  include OpenSSL::SSL
end
class Net::IMAP::Error < StandardError
end
class Net::IMAP::DataFormatError < Net::IMAP::Error
end
class Net::IMAP::ResponseParseError < Net::IMAP::Error
end
class Net::IMAP::ResponseError < Net::IMAP::Error
  def initialize(response); end
  def response; end
  def response=(arg0); end
end
class Net::IMAP::NoResponseError < Net::IMAP::ResponseError
end
class Net::IMAP::BadResponseError < Net::IMAP::ResponseError
end
class Net::IMAP::ByeResponseError < Net::IMAP::ResponseError
end
class Net::IMAP::InvalidResponseError < Net::IMAP::Error
end
class Net::IMAP::UnknownResponseError < Net::IMAP::ResponseError
end
class Net::IMAP::Config
  def defaults_hash; end
  def initialize(parent = nil, **attrs); end
  def load_defaults(version); end
  def self.[](config); end
  def self.default; end
  def self.global; end
  def self.version_defaults; end
  def to_h; end
  def update(**attrs); end
  def with(**attrs); end
  extend Net::IMAP::Config::AttrAccessors::Macros
  extend Net::IMAP::Config::AttrInheritance::Macros
  extend Net::IMAP::Config::AttrTypeCoercion::Macros
  include Net::IMAP::Config::AttrAccessors
  include Net::IMAP::Config::AttrInheritance
  include Net::IMAP::Config::AttrTypeCoercion
end
module Net::IMAP::Config::AttrAccessors
  def data; end
  def debug(*args, **, &block); end
  def debug=(*args, **, &block); end
  def freeze; end
  def idle_response_timeout(*args, **, &block); end
  def idle_response_timeout=(*args, **, &block); end
  def initialize; end
  def initialize_clone(other); end
  def initialize_dup(other); end
  def open_timeout(*args, **, &block); end
  def open_timeout=(*args, **, &block); end
  def responses_without_block(*args, **, &block); end
  def responses_without_block=(*args, **, &block); end
  def sasl_ir(*args, **, &block); end
  def sasl_ir=(*args, **, &block); end
  def self.attr_accessor(name); end
  def self.attributes; end
  def self.included(mod); end
  def self.struct; end
  extend Forwardable
end
module Net::IMAP::Config::AttrAccessors::Macros
  def attr_accessor(name); end
end
module Net::IMAP::Config::AttrInheritance
  def debug; end
  def idle_response_timeout; end
  def inherited?(attr); end
  def initialize(parent = nil); end
  def initialize_copy(other); end
  def new(**attrs); end
  def open_timeout; end
  def parent; end
  def reset(attr = nil); end
  def responses_without_block; end
  def sasl_ir; end
  def self.attr_accessor(name); end
  def self.included(mod); end
end
module Net::IMAP::Config::AttrInheritance::INHERITED
end
module Net::IMAP::Config::AttrInheritance::Macros
  def attr_accessor(name); end
end
module Net::IMAP::Config::AttrTypeCoercion
  def debug=(val); end
  def debug?; end
  def idle_response_timeout=(val); end
  def open_timeout=(val); end
  def responses_without_block=(val); end
  def sasl_ir=(val); end
  def sasl_ir?; end
  def self.attr_accessor(attr, type: nil); end
  def self.boolean(attr); end
  def self.enum(attr, enum); end
  def self.included(mod); end
  def self.integer(attr); end
end
module Net::IMAP::Config::AttrTypeCoercion::Macros
  def attr_accessor(attr, type: nil); end
end
class Net::IMAP::Config::AttrAccessors::Struct < Struct
  def debug; end
  def debug=(_); end
  def idle_response_timeout; end
  def idle_response_timeout=(_); end
  def open_timeout; end
  def open_timeout=(_); end
  def responses_without_block; end
  def responses_without_block=(_); end
  def sasl_ir; end
  def sasl_ir=(_); end
  def self.[](*arg0); end
  def self.inspect; end
  def self.keyword_init?; end
  def self.members; end
  def self.new(*arg0); end
end
class Net::IMAP::RawData
  def initialize(data); end
  def send_data(imap, tag); end
  def validate; end
end
class Net::IMAP::Atom
  def initialize(data); end
  def send_data(imap, tag); end
  def validate; end
end
class Net::IMAP::QuotedString
  def initialize(data); end
  def send_data(imap, tag); end
  def validate; end
end
class Net::IMAP::Literal
  def initialize(data); end
  def send_data(imap, tag); end
  def validate; end
end
class Net::IMAP::MessageSet
  def format_internal(data); end
  def initialize(data); end
  def send_data(imap, tag); end
  def validate; end
  def validate_internal(data); end
end
class Net::IMAP::ClientID
  def format_internal(client_id); end
  def initialize(data); end
  def send_data(imap, tag); end
  def validate; end
  def validate_internal(client_id); end
end
module Net::IMAP::StringFormatter
  def nstring(str); end
  def self.nstring(str); end
  def self.string(str); end
  def self.valid_nstring?(str); end
  def self.valid_string?(str); end
  def string(str); end
  def valid_nstring?(str); end
  def valid_string?(str); end
end
module Net::IMAP::NumValidator
  def ensure_mod_sequence_value(num); end
  def ensure_number(num); end
  def ensure_nz_number(num); end
  def self.ensure_mod_sequence_value(num); end
  def self.ensure_number(num); end
  def self.ensure_nz_number(num); end
  def self.valid_mod_sequence_value?(num); end
  def self.valid_number?(num); end
  def self.valid_nz_number?(num); end
  def valid_mod_sequence_value?(num); end
  def valid_number?(num); end
  def valid_nz_number?(num); end
end
class Anonymous_Struct_54 < Struct
  def data; end
  def data=(_); end
  def raw_data; end
  def raw_data=(_); end
  def self.[](*arg0); end
  def self.inspect; end
  def self.keyword_init?; end
  def self.members; end
  def self.new(*arg0); end
end
class Net::IMAP::ContinuationRequest < Anonymous_Struct_54
end
class Anonymous_Struct_55 < Struct
  def data; end
  def data=(_); end
  def name; end
  def name=(_); end
  def raw_data; end
  def raw_data=(_); end
  def self.[](*arg0); end
  def self.inspect; end
  def self.keyword_init?; end
  def self.members; end
  def self.new(*arg0); end
end
class Net::IMAP::UntaggedResponse < Anonymous_Struct_55
end
class Net::IMAP::IgnoredResponse < Net::IMAP::UntaggedResponse
end
class Anonymous_Struct_56 < Struct
  def self.[](*arg0); end
  def self.inspect; end
  def self.keyword_init?; end
  def self.members; end
  def self.new(*arg0); end
  def unparsed_data; end
  def unparsed_data=(_); end
end
class Net::IMAP::UnparsedData < Anonymous_Struct_56
end
class Anonymous_Struct_57 < Struct
  def number; end
  def number=(_); end
  def self.[](*arg0); end
  def self.inspect; end
  def self.keyword_init?; end
  def self.members; end
  def self.new(*arg0); end
  def unparsed_data; end
  def unparsed_data=(_); end
end
class Net::IMAP::UnparsedNumericResponseData < Anonymous_Struct_57
end
class Anonymous_Struct_58 < Struct
  def data; end
  def data=(_); end
  def self.[](*arg0); end
  def self.inspect; end
  def self.keyword_init?; end
  def self.members; end
  def self.new(*arg0); end
end
class Net::IMAP::ExtensionData < Anonymous_Struct_58
end
class Anonymous_Struct_59 < Struct
  def data; end
  def data=(_); end
  def name; end
  def name=(_); end
  def raw_data; end
  def raw_data=(_); end
  def self.[](*arg0); end
  def self.inspect; end
  def self.keyword_init?; end
  def self.members; end
  def self.new(*arg0); end
  def tag; end
  def tag=(_); end
end
class Net::IMAP::TaggedResponse < Anonymous_Struct_59
end
class Anonymous_Struct_60 < Struct
  def code; end
  def code=(_); end
  def self.[](*arg0); end
  def self.inspect; end
  def self.keyword_init?; end
  def self.members; end
  def self.new(*arg0); end
  def text; end
  def text=(_); end
end
class Net::IMAP::ResponseText < Anonymous_Struct_60
end
class Anonymous_Struct_61 < Struct
  def data; end
  def data=(_); end
  def name; end
  def name=(_); end
  def self.[](*arg0); end
  def self.inspect; end
  def self.keyword_init?; end
  def self.members; end
  def self.new(*arg0); end
end
class Net::IMAP::ResponseCode < Anonymous_Struct_61
end
class Anonymous_Struct_62 < Struct
  def assigned_uids; end
  def assigned_uids=(_); end
  def self.[](*arg0); end
  def self.inspect; end
  def self.keyword_init?; end
  def self.members; end
  def self.new(*arg0); end
  def source_uids; end
  def source_uids=(_); end
  def uidvalidity; end
  def uidvalidity=(_); end
end
class Net::IMAP::UIDPlusData < Anonymous_Struct_62
  def uid_mapping; end
end
class Anonymous_Struct_63 < Struct
  def attr; end
  def attr=(_); end
  def delim; end
  def delim=(_); end
  def name; end
  def name=(_); end
  def self.[](*arg0); end
  def self.inspect; end
  def self.keyword_init?; end
  def self.members; end
  def self.new(*arg0); end
end
class Net::IMAP::MailboxList < Anonymous_Struct_63
end
class Anonymous_Struct_64 < Struct
  def mailbox; end
  def mailbox=(_); end
  def quota; end
  def quota=(_); end
  def self.[](*arg0); end
  def self.inspect; end
  def self.keyword_init?; end
  def self.members; end
  def self.new(*arg0); end
  def usage; end
  def usage=(_); end
end
class Net::IMAP::MailboxQuota < Anonymous_Struct_64
end
class Anonymous_Struct_65 < Struct
  def mailbox; end
  def mailbox=(_); end
  def quotaroots; end
  def quotaroots=(_); end
  def self.[](*arg0); end
  def self.inspect; end
  def self.keyword_init?; end
  def self.members; end
  def self.new(*arg0); end
end
class Net::IMAP::MailboxQuotaRoot < Anonymous_Struct_65
end
class Anonymous_Struct_66 < Struct
  def mailbox; end
  def mailbox=(_); end
  def rights; end
  def rights=(_); end
  def self.[](*arg0); end
  def self.inspect; end
  def self.keyword_init?; end
  def self.members; end
  def self.new(*arg0); end
  def user; end
  def user=(_); end
end
class Net::IMAP::MailboxACLItem < Anonymous_Struct_66
end
class Anonymous_Struct_67 < Struct
  def delim; end
  def delim=(_); end
  def extensions; end
  def extensions=(_); end
  def prefix; end
  def prefix=(_); end
  def self.[](*arg0); end
  def self.inspect; end
  def self.keyword_init?; end
  def self.members; end
  def self.new(*arg0); end
end
class Net::IMAP::Namespace < Anonymous_Struct_67
end
class Anonymous_Struct_68 < Struct
  def other; end
  def other=(_); end
  def personal; end
  def personal=(_); end
  def self.[](*arg0); end
  def self.inspect; end
  def self.keyword_init?; end
  def self.members; end
  def self.new(*arg0); end
  def shared; end
  def shared=(_); end
end
class Net::IMAP::Namespaces < Anonymous_Struct_68
end
class Anonymous_Struct_69 < Struct
  def attr; end
  def attr=(_); end
  def mailbox; end
  def mailbox=(_); end
  def self.[](*arg0); end
  def self.inspect; end
  def self.keyword_init?; end
  def self.members; end
  def self.new(*arg0); end
end
class Net::IMAP::StatusData < Anonymous_Struct_69
end
class Anonymous_Struct_70 < Struct
  def bcc; end
  def bcc=(_); end
  def cc; end
  def cc=(_); end
  def date; end
  def date=(_); end
  def from; end
  def from=(_); end
  def in_reply_to; end
  def in_reply_to=(_); end
  def message_id; end
  def message_id=(_); end
  def reply_to; end
  def reply_to=(_); end
  def self.[](*arg0); end
  def self.inspect; end
  def self.keyword_init?; end
  def self.members; end
  def self.new(*arg0); end
  def sender; end
  def sender=(_); end
  def subject; end
  def subject=(_); end
  def to; end
  def to=(_); end
end
class Net::IMAP::Envelope < Anonymous_Struct_70
end
class Anonymous_Struct_71 < Struct
  def host; end
  def host=(_); end
  def mailbox; end
  def mailbox=(_); end
  def name; end
  def name=(_); end
  def route; end
  def route=(_); end
  def self.[](*arg0); end
  def self.inspect; end
  def self.keyword_init?; end
  def self.members; end
  def self.new(*arg0); end
end
class Net::IMAP::Address < Anonymous_Struct_71
end
class Anonymous_Struct_72 < Struct
  def dsp_type; end
  def dsp_type=(_); end
  def param; end
  def param=(_); end
  def self.[](*arg0); end
  def self.inspect; end
  def self.keyword_init?; end
  def self.members; end
  def self.new(*arg0); end
end
class Net::IMAP::ContentDisposition < Anonymous_Struct_72
end
class Anonymous_Struct_73 < Struct
  def children; end
  def children=(_); end
  def self.[](*arg0); end
  def self.inspect; end
  def self.keyword_init?; end
  def self.members; end
  def self.new(*arg0); end
  def seqno; end
  def seqno=(_); end
end
class Net::IMAP::ThreadMember < Anonymous_Struct_73
  def all_seqnos(node = nil); end
  def to_sequence_set; end
end
module Net::IMAP::BodyStructure
end
class Anonymous_Struct_74 < Struct
  def content_id; end
  def content_id=(_); end
  def description; end
  def description=(_); end
  def disposition; end
  def disposition=(_); end
  def encoding; end
  def encoding=(_); end
  def extension; end
  def extension=(_); end
  def language; end
  def language=(_); end
  def location; end
  def location=(_); end
  def md5; end
  def md5=(_); end
  def media_type; end
  def media_type=(_); end
  def param; end
  def param=(_); end
  def self.[](*arg0); end
  def self.inspect; end
  def self.keyword_init?; end
  def self.members; end
  def self.new(*arg0); end
  def size; end
  def size=(_); end
  def subtype; end
  def subtype=(_); end
end
class Net::IMAP::BodyTypeBasic < Anonymous_Struct_74
  def media_subtype; end
  def multipart?; end
  include Net::IMAP::BodyStructure
end
class Anonymous_Struct_75 < Struct
  def content_id; end
  def content_id=(_); end
  def description; end
  def description=(_); end
  def disposition; end
  def disposition=(_); end
  def encoding; end
  def encoding=(_); end
  def extension; end
  def extension=(_); end
  def language; end
  def language=(_); end
  def lines; end
  def lines=(_); end
  def location; end
  def location=(_); end
  def md5; end
  def md5=(_); end
  def media_type; end
  def media_type=(_); end
  def param; end
  def param=(_); end
  def self.[](*arg0); end
  def self.inspect; end
  def self.keyword_init?; end
  def self.members; end
  def self.new(*arg0); end
  def size; end
  def size=(_); end
  def subtype; end
  def subtype=(_); end
end
class Net::IMAP::BodyTypeText < Anonymous_Struct_75
  def media_subtype; end
  def multipart?; end
  include Net::IMAP::BodyStructure
end
class Anonymous_Struct_76 < Struct
  def body; end
  def body=(_); end
  def content_id; end
  def content_id=(_); end
  def description; end
  def description=(_); end
  def disposition; end
  def disposition=(_); end
  def encoding; end
  def encoding=(_); end
  def envelope; end
  def envelope=(_); end
  def extension; end
  def extension=(_); end
  def language; end
  def language=(_); end
  def lines; end
  def lines=(_); end
  def location; end
  def location=(_); end
  def md5; end
  def md5=(_); end
  def media_type; end
  def media_type=(_); end
  def param; end
  def param=(_); end
  def self.[](*arg0); end
  def self.inspect; end
  def self.keyword_init?; end
  def self.members; end
  def self.new(*arg0); end
  def size; end
  def size=(_); end
  def subtype; end
  def subtype=(_); end
end
class Net::IMAP::BodyTypeMessage < Anonymous_Struct_76
  def media_subtype; end
  def multipart?; end
  include Net::IMAP::BodyStructure
end
class Anonymous_Struct_77 < Struct
  def _unused_; end
  def _unused_=(_); end
  def dsp_type; end
  def dsp_type=(_); end
  def param; end
  def param=(_); end
  def self.[](*arg0); end
  def self.inspect; end
  def self.keyword_init?; end
  def self.members; end
  def self.new(*arg0); end
end
class Net::IMAP::BodyTypeAttachment < Anonymous_Struct_77
  def media_type; end
  def multipart?; end
  def subtype; end
end
class Anonymous_Struct_78 < Struct
  def disposition; end
  def disposition=(_); end
  def extension; end
  def extension=(_); end
  def language; end
  def language=(_); end
  def location; end
  def location=(_); end
  def media_type; end
  def media_type=(_); end
  def param; end
  def param=(_); end
  def parts; end
  def parts=(_); end
  def self.[](*arg0); end
  def self.inspect; end
  def self.keyword_init?; end
  def self.members; end
  def self.new(*arg0); end
  def subtype; end
  def subtype=(_); end
end
class Net::IMAP::BodyTypeMultipart < Anonymous_Struct_78
  def media_subtype; end
  def multipart?; end
  include Net::IMAP::BodyStructure
end
class Anonymous_Struct_79 < Struct
  def content_id; end
  def content_id=(_); end
  def description; end
  def description=(_); end
  def encoding; end
  def encoding=(_); end
  def media_type; end
  def media_type=(_); end
  def params; end
  def params=(_); end
  def self.[](*arg0); end
  def self.inspect; end
  def self.keyword_init?; end
  def self.members; end
  def self.new(*arg0); end
  def size; end
  def size=(_); end
  def subtype; end
  def subtype=(_); end
end
class Net::IMAP::BodyTypeExtension < Anonymous_Struct_79
  def multipart?; end
end
class Net::IMAP::ResponseParser
  def CRLF!; end
  def CRLF?; end
  def EOF!; end
  def EOF?; end
  def NIL!; end
  def NIL?; end
  def PLUS!; end
  def PLUS?; end
  def SP!; end
  def SP?; end
  def STAR!; end
  def STAR?; end
  def accept_spaces; end
  def acl_data; end
  def addr_adl; end
  def addr_host; end
  def addr_mailbox; end
  def addr_name; end
  def address; end
  def astring; end
  def astring?; end
  def astring_chars; end
  def atom; end
  def atom?; end
  def body; end
  def body_ext_1part; end
  def body_ext_mpart; end
  def body_extension; end
  def body_extensions; end
  def body_fields; end
  def body_fld_desc; end
  def body_fld_dsp; end
  def body_fld_enc; end
  def body_fld_id; end
  def body_fld_lang; end
  def body_fld_lines; end
  def body_fld_loc; end
  def body_fld_md5; end
  def body_fld_octets; end
  def body_fld_param; end
  def body_type_1part; end
  def body_type_basic; end
  def body_type_mixed; end
  def body_type_mpart; end
  def body_type_msg; end
  def body_type_text; end
  def capability; end
  def capability?; end
  def capability__list; end
  def capability_data__untagged; end
  def case_insensitive__atom; end
  def case_insensitive__atom?; end
  def case_insensitive__nstring; end
  def case_insensitive__string; end
  def case_insensitive__string?; end
  def charset; end
  def charset__list; end
  def comparator_data(klass = nil); end
  def config; end
  def continue_req; end
  def date_time; end
  def enable_data; end
  def env_bcc; end
  def env_cc; end
  def env_date; end
  def env_from; end
  def env_in_reply_to; end
  def env_message_id; end
  def env_reply_to; end
  def env_sender; end
  def env_subject; end
  def env_to; end
  def envelope; end
  def esearch_response(klass = nil); end
  def expunged_resp(klass = nil); end
  def flag_list; end
  def flag_perm__list; end
  def gt__number__lt; end
  def header_fld_name; end
  def header_list; end
  def id_response; end
  def initialize(config: nil); end
  def label(word); end
  def label_in(*labels); end
  def language_data(klass = nil); end
  def lbra; end
  def lbra?; end
  def listrights_data(klass = nil); end
  def lookahead_CRLF!; end
  def lookahead_EOF!; end
  def lookahead_NIL!; end
  def lookahead_PLUS?; end
  def lookahead_SP?; end
  def lookahead_STAR?; end
  def lookahead_body?; end
  def lookahead_case_insensitive__string!; end
  def lookahead_lbra?; end
  def lookahead_lpar?; end
  def lookahead_number!; end
  def lookahead_quoted!; end
  def lookahead_rbra?; end
  def lookahead_rpar?; end
  def lookahead_string!; end
  def lookahead_string8!; end
  def lookahead_tagged_ext_label!; end
  def lookahead_thread_list?; end
  def lookahead_thread_nested?; end
  def lpar; end
  def lpar?; end
  def mailbox; end
  def mailbox_data__exists; end
  def mailbox_data__flags; end
  def mailbox_data__list; end
  def mailbox_data__lsub; end
  def mailbox_data__recent; end
  def mailbox_data__search; end
  def mailbox_data__status; end
  def mailbox_data__xlist; end
  def mailbox_list; end
  def mbx_list_flags; end
  def media_basic; end
  def media_message; end
  def media_subtype; end
  def media_text; end
  def media_type; end
  def message_data__converted(klass = nil); end
  def message_data__expunge; end
  def message_data__fetch; end
  def metadata_resp(klass = nil); end
  def mod_sequence_value; end
  def mod_sequence_valzer; end
  def msg_att(n); end
  def msg_att__label; end
  def myrights_data(klass = nil); end
  def namespace; end
  def namespace_descr; end
  def namespace_response; end
  def namespace_response_extensions; end
  def ndatetime; end
  def next_token; end
  def nil_atom; end
  def nlist__address; end
  def nparens__objectid; end
  def nquoted; end
  def nstring8; end
  def nstring; end
  def number64; end
  def number64?; end
  def number; end
  def number?; end
  def nz_number64; end
  def nz_number; end
  def nz_number?; end
  def objectid; end
  def parens__modseq; end
  def parens__objectid; end
  def parse(str); end
  def peek_PLUS?; end
  def peek_SP?; end
  def peek_STAR?; end
  def peek_lbra?; end
  def peek_lpar?; end
  def peek_rbra?; end
  def peek_rpar?; end
  def permsg_modsequence; end
  def quirky_SP?; end
  def quirky__flag_list(name); end
  def quota_response; end
  def quotaroot_response; end
  def quoted; end
  def quoted?; end
  def rbra; end
  def rbra?; end
  def remaining_unparsed; end
  def resp_code__capability; end
  def resp_code_apnd__data; end
  def resp_code_copy__data; end
  def resp_cond_auth; end
  def resp_cond_auth__name; end
  def resp_cond_bye; end
  def resp_cond_state; end
  def resp_cond_state__name; end
  def resp_cond_state__untagged; end
  def resp_text; end
  def resp_text_code; end
  def resp_text_code__name; end
  def response; end
  def response_data; end
  def response_data__ignored; end
  def response_data__noop; end
  def response_data__simple_numeric; end
  def response_data__unhandled(klass = nil); end
  def response_tagged; end
  def rpar; end
  def rpar?; end
  def section; end
  def section_binary; end
  def section_part; end
  def section_spec; end
  def sequence_set; end
  def sort_data; end
  def status_att_list; end
  def status_att_val; end
  def string8; end
  def string8?; end
  def string; end
  def string?; end
  def tag; end
  def tagged_ext_comp; end
  def tagged_ext_label; end
  def tagged_ext_label?; end
  def tagged_ext_simple; end
  def tagged_ext_val; end
  def text; end
  def text?; end
  def text_chars_except_rbra; end
  def thread_data; end
  def thread_list; end
  def thread_members; end
  def thread_nested; end
  def uid_set; end
  def uidfetch_resp(klass = nil); end
  def uniqueid; end
  def x_gm_id; end
  def x_gm_label; end
  def x_gm_labels; end
  extend Net::IMAP::ResponseParser::ParserUtils::Generator
  include Net::IMAP::ResponseParser::ParserUtils
  include Net::IMAP::ResponseParser::ResponseConditions
end
module Net::IMAP::ResponseParser::ParserUtils
  def accept(*args); end
  def accept_re(re); end
  def assert_no_lookahead; end
  def combine_adjacent(*tokens); end
  def lookahead!(*args); end
  def lookahead; end
  def lookahead?(*symbols); end
  def match(*args); end
  def match_re(re, name); end
  def parse_error(fmt, *args); end
  def peek_re(re); end
  def peek_str?(str); end
  def shift_token; end
end
module Net::IMAP::ResponseParser::ParserUtils::Generator
  def def_char_matchers(name, char, token); end
  def def_token_matchers(name, *token_symbols, coerce: nil, send: nil); end
end
module Net::IMAP::ResponseParser::ResponseConditions
end
module Net::IMAP::ResponseParser::Patterns
  def self.unescape_quoted!(quoted); end
  def self.unescape_quoted(quoted); end
  def unescape_quoted!(quoted); end
  def unescape_quoted(quoted); end
  include Net::IMAP::ResponseParser::Patterns::RFC3629
  include Net::IMAP::ResponseParser::Patterns::RFC5234
end
module Net::IMAP::ResponseParser::Patterns::CharClassSubtraction
end
module Net::IMAP::ResponseParser::Patterns::RFC5234
end
module Net::IMAP::ResponseParser::Patterns::RFC3629
end
class Net::IMAP::ResponseParser::Token < Struct
  def self.[](*arg0); end
  def self.inspect; end
  def self.keyword_init?; end
  def self.members; end
  def self.new(*arg0); end
  def symbol; end
  def symbol=(_); end
  def value; end
  def value=(_); end
end
module Net::IMAP::SASL
  def saslprep(string, **opts); end
  def self.add_authenticator(*, **, &); end
  def self.authenticator(*args, registry: nil, **kwargs, &block); end
  def self.authenticators; end
  def self.saslprep(string, **opts); end
end
class Net::IMAP::SASL::Error < StandardError
end
class Net::IMAP::SASL::AuthenticationCanceled < Net::IMAP::SASL::Error
end
class Net::IMAP::SASL::AuthenticationError < Net::IMAP::SASL::Error
end
class Net::IMAP::SASL::AuthenticationFailed < Net::IMAP::SASL::Error
end
class Net::IMAP::SASL::AuthenticationIncomplete < Net::IMAP::SASL::AuthenticationFailed
  def initialize(response, message = nil); end
  def response; end
end
class Net::IMAP::SASL::PlainAuthenticator
  def authcid; end
  def authzid; end
  def done?; end
  def initial_response?; end
  def initialize(user = nil, pass = nil, authcid: nil, secret: nil, username: nil, password: nil, authzid: nil, **); end
  def password; end
  def process(data); end
  def secret; end
  def username; end
end
class Net::IMAP::SASL::XOAuth2Authenticator
  def authzid; end
  def build_oauth2_string(username, oauth2_token); end
  def done?; end
  def initial_response?; end
  def initialize(user = nil, token = nil, username: nil, oauth2_token: nil, authzid: nil, secret: nil, **); end
  def oauth2_token; end
  def process(_data); end
  def secret; end
  def username; end
end
module Net::IMAP::Authenticators
  def add_authenticator(*, **, &); end
  def authenticator(*, **, &); end
end
module Net::IMAP::DeprecatedClientOptions
  def create_ssl_params(certs = nil, verify = nil); end
  def initialize(host, port_or_options = nil, *deprecated, **options); end
  def starttls(*deprecated, **options); end
end
