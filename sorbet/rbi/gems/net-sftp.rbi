# This file is autogenerated. Do not edit it by hand. Regenerate it with:
#   srb rbi gems

# typed: true
#
# If you would like to make changes to this file, great! Please create the gem's shim here:
#
#   https://github.com/sorbet/sorbet-typed/new/master?filename=lib/net-sftp/all/net-sftp.rbi
#
# net-sftp-4.0.0

module Net
end
module Net::SFTP
  def self.start(host, user, ssh_options = nil, sftp_options = nil, &block); end
end
module Net::SFTP::Constants
end
module Net::SFTP::Constants::PacketTypes
end
module Net::SFTP::Constants::RenameFlags
end
module Net::SFTP::Constants::StatusCodes
end
module Net::SFTP::Constants::OpenFlags
end
module Net::SFTP::Constants::OpenFlags::FV1
end
module Net::SFTP::Constants::OpenFlags::FV5
end
module Net::SFTP::Constants::OpenFlags::FV6
end
module Net::SFTP::Constants::LockTypes
end
module Net::SFTP::Constants::ACE
end
module Net::SFTP::Constants::ACE::Type
end
module Net::SFTP::Constants::ACE::Flag
end
module Net::SFTP::Constants::ACE::Mask
end
class Net::SFTP::Exception < RuntimeError
end
class Net::SFTP::StatusException < Net::SFTP::Exception
  def code; end
  def description; end
  def initialize(response, text = nil); end
  def message; end
  def response; end
  def text; end
end
class Net::SFTP::Packet < Net::SSH::Buffer
  def initialize(data); end
  def type; end
end
module Net::SFTP::Protocol
  def self.load(session, version); end
end
class Net::SFTP::Protocol::Base
  def initialize(session); end
  def parse(packet); end
  def send_request(type, *args); end
  def session; end
  include Net::SFTP::Constants
  include Net::SFTP::Constants::PacketTypes
  include Net::SSH::Loggable
end
module Net::SFTP::Protocol::V01
end
class Net::SFTP::Protocol::V01::Attributes
  def atime; end
  def atime=(value); end
  def attributes; end
  def directory?; end
  def encode_extended(buffer); end
  def extended; end
  def extended=(value); end
  def file?; end
  def gid; end
  def gid=(value); end
  def group; end
  def initialize(attributes = nil); end
  def mtime; end
  def mtime=(value); end
  def owner; end
  def permissions; end
  def permissions=(value); end
  def prepare_serialization!; end
  def self.attr_accessor(name); end
  def self.attr_writer(name); end
  def self.elements; end
  def self.from_buffer(buffer); end
  def self.parse_extended(buffer); end
  def size; end
  def size=(value); end
  def symbolic_type; end
  def symlink?; end
  def to_s; end
  def type; end
  def uid; end
  def uid=(value); end
end
class Net::SFTP::Protocol::V01::Name
  def attributes; end
  def directory?; end
  def file?; end
  def initialize(name, longname, attributes); end
  def longname; end
  def name; end
  def symlink?; end
end
class Net::SFTP::Protocol::V01::Base < Net::SFTP::Protocol::Base
  def attribute_factory; end
  def block(handle, offset, length, mask); end
  def close(handle); end
  def fsetstat(handle, attrs); end
  def fstat(handle, flags = nil); end
  def link(*args); end
  def lstat(path, flags = nil); end
  def mkdir(path, attrs); end
  def name_factory; end
  def normalize_open_flags(flags); end
  def not_implemented!(operation); end
  def open(path, flags, options); end
  def opendir(path); end
  def parse_attrs_packet(packet); end
  def parse_data_packet(packet); end
  def parse_handle_packet(packet); end
  def parse_name_packet(packet); end
  def parse_status_packet(packet); end
  def read(handle, offset, length); end
  def readdir(handle); end
  def readlink(path); end
  def realpath(path); end
  def remove(filename); end
  def rename(name, new_name, flags = nil); end
  def rmdir(path); end
  def setstat(path, attrs); end
  def stat(path, flags = nil); end
  def symlink(path, target); end
  def unblock(handle, offset, length); end
  def version; end
  def write(handle, offset, data); end
  include Net::SFTP::Constants::OpenFlags
end
module Net::SFTP::Protocol::V02
end
class Net::SFTP::Protocol::V02::Base < Net::SFTP::Protocol::V01::Base
  def rename(name, new_name, flags = nil); end
  def version; end
end
module Net::SFTP::Protocol::V03
end
class Net::SFTP::Protocol::V03::Base < Net::SFTP::Protocol::V02::Base
  def readlink(path); end
  def symlink(path, target); end
  def version; end
end
module Net::SFTP::Protocol::V04
end
class Net::SFTP::Protocol::V04::Attributes < Net::SFTP::Protocol::V01::Attributes
  def acl; end
  def acl=(value); end
  def atime_nseconds; end
  def atime_nseconds=(value); end
  def createtime; end
  def createtime=(value); end
  def createtime_nseconds; end
  def createtime_nseconds=(value); end
  def encode_acl(buffer); end
  def group=(value); end
  def initialize(attributes = nil); end
  def mtime_nseconds; end
  def mtime_nseconds=(value); end
  def owner=(value); end
  def prepare_serialization!; end
  def self.elements; end
  def self.parse_acl(buffer); end
  def type; end
  def type=(value); end
end
class Net::SFTP::Protocol::V04::Attributes::ACL < Struct
  def flag; end
  def flag=(_); end
  def mask; end
  def mask=(_); end
  def self.[](*arg0); end
  def self.inspect; end
  def self.keyword_init?; end
  def self.members; end
  def self.new(*arg0); end
  def type; end
  def type=(_); end
  def who; end
  def who=(_); end
end
class Net::SFTP::Protocol::V04::Name
  def attributes; end
  def directory?; end
  def file?; end
  def initialize(name, attributes); end
  def longname; end
  def name; end
  def symlink?; end
end
class Net::SFTP::Protocol::V04::Base < Net::SFTP::Protocol::V03::Base
  def attribute_factory; end
  def fstat(handle, flags = nil); end
  def lstat(path, flags = nil); end
  def name_factory; end
  def parse_name_packet(packet); end
  def stat(path, flags = nil); end
  def version; end
end
module Net::SFTP::Protocol::V05
end
class Net::SFTP::Protocol::V05::Base < Net::SFTP::Protocol::V04::Base
  def open(path, flags, options); end
  def rename(name, new_name, flags = nil); end
  def version; end
end
module Net::SFTP::Protocol::V06
end
class Net::SFTP::Protocol::V06::Attributes < Net::SFTP::Protocol::V04::Attributes
  def allocation_size; end
  def allocation_size=(value); end
  def attrib_bits; end
  def attrib_bits=(value); end
  def attrib_bits_valid; end
  def attrib_bits_valid=(value); end
  def ctime; end
  def ctime=(value); end
  def ctime_nseconds; end
  def ctime_nseconds=(value); end
  def link_count; end
  def link_count=(value); end
  def mime_type; end
  def mime_type=(value); end
  def self.elements; end
  def text_hint; end
  def text_hint=(value); end
  def untranslated_name; end
  def untranslated_name=(value); end
end
class Net::SFTP::Protocol::V06::Base < Net::SFTP::Protocol::V05::Base
  def attribute_factory; end
  def block(handle, offset, length, mask); end
  def link(new_link_path, existing_path, symlink); end
  def symlink(path, target); end
  def unblock(handle, offset, length); end
  def version; end
end
class Net::SFTP::Response
  def [](key); end
  def code; end
  def data; end
  def eof?; end
  def initialize(request, data = nil); end
  def message; end
  def ok?; end
  def request; end
  def to_s; end
  def to_str; end
  include Net::SFTP::Constants::StatusCodes
end
class Net::SFTP::Request
  def [](key); end
  def []=(key, value); end
  def callback; end
  def id; end
  def initialize(session, type, id, &callback); end
  def pending?; end
  def properties; end
  def respond_to(packet); end
  def response; end
  def session; end
  def type; end
  def wait; end
  include Net::SFTP::Constants::PacketTypes
end
module Net::SFTP::Operations
end
class Net::SFTP::Operations::Dir
  def [](path, pattern); end
  def entries(path); end
  def foreach(path); end
  def glob(path, pattern, flags = nil); end
  def initialize(sftp); end
  def sftp; end
end
class Net::SFTP::Operations::Upload
  def [](name); end
  def []=(name, value); end
  def abort!; end
  def active?; end
  def entries_for(local); end
  def initialize(sftp, local, remote, options = nil, &progress); end
  def local; end
  def on_close(response); end
  def on_mkdir(response); end
  def on_open(response); end
  def on_write(response); end
  def open_file(local, remote); end
  def options; end
  def process_next_entry; end
  def progress; end
  def properties; end
  def recursive?; end
  def remote; end
  def sftp; end
  def update_progress(event, *args); end
  def wait; end
  def write_next_chunk(file); end
  include Net::SSH::Loggable
end
class Net::SFTP::Operations::Upload::LiveFile < Struct
  def handle; end
  def handle=(_); end
  def io; end
  def io=(_); end
  def local; end
  def local=(_); end
  def remote; end
  def remote=(_); end
  def self.[](*arg0); end
  def self.inspect; end
  def self.keyword_init?; end
  def self.members; end
  def self.new(*arg0); end
  def size; end
  def size=(_); end
end
class Net::SFTP::Operations::Download
  def [](name); end
  def []=(name, value); end
  def abort!; end
  def active?; end
  def download_next_chunk(entry); end
  def initialize(sftp, local, remote, options = nil, &progress); end
  def local; end
  def on_close(response); end
  def on_closedir(response); end
  def on_open(response); end
  def on_opendir(response); end
  def on_read(response); end
  def on_readdir(response); end
  def open_file(entry); end
  def options; end
  def process_next_entry; end
  def progress; end
  def properties; end
  def read_size; end
  def recursive?; end
  def remote; end
  def requests; end
  def sftp; end
  def stack; end
  def update_progress(hook, *args); end
  def wait; end
  include Net::SSH::Loggable
end
class Net::SFTP::Operations::Download::Entry < Struct
  def directory; end
  def directory=(_); end
  def handle; end
  def handle=(_); end
  def local; end
  def local=(_); end
  def offset; end
  def offset=(_); end
  def remote; end
  def remote=(_); end
  def self.[](*arg0); end
  def self.inspect; end
  def self.keyword_init?; end
  def self.members; end
  def self.new(*arg0); end
  def sink; end
  def sink=(_); end
  def size; end
  def size=(_); end
end
class Net::SFTP::Operations::File
  def close; end
  def eof?; end
  def fill; end
  def gets(sep_or_limit = nil, limit = nil); end
  def handle; end
  def initialize(sftp, handle); end
  def pos; end
  def pos=(offset); end
  def print(*items); end
  def puts(*items); end
  def read(n = nil); end
  def readline(sep_or_limit = nil, limit = nil); end
  def rewind; end
  def sftp; end
  def size; end
  def stat; end
  def write(data); end
end
class Net::SFTP::Operations::FileFactory
  def directory?(path); end
  def initialize(sftp); end
  def open(name, flags = nil, mode = nil, &block); end
  def sftp; end
end
class Net::SFTP::Session
  def block!(handle, offset, length, mask, &callback); end
  def block(handle, offset, length, mask, &callback); end
  def channel; end
  def close!(handle, &callback); end
  def close(handle, &callback); end
  def close_channel; end
  def closed?; end
  def connect!(&block); end
  def connect(&block); end
  def dir; end
  def dispatch_request(packet); end
  def do_version(packet); end
  def download!(remote, local = nil, options = nil, &block); end
  def download(remote, local, options = nil, &block); end
  def file; end
  def fsetstat!(handle, attrs, &callback); end
  def fsetstat(handle, attrs, &callback); end
  def fstat!(handle, flags = nil, &callback); end
  def fstat(handle, flags = nil, &callback); end
  def initialize(session, version = nil, &block); end
  def input; end
  def link!(new_link_path, existing_path, symlink = nil, &callback); end
  def link(new_link_path, existing_path, symlink = nil, &callback); end
  def loop(&block); end
  def loop_forever; end
  def lstat!(path, flags = nil, &callback); end
  def lstat(path, flags = nil, &callback); end
  def mkdir!(path, attrs = nil, &callback); end
  def mkdir(path, attrs = nil, &callback); end
  def open!(path, flags = nil, options = nil, &callback); end
  def open(path, flags = nil, options = nil, &callback); end
  def open?; end
  def opendir!(path, &callback); end
  def opendir(path, &callback); end
  def opening?; end
  def pending_requests; end
  def protocol; end
  def read!(handle, offset, length, &callback); end
  def read(handle, offset, length, &callback); end
  def readdir!(handle, &callback); end
  def readdir(handle, &callback); end
  def readlink!(path, &callback); end
  def readlink(path, &callback); end
  def realpath!(path, &callback); end
  def realpath(path, &callback); end
  def remove!(filename, &callback); end
  def remove(filename, &callback); end
  def rename!(name, new_name, flags = nil, &callback); end
  def rename(name, new_name, flags = nil, &callback); end
  def request(type, *args, &callback); end
  def rmdir!(path, &callback); end
  def rmdir(path, &callback); end
  def send_packet(type, *args); end
  def session; end
  def setstat!(path, attrs, &callback); end
  def setstat(path, attrs, &callback); end
  def stat!(path, flags = nil, &callback); end
  def stat(path, flags = nil, &callback); end
  def state; end
  def symlink!(path, target, &callback); end
  def symlink(path, target, &callback); end
  def unblock!(handle, offset, length, &callback); end
  def unblock(handle, offset, length, &callback); end
  def upload!(local, remote = nil, options = nil, &block); end
  def upload(local, remote = nil, options = nil, &block); end
  def wait_for(request, property = nil); end
  def when_channel_closed(channel); end
  def when_channel_confirmed(channel); end
  def when_channel_polled(channel); end
  def when_subsystem_started(channel, success); end
  def write!(handle, offset, data, &callback); end
  def write(handle, offset, data, &callback); end
  include Net::SFTP::Constants::PacketTypes
  include Net::SSH::Loggable
end
class Net::SSH::Connection::Session
  def sftp(wait = nil); end
end
