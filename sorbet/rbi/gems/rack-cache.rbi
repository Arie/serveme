# This file is autogenerated. Do not edit it by hand. Regenerate it with:
#   srb rbi gems

# typed: true
#
# If you would like to make changes to this file, great! Please create the gem's shim here:
#
#   https://github.com/sorbet/sorbet-typed/new/master?filename=lib/rack-cache/all/rack-cache.rbi
#
# rack-cache-1.17.0

module Rack::Cache
  def self.new(backend, options = nil, &b); end
end
class Rack::Cache::EntityStore
  def bytesize(string); end
  def slurp(body); end
end
class Rack::Cache::EntityStore::Heap < Rack::Cache::EntityStore
  def exist?(key); end
  def initialize(hash = nil, options = nil); end
  def open(key); end
  def purge(key); end
  def read(key); end
  def self.resolve(uri, options = nil); end
  def write(body, ttl = nil); end
end
class Rack::Cache::EntityStore::Disk < Rack::Cache::EntityStore
  def body_path(key); end
  def exist?(key); end
  def initialize(root); end
  def open(key); end
  def purge(key); end
  def read(key); end
  def root; end
  def self.resolve(uri); end
  def spread(key); end
  def storage_path(stem); end
  def write(body, ttl = nil); end
end
class Rack::Cache::EntityStore::Disk::Body < File
  def each; end
  def to_path; end
end
class Rack::Cache::EntityStore::MemCacheBase < Rack::Cache::EntityStore
  def cache; end
  def open(key); end
  def self.resolve(uri); end
  extend Rack::Utils
end
class Rack::Cache::EntityStore::Dalli < Rack::Cache::EntityStore::MemCacheBase
  def exist?(key); end
  def initialize(server = nil, options = nil); end
  def purge(key); end
  def read(key); end
  def write(body, ttl = nil); end
end
class Rack::Cache::EntityStore::MemCached < Rack::Cache::EntityStore::MemCacheBase
  def exist?(key); end
  def initialize(server = nil, options = nil); end
  def purge(key); end
  def read(key); end
  def write(body, ttl = nil); end
end
class Rack::Cache::EntityStore::GAEStore < Rack::Cache::EntityStore
  def cache; end
  def exist?(key); end
  def initialize(options = nil); end
  def open(key); end
  def purge(key); end
  def read(key); end
  def self.resolve(uri); end
  def write(body, ttl = nil); end
end
class Rack::Cache::EntityStore::Noop < Rack::Cache::EntityStore
  def exist?(key); end
  def open(key); end
  def purge(key); end
  def read(key); end
  def self.resolve(uri); end
  def write(body, ttl = nil); end
end
class Rack::Cache::Key
  def generate; end
  def initialize(request); end
  def query_string; end
  def self.call(request); end
  def self.query_string_ignore; end
  def self.query_string_ignore=(arg0); end
  include Rack::Utils
end
class Rack::Cache::MetaStore
  def cache_key(request); end
  def hexdigest(data); end
  def invalidate(request, entity_store); end
  def lookup(request, entity_store); end
  def persist_request(request); end
  def persist_response(response); end
  def purge(key); end
  def read(key); end
  def requests_match?(vary, env1, env2); end
  def restore_response(hash, body = nil); end
  def store(request, response, entity_store); end
  def write(key, negotiations, ttl = nil); end
end
class Rack::Cache::MetaStore::Heap < Rack::Cache::MetaStore
  def initialize(hash = nil, options = nil); end
  def purge(key); end
  def read(key); end
  def self.resolve(uri, options = nil); end
  def to_hash; end
  def write(key, entries, ttl = nil); end
end
class Rack::Cache::MetaStore::Disk < Rack::Cache::MetaStore
  def initialize(root = nil); end
  def key_path(key); end
  def purge(key); end
  def read(key); end
  def root; end
  def self.resolve(uri); end
  def spread(sha, n = nil); end
  def write(key, entries, ttl = nil); end
end
class Rack::Cache::MetaStore::MemCacheBase < Rack::Cache::MetaStore
  def cache; end
  def self.resolve(uri); end
  extend Rack::Utils
end
class Rack::Cache::MetaStore::Dalli < Rack::Cache::MetaStore::MemCacheBase
  def initialize(server = nil, options = nil); end
  def purge(key); end
  def read(key); end
  def write(key, entries, ttl = nil); end
end
class Rack::Cache::MetaStore::MemCached < Rack::Cache::MetaStore::MemCacheBase
  def cache; end
  def initialize(server = nil, options = nil); end
  def purge(key); end
  def read(key); end
  def write(key, entries, ttl = nil); end
end
class Rack::Cache::MetaStore::GAEStore < Rack::Cache::MetaStore
  def cache; end
  def initialize(options = nil); end
  def purge(key); end
  def read(key); end
  def self.resolve(uri); end
  def write(key, entries); end
end
class Rack::Cache::Storage
  def clear; end
  def create_store(type, uri, options = nil); end
  def initialize; end
  def resolve_entitystore_uri(uri, options = nil); end
  def resolve_metastore_uri(uri, options = nil); end
  def self.instance; end
end
module Rack::Cache::Options
  def allow_reload; end
  def allow_reload=(value); end
  def allow_reload?; end
  def allow_revalidate; end
  def allow_revalidate=(value); end
  def allow_revalidate?; end
  def cache_key; end
  def cache_key=(value); end
  def cache_key?; end
  def default_ttl; end
  def default_ttl=(value); end
  def default_ttl?; end
  def entitystore; end
  def entitystore=(value); end
  def entitystore?; end
  def fault_tolerant; end
  def fault_tolerant=(value); end
  def fault_tolerant?; end
  def ignore_headers; end
  def ignore_headers=(value); end
  def ignore_headers?; end
  def initialize_options(options = nil); end
  def metastore; end
  def metastore=(value); end
  def metastore?; end
  def option_name(key); end
  def options; end
  def options=(hash = nil); end
  def private_headers; end
  def private_headers=(value); end
  def private_headers?; end
  def read_option(key); end
  def self.option_accessor(key); end
  def self.option_name(key); end
  def set(option, value = nil, &block); end
  def storage; end
  def storage=(value); end
  def storage?; end
  def use_native_ttl; end
  def use_native_ttl=(value); end
  def use_native_ttl?; end
  def verbose; end
  def verbose=(value); end
  def verbose?; end
  def write_option(key, value); end
  extend Rack::Cache::Options
end
