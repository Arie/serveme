# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `rack-cache` gem.
# Please instead update this file by running `bin/tapioca gem rack-cache`.


# source://rack-cache//lib/rack/cache/cache_control.rb#1
module Rack
  class << self
    # source://rack/2.2.9/lib/rack/version.rb#26
    def release; end

    # source://rack/2.2.9/lib/rack/version.rb#19
    def version; end
  end
end

# = HTTP Caching For Rack
#
# Rack::Cache is suitable as a quick, drop-in component to enable HTTP caching
# for Rack-enabled applications that produce freshness (+expires+, +cache-control+)
# and/or validation (+last-modified+, +etag+) information.
#
# * Standards-based (RFC 2616 compliance)
# * Freshness/expiration based caching and validation
# * Supports HTTP Vary
# * Portable: 100% Ruby / works with any Rack-enabled framework
# * Disk, memcached, and heap memory storage backends
#
# === Usage
#
# Create with default options:
#   require 'rack/cache'
#   Rack::Cache.new(app, :verbose => true, :entitystore => 'file:cache')
#
# Within a rackup file (or with Rack::Builder):
#   require 'rack/cache'
#   use Rack::Cache do
#     set :verbose, true
#     set :metastore, 'memcached://localhost:11211/meta'
#     set :entitystore, 'file:/var/cache/rack'
#   end
#   run app
#
# source://rack-cache//lib/rack/cache.rb#29
module Rack::Cache
  class << self
    # source://rack-cache//lib/rack/cache/headers.rb#13
    def Headers(headers); end

    # Create a new Rack::Cache middleware component that fetches resources from
    # the specified backend application. The +options+ Hash can be used to
    # specify default configuration values (see attributes defined in
    # Rack::Cache::Options for possible key/values). When a block is given, it
    # is executed within the context of the newly create Rack::Cache::Context
    # object.
    #
    # source://rack-cache//lib/rack/cache.rb#42
    def new(backend, options = T.unsafe(nil), &b); end
  end
end

# Parses a cache-control header and exposes the directives as a Hash.
# Directives that do not have values are set to +true+.
#
# source://rack-cache//lib/rack/cache/cache_control.rb#6
class Rack::Cache::CacheControl < ::Hash
  # @return [CacheControl] a new instance of CacheControl
  #
  # source://rack-cache//lib/rack/cache/cache_control.rb#7
  def initialize(value = T.unsafe(nil)); end

  # The expiration time of an entity MAY be specified by the origin
  # server using the expires header (see section 14.21). Alternatively,
  # it MAY be specified using the max-age directive in a response. When
  # the max-age cache-control directive is present in a cached response,
  # the response is stale if its current age is greater than the age
  # value given (in seconds) at the time of a new request for that
  # resource. The max-age directive on a response implies that the
  # response is cacheable (i.e., "public") unless some other, more
  # restrictive cache directive is also present.
  #
  # If a response includes both an expires header and a max-age
  # directive, the max-age directive overrides the expires header, even
  # if the expires header is more restrictive. This rule allows an origin
  # server to provide, for a given response, a longer expiration time to
  # an HTTP/1.1 (or later) cache than to an HTTP/1.0 cache. This might be
  # useful if certain HTTP/1.0 caches improperly calculate ages or
  # expiration times, perhaps due to desynchronized clocks.
  #
  # Many HTTP/1.0 cache implementations will treat an expires value that
  # is less than or equal to the response Date value as being equivalent
  # to the cache-control response directive "no-cache". If an HTTP/1.1
  # cache receives such a response, and the response does not include a
  # cache-control header field, it SHOULD consider the response to be
  # non-cacheable in order to retain compatibility with HTTP/1.0 servers.
  #
  # When the max-age directive is included in the request, it indicates
  # that the client is willing to accept a response whose age is no
  # greater than the specified time in seconds.
  #
  # source://rack-cache//lib/rack/cache/cache_control.rb#110
  def max_age; end

  # Because a cache MAY be configured to ignore a server's specified
  # expiration time, and because a client request MAY include a max-
  # stale directive (which has a similar effect), the protocol also
  # includes a mechanism for the origin server to require revalidation
  # of a cache entry on any subsequent use. When the must-revalidate
  # directive is present in a response received by a cache, that cache
  # MUST NOT use the entry after it becomes stale to respond to a
  # subsequent request without first revalidating it with the origin
  # server. (I.e., the cache MUST do an end-to-end revalidation every
  # time, if, based solely on the origin server's expires or max-age
  # value, the cached response is stale.)
  #
  # The must-revalidate directive is necessary to support reliable
  # operation for certain protocol features. In all circumstances an
  # HTTP/1.1 cache MUST obey the must-revalidate directive; in
  # particular, if the cache cannot reach the origin server for any
  # reason, it MUST generate a 504 (Gateway Timeout) response.
  #
  # Servers SHOULD send the must-revalidate directive if and only if
  # failure to revalidate a request on the entity could result in
  # incorrect operation, such as a silently unexecuted financial
  # transaction. Recipients MUST NOT take any automated action that
  # violates this directive, and MUST NOT automatically provide an
  # unvalidated copy of the entity if revalidation fails.
  #
  # @return [Boolean]
  #
  # source://rack-cache//lib/rack/cache/cache_control.rb#166
  def must_revalidate?; end

  # When set in a response, a cache MUST NOT use the response to satisfy a
  # subsequent request without successful revalidation with the origin
  # server. This allows an origin server to prevent caching even by caches
  # that have been configured to return stale responses to client requests.
  #
  # Note that this does not necessary imply that the response may not be
  # stored by the cache, only that the cache cannot serve it without first
  # making a conditional GET request with the origin server.
  #
  # When set in a request, the server MUST NOT use a cached copy for its
  # response. This has quite different semantics compared to the no-cache
  # directive on responses. When the client specifies no-cache, it causes
  # an end-to-end reload, forcing each cache to update their cached copies.
  #
  # @return [Boolean]
  #
  # source://rack-cache//lib/rack/cache/cache_control.rb#49
  def no_cache?; end

  # Indicates that the response MUST NOT be stored under any circumstances.
  #
  # The purpose of the no-store directive is to prevent the
  # inadvertent release or retention of sensitive information (for
  # example, on backup tapes). The no-store directive applies to the
  # entire message, and MAY be sent either in a response or in a
  # request. If sent in a request, a cache MUST NOT store any part of
  # either this request or any response to it. If sent in a response,
  # a cache MUST NOT store any part of either this response or the
  # request that elicited it. This directive applies to both non-
  # shared and shared caches. "MUST NOT store" in this context means
  # that the cache MUST NOT intentionally store the information in
  # non-volatile storage, and MUST make a best-effort attempt to
  # remove the information from volatile storage as promptly as
  # possible after forwarding it.
  #
  # The purpose of this directive is to meet the stated requirements
  # of certain users and service authors who are concerned about
  # accidental releases of information via unanticipated accesses to
  # cache data structures. While the use of this directive might
  # improve privacy in some cases, we caution that it is NOT in any
  # way a reliable or sufficient mechanism for ensuring privacy. In
  # particular, malicious or compromised caches might not recognize or
  # obey this directive, and communications networks might be
  # vulnerable to eavesdropping.
  #
  # @return [Boolean]
  #
  # source://rack-cache//lib/rack/cache/cache_control.rb#78
  def no_store?; end

  # Indicates that all or part of the response message is intended for
  # a single user and MUST NOT be cached by a shared cache. This
  # allows an origin server to state that the specified parts of the
  # response are intended for only one user and are not a valid
  # response for requests by other users. A private (non-shared) cache
  # MAY cache the response.
  #
  # Note: This usage of the word private only controls where the
  # response may be cached, and cannot ensure the privacy of the
  # message content.
  #
  # @return [Boolean]
  #
  # source://rack-cache//lib/rack/cache/cache_control.rb#32
  def private?; end

  # The proxy-revalidate directive has the same meaning as the must-
  # revalidate directive, except that it does not apply to non-shared
  # user agent caches. It can be used on a response to an
  # authenticated request to permit the user's cache to store and
  # later return the response without needing to revalidate it (since
  # it has already been authenticated once by that user), while still
  # requiring proxies that service many users to revalidate each time
  # (in order to make sure that each user has been authenticated).
  # Note that such authenticated responses also need the public cache
  # control directive in order to allow them to be cached at all.
  #
  # @return [Boolean]
  #
  # source://rack-cache//lib/rack/cache/cache_control.rb#180
  def proxy_revalidate?; end

  # Indicates that the response MAY be cached by any cache, even if it
  # would normally be non-cacheable or cacheable only within a non-
  # shared cache.
  #
  # A response may be considered public without this directive if the
  # private directive is not set and the request does not include an
  # Authorization header.
  #
  # @return [Boolean]
  #
  # source://rack-cache//lib/rack/cache/cache_control.rb#18
  def public?; end

  # If a response includes a r-maxage directive, then for a reverse cache
  # (but not for a private or proxy cache), the maximum age specified by
  # this directive overrides the maximum age specified by either the max-age
  # directive, the s-maxage directive, or the expires header. The r-maxage
  # directive also implies the semantics of the proxy-revalidate directive.
  # i.e., that the reverse cache must not use the entry after it becomes
  # stale to respond to a subsequent request without first revalidating it
  # with the origin server. The r-maxage directive is always ignored by
  # private and proxy caches.
  #
  # source://rack-cache//lib/rack/cache/cache_control.rb#137
  def r_maxage; end

  # If a response includes a r-maxage directive, then for a reverse cache
  # (but not for a private or proxy cache), the maximum age specified by
  # this directive overrides the maximum age specified by either the max-age
  # directive, the s-maxage directive, or the expires header. The r-maxage
  # directive also implies the semantics of the proxy-revalidate directive.
  # i.e., that the reverse cache must not use the entry after it becomes
  # stale to respond to a subsequent request without first revalidating it
  # with the origin server. The r-maxage directive is always ignored by
  # private and proxy caches.
  #
  # source://rack-cache//lib/rack/cache/cache_control.rb#137
  def reverse_max_age; end

  # If a response includes an s-maxage directive, then for a shared
  # cache (but not for a private cache), the maximum age specified by
  # this directive overrides the maximum age specified by either the
  # max-age directive or the expires header. The s-maxage directive
  # also implies the semantics of the proxy-revalidate directive. i.e.,
  # that the shared cache must not use the entry after it becomes stale
  # to respond to a subsequent request without first revalidating it with
  # the origin server. The s-maxage directive is always ignored by a
  # private cache.
  #
  # source://rack-cache//lib/rack/cache/cache_control.rb#123
  def s_maxage; end

  # If a response includes an s-maxage directive, then for a shared
  # cache (but not for a private cache), the maximum age specified by
  # this directive overrides the maximum age specified by either the
  # max-age directive or the expires header. The s-maxage directive
  # also implies the semantics of the proxy-revalidate directive. i.e.,
  # that the shared cache must not use the entry after it becomes stale
  # to respond to a subsequent request without first revalidating it with
  # the origin server. The s-maxage directive is always ignored by a
  # private cache.
  #
  # source://rack-cache//lib/rack/cache/cache_control.rb#123
  def shared_max_age; end

  # source://rack-cache//lib/rack/cache/cache_control.rb#184
  def to_s; end

  private

  # source://rack-cache//lib/rack/cache/cache_control.rb#198
  def parse(value); end
end

# Implements Rack's middleware interface and provides the context for all
# cache logic, including the core logic engine.
#
# source://rack-cache//lib/rack/cache/context.rb#9
class Rack::Cache::Context
  include ::Rack::Cache::Options

  # @return [Context] a new instance of Context
  # @yield [_self]
  # @yieldparam _self [Rack::Cache::Context] the object that the method was called on
  #
  # source://rack-cache//lib/rack/cache/context.rb#18
  def initialize(backend, options = T.unsafe(nil)); end

  # The Rack application object immediately downstream.
  #
  # source://rack-cache//lib/rack/cache/context.rb#16
  def backend; end

  # The Rack call interface. The receiver acts as a prototype and runs
  # each request in a dup object unless the +rack.run_once+ variable is
  # set in the environment.
  #
  # source://rack-cache//lib/rack/cache/context.rb#48
  def call(env); end

  # The real Rack call interface. The caching logic is performed within
  # the context of the receiver.
  #
  # source://rack-cache//lib/rack/cache/context.rb#58
  def call!(env); end

  # The configured EntityStore instance. Changing the rack-cache.entitystore
  # value effects the result of this method immediately.
  #
  # source://rack-cache//lib/rack/cache/context.rb#40
  def entitystore; end

  # The configured MetaStore instance. Changing the rack-cache.metastore
  # value effects the result of this method immediately.
  #
  # source://rack-cache//lib/rack/cache/context.rb#33
  def metastore; end

  # Array of trace Symbols
  #
  # source://rack-cache//lib/rack/cache/context.rb#13
  def trace; end

  private

  # send no head requests because we want content
  #
  # source://rack-cache//lib/rack/cache/context.rb#322
  def convert_head_to_get!; end

  # The cache missed or a reload is required. Forward the request to the
  # backend and determine whether the response should be stored. This allows
  # conditional / validation requests through to the backend but performs no
  # caching of the response when the backend returns a 304.
  #
  # source://rack-cache//lib/rack/cache/context.rb#263
  def fetch; end

  # Delegate the request to the backend and create the response.
  #
  # source://rack-cache//lib/rack/cache/context.rb#140
  def forward; end

  # Whether the cache entry is "fresh enough" to satisfy the request.
  #
  # @return [Boolean]
  #
  # source://rack-cache//lib/rack/cache/context.rb#129
  def fresh_enough?(entry); end

  # Invalidate POST, PUT, DELETE and all methods not understood by this cache
  # See RFC2616 13.10
  #
  # source://rack-cache//lib/rack/cache/context.rb#153
  def invalidate; end

  # source://rack-cache//lib/rack/cache/context.rb#313
  def log(level, message); end

  # source://rack-cache//lib/rack/cache/context.rb#304
  def log_error(exception); end

  # source://rack-cache//lib/rack/cache/context.rb#309
  def log_info(message); end

  # Try to serve the response from cache. When a matching cache entry is
  # found and is fresh, use it as the response without forwarding any request
  # to the backend. When a matching cache entry is found but is stale, attempt
  # to #validate the entry with the backend using conditional GET.
  # If validation raises an exception and fault tolerant caching is enabled,
  # serve the stale cache entry.
  # When no matching cache entry is found, trigger miss processing.
  #
  # source://rack-cache//lib/rack/cache/context.rb#170
  def lookup; end

  # Determine if the #response validators (etag, last-modified) matches
  # a conditional value specified in #request.
  #
  # @return [Boolean]
  #
  # source://rack-cache//lib/rack/cache/context.rb#118
  def not_modified?(response); end

  # The request is sent to the backend, and the backend's response is sent
  # to the client, but is not entered into the cache.
  #
  # source://rack-cache//lib/rack/cache/context.rb#146
  def pass; end

  # Does the request include authorization or other sensitive information
  # that should cause the response to be considered private by default?
  # Private responses are not stored in the cache.
  #
  # @return [Boolean]
  #
  # source://rack-cache//lib/rack/cache/context.rb#112
  def private_request?; end

  # Record that an event took place.
  #
  # source://rack-cache//lib/rack/cache/context.rb#105
  def record(event); end

  # Write the response to the cache.
  #
  # source://rack-cache//lib/rack/cache/context.rb#287
  def store(response); end

  # Remove all ignored response headers before writing to the cache.
  #
  # source://rack-cache//lib/rack/cache/context.rb#299
  def strip_ignore_headers(response); end

  # Validate that the cache entry is fresh. The original request is used
  # as a template for a conditional GET request with the backend.
  #
  # source://rack-cache//lib/rack/cache/context.rb#214
  def validate(entry); end

  # Returns stale cache on exception.
  #
  # source://rack-cache//lib/rack/cache/context.rb#202
  def validate_with_stale_cache_failover(entry); end
end

# Entity stores are used to cache response bodies across requests. All
# Implementations are required to calculate a SHA checksum of the data written
# which becomes the response body's key.
#
# source://rack-cache//lib/rack/cache/entity_store.rb#8
class Rack::Cache::EntityStore
  private

  # source://rack-cache//lib/rack/cache/entity_store.rb#26
  def bytesize(string); end

  # Read body calculating the SHA1 checksum and size while
  # yielding each chunk to the block. If the body responds to close,
  # call it after iteration is complete. Return a two-tuple of the form:
  # [ hexdigest, size ].
  #
  # source://rack-cache//lib/rack/cache/entity_store.rb#14
  def slurp(body); end
end

# source://rack-cache//lib/rack/cache/entity_store.rb#168
Rack::Cache::EntityStore::DISK = Rack::Cache::EntityStore::Disk

# Uses the Dalli ruby library. This is the default unless
# the memcached library has already been required.
#
# source://rack-cache//lib/rack/cache/entity_store.rb#209
class Rack::Cache::EntityStore::Dalli < ::Rack::Cache::EntityStore::MemCacheBase
  # @return [Dalli] a new instance of Dalli
  #
  # source://rack-cache//lib/rack/cache/entity_store.rb#210
  def initialize(server = T.unsafe(nil), options = T.unsafe(nil)); end

  # @return [Boolean]
  #
  # source://rack-cache//lib/rack/cache/entity_store.rb#220
  def exist?(key); end

  # source://rack-cache//lib/rack/cache/entity_store.rb#236
  def purge(key); end

  # source://rack-cache//lib/rack/cache/entity_store.rb#224
  def read(key); end

  # source://rack-cache//lib/rack/cache/entity_store.rb#230
  def write(body, ttl = T.unsafe(nil)); end
end

# Stores entity bodies on disk at the specified path.
#
# source://rack-cache//lib/rack/cache/entity_store.rb#83
class Rack::Cache::EntityStore::Disk < ::Rack::Cache::EntityStore
  # @return [Disk] a new instance of Disk
  #
  # source://rack-cache//lib/rack/cache/entity_store.rb#90
  def initialize(root); end

  # @return [Boolean]
  #
  # source://rack-cache//lib/rack/cache/entity_store.rb#95
  def exist?(key); end

  # Open the entity body and return an IO object. The IO object's
  # each method is overridden to read 8K chunks instead of lines.
  #
  # source://rack-cache//lib/rack/cache/entity_store.rb#116
  def open(key); end

  # source://rack-cache//lib/rack/cache/entity_store.rb#140
  def purge(key); end

  # source://rack-cache//lib/rack/cache/entity_store.rb#99
  def read(key); end

  # Path where entities should be stored. This directory is
  # created the first time the store is instansiated if it does not
  # already exist.
  #
  # source://rack-cache//lib/rack/cache/entity_store.rb#88
  def root; end

  # source://rack-cache//lib/rack/cache/entity_store.rb#122
  def write(body, ttl = T.unsafe(nil)); end

  protected

  # source://rack-cache//lib/rack/cache/entity_store.rb#158
  def body_path(key); end

  # source://rack-cache//lib/rack/cache/entity_store.rb#152
  def spread(key); end

  # source://rack-cache//lib/rack/cache/entity_store.rb#148
  def storage_path(stem); end

  class << self
    # source://rack-cache//lib/rack/cache/entity_store.rb#162
    def resolve(uri); end
  end
end

# source://rack-cache//lib/rack/cache/entity_store.rb#105
class Rack::Cache::EntityStore::Disk::Body < ::File
  # source://rack-cache//lib/rack/cache/entity_store.rb#106
  def each; end

  def to_path; end
end

# source://rack-cache//lib/rack/cache/entity_store.rb#169
Rack::Cache::EntityStore::FILE = Rack::Cache::EntityStore::Disk

# source://rack-cache//lib/rack/cache/entity_store.rb#331
Rack::Cache::EntityStore::GAE = Rack::Cache::EntityStore::GAEStore

# source://rack-cache//lib/rack/cache/entity_store.rb#330
Rack::Cache::EntityStore::GAECACHE = Rack::Cache::EntityStore::GAEStore

# source://rack-cache//lib/rack/cache/entity_store.rb#288
class Rack::Cache::EntityStore::GAEStore < ::Rack::Cache::EntityStore
  # @return [GAEStore] a new instance of GAEStore
  #
  # source://rack-cache//lib/rack/cache/entity_store.rb#291
  def initialize(options = T.unsafe(nil)); end

  # Returns the value of attribute cache.
  #
  # source://rack-cache//lib/rack/cache/entity_store.rb#289
  def cache; end

  # @return [Boolean]
  #
  # source://rack-cache//lib/rack/cache/entity_store.rb#296
  def exist?(key); end

  # source://rack-cache//lib/rack/cache/entity_store.rb#304
  def open(key); end

  # source://rack-cache//lib/rack/cache/entity_store.rb#319
  def purge(key); end

  # source://rack-cache//lib/rack/cache/entity_store.rb#300
  def read(key); end

  # source://rack-cache//lib/rack/cache/entity_store.rb#312
  def write(body, ttl = T.unsafe(nil)); end

  class << self
    # source://rack-cache//lib/rack/cache/entity_store.rb#324
    def resolve(uri); end
  end
end

# source://rack-cache//lib/rack/cache/entity_store.rb#79
Rack::Cache::EntityStore::HEAP = Rack::Cache::EntityStore::Heap

# Stores entity bodies on the heap using a Hash object.
#
# source://rack-cache//lib/rack/cache/entity_store.rb#35
class Rack::Cache::EntityStore::Heap < ::Rack::Cache::EntityStore
  # Create the store with the specified backing Hash.
  #
  # @return [Heap] a new instance of Heap
  #
  # source://rack-cache//lib/rack/cache/entity_store.rb#37
  def initialize(hash = T.unsafe(nil), options = T.unsafe(nil)); end

  # Determine whether the response body with the specified key (SHA1)
  # exists in the store.
  #
  # @return [Boolean]
  #
  # source://rack-cache//lib/rack/cache/entity_store.rb#44
  def exist?(key); end

  # Return an object suitable for use as a Rack response body for the
  # specified key.
  #
  # source://rack-cache//lib/rack/cache/entity_store.rb#50
  def open(key); end

  # Remove the body corresponding to key; return nil.
  #
  # source://rack-cache//lib/rack/cache/entity_store.rb#69
  def purge(key); end

  # Read all data associated with the given key and return as a single
  # String.
  #
  # source://rack-cache//lib/rack/cache/entity_store.rb#56
  def read(key); end

  # Write the Rack response body immediately and return the SHA1 key.
  #
  # source://rack-cache//lib/rack/cache/entity_store.rb#61
  def write(body, ttl = T.unsafe(nil)); end

  class << self
    # source://rack-cache//lib/rack/cache/entity_store.rb#74
    def resolve(uri, options = T.unsafe(nil)); end
  end
end

# source://rack-cache//lib/rack/cache/entity_store.rb#80
Rack::Cache::EntityStore::MEM = Rack::Cache::EntityStore::Heap

# source://rack-cache//lib/rack/cache/entity_store.rb#285
Rack::Cache::EntityStore::MEMCACHE = Rack::Cache::EntityStore::Dalli

# source://rack-cache//lib/rack/cache/entity_store.rb#286
Rack::Cache::EntityStore::MEMCACHED = Rack::Cache::EntityStore::Dalli

# Base class for memcached entity stores.
#
# source://rack-cache//lib/rack/cache/entity_store.rb#172
class Rack::Cache::EntityStore::MemCacheBase < ::Rack::Cache::EntityStore
  extend ::Rack::Utils

  # The underlying Memcached instance used to communicate with the
  # memcached daemon.
  #
  # source://rack-cache//lib/rack/cache/entity_store.rb#175
  def cache; end

  # source://rack-cache//lib/rack/cache/entity_store.rb#179
  def open(key); end

  class << self
    # source://rack-cache//lib/rack/cache/entity_store.rb#184
    def resolve(uri); end
  end
end

# Uses the memcached client library. The ruby based memcache-client is used
# in preference to this store unless the memcached library has already been
# required.
#
# source://rack-cache//lib/rack/cache/entity_store.rb#245
class Rack::Cache::EntityStore::MemCached < ::Rack::Cache::EntityStore::MemCacheBase
  # @return [MemCached] a new instance of MemCached
  #
  # source://rack-cache//lib/rack/cache/entity_store.rb#246
  def initialize(server = T.unsafe(nil), options = T.unsafe(nil)); end

  # @return [Boolean]
  #
  # source://rack-cache//lib/rack/cache/entity_store.rb#257
  def exist?(key); end

  # source://rack-cache//lib/rack/cache/entity_store.rb#277
  def purge(key); end

  # source://rack-cache//lib/rack/cache/entity_store.rb#264
  def read(key); end

  # source://rack-cache//lib/rack/cache/entity_store.rb#270
  def write(body, ttl = T.unsafe(nil)); end
end

# source://rack-cache//lib/rack/cache/entity_store.rb#368
Rack::Cache::EntityStore::NOOP = Rack::Cache::EntityStore::Noop

# Noop Entity Store backend.
#
# Set `entitystore` to 'noop:/'.
# Does not persist response bodies (no disk/memory used).
# Responses from the cache will have an empty body.
# Clients must ignore these empty cached response (check for x-rack-cache response header).
# Atm cannot handle streamed responses, patch needed.
#
# source://rack-cache//lib/rack/cache/entity_store.rb#341
class Rack::Cache::EntityStore::Noop < ::Rack::Cache::EntityStore
  # @return [Boolean]
  #
  # source://rack-cache//lib/rack/cache/entity_store.rb#342
  def exist?(key); end

  # source://rack-cache//lib/rack/cache/entity_store.rb#350
  def open(key); end

  # source://rack-cache//lib/rack/cache/entity_store.rb#359
  def purge(key); end

  # source://rack-cache//lib/rack/cache/entity_store.rb#346
  def read(key); end

  # source://rack-cache//lib/rack/cache/entity_store.rb#354
  def write(body, ttl = T.unsafe(nil)); end

  class << self
    # source://rack-cache//lib/rack/cache/entity_store.rb#363
    def resolve(uri); end
  end
end

# source://rack-cache//lib/rack/cache/headers.rb#12
Rack::Cache::Headers = Rack::Utils::HeaderHash

# source://rack-cache//lib/rack/cache/key.rb#4
class Rack::Cache::Key
  include ::Rack::Utils

  # @return [Key] a new instance of Key
  #
  # source://rack-cache//lib/rack/cache/key.rb#28
  def initialize(request); end

  # Generate a normalized cache key for the request.
  #
  # source://rack-cache//lib/rack/cache/key.rb#33
  def generate; end

  private

  # Build a normalized query string by alphabetizing all keys/values
  # and applying consistent escaping.
  #
  # source://rack-cache//lib/rack/cache/key.rb#57
  def query_string; end

  class << self
    # Implement .call, since it seems like the "Rack-y" thing to do. Plus, it
    # opens the door for cache key generators to just be blocks.
    #
    # source://rack-cache//lib/rack/cache/key.rb#24
    def call(request); end

    # Returns the value of attribute query_string_ignore.
    #
    # source://rack-cache//lib/rack/cache/key.rb#19
    def query_string_ignore; end

    # Sets the attribute query_string_ignore
    #
    # @param value the value to set the attribute query_string_ignore to.
    #
    # source://rack-cache//lib/rack/cache/key.rb#19
    def query_string_ignore=(_arg0); end
  end
end

# The MetaStore is responsible for storing meta information about a
# request/response pair keyed by the request's URL.
#
# The meta store keeps a list of request/response pairs for each canonical
# request URL. A request/response pair is a two element Array of the form:
#   [request, response]
#
# The +request+ element is a Hash of Rack environment keys. Only protocol
# keys (i.e., those that start with "HTTP_") are stored. The +response+
# element is a Hash of cached HTTP response headers for the paired request.
#
# The MetaStore class is abstract and should not be instanstiated
# directly. Concrete subclasses should implement the protected #read,
# #write, and #purge methods. Care has been taken to keep these low-level
# methods dumb and straight-forward to implement.
#
# source://rack-cache//lib/rack/cache/meta_store.rb#23
class Rack::Cache::MetaStore
  # Generate a cache key for the request.
  #
  # source://rack-cache//lib/rack/cache/meta_store.rb#112
  def cache_key(request); end

  # Invalidate all cache entries that match the request.
  #
  # source://rack-cache//lib/rack/cache/meta_store.rb#118
  def invalidate(request, entity_store); end

  # Locate a cached response for the request provided. Returns a
  # Rack::Cache::Response object if the cache hits or nil if no cache entry
  # was found.
  #
  # source://rack-cache//lib/rack/cache/meta_store.rb#28
  def lookup(request, entity_store); end

  # Write a cache entry to the store under the given key. Existing
  # entries are read and any that match the response are removed.
  # This method calls #write with the new list of cache entries.
  #
  # source://rack-cache//lib/rack/cache/meta_store.rb#62
  def store(request, response, entity_store); end

  protected

  # Remove all cached entries at the key specified. No error is raised
  # when the key does not exist.
  #
  # @raise [NotImplementedError]
  #
  # source://rack-cache//lib/rack/cache/meta_store.rb#185
  def purge(key); end

  # Locate all cached request/response pairs that match the specified
  # URL key. The result must be an Array of all cached request/response
  # pairs. An empty Array must be returned if nothing is cached for
  # the specified key.
  #
  # @raise [NotImplementedError]
  #
  # source://rack-cache//lib/rack/cache/meta_store.rb#172
  def read(key); end

  # Store an Array of request/response pairs for the given key. Concrete
  # implementations should not attempt to filter or concatenate the
  # list in any way.
  #
  # @raise [NotImplementedError]
  #
  # source://rack-cache//lib/rack/cache/meta_store.rb#179
  def write(key, negotiations, ttl = T.unsafe(nil)); end

  private

  # Generate a SHA1 hex digest for the specified string. This is a
  # simple utility method for meta store implementations.
  #
  # source://rack-cache//lib/rack/cache/meta_store.rb#192
  def hexdigest(data); end

  # Extract the environment Hash from +request+ while making any
  # necessary modifications in preparation for persistence. The Hash
  # returned must be marshalable.
  #
  # source://rack-cache//lib/rack/cache/meta_store.rb#138
  def persist_request(request); end

  # source://rack-cache//lib/rack/cache/meta_store.rb#151
  def persist_response(response); end

  # Determine whether the two environment hashes are non-varying based on
  # the vary response header value provided.
  #
  # @return [Boolean]
  #
  # source://rack-cache//lib/rack/cache/meta_store.rb#159
  def requests_match?(vary, env1, env2); end

  # Converts a stored response hash into a Response object. The caller
  # is responsible for loading and passing the body if needed.
  #
  # source://rack-cache//lib/rack/cache/meta_store.rb#146
  def restore_response(hash, body = T.unsafe(nil)); end
end

# source://rack-cache//lib/rack/cache/meta_store.rb#289
Rack::Cache::MetaStore::DISK = Rack::Cache::MetaStore::Disk

# source://rack-cache//lib/rack/cache/meta_store.rb#334
class Rack::Cache::MetaStore::Dalli < ::Rack::Cache::MetaStore::MemCacheBase
  # @return [Dalli] a new instance of Dalli
  #
  # source://rack-cache//lib/rack/cache/meta_store.rb#335
  def initialize(server = T.unsafe(nil), options = T.unsafe(nil)); end

  # source://rack-cache//lib/rack/cache/meta_store.rb#356
  def purge(key); end

  # source://rack-cache//lib/rack/cache/meta_store.rb#345
  def read(key); end

  # Default TTL to zero, interpreted as "don't expire" by Memcached.
  #
  # source://rack-cache//lib/rack/cache/meta_store.rb#351
  def write(key, entries, ttl = T.unsafe(nil)); end
end

# Concrete MetaStore implementation that stores request/response
# pairs on disk.
#
# source://rack-cache//lib/rack/cache/meta_store.rb#236
class Rack::Cache::MetaStore::Disk < ::Rack::Cache::MetaStore
  # @return [Disk] a new instance of Disk
  #
  # source://rack-cache//lib/rack/cache/meta_store.rb#239
  def initialize(root = T.unsafe(nil)); end

  # source://rack-cache//lib/rack/cache/meta_store.rb#262
  def purge(key); end

  # source://rack-cache//lib/rack/cache/meta_store.rb#244
  def read(key); end

  # Returns the value of attribute root.
  #
  # source://rack-cache//lib/rack/cache/meta_store.rb#237
  def root; end

  # source://rack-cache//lib/rack/cache/meta_store.rb#251
  def write(key, entries, ttl = T.unsafe(nil)); end

  private

  # source://rack-cache//lib/rack/cache/meta_store.rb#271
  def key_path(key); end

  # source://rack-cache//lib/rack/cache/meta_store.rb#275
  def spread(sha, n = T.unsafe(nil)); end

  class << self
    # source://rack-cache//lib/rack/cache/meta_store.rb#282
    def resolve(uri); end
  end
end

# source://rack-cache//lib/rack/cache/meta_store.rb#290
Rack::Cache::MetaStore::FILE = Rack::Cache::MetaStore::Disk

# source://rack-cache//lib/rack/cache/meta_store.rb#439
Rack::Cache::MetaStore::GAE = Rack::Cache::MetaStore::GAEStore

# source://rack-cache//lib/rack/cache/meta_store.rb#438
Rack::Cache::MetaStore::GAECACHE = Rack::Cache::MetaStore::GAEStore

# source://rack-cache//lib/rack/cache/meta_store.rb#408
class Rack::Cache::MetaStore::GAEStore < ::Rack::Cache::MetaStore
  # @return [GAEStore] a new instance of GAEStore
  #
  # source://rack-cache//lib/rack/cache/meta_store.rb#411
  def initialize(options = T.unsafe(nil)); end

  # Returns the value of attribute cache.
  #
  # source://rack-cache//lib/rack/cache/meta_store.rb#409
  def cache; end

  # source://rack-cache//lib/rack/cache/meta_store.rb#426
  def purge(key); end

  # source://rack-cache//lib/rack/cache/meta_store.rb#416
  def read(key); end

  # source://rack-cache//lib/rack/cache/meta_store.rb#421
  def write(key, entries); end

  class << self
    # source://rack-cache//lib/rack/cache/meta_store.rb#432
    def resolve(uri); end
  end
end

# source://rack-cache//lib/rack/cache/meta_store.rb#231
Rack::Cache::MetaStore::HEAP = Rack::Cache::MetaStore::Heap

# Concrete MetaStore implementation that uses a simple Hash to store
# request/response pairs on the heap.
#
# source://rack-cache//lib/rack/cache/meta_store.rb#199
class Rack::Cache::MetaStore::Heap < ::Rack::Cache::MetaStore
  # @return [Heap] a new instance of Heap
  #
  # source://rack-cache//lib/rack/cache/meta_store.rb#200
  def initialize(hash = T.unsafe(nil), options = T.unsafe(nil)); end

  # source://rack-cache//lib/rack/cache/meta_store.rb#217
  def purge(key); end

  # source://rack-cache//lib/rack/cache/meta_store.rb#205
  def read(key); end

  # source://rack-cache//lib/rack/cache/meta_store.rb#222
  def to_hash; end

  # source://rack-cache//lib/rack/cache/meta_store.rb#213
  def write(key, entries, ttl = T.unsafe(nil)); end

  class << self
    # source://rack-cache//lib/rack/cache/meta_store.rb#226
    def resolve(uri, options = T.unsafe(nil)); end
  end
end

# source://rack-cache//lib/rack/cache/meta_store.rb#232
Rack::Cache::MetaStore::MEM = Rack::Cache::MetaStore::Heap

# source://rack-cache//lib/rack/cache/meta_store.rb#400
Rack::Cache::MetaStore::MEMCACHE = Rack::Cache::MetaStore::Dalli

# source://rack-cache//lib/rack/cache/meta_store.rb#406
Rack::Cache::MetaStore::MEMCACHED = Rack::Cache::MetaStore::Dalli

# Stores request/response pairs in memcached. Keys are not stored
# directly since memcached has a 250-byte limit on key names. Instead,
# the SHA1 hexdigest of the key is used.
#
# source://rack-cache//lib/rack/cache/meta_store.rb#295
class Rack::Cache::MetaStore::MemCacheBase < ::Rack::Cache::MetaStore
  extend ::Rack::Utils

  # The MemCache object used to communicated with the memcached
  # daemon.
  #
  # source://rack-cache//lib/rack/cache/meta_store.rb#300
  def cache; end

  class << self
    # Create MemCache store for the given URI. The URI must specify
    # a host and may specify a port, namespace, and options:
    #
    # memcached://example.com:11211/namespace?opt1=val1&opt2=val2
    #
    # Query parameter names and values are documented with the memcached
    # library: http://tinyurl.com/4upqnd
    #
    # source://rack-cache//lib/rack/cache/meta_store.rb#309
    def resolve(uri); end
  end
end

# source://rack-cache//lib/rack/cache/meta_store.rb#362
class Rack::Cache::MetaStore::MemCached < ::Rack::Cache::MetaStore::MemCacheBase
  # @return [MemCached] a new instance of MemCached
  #
  # source://rack-cache//lib/rack/cache/meta_store.rb#367
  def initialize(server = T.unsafe(nil), options = T.unsafe(nil)); end

  # The Memcached instance used to communicated with the memcached
  # daemon.
  #
  # source://rack-cache//lib/rack/cache/meta_store.rb#365
  def cache; end

  # source://rack-cache//lib/rack/cache/meta_store.rb#391
  def purge(key); end

  # source://rack-cache//lib/rack/cache/meta_store.rb#378
  def read(key); end

  # Default TTL to zero, interpreted as "don't expire" by Memcached.
  #
  # source://rack-cache//lib/rack/cache/meta_store.rb#386
  def write(key, entries, ttl = T.unsafe(nil)); end
end

# Configuration options and utility methods for option access. Rack::Cache
# uses the Rack Environment to store option values. All options documented
# below are stored in the Rack Environment as "rack-cache.<option>", where
# <option> is the option name.
#
# source://rack-cache//lib/rack/cache/options.rb#10
module Rack::Cache::Options
  extend ::Rack::Cache::Options

  # source://rack-cache//lib/rack/cache/options.rb#15
  def allow_reload; end

  # source://rack-cache//lib/rack/cache/options.rb#16
  def allow_reload=(value); end

  # source://rack-cache//lib/rack/cache/options.rb#17
  def allow_reload?; end

  # source://rack-cache//lib/rack/cache/options.rb#15
  def allow_revalidate; end

  # source://rack-cache//lib/rack/cache/options.rb#16
  def allow_revalidate=(value); end

  # source://rack-cache//lib/rack/cache/options.rb#17
  def allow_revalidate?; end

  # source://rack-cache//lib/rack/cache/options.rb#15
  def cache_key; end

  # source://rack-cache//lib/rack/cache/options.rb#16
  def cache_key=(value); end

  # source://rack-cache//lib/rack/cache/options.rb#17
  def cache_key?; end

  # source://rack-cache//lib/rack/cache/options.rb#15
  def compress; end

  # source://rack-cache//lib/rack/cache/options.rb#16
  def compress=(value); end

  # source://rack-cache//lib/rack/cache/options.rb#17
  def compress?; end

  # source://rack-cache//lib/rack/cache/options.rb#15
  def default_ttl; end

  # source://rack-cache//lib/rack/cache/options.rb#16
  def default_ttl=(value); end

  # source://rack-cache//lib/rack/cache/options.rb#17
  def default_ttl?; end

  # source://rack-cache//lib/rack/cache/options.rb#15
  def entitystore; end

  # source://rack-cache//lib/rack/cache/options.rb#16
  def entitystore=(value); end

  # source://rack-cache//lib/rack/cache/options.rb#17
  def entitystore?; end

  # source://rack-cache//lib/rack/cache/options.rb#15
  def fault_tolerant; end

  # source://rack-cache//lib/rack/cache/options.rb#16
  def fault_tolerant=(value); end

  # source://rack-cache//lib/rack/cache/options.rb#17
  def fault_tolerant?; end

  # source://rack-cache//lib/rack/cache/options.rb#15
  def ignore_headers; end

  # source://rack-cache//lib/rack/cache/options.rb#16
  def ignore_headers=(value); end

  # source://rack-cache//lib/rack/cache/options.rb#17
  def ignore_headers?; end

  # source://rack-cache//lib/rack/cache/options.rb#15
  def metastore; end

  # source://rack-cache//lib/rack/cache/options.rb#16
  def metastore=(value); end

  # source://rack-cache//lib/rack/cache/options.rb#17
  def metastore?; end

  # The underlying options Hash. During initialization (or outside of a
  # request), this is a default values Hash. During a request, this is the
  # Rack environment Hash. The default values Hash is merged in underneath
  # the Rack environment before each request is processed.
  #
  # source://rack-cache//lib/rack/cache/options.rb#118
  def options; end

  # Set multiple options.
  #
  # source://rack-cache//lib/rack/cache/options.rb#123
  def options=(hash = T.unsafe(nil)); end

  # source://rack-cache//lib/rack/cache/options.rb#15
  def private_headers; end

  # source://rack-cache//lib/rack/cache/options.rb#16
  def private_headers=(value); end

  # source://rack-cache//lib/rack/cache/options.rb#17
  def private_headers?; end

  # Set an option. When +option+ is a Symbol, it is set in the Rack
  # Environment as "rack-cache.option". When +option+ is a String, it
  # exactly as specified. The +option+ argument may also be a Hash in
  # which case each key/value pair is merged into the environment as if
  # the #set method were called on each.
  #
  # source://rack-cache//lib/rack/cache/options.rb#132
  def set(option, value = T.unsafe(nil), &block); end

  # source://rack-cache//lib/rack/cache/options.rb#15
  def storage; end

  # source://rack-cache//lib/rack/cache/options.rb#16
  def storage=(value); end

  # source://rack-cache//lib/rack/cache/options.rb#17
  def storage?; end

  # source://rack-cache//lib/rack/cache/options.rb#15
  def use_native_ttl; end

  # source://rack-cache//lib/rack/cache/options.rb#16
  def use_native_ttl=(value); end

  # source://rack-cache//lib/rack/cache/options.rb#17
  def use_native_ttl?; end

  # source://rack-cache//lib/rack/cache/options.rb#15
  def verbose; end

  # source://rack-cache//lib/rack/cache/options.rb#16
  def verbose=(value); end

  # source://rack-cache//lib/rack/cache/options.rb#17
  def verbose?; end

  private

  # source://rack-cache//lib/rack/cache/options.rb#143
  def initialize_options(options = T.unsafe(nil)); end

  # source://rack-cache//lib/rack/cache/options.rb#20
  def option_name(key); end

  # source://rack-cache//lib/rack/cache/options.rb#161
  def read_option(key); end

  # source://rack-cache//lib/rack/cache/options.rb#165
  def write_option(key, value); end

  class << self
    # source://rack-cache//lib/rack/cache/options.rb#13
    def option_accessor(key); end

    # source://rack-cache//lib/rack/cache/options.rb#20
    def option_name(key); end
  end
end

# Provides access to the HTTP request. The +request+ and +original_request+
# objects exposed by the Core caching engine are instances of this class.
#
# Request objects respond to a variety of convenience methods, including
# everything defined by Rack::Request as well as the Headers and
# RequestHeaders modules.
#
# source://rack-cache//lib/rack/cache/request.rb#12
class Rack::Cache::Request < ::Rack::Request
  # A CacheControl instance based on the request's cache-control header.
  #
  # source://rack-cache//lib/rack/cache/request.rb#22
  def cache_control; end

  # True when the cache-control/no-cache directive is present or the
  # Pragma header is set to no-cache.
  #
  # @return [Boolean]
  #
  # source://rack-cache//lib/rack/cache/request.rb#28
  def no_cache?; end

  # The HTTP request method. This is the standard implementation of this
  # method but is respecified here due to libraries that attempt to modify
  # the behavior to respect POST tunnel method specifiers. We always want
  # the real request method.
  #
  # source://rack-cache//lib/rack/cache/request.rb#17
  def request_method; end
end

# Provides access to the response generated by the downstream application. The
# +response+, +original_response+, and +entry+ objects exposed by the Core
# caching engine are instances of this class.
#
# Response objects respond to a variety of convenience methods, including
# those defined in Rack::Response::Helpers, Rack::Cache::Headers,
# and Rack::Cache::ResponseHeaders.
#
# Note that Rack::Cache::Response is not a subclass of Rack::Response and does
# not perform many of the same initialization and finalization tasks. For
# example, the body is not slurped during initialization and there are no
# facilities for generating response output.
#
# source://rack-cache//lib/rack/cache/response.rb#21
class Rack::Cache::Response
  include ::Rack::Response::Helpers

  # Create a Response instance given the response status code, header hash,
  # and body.
  #
  # @return [Response] a new instance of Response
  #
  # source://rack-cache//lib/rack/cache/response.rb#32
  def initialize(status, headers, body); end

  # The age of the response.
  #
  # source://rack-cache//lib/rack/cache/response.rb#152
  def age; end

  # Rack response tuple accessors.
  #
  # source://rack-cache//lib/rack/cache/response.rb#25
  def body; end

  # Rack response tuple accessors.
  #
  # source://rack-cache//lib/rack/cache/response.rb#25
  def body=(_arg0); end

  # A Hash of name=value pairs that correspond to the cache-control header.
  # Valueless parameters (e.g., must-revalidate, no-store) have a Hash value
  # of true. This method always returns a Hash, empty if no cache-control
  # header is present.
  #
  # source://rack-cache//lib/rack/cache/response.rb#69
  def cache_control; end

  # Set the cache-control header to the values specified by the Hash. See
  # the #cache_control method for information on expected Hash structure.
  #
  # source://rack-cache//lib/rack/cache/response.rb#75
  def cache_control=(value); end

  # Determine if the response is worth caching under any circumstance. Responses
  # marked "private" with an explicit cache-control directive are considered
  # uncacheable
  #
  # Responses with neither a freshness lifetime (expires, max-age) nor cache
  # validator (last-modified, etag) are considered uncacheable.
  #
  # @return [Boolean]
  #
  # source://rack-cache//lib/rack/cache/response.rb#103
  def cacheable?; end

  # Set the response's time-to-live for private/client caches. This adjusts
  # the cache-control/max-age directive.
  #
  # source://rack-cache//lib/rack/cache/response.rb#209
  def client_ttl=(seconds); end

  # The date, as specified by the Date header. When no Date header is present
  # or is unparseable, set the Date header to Time.now and return.
  #
  # source://rack-cache//lib/rack/cache/response.rb#139
  def date; end

  # The literal value of etag HTTP header or nil if no etag is specified.
  #
  # source://rack-cache//lib/rack/cache/response.rb#220
  def etag; end

  # Mark the response stale by setting the Age header to be equal to the
  # maximum age of the response.
  #
  # source://rack-cache//lib/rack/cache/response.rb#133
  def expire!; end

  # The value of the expires header as a Time object.
  #
  # source://rack-cache//lib/rack/cache/response.rb#169
  def expires; end

  # Determine if the response is "fresh". Fresh responses may be served from
  # cache without any interaction with the origin. A response is considered
  # fresh when it includes a cache-control/max-age indicator or Expiration
  # header and the calculated age is less than the freshness lifetime.
  #
  # @return [Boolean]
  #
  # source://rack-cache//lib/rack/cache/response.rb#93
  def fresh?; end

  # Rack response tuple accessors.
  #
  # source://rack-cache//lib/rack/cache/response.rb#25
  def headers; end

  # Rack response tuple accessors.
  #
  # source://rack-cache//lib/rack/cache/response.rb#25
  def headers=(_arg0); end

  # The String value of the last-modified header exactly as it appears
  # in the response (i.e., no date parsing / conversion is performed).
  #
  # source://rack-cache//lib/rack/cache/response.rb#215
  def last_modified; end

  # The number of seconds after the time specified in the response's Date
  # header when the the response should no longer be considered fresh. First
  # check for a r-maxage directive, then a s-maxage directive, then a max-age
  # directive, and then fall back on an expires header; return nil when no
  # maximum age can be established.
  #
  # source://rack-cache//lib/rack/cache/response.rb#161
  def max_age; end

  # The number of seconds after which the response should no longer
  # be considered fresh. Sets the cache-control max-age directive.
  #
  # source://rack-cache//lib/rack/cache/response.rb#177
  def max_age=(value); end

  # Indicates that the cache must not serve a stale response in any
  # circumstance without first revalidating with the origin. When present,
  # the TTL of the response should not be overriden to be greater than the
  # value provided by the origin.
  #
  # @return [Boolean]
  #
  # source://rack-cache//lib/rack/cache/response.rb#127
  def must_revalidate?; end

  # Modify the response so that it conforms to the rules defined for
  # '304 Not Modified'. This sets the status, removes the body, and
  # discards any headers that MUST NOT be included in 304 responses.
  #
  # http://tools.ietf.org/html/rfc2616#section-10.3.5
  #
  # source://rack-cache//lib/rack/cache/response.rb#242
  def not_modified!; end

  # The time when the Response object was instantiated.
  #
  # source://rack-cache//lib/rack/cache/response.rb#28
  def now; end

  # Mark the response "private", making it ineligible for serving other
  # clients.
  #
  # source://rack-cache//lib/rack/cache/response.rb#117
  def private=(value); end

  # Like #shared_max_age= but sets the r-maxage directive, which applies only
  # to reverse caches.
  #
  # source://rack-cache//lib/rack/cache/response.rb#189
  def reverse_max_age=(value); end

  # Like #max_age= but sets the s-maxage directive, which applies only
  # to shared caches.
  #
  # source://rack-cache//lib/rack/cache/response.rb#183
  def shared_max_age=(value); end

  # Rack response tuple accessors.
  #
  # source://rack-cache//lib/rack/cache/response.rb#25
  def status; end

  # Rack response tuple accessors.
  #
  # source://rack-cache//lib/rack/cache/response.rb#25
  def status=(_arg0); end

  # Return the status, headers, and body in a three-tuple.
  #
  # source://rack-cache//lib/rack/cache/response.rb#47
  def to_a; end

  # The response's time-to-live in seconds, or nil when no freshness
  # information is present in the response. When the responses #ttl
  # is <= 0, the response may not be served from cache without first
  # revalidating with the origin.
  #
  # source://rack-cache//lib/rack/cache/response.rb#197
  def ttl; end

  # Set the response's time-to-live for shared caches to the specified number
  # of seconds. This adjusts the cache-control/s-maxage directive.
  #
  # source://rack-cache//lib/rack/cache/response.rb#203
  def ttl=(seconds); end

  # Determine if the response includes headers that can be used to validate
  # the response with the origin using a conditional GET request.
  #
  # @return [Boolean]
  #
  # source://rack-cache//lib/rack/cache/response.rb#111
  def validateable?; end

  # The literal value of the vary header, or nil when no header is present.
  #
  # source://rack-cache//lib/rack/cache/response.rb#251
  def vary; end

  # Does the response include a vary header?
  #
  # @return [Boolean]
  #
  # source://rack-cache//lib/rack/cache/response.rb#256
  def vary?; end

  # An array of header names given in the vary header or an empty
  # array when no vary header is present.
  #
  # source://rack-cache//lib/rack/cache/response.rb#262
  def vary_header_names; end

  private

  # source://rack-cache//lib/rack/cache/response.rb#40
  def initialize_copy(other); end
end

# Status codes of responses that MAY be stored by a cache or used in reply
# to a subsequent request.
#
# http://tools.ietf.org/html/rfc2616#section-13.4
#
# source://rack-cache//lib/rack/cache/response.rb#55
Rack::Cache::Response::CACHEABLE_RESPONSE_CODES = T.let(T.unsafe(nil), Set)

# Headers that MUST NOT be included with 304 Not Modified responses.
#
# http://tools.ietf.org/html/rfc2616#section-10.3.5
#
# source://rack-cache//lib/rack/cache/response.rb#227
Rack::Cache::Response::NOT_MODIFIED_OMIT_HEADERS = T.let(T.unsafe(nil), Set)

# Maintains a collection of MetaStore and EntityStore instances keyed by
# URI. A single instance of this class can be used across a single process
# to ensure that only a single instance of a backing store is created per
# unique storage URI.
#
# source://rack-cache//lib/rack/cache/storage.rb#11
class Rack::Cache::Storage
  # @return [Storage] a new instance of Storage
  #
  # source://rack-cache//lib/rack/cache/storage.rb#12
  def initialize; end

  # source://rack-cache//lib/rack/cache/storage.rb#25
  def clear; end

  # source://rack-cache//lib/rack/cache/storage.rb#21
  def resolve_entitystore_uri(uri, options = T.unsafe(nil)); end

  # source://rack-cache//lib/rack/cache/storage.rb#17
  def resolve_metastore_uri(uri, options = T.unsafe(nil)); end

  private

  # source://rack-cache//lib/rack/cache/storage.rb#33
  def create_store(type, uri, options = T.unsafe(nil)); end

  class << self
    # source://rack-cache//lib/rack/cache/storage.rb#60
    def instance; end
  end
end
