# This file is autogenerated. Do not edit it by hand. Regenerate it with:
#   srb rbi gems

# typed: false
#
# If you would like to make changes to this file, great! Please create the gem's shim here:
#
#   https://github.com/sorbet/sorbet-typed/new/master?filename=lib/rbs/all/rbs.rbi
#
# rbs-2.8.4

module RBS
  def self.logger; end
  def self.logger_level; end
  def self.logger_level=(level); end
  def self.logger_output; end
  def self.logger_output=(val); end
  def self.print_warning; end
end
module RBS::MethodNameHelper
  def method_name_string; end
end
class RBS::BaseError < StandardError
end
class RBS::LoadingError < RBS::BaseError
end
class RBS::DefinitionError < RBS::BaseError
end
class RBS::ParsingError < RBS::BaseError
  def error_message; end
  def error_value; end
  def initialize(location, error_message, token_type); end
  def location; end
  def token_str; end
  def token_type; end
end
class RBS::InvalidTypeApplicationError < RBS::DefinitionError
  def args; end
  def initialize(type_name:, args:, params:, location:); end
  def location; end
  def params; end
  def self.check!(type_name:, args:, params:, location:); end
  def type_name; end
end
class RBS::RecursiveAncestorError < RBS::DefinitionError
  def ancestors; end
  def initialize(ancestors:, location:); end
  def location; end
  def self.check!(self_ancestor, ancestors:, location:); end
end
class RBS::NoTypeFoundError < RBS::BaseError
  def initialize(type_name:, location:); end
  def location; end
  def self.check!(type_name, env:, location:); end
  def type_name; end
end
class RBS::NoSuperclassFoundError < RBS::DefinitionError
  def initialize(type_name:, location:); end
  def location; end
  def self.check!(type_name, env:, location:); end
  def type_name; end
end
class RBS::InheritModuleError < RBS::DefinitionError
  def initialize(super_decl); end
  def self.check!(super_decl, env:); end
  def super_decl; end
end
class RBS::NoSelfTypeFoundError < RBS::DefinitionError
  def initialize(type_name:, location:); end
  def location; end
  def self.check!(self_type, env:); end
  def type_name; end
end
class RBS::NoMixinFoundError < RBS::DefinitionError
  def initialize(type_name:, member:); end
  def location; end
  def member; end
  def self.check!(type_name, env:, member:); end
  def type_name; end
end
class RBS::DuplicatedMethodDefinitionError < RBS::DefinitionError
  def initialize(type:, method_name:, members:); end
  def location; end
  def members; end
  def method_name; end
  def other_locations; end
  def qualified_method_name; end
  def type; end
  def type_name; end
end
class RBS::DuplicatedInterfaceMethodDefinitionError < RBS::DefinitionError
  def initialize(type:, method_name:, member:); end
  def member; end
  def method_name; end
  def qualified_method_name; end
  def type; end
  def type_name; end
end
class RBS::UnknownMethodAliasError < RBS::DefinitionError
  def aliased_name; end
  def initialize(type_name:, original_name:, aliased_name:, location:); end
  def location; end
  def original_name; end
  def type_name; end
end
class RBS::SuperclassMismatchError < RBS::DefinitionError
  def entry; end
  def initialize(name:, entry:); end
  def name; end
end
class RBS::InvalidOverloadMethodError < RBS::DefinitionError
  def initialize(type_name:, method_name:, kind:, members:); end
  def kind; end
  def members; end
  def method_name; end
  def type_name; end
end
class RBS::GenericParameterMismatchError < RBS::LoadingError
  def decl; end
  def initialize(name:, decl:); end
  def name; end
end
class RBS::DuplicatedDeclarationError < RBS::LoadingError
  def decls; end
  def initialize(name, *decls); end
  def name; end
end
class RBS::InvalidVarianceAnnotationError < RBS::DefinitionError
  def initialize(type_name:, param:, location:); end
  def location; end
  def param; end
  def type_name; end
end
class RBS::RecursiveAliasDefinitionError < RBS::DefinitionError
  def defs; end
  def initialize(type:, defs:); end
  def location; end
  def type; end
end
class RBS::MixinClassError < RBS::DefinitionError
  def initialize(type_name:, member:); end
  def location; end
  def member; end
  def mixin_name; end
  def self.check!(type_name:, env:, member:); end
  def type_name; end
end
class RBS::RecursiveTypeAliasError < RBS::BaseError
  def alias_names; end
  def initialize(alias_names:, location:); end
  def location; end
  def name; end
end
class RBS::NonregularTypeAliasError < RBS::BaseError
  def diagnostic; end
  def initialize(diagnostic:, location:); end
  def location; end
end
class RBS::CyclicTypeParameterBound < RBS::BaseError
  def initialize(type_name:, method_name:, params:, location:); end
  def location; end
  def method_name; end
  def params; end
  def type_name; end
end
class RBS::Buffer
  def content; end
  def initialize(name:, content:); end
  def inspect; end
  def last_position; end
  def lines; end
  def loc_to_pos(loc); end
  def name; end
  def pos_to_loc(pos); end
  def ranges; end
end
class RBS::Namespace
  def +(other); end
  def ==(other); end
  def absolute!; end
  def absolute?; end
  def append(component); end
  def ascend; end
  def empty?; end
  def eql?(other); end
  def hash; end
  def initialize(path:, absolute:); end
  def parent; end
  def path; end
  def relative!; end
  def relative?; end
  def self.empty; end
  def self.parse(string); end
  def self.root; end
  def split; end
  def to_s; end
  def to_type_name; end
end
module Kernel
  def Namespace(name); end
  def TypeName(string); end
end
class RBS::TypeName
  def +(other); end
  def ==(other); end
  def absolute!; end
  def absolute?; end
  def alias?; end
  def class?; end
  def eql?(other); end
  def hash; end
  def initialize(namespace:, name:); end
  def interface?; end
  def kind; end
  def name; end
  def namespace; end
  def relative!; end
  def split; end
  def to_json(state = nil); end
  def to_namespace; end
  def to_s; end
  def with_prefix(namespace); end
end
module RBS::Types
end
module RBS::Types::NoFreeVariables
  def free_variables(set = nil); end
end
module RBS::Types::NoSubst
  def sub(s); end
end
module RBS::Types::NoTypeName
  def map_type_name; end
end
module RBS::Types::EmptyEachType
  def each_type; end
  def map_type(&block); end
end
module RBS::Types::Bases
end
class RBS::Types::Bases::Base
  def ==(other); end
  def eql?(other); end
  def hash; end
  def initialize(location:); end
  def location; end
  def to_json(state = nil); end
  def to_s(level = nil); end
  include RBS::Types::EmptyEachType
  include RBS::Types::NoFreeVariables
  include RBS::Types::NoSubst
  include RBS::Types::NoTypeName
end
class RBS::Types::Bases::Bool < RBS::Types::Bases::Base
end
class RBS::Types::Bases::Void < RBS::Types::Bases::Base
end
class RBS::Types::Bases::Any < RBS::Types::Bases::Base
end
class RBS::Types::Bases::Nil < RBS::Types::Bases::Base
end
class RBS::Types::Bases::Top < RBS::Types::Bases::Base
end
class RBS::Types::Bases::Bottom < RBS::Types::Bases::Base
end
class RBS::Types::Bases::Self < RBS::Types::Bases::Base
end
class RBS::Types::Bases::Instance < RBS::Types::Bases::Base
  def sub(s); end
end
class RBS::Types::Bases::Class < RBS::Types::Bases::Base
end
class RBS::Types::Variable
  def ==(other); end
  def eql?(other); end
  def free_variables(set = nil); end
  def hash; end
  def initialize(name:, location:); end
  def location; end
  def name; end
  def self.build(v); end
  def self.fresh(v = nil); end
  def sub(s); end
  def to_json(state = nil); end
  def to_s(level = nil); end
  include RBS::Types::EmptyEachType
  include RBS::Types::NoTypeName
end
class RBS::Types::ClassSingleton
  def ==(other); end
  def eql?(other); end
  def hash; end
  def initialize(name:, location:); end
  def location; end
  def map_type_name; end
  def name; end
  def to_json(state = nil); end
  def to_s(level = nil); end
  include RBS::Types::EmptyEachType
  include RBS::Types::NoFreeVariables
  include RBS::Types::NoSubst
end
module RBS::Types::Application
  def ==(other); end
  def args; end
  def each_type(&block); end
  def eql?(other); end
  def free_variables(set = nil); end
  def hash; end
  def name; end
  def to_s(level = nil); end
end
class RBS::Types::Interface
  def initialize(name:, args:, location:); end
  def location; end
  def map_type(&block); end
  def map_type_name(&block); end
  def sub(s); end
  def to_json(state = nil); end
  include RBS::Types::Application
end
class RBS::Types::ClassInstance
  def initialize(name:, args:, location:); end
  def location; end
  def map_type(&block); end
  def map_type_name(&block); end
  def sub(s); end
  def to_json(state = nil); end
  include RBS::Types::Application
end
class RBS::Types::Alias
  def initialize(name:, args:, location:); end
  def location; end
  def map_type(&block); end
  def map_type_name(&block); end
  def sub(s); end
  def to_json(state = nil); end
  include RBS::Types::Application
end
class RBS::Types::Tuple
  def ==(other); end
  def each_type(&block); end
  def eql?(other); end
  def free_variables(set = nil); end
  def hash; end
  def initialize(types:, location:); end
  def location; end
  def map_type(&block); end
  def map_type_name(&block); end
  def sub(s); end
  def to_json(state = nil); end
  def to_s(level = nil); end
  def types; end
end
class RBS::Types::Record
  def ==(other); end
  def each_type(&block); end
  def eql?(other); end
  def fields; end
  def free_variables(set = nil); end
  def hash; end
  def initialize(fields:, location:); end
  def location; end
  def map_type(&block); end
  def map_type_name(&block); end
  def sub(s); end
  def to_json(state = nil); end
  def to_s(level = nil); end
end
class RBS::Types::Optional
  def ==(other); end
  def each_type; end
  def eql?(other); end
  def free_variables(set = nil); end
  def hash; end
  def initialize(type:, location:); end
  def location; end
  def map_type(&block); end
  def map_type_name(&block); end
  def sub(s); end
  def to_json(state = nil); end
  def to_s(level = nil); end
  def type; end
end
class RBS::Types::Union
  def ==(other); end
  def each_type(&block); end
  def eql?(other); end
  def free_variables(set = nil); end
  def hash; end
  def initialize(types:, location:); end
  def location; end
  def map_type(&block); end
  def map_type_name(&block); end
  def sub(s); end
  def to_json(state = nil); end
  def to_s(level = nil); end
  def types; end
end
class RBS::Types::Intersection
  def ==(other); end
  def each_type(&block); end
  def eql?(other); end
  def free_variables(set = nil); end
  def hash; end
  def initialize(types:, location:); end
  def location; end
  def map_type(&block); end
  def map_type_name(&block); end
  def sub(s); end
  def to_json(state = nil); end
  def to_s(level = nil); end
  def types; end
end
class RBS::Types::Function
  def ==(other); end
  def amap(array, &block); end
  def drop_head; end
  def drop_tail; end
  def each_param(&block); end
  def each_type; end
  def empty?; end
  def eql?(other); end
  def free_variables(set = nil); end
  def has_keyword?; end
  def hash; end
  def hmapv(hash, &block); end
  def initialize(required_positionals:, optional_positionals:, rest_positionals:, trailing_positionals:, required_keywords:, optional_keywords:, rest_keywords:, return_type:); end
  def map_type(&block); end
  def map_type_name(&block); end
  def optional_keywords; end
  def optional_positionals; end
  def param_to_s; end
  def required_keywords; end
  def required_positionals; end
  def rest_keywords; end
  def rest_positionals; end
  def return_to_s; end
  def return_type; end
  def self.empty(return_type); end
  def sub(s); end
  def to_json(state = nil); end
  def trailing_positionals; end
  def update(required_positionals: nil, optional_positionals: nil, rest_positionals: nil, trailing_positionals: nil, required_keywords: nil, optional_keywords: nil, rest_keywords: nil, return_type: nil); end
  def with_return_type(type); end
end
class RBS::Types::Function::Param
  def ==(other); end
  def eql?(other); end
  def hash; end
  def initialize(type:, name:, location: nil); end
  def location; end
  def map_type(&block); end
  def name; end
  def to_json(state = nil); end
  def to_s; end
  def type; end
end
class RBS::Types::Block
  def ==(other); end
  def initialize(type:, required:, self_type: nil); end
  def map_type(&block); end
  def required; end
  def self_type; end
  def sub(s); end
  def to_json(state = nil); end
  def type; end
end
module RBS::Types::SelfTypeBindingHelper
  def self.self_type_binding_to_s(t); end
  def self_type_binding_to_s(t); end
end
class RBS::Types::Proc
  def ==(other); end
  def block; end
  def each_type(&block); end
  def eql?(other); end
  def free_variables(set = nil); end
  def hash; end
  def initialize(location:, type:, block:, self_type: nil); end
  def location; end
  def map_type(&block); end
  def map_type_name(&block); end
  def self_type; end
  def sub(s); end
  def to_json(state = nil); end
  def to_s(level = nil); end
  def type; end
end
class RBS::Types::Literal
  def ==(other); end
  def eql?(other); end
  def hash; end
  def initialize(literal:, location:); end
  def literal; end
  def location; end
  def to_json(state = nil); end
  def to_s(level = nil); end
  include RBS::Types::EmptyEachType
  include RBS::Types::NoFreeVariables
  include RBS::Types::NoSubst
  include RBS::Types::NoTypeName
end
class RBS::MethodType
  def ==(other); end
  def block; end
  def each_type(&block); end
  def free_variables(set = nil); end
  def initialize(type_params:, type:, block:, location:); end
  def location; end
  def map_type(&block); end
  def map_type_bound(&block); end
  def sub(s); end
  def to_json(state = nil); end
  def to_s; end
  def type; end
  def type_param_names; end
  def type_params; end
  def update(type_params: nil, type: nil, block: nil, location: nil); end
end
module RBS::AST
end
class RBS::AST::TypeParam
  def ==(other); end
  def eql?(other); end
  def hash; end
  def initialize(name:, variance:, upper_bound:, location:); end
  def location; end
  def map_type(&block); end
  def name; end
  def rename(name); end
  def self.rename(params, new_names:); end
  def self.resolve_variables(params); end
  def self.subst_var(vars, type); end
  def to_json(state = nil); end
  def to_s; end
  def unchecked!(value = nil); end
  def unchecked?; end
  def upper_bound; end
  def variance; end
end
module RBS::AST::Declarations
end
class RBS::AST::Declarations::Base
end
module RBS::AST::Declarations::NestedDeclarationHelper
  def each_decl; end
  def each_member; end
end
module RBS::AST::Declarations::MixinHelper
  def each_mixin(&block); end
end
class RBS::AST::Declarations::Class < RBS::AST::Declarations::Base
  def ==(other); end
  def annotations; end
  def comment; end
  def eql?(other); end
  def hash; end
  def initialize(name:, type_params:, super_class:, members:, annotations:, location:, comment:); end
  def location; end
  def members; end
  def name; end
  def super_class; end
  def to_json(state = nil); end
  def type_params; end
  include RBS::AST::Declarations::MixinHelper
  include RBS::AST::Declarations::NestedDeclarationHelper
end
class RBS::AST::Declarations::Class::Super
  def ==(other); end
  def args; end
  def eql?(other); end
  def hash; end
  def initialize(name:, args:, location:); end
  def location; end
  def name; end
  def to_json(state = nil); end
end
class RBS::AST::Declarations::Module < RBS::AST::Declarations::Base
  def ==(other); end
  def annotations; end
  def comment; end
  def eql?(other); end
  def hash; end
  def initialize(name:, type_params:, members:, self_types:, annotations:, location:, comment:); end
  def location; end
  def members; end
  def name; end
  def self_types; end
  def to_json(state = nil); end
  def type_params; end
  include RBS::AST::Declarations::MixinHelper
  include RBS::AST::Declarations::NestedDeclarationHelper
end
class RBS::AST::Declarations::Module::Self
  def ==(other); end
  def args; end
  def eql?(other); end
  def hash; end
  def initialize(name:, args:, location:); end
  def location; end
  def name; end
  def to_json(state = nil); end
  def to_s; end
end
class RBS::AST::Declarations::Interface < RBS::AST::Declarations::Base
  def ==(other); end
  def annotations; end
  def comment; end
  def eql?(other); end
  def hash; end
  def initialize(name:, type_params:, members:, annotations:, location:, comment:); end
  def location; end
  def members; end
  def name; end
  def to_json(state = nil); end
  def type_params; end
  include RBS::AST::Declarations::MixinHelper
end
class RBS::AST::Declarations::Alias < RBS::AST::Declarations::Base
  def ==(other); end
  def annotations; end
  def comment; end
  def eql?(other); end
  def hash; end
  def initialize(name:, type_params:, type:, annotations:, location:, comment:); end
  def location; end
  def name; end
  def to_json(state = nil); end
  def type; end
  def type_params; end
end
class RBS::AST::Declarations::Constant < RBS::AST::Declarations::Base
  def ==(other); end
  def comment; end
  def eql?(other); end
  def hash; end
  def initialize(name:, type:, location:, comment:); end
  def location; end
  def name; end
  def to_json(state = nil); end
  def type; end
end
class RBS::AST::Declarations::Global < RBS::AST::Declarations::Base
  def ==(other); end
  def comment; end
  def eql?(other); end
  def hash; end
  def initialize(name:, type:, location:, comment:); end
  def location; end
  def name; end
  def to_json(state = nil); end
  def type; end
end
module RBS::AST::Members
end
class RBS::AST::Members::Base
end
class RBS::AST::Members::MethodDefinition < RBS::AST::Members::Base
  def ==(other); end
  def annotations; end
  def comment; end
  def eql?(other); end
  def hash; end
  def initialize(name:, kind:, types:, annotations:, location:, comment:, overload:, visibility: nil); end
  def instance?; end
  def kind; end
  def location; end
  def name; end
  def overload; end
  def overload?; end
  def singleton?; end
  def to_json(state = nil); end
  def types; end
  def update(name: nil, kind: nil, types: nil, annotations: nil, location: nil, comment: nil, overload: nil, visibility: nil); end
  def visibility; end
end
module RBS::AST::Members::Var
  def ==(other); end
  def comment; end
  def eql?(other); end
  def hash; end
  def initialize(name:, type:, location:, comment:); end
  def location; end
  def name; end
  def type; end
end
class RBS::AST::Members::InstanceVariable < RBS::AST::Members::Base
  def to_json(state = nil); end
  include RBS::AST::Members::Var
end
class RBS::AST::Members::ClassInstanceVariable < RBS::AST::Members::Base
  def to_json(state = nil); end
  include RBS::AST::Members::Var
end
class RBS::AST::Members::ClassVariable < RBS::AST::Members::Base
  def to_json(state = nil); end
  include RBS::AST::Members::Var
end
module RBS::AST::Members::Mixin
  def ==(other); end
  def annotations; end
  def args; end
  def comment; end
  def eql?(other); end
  def hash; end
  def initialize(name:, args:, annotations:, location:, comment:); end
  def location; end
  def name; end
end
class RBS::AST::Members::Include < RBS::AST::Members::Base
  def to_json(state = nil); end
  include RBS::AST::Members::Mixin
end
class RBS::AST::Members::Extend < RBS::AST::Members::Base
  def to_json(state = nil); end
  include RBS::AST::Members::Mixin
end
class RBS::AST::Members::Prepend < RBS::AST::Members::Base
  def to_json(state = nil); end
  include RBS::AST::Members::Mixin
end
module RBS::AST::Members::Attribute
  def ==(other); end
  def annotations; end
  def comment; end
  def eql?(other); end
  def hash; end
  def initialize(name:, type:, ivar_name:, kind:, annotations:, location:, comment:, visibility: nil); end
  def ivar_name; end
  def kind; end
  def location; end
  def name; end
  def type; end
  def update(name: nil, type: nil, ivar_name: nil, kind: nil, annotations: nil, location: nil, comment: nil, visibility: nil); end
  def visibility; end
end
class RBS::AST::Members::AttrReader < RBS::AST::Members::Base
  def to_json(state = nil); end
  include RBS::AST::Members::Attribute
end
class RBS::AST::Members::AttrAccessor < RBS::AST::Members::Base
  def to_json(state = nil); end
  include RBS::AST::Members::Attribute
end
class RBS::AST::Members::AttrWriter < RBS::AST::Members::Base
  def to_json(state = nil); end
  include RBS::AST::Members::Attribute
end
module RBS::AST::Members::LocationOnly
  def ==(other); end
  def eql?(other); end
  def hash; end
  def initialize(location:); end
  def location; end
end
class RBS::AST::Members::Public < RBS::AST::Members::Base
  def to_json(state = nil); end
  include RBS::AST::Members::LocationOnly
end
class RBS::AST::Members::Private < RBS::AST::Members::Base
  def to_json(state = nil); end
  include RBS::AST::Members::LocationOnly
end
class RBS::AST::Members::Alias < RBS::AST::Members::Base
  def ==(other); end
  def annotations; end
  def comment; end
  def eql?(other); end
  def hash; end
  def initialize(new_name:, old_name:, kind:, annotations:, location:, comment:); end
  def instance?; end
  def kind; end
  def location; end
  def new_name; end
  def old_name; end
  def singleton?; end
  def to_json(state = nil); end
end
class RBS::AST::Annotation
  def ==(other); end
  def eql?(other); end
  def hash; end
  def initialize(string:, location:); end
  def location; end
  def string; end
  def to_json(state = nil); end
end
class RBS::Environment
  def <<(decl); end
  def absolute_type(resolver, type, context:); end
  def absolute_type_name(resolver, type_name, context:); end
  def alias_decls; end
  def buffers; end
  def buffers_decls; end
  def cache_name(cache, name:, decl:, outer:); end
  def class_decls; end
  def constant_decls; end
  def declarations; end
  def foo; end
  def global_decls; end
  def initialize; end
  def initialize_copy(other); end
  def insert_decl(decl, outer:, namespace:); end
  def inspect; end
  def interface_decls; end
  def reject; end
  def resolve_declaration(resolver, decl, outer:, prefix:); end
  def resolve_member(resolver, member, context:); end
  def resolve_method_type(resolver, type, context:); end
  def resolve_type_names(only: nil); end
  def resolve_type_params(resolver, params, context:); end
  def self.from_loader(loader); end
  def validate_type_params; end
end
module RBS::Environment::ContextUtil
  def calculate_context(decls); end
end
class RBS::Environment::MultiEntry
  def compatible_params?(ps1, ps2); end
  def decls; end
  def initialize(name:); end
  def insert(decl:, outer:); end
  def name; end
  def primary; end
  def type_params; end
  def validate_type_params; end
end
class RBS::Environment::MultiEntry::D < Struct
  def context; end
  def decl; end
  def decl=(_); end
  def outer; end
  def outer=(_); end
  def self.[](*arg0); end
  def self.inspect; end
  def self.keyword_init?; end
  def self.members; end
  def self.new(*arg0); end
  include RBS::Environment::ContextUtil
end
class RBS::Environment::ModuleEntry < RBS::Environment::MultiEntry
  def primary; end
  def self_types; end
end
class RBS::Environment::ClassEntry < RBS::Environment::MultiEntry
  def primary; end
end
class RBS::Environment::SingleEntry
  def context; end
  def decl; end
  def initialize(name:, decl:, outer:); end
  def name; end
  def outer; end
  include RBS::Environment::ContextUtil
end
class RBS::EnvironmentLoader
  def add(path: nil, library: nil, version: nil, resolve_dependencies: nil); end
  def add_collection(collection_config); end
  def core_root; end
  def dirs; end
  def each_decl; end
  def each_dir; end
  def each_file(path, immediate:, skip_hidden:, &block); end
  def has_library?(library:, version:); end
  def initialize(core_root: nil, repository: nil); end
  def libs; end
  def load(env:); end
  def repository; end
  def resolve_dependencies(library:, version:); end
  def self.gem_sig_path(name, version); end
end
class RBS::EnvironmentLoader::UnknownLibraryError < StandardError
  def initialize(lib:); end
  def library; end
end
class RBS::EnvironmentLoader::Library < Struct
  def name; end
  def name=(_); end
  def self.[](*arg0); end
  def self.inspect; end
  def self.keyword_init?; end
  def self.members; end
  def self.new(*arg0); end
  def version; end
  def version=(_); end
end
module RBS::BuiltinNames
end
class RBS::BuiltinNames::Name
  def initialize(name:); end
  def instance_type(*args); end
  def instance_type?(type); end
  def name; end
  def self.define(name, namespace: nil); end
  def singleton_type; end
  def singleton_type?(type); end
  def to_s; end
end
class RBS::Definition
  def ancestors; end
  def class?; end
  def class_type?; end
  def class_variables; end
  def each_type(&block); end
  def entry; end
  def initialize(type_name:, entry:, self_type:, ancestors:); end
  def instance_type?; end
  def instance_variables; end
  def interface?; end
  def interface_type?; end
  def map_method_type(&block); end
  def methods; end
  def module?; end
  def self_type; end
  def sub(s); end
  def type_name; end
  def type_params; end
  def type_params_decl; end
end
class RBS::Definition::Variable
  def declared_in; end
  def initialize(parent_variable:, type:, declared_in:); end
  def parent_variable; end
  def sub(s); end
  def type; end
end
class RBS::Definition::Method
  def ==(other); end
  def accessibility; end
  def alias_of; end
  def annotations; end
  def comments; end
  def defined_in; end
  def defs; end
  def eql?(other); end
  def extra_annotations; end
  def hash; end
  def implemented_in; end
  def initialize(super_method:, defs:, accessibility:, alias_of:, annotations: nil); end
  def map_method_type(&block); end
  def map_type(&block); end
  def map_type_bound(&block); end
  def members; end
  def method_types; end
  def private?; end
  def public?; end
  def sub(s); end
  def super_method; end
  def update(super_method: nil, defs: nil, accessibility: nil, alias_of: nil, annotations: nil); end
end
class RBS::Definition::Method::TypeDef
  def ==(other); end
  def annotations; end
  def comment; end
  def defined_in; end
  def eql?(other); end
  def hash; end
  def implemented_in; end
  def initialize(type:, member:, defined_in:, implemented_in:); end
  def member; end
  def overload?; end
  def type; end
  def update(type: nil, member: nil, defined_in: nil, implemented_in: nil); end
end
module RBS::Definition::Ancestor
end
class RBS::Definition::Ancestor::Instance
  def ==(other); end
  def args; end
  def eql?(other); end
  def hash; end
  def initialize(name:, args:, source:); end
  def name; end
  def source; end
end
class RBS::Definition::Ancestor::Singleton
  def ==(other); end
  def eql?(other); end
  def hash; end
  def initialize(name:); end
  def name; end
end
class RBS::Definition::InstanceAncestors
  def ancestors; end
  def apply(args, location:); end
  def initialize(type_name:, params:, ancestors:); end
  def params; end
  def type_name; end
end
class RBS::Definition::SingletonAncestors
  def ancestors; end
  def initialize(type_name:, ancestors:); end
  def type_name; end
end
class RBS::DefinitionBuilder
  def ancestor_builder; end
  def build_instance(type_name, no_self_types: nil); end
  def build_interface(type_name); end
  def build_singleton(type_name); end
  def build_singleton0(type_name); end
  def define_methods(definition, methods:, interface_methods:, methods_with_self:, super_interface_method:); end
  def define_methods_instance(definition, methods:, interface_methods:); end
  def define_methods_module_instance(definition, methods:, interface_methods:, module_self_methods:); end
  def define_methods_singleton(definition, methods:, interface_methods:); end
  def ensure_namespace!(namespace, location:); end
  def env; end
  def expand_alias(type_name); end
  def expand_alias1(type_name); end
  def expand_alias2(type_name, args); end
  def initialize(env:, ancestor_builder: nil, method_builder: nil); end
  def insert_variable(type_name, variables, name:, type:); end
  def instance_cache; end
  def interface_cache; end
  def merge_definition(src:, dest:, subst:, implemented_in: nil, keep_super: nil); end
  def merge_method(type_name, methods, name, method, sub, implemented_in: nil, keep_super: nil); end
  def merge_variable(variables, name, variable, sub, keep_super: nil); end
  def method_builder; end
  def singleton0_cache; end
  def singleton_cache; end
  def source_location(source, decl); end
  def try_cache(type_name, cache:, key: nil); end
  def type_name_resolver; end
  def update(env:, except:, ancestor_builder:); end
  def validate_params_with(type_params, result:); end
  def validate_type_name(name, location); end
  def validate_type_params(definition, ancestors:, methods:); end
  def validate_type_presence(type); end
end
class RBS::DefinitionBuilder::AncestorBuilder
  def env; end
  def initialize(env:); end
  def instance_ancestors(type_name, building_ancestors: nil); end
  def instance_ancestors_cache; end
  def interface_ancestors(type_name, building_ancestors: nil); end
  def interface_ancestors_cache; end
  def mixin_ancestors(entry, type_name, included_modules:, included_interfaces:, extended_modules:, prepended_modules:, extended_interfaces:); end
  def mixin_ancestors0(decl, type_name, align_params:, included_modules:, included_interfaces:, extended_modules:, prepended_modules:, extended_interfaces:); end
  def one_instance_ancestors(type_name); end
  def one_instance_ancestors_cache; end
  def one_interface_ancestors(type_name); end
  def one_interface_ancestors_cache; end
  def one_singleton_ancestors(type_name); end
  def one_singleton_ancestors_cache; end
  def singleton_ancestors(type_name, building_ancestors: nil); end
  def singleton_ancestors_cache; end
  def validate_super_class!(type_name, entry); end
end
class RBS::DefinitionBuilder::AncestorBuilder::OneAncestors
  def each_ancestor(&block); end
  def each_extended_interface(&block); end
  def each_extended_module(&block); end
  def each_included_interface(&block); end
  def each_included_module(&block); end
  def each_prepended_module(&block); end
  def each_self_type(&block); end
  def extended_interfaces; end
  def extended_modules; end
  def included_interfaces; end
  def included_modules; end
  def initialize(type_name:, params:, super_class:, self_types:, included_modules:, included_interfaces:, prepended_modules:, extended_modules:, extended_interfaces:); end
  def params; end
  def prepended_modules; end
  def self.class_instance(type_name:, params:, super_class:); end
  def self.interface(type_name:, params:); end
  def self.module_instance(type_name:, params:); end
  def self.singleton(type_name:, super_class:); end
  def self_types; end
  def super_class; end
  def type_name; end
end
class RBS::DefinitionBuilder::MethodBuilder
  def build_alias(methods, type, member:); end
  def build_attribute(methods, type, member:, accessibility:); end
  def build_instance(type_name); end
  def build_interface(type_name); end
  def build_method(methods, type, member:, accessibility:); end
  def build_singleton(type_name); end
  def each_member_with_accessibility(members, accessibility: nil); end
  def env; end
  def initialize(env:); end
  def instance_methods; end
  def interface_methods; end
  def singleton_methods; end
  def update(env:, except:); end
end
class RBS::DefinitionBuilder::MethodBuilder::Methods
  def each; end
  def initialize(type:); end
  def methods; end
  def type; end
  def validate!; end
end
class RBS::DefinitionBuilder::MethodBuilder::Methods::Definition < Struct
  def accessibilities; end
  def accessibilities=(_); end
  def accessibility; end
  def name; end
  def name=(_); end
  def original; end
  def originals; end
  def originals=(_); end
  def overloads; end
  def overloads=(_); end
  def self.[](*arg0); end
  def self.empty(name:, type:); end
  def self.inspect; end
  def self.keyword_init?; end
  def self.members; end
  def self.new(*arg0); end
  def type; end
  def type=(_); end
end
class RBS::DefinitionBuilder::MethodBuilder::Methods::Sorter
  def initialize(methods); end
  def methods; end
  def tsort_each_child(defn); end
  def tsort_each_node(&block); end
  include TSort
end
class RBS::VarianceCalculator
  def builder; end
  def env; end
  def function(type, result:, context:); end
  def in_inherit(name:, args:, variables:); end
  def in_method_type(method_type:, variables:); end
  def in_type_alias(name:); end
  def initialize(builder:); end
  def negate(variance); end
  def type(type, result:, context:); end
end
class RBS::VarianceCalculator::Result
  def compatible?(var, with_annotation:); end
  def contravariant(x); end
  def covariant(x); end
  def each(&block); end
  def include?(name); end
  def incompatible?(params); end
  def initialize(variables:); end
  def invariant(x); end
  def result; end
end
class RBS::Substitution
  def add(from:, to:); end
  def apply(ty); end
  def empty?; end
  def initialize; end
  def instance_type; end
  def instance_type=(arg0); end
  def mapping; end
  def self.build(variables, types, instance_type: nil, &block); end
  def without(*vars); end
end
class RBS::Constant
  def ==(other); end
  def entry; end
  def eql?(other); end
  def hash; end
  def initialize(name:, type:, entry:); end
  def name; end
  def type; end
end
module RBS::Resolver
end
class RBS::Resolver::ConstantResolver
  def builder; end
  def child_constants_cache; end
  def children(module_name); end
  def constants(context); end
  def constants_from_ancestors(module_name, constants:); end
  def constants_from_context(context, constants:); end
  def constants_itself(context, constants:); end
  def context_constants_cache; end
  def initialize(builder:); end
  def load_child_constants(name); end
  def load_context_constants(context); end
  def resolve(name, context:); end
  def resolve_child(module_name, name); end
  def table; end
end
class RBS::Resolver::ConstantResolver::Table
  def children(name); end
  def children_table; end
  def constant(name); end
  def constant_of_constant(name, entry); end
  def constant_of_module(name, entry); end
  def constants_table; end
  def initialize(environment); end
  def toplevel; end
end
class RBS::Resolver::TypeNameResolver
  def all_names; end
  def cache; end
  def has_name?(full_name); end
  def initialize(env); end
  def resolve(type_name, context:); end
  def resolve_in(type_name, context); end
  def try_cache(query); end
end
class RBS::ConstantTable
  def absolute_type(type, context:); end
  def absolute_type_name(type_name, context:, location:); end
  def constant_scopes(name); end
  def constant_scopes0(name, scopes: nil); end
  def constant_scopes_cache; end
  def constant_scopes_module(name, scopes:); end
  def definition_builder; end
  def env; end
  def initialize(builder:); end
  def name_to_constant(name); end
  def resolve_constant_reference(name, context:); end
  def resolve_constant_reference_context(name, context:); end
  def resolve_constant_reference_inherit(name, scopes:, no_object: nil); end
  def resolver; end
  def split_name(name); end
end
class RBS::AST::Comment
  def ==(other); end
  def eql?(other); end
  def hash; end
  def initialize(string:, location:); end
  def location; end
  def string; end
  def to_json(state = nil); end
end
class RBS::Writer
  def attribute(kind, attr); end
  def indent(size = nil); end
  def indentation; end
  def initialize(out:); end
  def method_name(name); end
  def name_and_args(name, args); end
  def name_and_params(name, params); end
  def out; end
  def prefix; end
  def preserve!(preserve: nil); end
  def preserve?; end
  def preserve_empty_line(prev, decl); end
  def put_lines(lines, leading_spaces:); end
  def puts(string = nil); end
  def write(decls); end
  def write_annotation(annotations); end
  def write_comment(comment); end
  def write_decl(decl); end
  def write_def(member); end
  def write_loc_source(located); end
  def write_member(member); end
end
module RBS::Prototype
end
module RBS::Prototype::Helpers
  def any_node?(node, nodes: nil, &block); end
  def args_from_node(args_node); end
  def block_from_body(node); end
  def each_child(node, &block); end
  def each_node(nodes); end
  def keyword_hash?(node); end
  def untyped; end
end
class RBS::Prototype::RBI
  def call_node?(node, name:, receiver: nil, args: nil); end
  def const_to_name(node); end
  def current_module!; end
  def current_module; end
  def current_namespace; end
  def decls; end
  def each_arg(array, &block); end
  def each_child(node); end
  def initialize; end
  def join_comments(nodes, comments); end
  def last_sig; end
  def method_type(args_node, type_node, variables:, overloads:); end
  def modules; end
  def nested_name(name); end
  def node_to_hash(node); end
  def parse(string); end
  def parse_params(args_node, args, method_type, variables:, overloads:); end
  def pop_sig; end
  def proc_type?(type_node); end
  def process(node, comments:, outer: nil); end
  def push_class(name, super_class, comment:); end
  def push_module(name, comment:); end
  def push_sig(node); end
  def type_of(type_node, variables:); end
  def type_of0(type_node, variables:); end
end
class RBS::Prototype::RB
  def block_type(node); end
  def body_type(node); end
  def const_to_name!(node); end
  def const_to_name(node, context:); end
  def current_accessibility(decls, index = nil); end
  def decls; end
  def find_def_index_by_name(decls, name); end
  def function_return_type_from_body(node); end
  def function_type_from_body(node, def_name); end
  def if_unless_type(node); end
  def initialize; end
  def is_accessibility?(decl); end
  def literal_to_symbol(node); end
  def literal_to_type(node); end
  def node_type(node, default: nil); end
  def param_type(node, default: nil); end
  def parse(string); end
  def private; end
  def process(node, decls:, comments:, context:); end
  def process_children(node, decls:, comments:, context:); end
  def public; end
  def range_element_type(types); end
  def remove_unnecessary_accessibility_methods!(decls); end
  def source_decls; end
  def toplevel_members; end
  def types_to_union_type(types); end
  include RBS::Prototype::Helpers
end
class RBS::Prototype::RB::Context < Struct
  def attribute_kind; end
  def method_kind; end
  def module_function; end
  def module_function=(_); end
  def namespace; end
  def namespace=(_); end
  def self.[](*arg0); end
  def self.initial(namespace: nil); end
  def self.inspect; end
  def self.keyword_init?; end
  def self.members; end
  def self.new(*arg0); end
  def singleton; end
  def singleton=(_); end
end
class RBS::Prototype::Runtime
  def block_from_ast_of(method); end
  def builder; end
  def const_name(const); end
  def decls; end
  def each_included_module(type_name, mod); end
  def ensure_outer_module_declarations(mod); end
  def env; end
  def generate_class(mod); end
  def generate_constants(mod, decls); end
  def generate_methods(mod, module_name, members); end
  def generate_module(mod); end
  def generate_super_class(mod); end
  def initialize(patterns:, env:, merge:, owners_included: nil); end
  def merge; end
  def merge_rbs(module_name, members, instance: nil, singleton: nil); end
  def method_type(method); end
  def only_name(mod); end
  def owners_included; end
  def parse(file); end
  def patterns; end
  def target?(const); end
  def target_method?(mod, instance: nil, singleton: nil); end
  def to_type_name(name, full_name: nil); end
  def type_args(type_name); end
  include RBS::Prototype::Helpers
end
class RBS::TypeNameResolver
  def add_names(names); end
  def all_names; end
  def cache; end
  def has_name?(full_name); end
  def initialize; end
  def resolve(type_name, context:); end
  def self.from_env(env); end
  def try_cache(query); end
end
class RBS::TypeNameResolver::Query < Struct
  def context; end
  def context=(_); end
  def self.[](*arg0); end
  def self.inspect; end
  def self.keyword_init?; end
  def self.members; end
  def self.new(*arg0); end
  def type_name; end
  def type_name=(_); end
end
class RBS::EnvironmentWalker
  def builder; end
  def each_type_name(type, &block); end
  def each_type_node(type, &block); end
  def env; end
  def initialize(env:); end
  def only_ancestors!(only = nil); end
  def only_ancestors?; end
  def tsort_each_child(node, &block); end
  def tsort_each_node(&block); end
  include TSort
end
class RBS::EnvironmentWalker::InstanceNode < Struct
  def self.[](*arg0); end
  def self.inspect; end
  def self.keyword_init?; end
  def self.members; end
  def self.new(*arg0); end
  def type_name; end
  def type_name=(_); end
end
class RBS::EnvironmentWalker::SingletonNode < Struct
  def self.[](*arg0); end
  def self.inspect; end
  def self.keyword_init?; end
  def self.members; end
  def self.new(*arg0); end
  def type_name; end
  def type_name=(_); end
end
class RBS::EnvironmentWalker::TypeNameNode < Struct
  def self.[](*arg0); end
  def self.inspect; end
  def self.keyword_init?; end
  def self.members; end
  def self.new(*arg0); end
  def type_name; end
  def type_name=(_); end
end
class RBS::Vendorer
  def clean!; end
  def copy!; end
  def ensure_dir; end
  def initialize(vendor_dir:, loader:); end
  def loader; end
  def vendor_dir; end
end
class RBS::Validator
  def absolute_type(type, context:); end
  def definition_builder; end
  def env; end
  def initialize(env:, resolver:); end
  def resolver; end
  def type_alias_dependency; end
  def type_alias_regularity; end
  def validate_method_definition(method_def, type_name:); end
  def validate_type(type, context:); end
  def validate_type_alias(entry:); end
  def validate_type_params(params, type_name:, location:, method_name: nil); end
end
class RBS::Factory
  def type_name(string); end
end
class RBS::Repository
  def add(dir); end
  def dirs; end
  def gems; end
  def initialize(no_stdlib: nil); end
  def lookup(gem, version); end
  def lookup_path(gem, version); end
  def self.default; end
  def self.find_best_version(version, candidates); end
end
class RBS::Repository::GemRBS
  def empty?; end
  def find_best_version(version); end
  def initialize(name:); end
  def latest_version; end
  def load!; end
  def name; end
  def oldest_version; end
  def paths; end
  def version_names; end
  def versions; end
end
class RBS::Repository::VersionPath < Struct
  def gem; end
  def gem=(_); end
  def path; end
  def path=(_); end
  def self.[](*arg0); end
  def self.inspect; end
  def self.keyword_init?; end
  def self.members; end
  def self.new(*arg0); end
  def version; end
  def version=(_); end
end
class RBS::AncestorGraph
  def ancestor_builder; end
  def build; end
  def build_ancestors(node, ancestors); end
  def children; end
  def each_ancestor(node, yielded: nil, &block); end
  def each_child(node, &block); end
  def each_descendant(node, yielded: nil, &block); end
  def each_parent(node, &block); end
  def env; end
  def initialize(env:, ancestor_builder: nil); end
  def parents; end
  def register(parent:, child:); end
end
class RBS::AncestorGraph::InstanceNode < Struct
  def self.[](*arg0); end
  def self.inspect; end
  def self.keyword_init?; end
  def self.members; end
  def self.new(*arg0); end
  def type_name; end
  def type_name=(_); end
end
class RBS::AncestorGraph::SingletonNode < Struct
  def self.[](*arg0); end
  def self.inspect; end
  def self.keyword_init?; end
  def self.members; end
  def self.new(*arg0); end
  def type_name; end
  def type_name=(_); end
end
class RBS::Locator
  def buffer; end
  def decls; end
  def find(line:, column:); end
  def find2(line:, column:); end
  def find_in_decl(pos, decl:, array:); end
  def find_in_loc(pos, location:, array:); end
  def find_in_member(pos, member:, array:); end
  def find_in_method_type(pos, method_type:, array:); end
  def find_in_type(pos, type:, array:); end
  def find_in_type_param(pos, type_param:, array:); end
  def initialize(decls:); end
  def test_loc(pos, location:); end
end
class RBS::TypeAliasDependency
  def build_dependencies; end
  def circular_definition?(alias_name); end
  def dependencies; end
  def dependency(start, vertex, nested = nil); end
  def direct_dependencies; end
  def direct_dependency(type, result = nil); end
  def env; end
  def initialize(env:); end
  def transitive_closure; end
end
class RBS::TypeAliasRegularity
  def build_alias_type(name); end
  def builder; end
  def compatible_args?(args1, args2); end
  def diagnostics; end
  def each_alias_type(type, &block); end
  def each_mutual_alias_defs(&block); end
  def env; end
  def initialize(env:); end
  def nonregular?(type_name); end
  def self.validate(env:); end
  def validate; end
  def validate_alias_type(alias_type, names, types); end
end
class RBS::TypeAliasRegularity::Diagnostic
  def initialize(type_name:, nonregular_type:); end
  def nonregular_type; end
  def type_name; end
end
module RBS::Collection
end
module RBS::Collection::Sources
  def self.from_config_entry(source_entry); end
end
module RBS::Collection::Sources::Base
  def dependencies_of(config_entry); end
end
class RBS::Collection::Sources::Git
  def _install(dest:, config_entry:); end
  def cp_r(src, dest); end
  def format_config_entry(config_entry); end
  def gem_repo_dir; end
  def git(*cmd, **opt); end
  def git_dir; end
  def has?(config_entry); end
  def initialize(name:, revision:, remote:, repo_dir:); end
  def install(dest:, config_entry:, stdout:); end
  def manifest_of(config_entry); end
  def name; end
  def need_to_fetch?(revision); end
  def remote; end
  def repo_dir; end
  def resolve_revision; end
  def resolved_revision; end
  def setup!(revision:); end
  def sh!(*cmd, **opt); end
  def to_lockfile; end
  def versions(config_entry); end
  include RBS::Collection::Sources::Base
end
class RBS::Collection::Sources::Git::CommandError < StandardError
end
class RBS::Collection::Sources::Stdlib
  def has?(config_entry); end
  def install(dest:, config_entry:, stdout:); end
  def lookup(config_entry); end
  def manifest_of(config_entry); end
  def self.allocate; end
  def self.new(*, **); end
  def to_lockfile; end
  def versions(config_entry); end
  extend Singleton::SingletonClassMethods
  include RBS::Collection::Sources::Base
  include Singleton
end
class RBS::Collection::Sources::Rubygems
  def gem_sig_path(config_entry); end
  def has?(config_entry); end
  def install(dest:, config_entry:, stdout:); end
  def manifest_of(config_entry); end
  def self.allocate; end
  def self.new(*, **); end
  def to_lockfile; end
  def versions(config_entry); end
  extend Singleton::SingletonClassMethods
  include RBS::Collection::Sources::Base
  include Singleton
end
class RBS::Collection::Config
  def add_gem(gem); end
  def check_rbs_availability!; end
  def dump_to(io); end
  def gem(gem_name); end
  def gemfile_lock_path; end
  def gemfile_lock_path=(path); end
  def gems; end
  def initialize(data, config_path:); end
  def repo_path; end
  def self.find_config_path; end
  def self.from_path(path); end
  def self.generate_lockfile(config_path:, gemfile_lock_path:, with_lockfile: nil); end
  def self.lockfile_of(config_path); end
  def self.to_lockfile_path(config_path); end
  def sources; end
end
class RBS::Collection::Config::CollectionNotAvailable < StandardError
  def initialize; end
end
class RBS::Collection::Config::LockfileGenerator
  def assign_gem(name:, version:); end
  def config; end
  def find_best_version(version:, versions:); end
  def find_source(name:); end
  def gemfile_lock; end
  def gemfile_lock_gems(&block); end
  def generate; end
  def initialize(config_path:, gemfile_lock_path:, with_lockfile:); end
  def lock; end
  def lock_path; end
  def remove_ignored_gems!; end
  def self.generate(config_path:, gemfile_lock_path:, with_lockfile: nil); end
  def upsert_gem(old, new); end
  def validate_gemfile_lock_path!(lock:, gemfile_lock_path:); end
end
class RBS::Collection::Config::LockfileGenerator::GemfileLockMismatchError < StandardError
  def initialize(expected:, actual:); end
  def message; end
end
class RBS::Collection::Installer
  def initialize(lockfile_path:, stdout: nil); end
  def install_from_lockfile; end
  def lockfile; end
  def source_for(config_entry); end
  def stdout; end
end
class RBS::Collection::Cleaner
  def clean; end
  def initialize(lockfile_path:); end
  def lock; end
  def needed?(gem_name, version); end
end
class RBS::Location
  def ==(other); end
  def [](arg0); end
  def _add_optional_child(arg0, arg1, arg2); end
  def _add_optional_no_child(arg0); end
  def _add_required_child(arg0, arg1, arg2); end
  def _end_loc; end
  def _optional_keys; end
  def _required_keys; end
  def _start_loc; end
  def add_optional_child(name, range); end
  def add_required_child(name, range); end
  def aref(arg0); end
  def buffer; end
  def each_optional_key(&block); end
  def each_required_key(&block); end
  def end_column; end
  def end_line; end
  def end_loc; end
  def end_pos; end
  def initialize(arg0, arg1, arg2); end
  def initialize_copy(arg0); end
  def inspect; end
  def key?(name); end
  def name; end
  def optional_key?(name); end
  def range; end
  def required_key?(name); end
  def self.new(buffer_ = nil, start_pos_ = nil, end_pos_ = nil, buffer: nil, start_pos: nil, end_pos: nil); end
  def self.to_string(location, default: nil); end
  def source; end
  def start_column; end
  def start_line; end
  def start_loc; end
  def start_pos; end
  def to_json(state = nil); end
  def to_s; end
end
class RBS::Parser
  def self._parse_method_type(arg0, arg1, arg2, arg3, arg4); end
  def self._parse_signature(arg0, arg1); end
  def self._parse_type(arg0, arg1, arg2, arg3, arg4); end
  def self.buffer(source); end
  def self.parse_method_type(source, line: nil, column: nil, range: nil, variables: nil); end
  def self.parse_signature(source, line: nil, column: nil); end
  def self.parse_type(source, line: nil, column: nil, range: nil, variables: nil); end
end
