# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `redis-activesupport` gem.
# Please instead update this file by running `bin/tapioca gem redis-activesupport`.


# source://redis-activesupport//lib/active_support/cache/redis_store.rb#4
module ActiveSupport
  # source://activesupport/7.2.0/lib/active_support/json/decoding.rb#9
  def parse_json_times; end

  # source://activesupport/7.2.0/lib/active_support/json/decoding.rb#9
  def parse_json_times=(val); end

  # source://activesupport/7.2.0/lib/active_support.rb#99
  def test_order; end

  # source://activesupport/7.2.0/lib/active_support.rb#99
  def test_order=(val); end

  # source://activesupport/7.2.0/lib/active_support.rb#100
  def test_parallelization_threshold; end

  # source://activesupport/7.2.0/lib/active_support.rb#100
  def test_parallelization_threshold=(val); end

  class << self
    # source://activesupport/7.2.0/lib/active_support.rb#105
    def cache_format_version; end

    # source://activesupport/7.2.0/lib/active_support.rb#109
    def cache_format_version=(value); end

    # source://activesupport/7.2.0/lib/active_support/deprecator.rb#4
    def deprecator; end

    # source://activesupport/7.2.0/lib/active_support.rb#93
    def eager_load!; end

    # source://activesupport/7.2.0/lib/active_support.rb#103
    def error_reporter; end

    # source://activesupport/7.2.0/lib/active_support.rb#103
    def error_reporter=(_arg0); end

    # source://activesupport/7.2.0/lib/active_support/json/encoding.rb#8
    def escape_html_entities_in_json(*_arg0, **_arg1, &_arg2); end

    # source://activesupport/7.2.0/lib/active_support/json/encoding.rb#8
    def escape_html_entities_in_json=(arg); end

    # source://activesupport/7.2.0/lib/active_support/gem_version.rb#5
    def gem_version; end

    # source://activesupport/7.2.0/lib/active_support/json/encoding.rb#8
    def json_encoder(*_arg0, **_arg1, &_arg2); end

    # source://activesupport/7.2.0/lib/active_support/json/encoding.rb#8
    def json_encoder=(arg); end

    # source://activesupport/7.2.0/lib/active_support/json/decoding.rb#9
    def parse_json_times; end

    # source://activesupport/7.2.0/lib/active_support/json/decoding.rb#9
    def parse_json_times=(val); end

    # source://activesupport/7.2.0/lib/active_support.rb#99
    def test_order; end

    # source://activesupport/7.2.0/lib/active_support.rb#99
    def test_order=(val); end

    # source://activesupport/7.2.0/lib/active_support.rb#100
    def test_parallelization_threshold; end

    # source://activesupport/7.2.0/lib/active_support.rb#100
    def test_parallelization_threshold=(val); end

    # source://activesupport/7.2.0/lib/active_support/json/encoding.rb#8
    def time_precision(*_arg0, **_arg1, &_arg2); end

    # source://activesupport/7.2.0/lib/active_support/json/encoding.rb#8
    def time_precision=(arg); end

    # source://activesupport/7.2.0/lib/active_support.rb#113
    def to_time_preserves_timezone; end

    # source://activesupport/7.2.0/lib/active_support.rb#117
    def to_time_preserves_timezone=(value); end

    # source://activesupport/7.2.0/lib/active_support/json/encoding.rb#8
    def use_standard_json_time_format(*_arg0, **_arg1, &_arg2); end

    # source://activesupport/7.2.0/lib/active_support/json/encoding.rb#8
    def use_standard_json_time_format=(arg); end

    # source://activesupport/7.2.0/lib/active_support.rb#127
    def utc_to_local_returns_utc_offset_times; end

    # source://activesupport/7.2.0/lib/active_support.rb#131
    def utc_to_local_returns_utc_offset_times=(value); end

    # source://activesupport/7.2.0/lib/active_support/version.rb#7
    def version; end
  end
end

# source://redis-activesupport//lib/active_support/cache/redis_store.rb#5
module ActiveSupport::Cache
  class << self
    # source://activesupport/7.2.0/lib/active_support/cache.rb#111
    def expand_cache_key(key, namespace = T.unsafe(nil)); end

    # source://activesupport/7.2.0/lib/active_support/cache.rb#58
    def format_version; end

    # source://activesupport/7.2.0/lib/active_support/cache.rb#58
    def format_version=(_arg0); end

    # source://activesupport/7.2.0/lib/active_support/cache.rb#85
    def lookup_store(store = T.unsafe(nil), *parameters); end

    private

    # source://activesupport/7.2.0/lib/active_support/cache.rb#123
    def retrieve_cache_key(key); end

    # source://activesupport/7.2.0/lib/active_support/cache.rb#135
    def retrieve_store_class(store); end
  end
end

# source://redis-activesupport//lib/active_support/cache/redis_store.rb#6
class ActiveSupport::Cache::RedisStore < ::ActiveSupport::Cache::Store
  # Instantiate the store.
  #
  # Example:
  #   RedisStore.new
  #     # => host: localhost,   port: 6379,  db: 0
  #
  #   RedisStore.new client: Redis.new(url: "redis://127.0.0.1:6380/1")
  #     # => host: localhost,   port: 6379,  db: 0
  #
  #   RedisStore.new "redis://example.com"
  #     # => host: example.com, port: 6379,  db: 0
  #
  #   RedisStore.new "redis://example.com:23682"
  #     # => host: example.com, port: 23682, db: 0
  #
  #   RedisStore.new "redis://example.com:23682/1"
  #     # => host: example.com, port: 23682, db: 1
  #
  #   RedisStore.new "redis://example.com:23682/1/theplaylist"
  #     # => host: example.com, port: 23682, db: 1, namespace: theplaylist
  #
  #   RedisStore.new "redis://localhost:6379/0", "redis://localhost:6380/0"
  #     # => instantiate a cluster
  #
  #   RedisStore.new "redis://localhost:6379/0", "redis://localhost:6380/0", pool_size: 5, pool_timeout: 10
  #     # => use a ConnectionPool
  #
  #   RedisStore.new "redis://localhost:6379/0", "redis://localhost:6380/0",
  #     pool: ::ConnectionPool.new(size: 1, timeout: 1) { ::Redis::Store::Factory.create("localhost:6379/0") })
  #     # => supply an existing connection pool (e.g. for use with redis-sentinel or redis-failover)
  #
  # @return [RedisStore] a new instance of RedisStore
  #
  # source://redis-activesupport//lib/active_support/cache/redis_store.rb#54
  def initialize(*addresses); end

  # Clear all the data from the store.
  #
  # source://redis-activesupport//lib/active_support/cache/redis_store.rb#247
  def clear; end

  # Returns the value of attribute data.
  #
  # source://redis-activesupport//lib/active_support/cache/redis_store.rb#22
  def data; end

  # Decrement a key in the store
  #
  # If the key doesn't exist it will be initialized on 0.
  # If the key exist but it isn't a Fixnum it will be initialized on 0.
  #
  # Example:
  #   We have two objects in cache:
  #     counter # => 23
  #     rabbit  # => #<Rabbit:0x5eee6c>
  #
  #   cache.decrement "counter"
  #   cache.read "counter", :raw => true      # => "22"
  #
  #   cache.decrement "counter", 2
  #   cache.read "counter", :raw => true      # => "20"
  #
  #   cache.decrement "a counter"
  #   cache.read "a counter", :raw => true    # => "-1"
  #
  #   cache.decrement "rabbit"
  #   cache.read "rabbit", :raw => true       # => "-1"
  #
  # source://redis-activesupport//lib/active_support/cache/redis_store.rb#226
  def decrement(name, amount = T.unsafe(nil), options = T.unsafe(nil)); end

  # Delete objects for matched keys.
  #
  # Performance note: this operation can be dangerous for large production
  # databases, as it uses the Redis "KEYS" command, which is O(N) over the
  # total number of keys in the database. Users of large Redis caches should
  # avoid this method.
  #
  # Example:
  #   cache.delete_matched "rab*"
  #
  # source://redis-activesupport//lib/active_support/cache/redis_store.rb#99
  def delete_matched(matcher, options = T.unsafe(nil)); end

  # fixed problem with invalid exists? method
  # https://github.com/rails/rails/commit/cad2c8f5791d5bd4af0f240d96e00bae76eabd2f
  #
  # @return [Boolean]
  #
  # source://redis-activesupport//lib/active_support/cache/redis_store.rb#257
  def exist?(name, options = T.unsafe(nil)); end

  # source://redis-activesupport//lib/active_support/cache/redis_store.rb#241
  def expire(key, ttl); end

  # source://redis-activesupport//lib/active_support/cache/redis_store.rb#139
  def fetch_multi(*names); end

  # Increment a key in the store.
  #
  # If the key doesn't exist it will be initialized on 0.
  # If the key exist but it isn't a Fixnum it will be initialized on 0.
  #
  # Example:
  #   We have two objects in cache:
  #     counter # => 23
  #     rabbit  # => #<Rabbit:0x5eee6c>
  #
  #   cache.increment "counter"
  #   cache.read "counter", :raw => true      # => "24"
  #
  #   cache.increment "counter", 6
  #   cache.read "counter", :raw => true      # => "30"
  #
  #   cache.increment "a counter"
  #   cache.read "a counter", :raw => true    # => "1"
  #
  #   cache.increment "rabbit"
  #   cache.read "rabbit", :raw => true       # => "1"
  #
  # source://redis-activesupport//lib/active_support/cache/redis_store.rb#190
  def increment(name, amount = T.unsafe(nil), options = T.unsafe(nil)); end

  # Reads multiple keys from the cache using a single call to the
  # servers for all keys. Options can be passed in the last argument.
  #
  # Example:
  #   cache.read_multi "rabbit", "white-rabbit"
  #   cache.read_multi "rabbit", "white-rabbit", :raw => true
  #
  # source://redis-activesupport//lib/active_support/cache/redis_store.rb#119
  def read_multi(*names); end

  # source://redis-activesupport//lib/active_support/cache/redis_store.rb#274
  def reconnect; end

  # source://redis-activesupport//lib/active_support/cache/redis_store.rb#262
  def stats; end

  # source://redis-activesupport//lib/active_support/cache/redis_store.rb#266
  def with(&block); end

  # source://redis-activesupport//lib/active_support/cache/redis_store.rb#79
  def write(name, value, options = T.unsafe(nil)); end

  protected

  # Implement the ActiveSupport::Cache#delete_entry
  #
  # It's really needed and use
  #
  # source://redis-activesupport//lib/active_support/cache/redis_store.rb#305
  def delete_entry(key, **options); end

  # Add the namespace defined in the options to a pattern designed to match keys.
  #
  # This implementation is __different__ than ActiveSupport:
  # __it doesn't accept Regular expressions__, because the Redis matcher is designed
  # only for strings with wildcards.
  #
  # source://redis-activesupport//lib/active_support/cache/redis_store.rb#320
  def key_matcher(pattern, options); end

  # @return [Boolean]
  #
  # source://redis-activesupport//lib/active_support/cache/redis_store.rb#311
  def raise_errors?; end

  # source://redis-activesupport//lib/active_support/cache/redis_store.rb#286
  def read_entry(key, options); end

  # source://redis-activesupport//lib/active_support/cache/redis_store.rb#279
  def write_entry(key, entry, options); end

  # source://redis-activesupport//lib/active_support/cache/redis_store.rb#294
  def write_key_expiry(client, key, options); end

  private

  # source://redis-activesupport//lib/active_support/cache/redis_store.rb#339
  def failsafe(method, returning: T.unsafe(nil)); end

  # source://redis-activesupport//lib/active_support/cache/redis_store.rb#347
  def handle_exception(exception: T.unsafe(nil), method: T.unsafe(nil), returning: T.unsafe(nil)); end
end

# source://redis-activesupport//lib/active_support/cache/redis_store.rb#16
ActiveSupport::Cache::RedisStore::DEFAULT_ERROR_HANDLER = T.let(T.unsafe(nil), Proc)

# source://redis-activesupport//lib/active_support/cache/redis_store.rb#8
ActiveSupport::Cache::RedisStore::ERRORS_TO_RESCUE = T.let(T.unsafe(nil), Array)
