# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `remote_lock` gem.
# Please instead update this file by running `bin/tapioca gem remote_lock`.


# source://remote_lock//lib/remote_lock.rb#1
class RemoteLock
  # @return [RemoteLock] a new instance of RemoteLock
  #
  # source://remote_lock//lib/remote_lock.rb#10
  def initialize(adapter, prefix = T.unsafe(nil)); end

  # @raise [RemoteLock::Error]
  #
  # source://remote_lock//lib/remote_lock.rb#29
  def acquire_lock(key, options = T.unsafe(nil)); end

  # @return [Boolean]
  #
  # source://remote_lock//lib/remote_lock.rb#44
  def acquired?(key); end

  # source://remote_lock//lib/remote_lock.rb#40
  def release_lock(key); end

  # source://remote_lock//lib/remote_lock.rb#16
  def synchronize(key, options = T.unsafe(nil)); end

  private

  # source://remote_lock//lib/remote_lock.rb#50
  def key_for(string); end
end

# source://remote_lock//lib/remote_lock/adapters/base.rb#3
module RemoteLock::Adapters; end

# source://remote_lock//lib/remote_lock/adapters/base.rb#4
class RemoteLock::Adapters::Base
  # @return [Base] a new instance of Base
  #
  # source://remote_lock//lib/remote_lock/adapters/base.rb#6
  def initialize(connection); end

  # @raise [NotImplementedError]
  #
  # source://remote_lock//lib/remote_lock/adapters/base.rb#18
  def delete(key); end

  # @raise [NotImplementedError]
  # @return [Boolean]
  #
  # source://remote_lock//lib/remote_lock/adapters/base.rb#14
  def has_key?(key, options = T.unsafe(nil)); end

  # @raise [NotImplementedError]
  #
  # source://remote_lock//lib/remote_lock/adapters/base.rb#10
  def store(key, options = T.unsafe(nil)); end

  private

  # source://remote_lock//lib/remote_lock/adapters/base.rb#35
  def thread_id; end

  # Globally unique ID for the current thread (or close enough)
  #
  # source://remote_lock//lib/remote_lock/adapters/base.rb#31
  def uid; end

  class << self
    # @return [Boolean]
    #
    # source://remote_lock//lib/remote_lock/adapters/base.rb#22
    def valid?(adapter); end
  end
end

# source://remote_lock//lib/remote_lock/adapters/dalli.rb#4
class RemoteLock::Adapters::Dalli < ::RemoteLock::Adapters::Base
  # source://remote_lock//lib/remote_lock/adapters/dalli.rb#10
  def delete(key); end

  # @return [Boolean]
  #
  # source://remote_lock//lib/remote_lock/adapters/dalli.rb#14
  def has_key?(key); end

  # source://remote_lock//lib/remote_lock/adapters/dalli.rb#6
  def store(key, expires_in_seconds); end
end

# source://remote_lock//lib/remote_lock/adapters/dalli_connection_pool.rb#4
class RemoteLock::Adapters::DalliConnectionPool < ::RemoteLock::Adapters::Base
  # source://remote_lock//lib/remote_lock/adapters/dalli_connection_pool.rb#12
  def delete(key); end

  # @return [Boolean]
  #
  # source://remote_lock//lib/remote_lock/adapters/dalli_connection_pool.rb#18
  def has_key?(key); end

  # source://remote_lock//lib/remote_lock/adapters/dalli_connection_pool.rb#6
  def store(key, expires_in_seconds); end
end

# source://remote_lock//lib/remote_lock/adapters/memcached.rb#4
class RemoteLock::Adapters::Memcached < ::RemoteLock::Adapters::Base
  # source://remote_lock//lib/remote_lock/adapters/memcached.rb#11
  def delete(key); end

  # @return [Boolean]
  #
  # source://remote_lock//lib/remote_lock/adapters/memcached.rb#15
  def has_key?(key); end

  # source://remote_lock//lib/remote_lock/adapters/memcached.rb#6
  def store(key, expires_in_seconds); end
end

# source://remote_lock//lib/remote_lock/adapters/redis.rb#4
class RemoteLock::Adapters::Redis < ::RemoteLock::Adapters::Base
  # source://remote_lock//lib/remote_lock/adapters/redis.rb#29
  def delete(key); end

  # @return [Boolean]
  #
  # source://remote_lock//lib/remote_lock/adapters/redis.rb#33
  def has_key?(key); end

  # source://remote_lock//lib/remote_lock/adapters/redis.rb#5
  def store(key, expires_in_seconds); end
end

# source://remote_lock//lib/remote_lock.rb#4
RemoteLock::DEFAULT_OPTIONS = T.let(T.unsafe(nil), Hash)

# source://remote_lock//lib/remote_lock.rb#2
class RemoteLock::Error < ::RuntimeError; end
