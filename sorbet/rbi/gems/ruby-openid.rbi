# This file is autogenerated. Do not edit it by hand. Regenerate it with:
#   srb rbi gems

# typed: true
#
# If you would like to make changes to this file, great! Please create the gem's shim here:
#
#   https://github.com/sorbet/sorbet-typed/new/master?filename=lib/ruby-openid/all/ruby-openid.rbi
#
# ruby-openid-2.9.2

module OpenID
  def self.arrange_by_type(service_list, preferred_types); end
  def self.best_matching_service(service, preferred_types); end
  def self.check_sreg_field_name(fieldname); end
  def self.discover(identifier); end
  def self.discover_no_yadis(uri); end
  def self.discover_uri(uri); end
  def self.discover_xri(iname); end
  def self.discover_yadis(uri); end
  def self.fetch(url, body = nil, headers = nil, redirect_limit = nil); end
  def self.fetcher; end
  def self.fetcher=(fetcher); end
  def self.fetcher_use_env_http_proxy; end
  def self.find_first_href(link_attrs_list, target_rel); end
  def self.find_links_rel(link_attrs_list, target_rel); end
  def self.find_op_local_identifier(service_element, type_uris); end
  def self.get_op_or_user_services(openid_services); end
  def self.get_secret_size(assoc_type); end
  def self.get_sreg_ns(message); end
  def self.link_has_rel(link_attrs, target_rel); end
  def self.make_kv_post(request_message, server_url); end
  def self.normalize_url(url); end
  def self.normalize_xri(xri); end
  def self.openid_unescape(s); end
  def self.parse_link_attrs(html); end
  def self.rel_matches(rel_attr, target_rel); end
  def self.supports_sreg?(endpoint); end
  def self.unescape_hash(h); end
end
class OpenID::AssertionError < Exception
end
class OpenID::OpenIDError < StandardError
end
module OpenID::Util
  def self.append_args(url, args); end
  def self.assert(value, message = nil); end
  def self.auto_submit_html(form, title = nil); end
  def self.dict_to_kv(d); end
  def self.from_base64(s); end
  def self.html_encode(str); end
  def self.kv_to_dict(s); end
  def self.kv_to_seq(data, strict = nil); end
  def self.log(message); end
  def self.logger; end
  def self.logger=(logger); end
  def self.parse_query(qs); end
  def self.seq_to_kv(seq, strict = nil); end
  def self.to_base64(s); end
  def self.urlencode(args); end
end
class OpenID::KVFormError < Exception
end
class OpenID::UndefinedOpenIDNamespace < Exception
end
class OpenID::NamespaceAliasRegistrationError < Exception
end
class OpenID::InvalidOpenIDNamespace < Exception
end
class OpenID::Message
  def ==(other); end
  def _fix_ns(namespace); end
  def _from_openid_args(openid_args); end
  def _get_default_namespace(mystery_alias); end
  def copy; end
  def del_arg(namespace, key); end
  def get_aliased_arg(aliased_key, default = nil); end
  def get_arg(namespace, key, default = nil); end
  def get_args(namespace); end
  def get_key(namespace, ns_key); end
  def get_openid_namespace; end
  def has_key?(namespace, ns_key); end
  def initialize(openid_namespace = nil); end
  def is_openid1; end
  def is_openid2; end
  def namespaces; end
  def self.from_http_response(response, server_url); end
  def self.from_kvform(kvform_string); end
  def self.from_openid_args(openid_args); end
  def self.from_post_args(args); end
  def self.register_namespace_alias(namespace_uri, alias_); end
  def set_arg(namespace, key, value); end
  def set_openid_namespace(openid_ns_uri, implicit); end
  def to_args; end
  def to_form_markup(action_url, form_tag_attrs = nil, submit_text = nil); end
  def to_kvform; end
  def to_post_args; end
  def to_url(base_url); end
  def to_url_encoded; end
  def update_args(namespace, updates); end
end
class OpenID::Message::KeyNotFound < IndexError
end
class OpenID::NamespaceMap
  def add(namespace_uri); end
  def add_alias(namespace_uri, desired_alias, implicit = nil); end
  def aliases; end
  def each; end
  def get_alias(namespace_uri); end
  def get_namespace_uri(namespace_alias); end
  def implicit?(namespace_uri); end
  def initialize; end
  def member?(namespace_uri); end
  def namespace_uris; end
end
class OpenID::ProtocolError < OpenID::OpenIDError
end
module Net
end
class Net::HTTP < Net::Protocol
  def post_connection_check(hostname); end
end
class OpenID::HTTPResponse
  def _response; end
  def _response=(arg0); end
  def body=(s); end
  def final_url; end
  def final_url=(arg0); end
  def method_missing(method, *args); end
  def self._from_net_response(response, final_url, headers = nil); end
end
class OpenID::FetchingError < OpenID::OpenIDError
end
class OpenID::HTTPRedirectLimitReached < OpenID::FetchingError
end
class OpenID::SSLFetchingError < OpenID::FetchingError
end
class OpenID::StandardFetcher
  def ca_file; end
  def ca_file=(arg0); end
  def fetch(url, body = nil, headers = nil, redirect_limit = nil); end
  def initialize(proxy_addr = nil, proxy_port = nil, proxy_user = nil, proxy_pass = nil); end
  def make_connection(uri); end
  def make_http(uri); end
  def set_verified(conn, verify); end
  def setup_encoding(response); end
  def supports_ssl?(conn); end
  def timeout; end
  def timeout=(arg0); end
end
class OpenID::ServerError < OpenID::OpenIDError
  def error_code; end
  def error_text; end
  def initialize(error_text, error_code, message); end
  def message; end
  def self.from_message(msg); end
end
class OpenID::KVPostNetworkError < OpenID::OpenIDError
end
class OpenID::HTTPStatusError < OpenID::OpenIDError
end
module OpenID::URINorm
  def self.remove_dot_segments(path); end
  def self.reserved(chr); end
  def self.urinorm(uri); end
end
module OpenID::Yadis
  def self.apply_filter(normalized_uri, xrd_data, flt = nil); end
  def self.disable_entity_expansion; end
  def self.discover(uri); end
  def self.each_service(xrds_tree, &block); end
  def self.expand_service(service_element); end
  def self.generate_accept_header(*elements); end
  def self.get_acceptable(accept_header, have_types); end
  def self.get_canonical_id(iname, xrd_tree); end
  def self.get_service_endpoints(input_url, flt = nil); end
  def self.get_yadis_xrd(xrds_tree); end
  def self.html_yadis_location(html); end
  def self.is_xrds?(xrds_tree); end
  def self.make_filter(parts); end
  def self.match_types(accept_types, have_types); end
  def self.mk_compound_filter(parts); end
  def self.parseXRDS(text); end
  def self.parse_accept_header(value); end
  def self.prio_sort(elements); end
  def self.services(xrds_tree); end
  def self.where_is_yadis?(resp); end
end
class HTMLTokenizer
  def getNextToken; end
  def getTag(*sought_tags); end
  def getText(until_tag = nil); end
  def getTrimmedText(until_tag = nil); end
  def initialize(content); end
  def page; end
  def peekNextToken; end
  def reset; end
  def self.version; end
end
class HTMLTokenizerError < Exception
end
class HTMLToken
  def ==(other); end
  def initialize(text); end
  def raw; end
  def raw=(arg0); end
  def text; end
  def to_s; end
  def trimmed_text; end
end
class HTMLText < HTMLToken
  def text; end
end
class HTMLComment < HTMLToken
  def contents; end
  def contents=(arg0); end
  def initialize(text); end
end
class HTMLTag < HTMLToken
  def attr_hash; end
  def end_tag; end
  def initialize(text); end
  def tag_name; end
  def text; end
end
class OpenID::DiscoveryFailure < OpenID::OpenIDError
  def http_response; end
  def http_response=(arg0); end
  def identity_url; end
  def identity_url=(arg0); end
  def initialize(message, http_response); end
end
class OpenID::Yadis::DiscoveryResult
  def content_type; end
  def content_type=(arg0); end
  def initialize(request_uri); end
  def is_xrds; end
  def normalize_uri; end
  def normalize_uri=(arg0); end
  def normalized_uri; end
  def normalized_uri=(arg0); end
  def request_uri; end
  def request_uri=(arg0); end
  def response_text; end
  def response_text=(arg0); end
  def used_yadis_location?; end
  def xrds_uri; end
  def xrds_uri=(arg0); end
end
module OpenID::Yadis::XRI
  def self.append_args(url, args); end
  def self.escape_for_iri(xri); end
  def self.identifier_scheme(identifier); end
  def self.iri_to_uri(iri); end
  def self.make_xri(xri); end
  def self.provider_is_authoritative(provider_id, canonical_id); end
  def self.root_authority(xri); end
  def self.to_iri_normal(xri); end
  def self.to_uri_normal(xri); end
  def self.urlencode(args); end
end
class OpenID::Yadis::XRDSError < StandardError
end
class OpenID::Yadis::XRDSFraud < OpenID::Yadis::XRDSError
end
class OpenID::Yadis::BasicServiceEndpoint
  def from_basic_service_endpoint(endpoint); end
  def initialize(yadis_url, type_uris, uri, service_element); end
  def match_types(type_uris); end
  def self.from_basic_service_endpoint(endpoint); end
  def service_element; end
  def type_uris; end
  def uri; end
  def yadis_url; end
end
class OpenID::Yadis::TransformFilterMaker
  def apply_filters(endpoint); end
  def filter_procs; end
  def get_service_endpoints(yadis_url, service_element); end
  def initialize(filter_procs); end
end
class OpenID::Yadis::CompoundFilter
  def get_service_endpoints(yadis_url, service_element); end
  def initialize(subfilters); end
  def subfilters; end
end
class OpenID::Yadis::XRI::XRIHTTPError < StandardError
end
class OpenID::Yadis::XRI::ProxyResolver
  def initialize(proxy_url = nil); end
  def query(xri); end
  def query_url(xri, service_type = nil); end
end
class OpenID::OpenIDServiceEndpoint
  def ==(other); end
  def canonical_id; end
  def canonical_id=(arg0); end
  def claimed_id; end
  def claimed_id=(arg0); end
  def compatibility_mode; end
  def display_identifier; end
  def display_identifier=(display_identifier); end
  def get_local_id; end
  def initialize; end
  def is_op_identifier; end
  def local_id; end
  def local_id=(arg0); end
  def parse_service(yadis_url, uri, type_uris, service_element); end
  def preferred_namespace; end
  def self.from_basic_service_endpoint(endpoint); end
  def self.from_discovery_result(discoveryResult); end
  def self.from_html(uri, html); end
  def self.from_op_endpoint_url(op_endpoint_url); end
  def self.from_session_value(value); end
  def self.from_xrds(uri, xrds); end
  def server_url; end
  def server_url=(arg0); end
  def supports_type(type_uri); end
  def to_s; end
  def to_session_value; end
  def type_uris; end
  def type_uris=(arg0); end
  def used_yadis; end
  def used_yadis=(arg0); end
  def uses_extension(extension_uri); end
end
class OpenID::TypeURIMismatch < OpenID::ProtocolError
  def endpoint; end
  def initialize(type_uri, endpoint); end
  def type_uri; end
end
class OpenID::Consumer
  def association_manager(service); end
  def begin(openid_identifier, anonymous = nil); end
  def begin_without_discovery(service, anonymous); end
  def cleanup_last_requested_endpoint; end
  def cleanup_session; end
  def complete(query, current_url); end
  def complete_cancel(unused_message, unused_return_to); end
  def complete_error(message, unused_return_to); end
  def complete_id_res(message, current_url); end
  def complete_invalid(message, unused_return_to); end
  def complete_setup_needed(message, unused_return_to); end
  def discover(identifier); end
  def discovery_manager(openid_identifier); end
  def handle_idres(message, current_url); end
  def initialize(session, store); end
  def last_requested_endpoint; end
  def last_requested_endpoint=(endpoint); end
  def negotiator; end
  def self.openid1_return_to_claimed_id_name; end
  def self.openid1_return_to_claimed_id_name=(query_arg_name); end
  def self.openid1_return_to_nonce_name; end
  def self.openid1_return_to_nonce_name=(query_arg_name); end
  def session_get(name); end
  def session_key(suffix); end
  def session_key_prefix; end
  def session_key_prefix=(arg0); end
  def session_set(name, val); end
end
class OpenID::Consumer::IdResHandler
  def check_auth; end
  def check_for_fields; end
  def check_nonce; end
  def check_signature; end
  def create_check_auth_request; end
  def discover_and_verify(claimed_id, to_match_endpoints); end
  def endpoint; end
  def fetch(field, default = nil); end
  def id_res; end
  def initialize(message, current_url, store = nil, endpoint = nil); end
  def message; end
  def openid_namespace; end
  def process_check_auth_response(response); end
  def server_url; end
  def signed_fields; end
  def signed_list; end
  def verify_discovered_services(claimed_id, services, to_match_endpoints); end
  def verify_discovery_results; end
  def verify_discovery_results_openid1; end
  def verify_discovery_results_openid2; end
  def verify_discovery_single(endpoint, to_match); end
  def verify_return_to; end
  def verify_return_to_args(msg_return_to); end
  def verify_return_to_base(msg_return_to); end
end
class OpenID::Consumer::CheckIDRequest
  def add_extension(extension_request); end
  def add_extension_arg(namespace, key, value); end
  def anonymous; end
  def anonymous=(is_anonymous); end
  def endpoint; end
  def form_markup(realm, return_to = nil, immediate = nil, form_tag_attrs = nil); end
  def get_message(realm, return_to = nil, immediate = nil); end
  def html_markup(realm, return_to = nil, immediate = nil, form_tag_attrs = nil); end
  def initialize(assoc, endpoint); end
  def message; end
  def message=(arg0); end
  def redirect_url(realm, return_to = nil, immediate = nil); end
  def return_to_args; end
  def return_to_args=(arg0); end
  def send_redirect?(realm, return_to = nil, immediate = nil); end
end
module OpenID::CryptUtil
  def self.base64_to_num(s); end
  def self.binary_to_num(s); end
  def self.const_eq(s1, s2); end
  def self.hmac_sha1(key, text); end
  def self.hmac_sha256(key, text); end
  def self.num_to_base64(l); end
  def self.num_to_binary(n); end
  def self.rand(max); end
  def self.random_string(length, chars = nil); end
  def self.sha1(text); end
  def self.sha256(text); end
end
class OpenID::DiffieHellman
  def generator; end
  def get_shared_secret(composite); end
  def initialize(modulus = nil, generator = nil, priv = nil); end
  def modulus; end
  def public; end
  def self.from_defaults; end
  def self.powermod(x, n, q); end
  def self.strxor(s, t); end
  def set_private(priv); end
  def using_default_values?; end
  def xor_secret(algorithm, composite, secret); end
end
class OpenID::Association
  def ==(other); end
  def assoc_type; end
  def check_message_signature(message); end
  def expires_in(now = nil); end
  def get_message_signature(message); end
  def handle; end
  def initialize(handle, secret, issued, lifetime, assoc_type); end
  def issued; end
  def lifetime; end
  def make_pairs(message); end
  def secret; end
  def self.deserialize(serialized); end
  def self.from_expires_in(expires_in, handle, secret, assoc_type); end
  def serialize; end
  def sign(pairs); end
  def sign_message(message); end
end
class OpenID::AssociationNegotiator
  def add_allowed_type(assoc_type, session_type = nil); end
  def allowed?(assoc_type, session_type); end
  def allowed_types; end
  def allowed_types=(allowed_types); end
  def copy; end
  def get_allowed_type; end
  def initialize(allowed_types); end
  def self.check_session_type(assoc_type, session_type); end
  def self.get_session_types(assoc_type); end
end
class OpenID::Consumer::DiffieHellmanSession
  def extract_secret(response); end
  def get_request; end
  def initialize(dh = nil); end
  def self.allowed_assoc_types; end
  def self.hashfunc; end
  def self.secret_size; end
  def self.session_type; end
end
class OpenID::Consumer::DiffieHellmanSHA1Session < OpenID::Consumer::DiffieHellmanSession
end
class OpenID::Consumer::DiffieHellmanSHA256Session < OpenID::Consumer::DiffieHellmanSession
end
class OpenID::Consumer::NoEncryptionSession
  def extract_secret(response); end
  def get_request; end
  def self.allowed_assoc_types; end
  def self.session_type; end
end
class OpenID::Consumer::AssociationManager
  def create_associate_request(assoc_type, session_type); end
  def extract_association(assoc_response, assoc_session); end
  def extract_supported_association_type(server_error, assoc_type); end
  def get_association; end
  def get_openid1_session_type(assoc_response); end
  def initialize(store, server_url, compatibility_mode = nil, negotiator = nil); end
  def negotiate_association; end
  def request_association(assoc_type, session_type); end
  def self.create_session(session_type); end
  def self.extract_expires_in(message); end
end
module OpenID::Consumer::Response
  def display_identifier; end
  def endpoint; end
  def identity_url; end
  def status; end
end
class OpenID::Consumer::SuccessResponse
  def extension_response(namespace_uri, require_signed); end
  def get_signed(ns_uri, ns_key, default = nil); end
  def get_signed_ns(ns_uri); end
  def initialize(endpoint, message, signed_fields); end
  def is_openid1; end
  def message; end
  def signed?(ns_uri, ns_key); end
  def signed_fields; end
  include OpenID::Consumer::Response
end
class OpenID::Consumer::FailureResponse
  def contact; end
  def initialize(endpoint, message, contact = nil, reference = nil); end
  def message; end
  def reference; end
  include OpenID::Consumer::Response
end
class OpenID::Consumer::CancelResponse
  def initialize(endpoint); end
  include OpenID::Consumer::Response
end
class OpenID::Consumer::SetupNeededResponse
  def initialize(endpoint, setup_url); end
  def setup_url; end
  include OpenID::Consumer::Response
end
class OpenID::Consumer::Session
  def [](key); end
  def []=(key, val); end
  def initialize(session, decode_klass = nil); end
  def keys; end
  def to_session_value(val); end
end
class OpenID::Consumer::DiscoveredServices
  def ==(other); end
  def current; end
  def empty?; end
  def for_url?(url); end
  def initialize(starting_url, yadis_url, services); end
  def next; end
  def self.from_session_value(value); end
  def started?; end
  def to_session_value; end
end
class OpenID::Consumer::DiscoveryManager
  def cleanup(force = nil); end
  def create_manager(yadis_url, services); end
  def destroy!; end
  def destroy_manager(force = nil); end
  def get_manager(force = nil); end
  def get_next_service; end
  def initialize(session, url, session_key_suffix = nil); end
  def load; end
  def session_key; end
  def store(manager); end
end
module OpenID::Nonce
  def self.check_timestamp(nonce_str, allowed_skew = nil, now = nil); end
  def self.mk_nonce(time = nil); end
  def self.skew; end
  def self.skew=(new_skew); end
  def self.split_nonce(nonce_str); end
end
class OpenID::RealmVerificationRedirected < Exception
  def initialize(relying_party_url, rp_url_after_redirects); end
  def to_s; end
end
module OpenID::TrustRoot
  def self._extract_return_url(endpoint); end
  def self.get_allowed_return_urls(relying_party_url); end
  def self.return_to_matches(allowed_return_to_urls, return_to); end
  def self.verify_return_to(realm_str, return_to, _vrfy = nil); end
end
class OpenID::TrustRoot::TrustRoot
  def build_discovery_url; end
  def host; end
  def initialize(unparsed, proto, wildcard, host, port, path); end
  def path; end
  def port; end
  def proto; end
  def sane?; end
  def self._build_path(path, query = nil, frag = nil); end
  def self._parse_url(url); end
  def self.check_sanity(trust_root_string); end
  def self.check_url(trust_root, url); end
  def self.parse(trust_root); end
  def unparsed; end
  def validate_url(url); end
  def wildcard; end
end
module OpenID::Server
end
class OpenID::Server::OpenIDRequest
  def initialize; end
  def message; end
  def message=(arg0); end
  def mode; end
  def mode=(arg0); end
  def namespace; end
end
class OpenID::Server::CheckAuthRequest < OpenID::Server::OpenIDRequest
  def answer(signatory); end
  def assoc_handle; end
  def assoc_handle=(arg0); end
  def initialize(assoc_handle, signed, invalidate_handle = nil); end
  def invalidate_handle; end
  def invalidate_handle=(arg0); end
  def self.from_message(message, op_endpoint = nil); end
  def sig; end
  def sig=(arg0); end
  def signed; end
  def signed=(arg0); end
  def to_s; end
end
class OpenID::Server::BaseServerSession
  def allowed_assoc_type?(typ); end
  def initialize(session_type, allowed_assoc_types); end
  def session_type; end
end
class OpenID::Server::PlainTextServerSession < OpenID::Server::BaseServerSession
  def answer(secret); end
  def initialize; end
  def self.from_message(unused_request); end
  def session_type; end
end
class OpenID::Server::DiffieHellmanSHA1ServerSession < OpenID::Server::BaseServerSession
  def answer(secret); end
  def consumer_pubkey; end
  def consumer_pubkey=(arg0); end
  def dh; end
  def dh=(arg0); end
  def initialize(dh, consumer_pubkey); end
  def self.from_message(message); end
  def session_type; end
end
class OpenID::Server::DiffieHellmanSHA256ServerSession < OpenID::Server::DiffieHellmanSHA1ServerSession
  def initialize(*args); end
end
class OpenID::Server::AssociateRequest < OpenID::Server::OpenIDRequest
  def answer(assoc); end
  def answer_unsupported(message, preferred_association_type = nil, preferred_session_type = nil); end
  def assoc_type; end
  def assoc_type=(arg0); end
  def initialize(session, assoc_type); end
  def self.from_message(message, op_endpoint = nil); end
  def session; end
  def session=(arg0); end
end
class OpenID::Server::CheckIDRequest < OpenID::Server::OpenIDRequest
  def answer(allow, server_url = nil, identity = nil, claimed_id = nil); end
  def assoc_handle; end
  def assoc_handle=(arg0); end
  def cancel_url; end
  def claimed_id; end
  def claimed_id=(arg0); end
  def encode_to_url(server_url); end
  def id_select; end
  def identity; end
  def identity=(arg0); end
  def immediate; end
  def immediate=(arg0); end
  def initialize(identity, return_to, op_endpoint, trust_root = nil, immediate = nil, assoc_handle = nil, claimed_id = nil); end
  def mode; end
  def mode=(arg0); end
  def op_endpoint; end
  def op_endpoint=(arg0); end
  def return_to; end
  def return_to=(arg0); end
  def return_to_verified; end
  def self.from_message(message, op_endpoint); end
  def to_s; end
  def trust_root; end
  def trust_root=(arg0); end
  def trust_root_valid; end
end
class OpenID::Server::OpenIDResponse
  def add_extension(extension_response); end
  def copy; end
  def encode_to_kvform; end
  def encode_to_url; end
  def fields; end
  def fields=(arg0); end
  def initialize(request); end
  def needs_signing; end
  def render_as_form; end
  def request; end
  def request=(arg0); end
  def to_form_markup(form_tag_attrs = nil); end
  def to_html(form_tag_attrs = nil); end
  def to_s; end
  def which_encoding; end
end
class OpenID::Server::WebResponse
  def body; end
  def body=(arg0); end
  def code; end
  def code=(arg0); end
  def headers; end
  def headers=(arg0); end
  def initialize(code = nil, headers = nil, body = nil); end
end
class OpenID::Server::Signatory
  def create_association(dumb = nil, assoc_type = nil); end
  def get_association(assoc_handle, dumb, checkExpiration = nil); end
  def initialize(store); end
  def invalidate(assoc_handle, dumb); end
  def secret_lifetime; end
  def secret_lifetime=(arg0); end
  def self._dumb_key; end
  def self._normal_key; end
  def sign(response); end
  def store; end
  def store=(arg0); end
  def verify(assoc_handle, message); end
end
class OpenID::Server::Encoder
  def encode(response); end
end
class OpenID::Server::SigningEncoder < OpenID::Server::Encoder
  def encode(response); end
  def initialize(signatory); end
  def signatory; end
  def signatory=(arg0); end
end
class OpenID::Server::Decoder
  def decode(query); end
  def default_decoder(message, server); end
  def initialize(server); end
  def server; end
  def server=(arg0); end
end
class OpenID::Server::Server
  def decode_request(query); end
  def decoder; end
  def decoder=(arg0); end
  def encode_response(response); end
  def encoder; end
  def encoder=(arg0); end
  def handle_request(request); end
  def initialize(store, op_endpoint); end
  def negotiator; end
  def negotiator=(arg0); end
  def op_endpoint; end
  def op_endpoint=(arg0); end
  def openid_associate(request); end
  def openid_check_authentication(request); end
  def signatory; end
  def signatory=(arg0); end
  def store; end
  def store=(arg0); end
end
class OpenID::Server::ProtocolError < Exception
  def contact; end
  def contact=(arg0); end
  def encode_to_kvform; end
  def encode_to_url; end
  def get_return_to; end
  def has_return_to; end
  def initialize(message, text = nil, reference = nil, contact = nil); end
  def openid_message; end
  def openid_message=(arg0); end
  def reference; end
  def reference=(arg0); end
  def to_form_markup; end
  def to_html; end
  def to_message; end
  def which_encoding; end
end
class OpenID::Server::VersionError < Exception
end
class OpenID::Server::NoReturnToError < Exception
end
class OpenID::Server::EncodingError < Exception
  def initialize(response); end
  def response; end
end
class OpenID::Server::AlreadySigned < OpenID::Server::EncodingError
end
class OpenID::Server::UntrustedReturnURL < OpenID::Server::ProtocolError
  def initialize(message, return_to, trust_root); end
  def return_to; end
  def to_s; end
  def trust_root; end
end
class OpenID::Server::MalformedReturnURL < OpenID::Server::ProtocolError
  def initialize(openid_message, return_to); end
  def return_to; end
end
class OpenID::Server::MalformedTrustRoot < OpenID::Server::ProtocolError
end
class OpenID::Extension
  def get_extension_args; end
  def initialize; end
  def to_message(message = nil); end
end
module OpenID::SReg
end
class OpenID::SReg::NamespaceError < ArgumentError
end
class OpenID::SReg::Request < OpenID::Extension
  def all_requested_fields; end
  def get_extension_args; end
  def initialize(required = nil, optional = nil, policy_url = nil, ns_uri = nil); end
  def member?(field_name); end
  def ns_uri; end
  def optional; end
  def parse_extension_args(args, strict = nil); end
  def policy_url; end
  def policy_url=(arg0); end
  def request_field(field_name, required = nil, strict = nil); end
  def request_fields(field_names, required = nil, strict = nil); end
  def required; end
  def self.from_openid_request(request); end
  def were_fields_requested?; end
end
class OpenID::SReg::Response < OpenID::Extension
  def [](field_name); end
  def data; end
  def empty?; end
  def get_extension_args; end
  def initialize(data = nil, ns_uri = nil); end
  def ns_uri; end
  def self.extract_response(request, data); end
  def self.from_success_response(success_response, signed_only = nil); end
end
module OpenID::AX
  def self.check_alias(name); end
  def self.to_type_uris(namespace_map, alias_list_s); end
end
class OpenID::AX::Error < ArgumentError
end
class OpenID::AX::AXMessage < OpenID::Extension
  def check_mode(ax_args); end
  def initialize; end
  def mode; end
  def mode=(arg0); end
  def new_args; end
  def ns_alias; end
  def ns_alias=(arg0); end
  def ns_uri; end
  def ns_uri=(arg0); end
end
class OpenID::AX::AttrInfo
  def count; end
  def initialize(type_uri, ns_alias = nil, required = nil, count = nil); end
  def ns_alias; end
  def required; end
  def required=(arg0); end
  def type_uri; end
  def wants_unlimited_values?; end
end
class OpenID::AX::FetchRequest < OpenID::AX::AXMessage
  def add(attribute); end
  def attributes; end
  def get_extension_args; end
  def get_required_attrs; end
  def initialize(update_url = nil); end
  def member?(type_uri); end
  def parse_extension_args(ax_args); end
  def requested_attributes; end
  def requested_types; end
  def self.from_openid_request(oidreq); end
  def update_url; end
  def update_url=(arg0); end
end
class OpenID::AX::KeyValueMessage < OpenID::AX::AXMessage
  def [](type_uri); end
  def _get_extension_kv_args(aliases = nil); end
  def add_value(type_uri, value); end
  def count(type_uri); end
  def data; end
  def get(type_uri); end
  def get_single(type_uri, default = nil); end
  def initialize; end
  def parse_extension_args(ax_args); end
  def set_values(type_uri, values); end
end
class OpenID::AX::FetchResponse < OpenID::AX::KeyValueMessage
  def aliases; end
  def aliases=(arg0); end
  def get_extension_args(request = nil); end
  def initialize(update_url = nil); end
  def parse_extension_args(ax_args); end
  def self.from_success_response(success_response, signed = nil); end
  def update_url; end
end
class OpenID::AX::StoreRequest < OpenID::AX::KeyValueMessage
  def get_extension_args(aliases = nil); end
  def initialize; end
  def self.from_openid_request(oidreq); end
end
class OpenID::AX::StoreResponse < OpenID::AX::AXMessage
  def error_message; end
  def get_extension_args; end
  def initialize(succeeded = nil, error_message = nil); end
  def self.from_success_response(success_response); end
  def succeeded?; end
end
module OpenID::OAuth
end
class OpenID::OAuth::Request < OpenID::Extension
  def consumer; end
  def consumer=(arg0); end
  def get_extension_args; end
  def initialize(consumer = nil, scope = nil); end
  def ns_alias; end
  def ns_alias=(arg0); end
  def ns_uri; end
  def ns_uri=(arg0); end
  def parse_extension_args(args); end
  def scope; end
  def scope=(arg0); end
  def self.from_openid_request(oid_req); end
end
class OpenID::OAuth::Response < OpenID::Extension
  def get_extension_args; end
  def initialize(request_token = nil, scope = nil); end
  def parse_extension_args(args, strict = nil); end
  def request_token; end
  def request_token=(arg0); end
  def scope; end
  def scope=(arg0); end
  def self.from_success_response(success_response); end
end
module OpenID::PAPE
end
class OpenID::PAPE::Request < OpenID::Extension
  def add_policy_uri(policy_uri); end
  def get_extension_args; end
  def initialize(preferred_auth_policies = nil, max_auth_age = nil); end
  def max_auth_age; end
  def max_auth_age=(arg0); end
  def ns_alias; end
  def ns_alias=(arg0); end
  def ns_uri; end
  def ns_uri=(arg0); end
  def parse_extension_args(args); end
  def preferred_auth_policies; end
  def preferred_auth_policies=(arg0); end
  def preferred_types(supported_types); end
  def self.from_openid_request(oid_req); end
end
class OpenID::PAPE::Response < OpenID::Extension
  def add_policy_uri(policy_uri); end
  def auth_policies; end
  def auth_policies=(arg0); end
  def auth_time; end
  def auth_time=(arg0); end
  def get_extension_args; end
  def initialize(auth_policies = nil, auth_time = nil, nist_auth_level = nil); end
  def nist_auth_level; end
  def nist_auth_level=(arg0); end
  def ns_alias; end
  def ns_alias=(arg0); end
  def parse_extension_args(args, strict = nil); end
  def self.from_success_response(success_response); end
end
module OpenID::Store
end
class OpenID::Store::Interface
  def cleanup; end
  def cleanup_associations; end
  def cleanup_nonces; end
  def get_association(server_url, handle = nil); end
  def remove_association(server_url, handle); end
  def store_association(server_url, association); end
  def use_nonce(server_url, timestamp, salt); end
end
class OpenID::Store::Memory < OpenID::Store::Interface
  def cleanup_associations; end
  def cleanup_nonces; end
  def deepcopy(o); end
  def get_association(server_url, handle = nil); end
  def initialize; end
  def remove_association(server_url, handle); end
  def store_association(server_url, assoc); end
  def use_nonce(server_url, timestamp, salt); end
end
