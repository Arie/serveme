# This file is autogenerated. Do not edit it by hand. Regenerate it with:
#   srb rbi gems

# typed: true
#
# If you would like to make changes to this file, great! Please create the gem's shim here:
#
#   https://github.com/sorbet/sorbet-typed/new/master?filename=lib/rubyntlm/all/rubyntlm.rbi
#
# rubyntlm-0.6.5

module Net
end
module Net::NTLM
  def self.apply_des(plain, keys); end
  def self.gen_keys(str); end
  def self.is_ntlm_hash?(data); end
  def self.lm_hash(password); end
  def self.lm_response(arg); end
  def self.lmv2_response(arg, opt = nil); end
  def self.ntlm2_session(arg, opt = nil); end
  def self.ntlm_hash(password, opt = nil); end
  def self.ntlm_response(arg); end
  def self.ntlmv2_hash(user, password, target, opt = nil); end
  def self.ntlmv2_response(arg, opt = nil); end
  def self.pack_int64le(val); end
  def self.split7(str); end
end
class Net::NTLM::NtlmError < StandardError
end
class Net::NTLM::InvalidTargetDataError < Net::NTLM::NtlmError
  def data; end
  def initialize(msg, data); end
end
class Net::NTLM::Field
  def active; end
  def active=(arg0); end
  def initialize(opts); end
  def parse(str, offset = nil); end
  def serialize; end
  def size; end
  def value; end
  def value=(arg0); end
end
class Net::NTLM::Int16LE < Net::NTLM::Field
  def initialize(opt); end
  def parse(str, offset = nil); end
  def serialize; end
end
class Net::NTLM::Int32LE < Net::NTLM::Field
  def initialize(opt); end
  def parse(str, offset = nil); end
  def serialize; end
end
class Net::NTLM::Int64LE < Net::NTLM::Field
  def initialize(opt); end
  def parse(str, offset = nil); end
  def serialize; end
end
class Net::NTLM::String < Net::NTLM::Field
  def initialize(opts); end
  def parse(str, offset = nil); end
  def serialize; end
  def value=(val); end
end
class Net::NTLM::FieldSet
  def [](name); end
  def []=(name, val); end
  def disable(name); end
  def enable(name); end
  def has_disabled_fields?; end
  def initialize; end
  def parse(str, offset = nil); end
  def self.add_field(name, type, opts); end
  def self.define_accessor(name); end
  def self.int16LE(name, opts); end
  def self.int32LE(name, opts); end
  def self.int64LE(name, opts); end
  def self.names; end
  def self.opts; end
  def self.prototypes; end
  def self.security_buffer(name, opts); end
  def self.string(name, opts); end
  def self.types; end
  def serialize; end
  def size; end
end
class Net::NTLM::Blob < Net::NTLM::FieldSet
  def blob_signature; end
  def blob_signature=(val); end
  def challenge; end
  def challenge=(val); end
  def parse(str, offset = nil); end
  def reserved; end
  def reserved=(val); end
  def target_info; end
  def target_info=(val); end
  def timestamp; end
  def timestamp=(val); end
  def unknown1; end
  def unknown1=(val); end
  def unknown2; end
  def unknown2=(val); end
end
class Net::NTLM::SecurityBuffer < Net::NTLM::FieldSet
  def active; end
  def active=(arg0); end
  def allocated; end
  def allocated=(val); end
  def data_size; end
  def initialize(opts = nil); end
  def length; end
  def length=(val); end
  def offset; end
  def offset=(val); end
  def parse(str, offset = nil); end
  def serialize; end
  def value; end
  def value=(val); end
end
class Net::NTLM::Message < Net::NTLM::FieldSet
  def data_edge; end
  def data_size; end
  def decode64(str); end
  def deflag; end
  def dump_flags; end
  def encode64; end
  def has_flag?(flag); end
  def head_size; end
  def parse(str); end
  def security_buffers; end
  def self.decode64(str); end
  def self.parse(str); end
  def serialize; end
  def set_flag(flag); end
  def size; end
end
class Net::NTLM::Message::Type0 < Net::NTLM::Message
  def sign; end
  def sign=(val); end
  def type; end
  def type=(val); end
end
class Net::NTLM::Message::Type1 < Net::NTLM::Message
  def domain; end
  def domain=(val); end
  def flag; end
  def flag=(val); end
  def os_version; end
  def os_version=(val); end
  def sign; end
  def sign=(val); end
  def type; end
  def type=(val); end
  def workstation; end
  def workstation=(val); end
end
class Net::NTLM::Message::Type2 < Net::NTLM::Message
  def challenge; end
  def challenge=(val); end
  def context; end
  def context=(val); end
  def flag; end
  def flag=(val); end
  def os_version; end
  def os_version=(val); end
  def response(arg, opt = nil); end
  def sign; end
  def sign=(val); end
  def target_info; end
  def target_info=(val); end
  def target_name; end
  def target_name=(val); end
  def type; end
  def type=(val); end
end
class Net::NTLM::Message::Type3 < Net::NTLM::Message
  def blank_password?(server_challenge); end
  def domain; end
  def domain=(val); end
  def flag; end
  def flag=(val); end
  def lm_response; end
  def lm_response=(val); end
  def ntlm2_session_password?(password, server_challenge); end
  def ntlm_response; end
  def ntlm_response=(val); end
  def ntlm_version; end
  def ntlmv2_password?(password, server_challenge); end
  def os_version; end
  def os_version=(val); end
  def password?(password, server_challenge); end
  def self.create(arg, opt = nil); end
  def session_key; end
  def session_key=(val); end
  def sign; end
  def sign=(val); end
  def type; end
  def type=(val); end
  def user; end
  def user=(val); end
  def workstation; end
  def workstation=(val); end
end
class Net::NTLM::EncodeUtil
  def self.decode_utf16le(str); end
  def self.encode_utf16le(str); end
end
class Net::NTLM::Md4
  def self.digest(string); end
end
class Net::NTLM::Rc4
  def encrypt(text); end
  def initialize(str); end
  def initialize_state(key); end
end
class Net::NTLM::Client::Session
  def authenticate!; end
  def blob; end
  def calculate_user_session_key!; end
  def challenge_message; end
  def channel_binding; end
  def client; end
  def client_challenge; end
  def client_cipher; end
  def client_seal_key; end
  def client_sign_key; end
  def domain; end
  def exported_session_key; end
  def initialize(client, challenge_message, channel_binding = nil); end
  def is_anonymous?; end
  def lmv2_resp; end
  def negotiate_key_exchange?; end
  def nt_proof_str; end
  def ntlmv2_hash; end
  def ntlmv2_resp; end
  def oem_or_unicode_str(str); end
  def password; end
  def raw_sequence; end
  def seal_message(message); end
  def sequence; end
  def server_challenge; end
  def server_cipher; end
  def server_seal_key; end
  def server_sign_key; end
  def sign_message(message); end
  def target_info; end
  def timestamp; end
  def unseal_message(emessage); end
  def use_oem_strings?; end
  def user_session_key; end
  def username; end
  def verify_signature(signature, message); end
  def workstation; end
end
class Net::NTLM::Client
  def domain; end
  def flags; end
  def init_context(resp = nil, channel_binding = nil); end
  def initialize(username, password, opts = nil); end
  def password; end
  def session; end
  def session_key; end
  def type1_message; end
  def username; end
  def workstation; end
end
class Net::NTLM::ChannelBinding
  def acceptor_address_length; end
  def acceptor_addrtype; end
  def application_data; end
  def channel; end
  def channel_binding_token; end
  def channel_hash; end
  def gss_channel_bindings_struct; end
  def initialize(outer_channel); end
  def initiator_address_length; end
  def initiator_addtype; end
  def self.create(outer_channel); end
  def unique_prefix; end
end
class Net::NTLM::TargetInfo
  def av_pairs; end
  def initialize(av_pair_sequence); end
  def read_pairs(av_pair_sequence); end
  def to_hex(str); end
  def to_s; end
end
