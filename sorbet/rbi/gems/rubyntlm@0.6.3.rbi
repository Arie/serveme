# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `rubyntlm` gem.
# Please instead update this file by running `bin/tapioca gem rubyntlm`.

# source://rubyntlm//lib/net/ntlm/exceptions.rb#2
module Net::NTLM
  class << self
    # source://rubyntlm//lib/net/ntlm.rb#125
    def apply_des(plain, keys); end

    # Not sure what this is doing
    #
    # @api private
    # @param str [String] String to generate keys for
    #
    # source://rubyntlm//lib/net/ntlm.rb#117
    def gen_keys(str); end

    # Takes a string and determines whether it is a valid NTLM Hash
    #
    # @param the [String] string to validate
    # @return [Boolean] whether or not the string is a valid NTLM hash
    #
    # source://rubyntlm//lib/net/ntlm.rb#87
    def is_ntlm_hash?(data); end

    # Generates a Lan Manager Hash
    #
    # @param password [String] The password to base the hash on
    #
    # source://rubyntlm//lib/net/ntlm.rb#136
    def lm_hash(password); end

    # source://rubyntlm//lib/net/ntlm.rb#171
    def lm_response(arg); end

    # source://rubyntlm//lib/net/ntlm.rb#226
    def lmv2_response(arg, opt = T.unsafe(nil)); end

    # source://rubyntlm//lib/net/ntlm.rb#242
    def ntlm2_session(arg, opt = T.unsafe(nil)); end

    # Generate a NTLM Hash
    #
    # @option opt
    # @param password [String] The password to base the hash on
    # @param opt [Hash] a customizable set of options
    #
    # source://rubyntlm//lib/net/ntlm.rb#144
    def ntlm_hash(password, opt = T.unsafe(nil)); end

    # source://rubyntlm//lib/net/ntlm.rb#183
    def ntlm_response(arg); end

    # Generate a NTLMv2 Hash
    #
    # @option opt
    # @param user [String] The username
    # @param password [String] The password
    # @param target [String] The domain or workstation to authenticate to
    # @param opt [Hash] a customizable set of options
    #
    # source://rubyntlm//lib/net/ntlm.rb#157
    def ntlmv2_hash(user, password, target, opt = T.unsafe(nil)); end

    # source://rubyntlm//lib/net/ntlm.rb#191
    def ntlmv2_response(arg, opt = T.unsafe(nil)); end

    # Conver the value to a 64-Bit Little Endian Int
    #
    # @param val [String] The string to convert
    #
    # source://rubyntlm//lib/net/ntlm.rb#99
    def pack_int64le(val); end

    # Builds an array of strings that are 7 characters long
    #
    # @api private
    # @param str [String] The string to split
    #
    # source://rubyntlm//lib/net/ntlm.rb#106
    def split7(str); end
  end
end

# source://rubyntlm//lib/net/ntlm/blob.rb#6
class Net::NTLM::Blob < ::Net::NTLM::FieldSet
  # source://rubyntlm//lib/net/ntlm/field_set.rb#76
  def blob_signature; end

  # source://rubyntlm//lib/net/ntlm/field_set.rb#80
  def blob_signature=(val); end

  # source://rubyntlm//lib/net/ntlm/field_set.rb#76
  def challenge; end

  # source://rubyntlm//lib/net/ntlm/field_set.rb#80
  def challenge=(val); end

  # source://rubyntlm//lib/net/ntlm/blob.rb#15
  def parse(str, offset = T.unsafe(nil)); end

  # source://rubyntlm//lib/net/ntlm/field_set.rb#76
  def reserved; end

  # source://rubyntlm//lib/net/ntlm/field_set.rb#80
  def reserved=(val); end

  # source://rubyntlm//lib/net/ntlm/field_set.rb#76
  def target_info; end

  # source://rubyntlm//lib/net/ntlm/field_set.rb#80
  def target_info=(val); end

  # source://rubyntlm//lib/net/ntlm/field_set.rb#76
  def timestamp; end

  # source://rubyntlm//lib/net/ntlm/field_set.rb#80
  def timestamp=(val); end

  # source://rubyntlm//lib/net/ntlm/field_set.rb#76
  def unknown1; end

  # source://rubyntlm//lib/net/ntlm/field_set.rb#80
  def unknown1=(val); end

  # source://rubyntlm//lib/net/ntlm/field_set.rb#76
  def unknown2; end

  # source://rubyntlm//lib/net/ntlm/field_set.rb#80
  def unknown2=(val); end
end

# source://rubyntlm//lib/net/ntlm/channel_binding.rb#3
class Net::NTLM::ChannelBinding
  # @param outer_channel [OpenSSL::X509::Certificate] Server certificate securing
  #   the outer TLS channel
  # @return [ChannelBinding] a new instance of ChannelBinding
  #
  # source://rubyntlm//lib/net/ntlm/channel_binding.rb#18
  def initialize(outer_channel); end

  # Returns the value of attribute acceptor_address_length.
  #
  # source://rubyntlm//lib/net/ntlm/channel_binding.rb#29
  def acceptor_address_length; end

  # Returns the value of attribute acceptor_addrtype.
  #
  # source://rubyntlm//lib/net/ntlm/channel_binding.rb#28
  def acceptor_addrtype; end

  # source://rubyntlm//lib/net/ntlm/channel_binding.rb#55
  def application_data; end

  # Returns the value of attribute channel.
  #
  # source://rubyntlm//lib/net/ntlm/channel_binding.rb#27
  def channel; end

  # Returns a channel binding hash acceptable for use as a AV_PAIR MsvAvChannelBindings
  #   field value as specified in the NTLM protocol
  #
  # @return [String] MD5 hash of gss_channel_bindings_struct
  #
  # source://rubyntlm//lib/net/ntlm/channel_binding.rb#35
  def channel_binding_token; end

  # source://rubyntlm//lib/net/ntlm/channel_binding.rb#51
  def channel_hash; end

  # source://rubyntlm//lib/net/ntlm/channel_binding.rb#39
  def gss_channel_bindings_struct; end

  # Returns the value of attribute initiator_address_length.
  #
  # source://rubyntlm//lib/net/ntlm/channel_binding.rb#28
  def initiator_address_length; end

  # Returns the value of attribute initiator_addtype.
  #
  # source://rubyntlm//lib/net/ntlm/channel_binding.rb#27
  def initiator_addtype; end

  # Returns the value of attribute unique_prefix.
  #
  # source://rubyntlm//lib/net/ntlm/channel_binding.rb#27
  def unique_prefix; end

  class << self
    # Creates a ChannelBinding used for Extended Protection Authentication
    #
    # @param outer_channel [OpenSSL::X509::Certificate] Server certificate securing
    #   the outer TLS channel
    # @return [NTLM::ChannelBinding] A ChannelBinding holding a token that can be
    #   embedded in a {Type3} message
    # @see http://blogs.msdn.com/b/openspecification/archive/2013/03/26/ntlm-and-channel-binding-hash-aka-exteneded-protection-for-authentication.aspx
    #
    # source://rubyntlm//lib/net/ntlm/channel_binding.rb#12
    def create(outer_channel); end
  end
end

# source://rubyntlm//lib/net/ntlm/client.rb#3
class Net::NTLM::Client
  # @note All string parameters should be encoded in UTF-8. The proper
  #   final encoding for placing in the various {Message messages} will be
  #   chosen based on negotiation with the server.
  # @option opts
  # @option opts
  # @option opts
  # @param username [String]
  # @param password [String]
  # @param opts [Hash] a customizable set of options
  # @return [Client] a new instance of Client
  #
  # source://rubyntlm//lib/net/ntlm/client.rb#21
  def initialize(username, password, opts = T.unsafe(nil)); end

  # Returns the value of attribute domain.
  #
  # source://rubyntlm//lib/net/ntlm/client.rb#10
  def domain; end

  # Returns the value of attribute flags.
  #
  # source://rubyntlm//lib/net/ntlm/client.rb#10
  def flags; end

  # @return [NTLM::Message]
  #
  # source://rubyntlm//lib/net/ntlm/client.rb#30
  def init_context(resp = T.unsafe(nil), channel_binding = T.unsafe(nil)); end

  # Returns the value of attribute password.
  #
  # source://rubyntlm//lib/net/ntlm/client.rb#10
  def password; end

  # @return [Client::Session]
  #
  # source://rubyntlm//lib/net/ntlm/client.rb#41
  def session; end

  # source://rubyntlm//lib/net/ntlm/client.rb#45
  def session_key; end

  # Returns the value of attribute username.
  #
  # source://rubyntlm//lib/net/ntlm/client.rb#10
  def username; end

  # Returns the value of attribute workstation.
  #
  # source://rubyntlm//lib/net/ntlm/client.rb#10
  def workstation; end

  private

  # @return [Message::Type1]
  #
  # source://rubyntlm//lib/net/ntlm/client.rb#52
  def type1_message; end
end

# source://rubyntlm//lib/net/ntlm/client/session.rb#3
class Net::NTLM::Client::Session
  # source://rubyntlm//lib/net/ntlm/client/session.rb#17
  def initialize(client, challenge_message, channel_binding = T.unsafe(nil)); end

  # source://rubyntlm//lib/net/ntlm/client/session.rb#26
  def authenticate!; end

  # source://rubyntlm//lib/net/ntlm/client/session.rb#13
  def challenge_message; end

  # source://rubyntlm//lib/net/ntlm/client/session.rb#13
  def channel_binding; end

  # source://rubyntlm//lib/net/ntlm/client/session.rb#13
  def client; end

  # source://rubyntlm//lib/net/ntlm/client/session.rb#49
  def exported_session_key; end

  # source://rubyntlm//lib/net/ntlm/client/session.rb#80
  def seal_message(message); end

  # source://rubyntlm//lib/net/ntlm/client/session.rb#60
  def sign_message(message); end

  # source://rubyntlm//lib/net/ntlm/client/session.rb#85
  def unseal_message(emessage); end

  # source://rubyntlm//lib/net/ntlm/client/session.rb#70
  def verify_signature(signature, message); end

  private

  # source://rubyntlm//lib/net/ntlm/client/session.rb#211
  def blob; end

  # source://rubyntlm//lib/net/ntlm/client/session.rb#195
  def calculate_user_session_key!; end

  # source://rubyntlm//lib/net/ntlm/client/session.rb#145
  def client_challenge; end

  # source://rubyntlm//lib/net/ntlm/client/session.rb#125
  def client_cipher; end

  # source://rubyntlm//lib/net/ntlm/client/session.rb#117
  def client_seal_key; end

  # source://rubyntlm//lib/net/ntlm/client/session.rb#109
  def client_sign_key; end

  # source://rubyntlm//lib/net/ntlm/client/session.rb#179
  def domain; end

  # source://rubyntlm//lib/net/ntlm/client/session.rb#199
  def lmv2_resp; end

  # source://rubyntlm//lib/net/ntlm/client/session.rb#163
  def negotiate_key_exchange?; end

  # source://rubyntlm//lib/net/ntlm/client/session.rb#207
  def nt_proof_str; end

  # source://rubyntlm//lib/net/ntlm/client/session.rb#191
  def ntlmv2_hash; end

  # source://rubyntlm//lib/net/ntlm/client/session.rb#203
  def ntlmv2_resp; end

  # source://rubyntlm//lib/net/ntlm/client/session.rb#183
  def oem_or_unicode_str(str); end

  # source://rubyntlm//lib/net/ntlm/client/session.rb#171
  def password; end

  # source://rubyntlm//lib/net/ntlm/client/session.rb#101
  def raw_sequence; end

  # source://rubyntlm//lib/net/ntlm/client/session.rb#97
  def sequence; end

  # source://rubyntlm//lib/net/ntlm/client/session.rb#149
  def server_challenge; end

  # source://rubyntlm//lib/net/ntlm/client/session.rb#135
  def server_cipher; end

  # source://rubyntlm//lib/net/ntlm/client/session.rb#121
  def server_seal_key; end

  # source://rubyntlm//lib/net/ntlm/client/session.rb#113
  def server_sign_key; end

  # source://rubyntlm//lib/net/ntlm/client/session.rb#222
  def target_info; end

  # source://rubyntlm//lib/net/ntlm/client/session.rb#155
  def timestamp; end

  # source://rubyntlm//lib/net/ntlm/client/session.rb#159
  def use_oem_strings?; end

  # source://rubyntlm//lib/net/ntlm/client/session.rb#93
  def user_session_key; end

  # source://rubyntlm//lib/net/ntlm/client/session.rb#167
  def username; end

  # source://rubyntlm//lib/net/ntlm/client/session.rb#175
  def workstation; end
end

# source://rubyntlm//lib/net/ntlm/encode_util.rb#4
class Net::NTLM::EncodeUtil
  class << self
    # Decode a UTF16 string to a ASCII string
    #
    # @param str [String] The string to convert
    #
    # source://rubyntlm//lib/net/ntlm/encode_util.rb#29
    def decode_utf16le(str); end

    # Encodes a ASCII string to a UTF16 string
    #
    # @note This implementation may seem stupid but the problem is that UTF16-LE and UTF-8 are incompatiable
    #   encodings. This library uses string contatination to build the packet bytes. The end result is that
    #   you can either marshal the encodings elsewhere of simply know that each time you call encode_utf16le
    #   the function will convert the string bytes to UTF-16LE and note the encoding as UTF-8 so that byte
    #   concatination works seamlessly.
    # @param str [String] The string to convert
    #
    # source://rubyntlm//lib/net/ntlm/encode_util.rb#41
    def encode_utf16le(str); end
  end
end

# base classes for primitives
#
# @private
#
# source://rubyntlm//lib/net/ntlm/field.rb#6
class Net::NTLM::Field
  # @return [Field] a new instance of Field
  #
  # source://rubyntlm//lib/net/ntlm/field.rb#9
  def initialize(opts); end

  # Returns the value of attribute active.
  #
  # source://rubyntlm//lib/net/ntlm/field.rb#7
  def active; end

  # Sets the attribute active
  #
  # @param value the value to set the attribute active to.
  #
  # source://rubyntlm//lib/net/ntlm/field.rb#7
  def active=(_arg0); end

  # Parser function for field data
  # Exists in this class to be overridden by child classes
  #
  # @raise [NotImplementedError]
  #
  # source://rubyntlm//lib/net/ntlm/field.rb#27
  def parse(str, offset = T.unsafe(nil)); end

  # Serializer function for field data
  # Exists in this class to be overridden by child classes
  #
  # @raise [NotImplementedError]
  #
  # source://rubyntlm//lib/net/ntlm/field.rb#21
  def serialize; end

  # source://rubyntlm//lib/net/ntlm/field.rb#15
  def size; end

  # Returns the value of attribute value.
  #
  # source://rubyntlm//lib/net/ntlm/field.rb#7
  def value; end

  # Sets the attribute value
  #
  # @param value the value to set the attribute value to.
  #
  # source://rubyntlm//lib/net/ntlm/field.rb#7
  def value=(_arg0); end
end

# base class of data structure
#
# source://rubyntlm//lib/net/ntlm/field_set.rb#5
class Net::NTLM::FieldSet
  # @return [FieldSet] a new instance of FieldSet
  #
  # source://rubyntlm//lib/net/ntlm/field_set.rb#87
  def initialize; end

  # @raise [ArgumentError]
  #
  # source://rubyntlm//lib/net/ntlm/field_set.rb#103
  def [](name); end

  # @raise [ArgumentError]
  #
  # source://rubyntlm//lib/net/ntlm/field_set.rb#109
  def []=(name, val); end

  # source://rubyntlm//lib/net/ntlm/field_set.rb#119
  def disable(name); end

  # source://rubyntlm//lib/net/ntlm/field_set.rb#115
  def enable(name); end

  # @return [Boolean]
  #
  # source://rubyntlm//lib/net/ntlm/field_set.rb#123
  def has_disabled_fields?; end

  # source://rubyntlm//lib/net/ntlm/field_set.rb#91
  def parse(str, offset = T.unsafe(nil)); end

  # source://rubyntlm//lib/net/ntlm/field_set.rb#95
  def serialize; end

  # source://rubyntlm//lib/net/ntlm/field_set.rb#99
  def size; end

  class << self
    # source://rubyntlm//lib/net/ntlm/field_set.rb#20
    def int16LE(name, opts); end

    # source://rubyntlm//lib/net/ntlm/field_set.rb#28
    def int32LE(name, opts); end

    # source://rubyntlm//lib/net/ntlm/field_set.rb#36
    def int64LE(name, opts); end

    # source://rubyntlm//lib/net/ntlm/field_set.rb#52
    def names; end

    # source://rubyntlm//lib/net/ntlm/field_set.rb#62
    def opts; end

    # source://rubyntlm//lib/net/ntlm/field_set.rb#48
    def prototypes; end

    # source://rubyntlm//lib/net/ntlm/field_set.rb#44
    def security_buffer(name, opts); end

    # source://rubyntlm//lib/net/ntlm/field_set.rb#12
    def string(name, opts); end

    # source://rubyntlm//lib/net/ntlm/field_set.rb#57
    def types; end

    private

    # source://rubyntlm//lib/net/ntlm/field_set.rb#69
    def add_field(name, type, opts); end

    # source://rubyntlm//lib/net/ntlm/field_set.rb#74
    def define_accessor(name); end
  end
end

# source://rubyntlm//lib/net/ntlm/int16_le.rb#4
class Net::NTLM::Int16LE < ::Net::NTLM::Field
  # @return [Int16LE] a new instance of Int16LE
  #
  # source://rubyntlm//lib/net/ntlm/int16_le.rb#6
  def initialize(opt); end

  # source://rubyntlm//lib/net/ntlm/int16_le.rb#11
  def parse(str, offset = T.unsafe(nil)); end

  # source://rubyntlm//lib/net/ntlm/int16_le.rb#20
  def serialize; end
end

# source://rubyntlm//lib/net/ntlm/int32_le.rb#4
class Net::NTLM::Int32LE < ::Net::NTLM::Field
  # @return [Int32LE] a new instance of Int32LE
  #
  # source://rubyntlm//lib/net/ntlm/int32_le.rb#5
  def initialize(opt); end

  # source://rubyntlm//lib/net/ntlm/int32_le.rb#10
  def parse(str, offset = T.unsafe(nil)); end

  # source://rubyntlm//lib/net/ntlm/int32_le.rb#19
  def serialize; end
end

# source://rubyntlm//lib/net/ntlm/int64_le.rb#4
class Net::NTLM::Int64LE < ::Net::NTLM::Field
  # @return [Int64LE] a new instance of Int64LE
  #
  # source://rubyntlm//lib/net/ntlm/int64_le.rb#5
  def initialize(opt); end

  # source://rubyntlm//lib/net/ntlm/int64_le.rb#10
  def parse(str, offset = T.unsafe(nil)); end

  # source://rubyntlm//lib/net/ntlm/int64_le.rb#20
  def serialize; end
end

# source://rubyntlm//lib/net/ntlm/exceptions.rb#5
class Net::NTLM::InvalidTargetDataError < ::Net::NTLM::NtlmError
  # @return [InvalidTargetDataError] a new instance of InvalidTargetDataError
  #
  # source://rubyntlm//lib/net/ntlm/exceptions.rb#8
  def initialize(msg, data); end

  # Returns the value of attribute data.
  #
  # source://rubyntlm//lib/net/ntlm/exceptions.rb#6
  def data; end
end

# @private false
#
# source://rubyntlm//lib/net/ntlm/message.rb#40
class Net::NTLM::Message < ::Net::NTLM::FieldSet
  # source://rubyntlm//lib/net/ntlm/message.rb#123
  def data_edge; end

  # source://rubyntlm//lib/net/ntlm/message.rb#103
  def data_size; end

  # source://rubyntlm//lib/net/ntlm/message.rb#97
  def decode64(str); end

  # source://rubyntlm//lib/net/ntlm/message.rb#116
  def deflag; end

  # source://rubyntlm//lib/net/ntlm/message.rb#84
  def dump_flags; end

  # source://rubyntlm//lib/net/ntlm/message.rb#93
  def encode64; end

  # @return [Boolean]
  #
  # source://rubyntlm//lib/net/ntlm/message.rb#76
  def has_flag?(flag); end

  # source://rubyntlm//lib/net/ntlm/field_set.rb#99
  def head_size; end

  # @return [self]
  #
  # source://rubyntlm//lib/net/ntlm/message.rb#64
  def parse(str); end

  # source://rubyntlm//lib/net/ntlm/message.rb#112
  def security_buffers; end

  # source://rubyntlm//lib/net/ntlm/message.rb#88
  def serialize; end

  # source://rubyntlm//lib/net/ntlm/message.rb#80
  def set_flag(flag); end

  # source://rubyntlm//lib/net/ntlm/message.rb#107
  def size; end

  class << self
    # source://rubyntlm//lib/net/ntlm/message.rb#58
    def decode64(str); end

    # source://rubyntlm//lib/net/ntlm/message.rb#42
    def parse(str); end
  end
end

# sub class definitions
#
# source://rubyntlm//lib/net/ntlm/message/type0.rb#6
class Net::NTLM::Message::Type0 < ::Net::NTLM::Message
  # source://rubyntlm//lib/net/ntlm/field_set.rb#76
  def sign; end

  # source://rubyntlm//lib/net/ntlm/field_set.rb#80
  def sign=(val); end

  # source://rubyntlm//lib/net/ntlm/field_set.rb#76
  def type; end

  # source://rubyntlm//lib/net/ntlm/field_set.rb#80
  def type=(val); end
end

# @private false
#
# source://rubyntlm//lib/net/ntlm/message/type1.rb#6
class Net::NTLM::Message::Type1 < ::Net::NTLM::Message
  # source://rubyntlm//lib/net/ntlm/field_set.rb#76
  def domain; end

  # source://rubyntlm//lib/net/ntlm/field_set.rb#80
  def domain=(val); end

  # source://rubyntlm//lib/net/ntlm/field_set.rb#76
  def flag; end

  # source://rubyntlm//lib/net/ntlm/field_set.rb#80
  def flag=(val); end

  # source://rubyntlm//lib/net/ntlm/field_set.rb#76
  def os_version; end

  # source://rubyntlm//lib/net/ntlm/field_set.rb#80
  def os_version=(val); end

  # source://rubyntlm//lib/net/ntlm/field_set.rb#76
  def sign; end

  # source://rubyntlm//lib/net/ntlm/field_set.rb#80
  def sign=(val); end

  # source://rubyntlm//lib/net/ntlm/field_set.rb#76
  def type; end

  # source://rubyntlm//lib/net/ntlm/field_set.rb#80
  def type=(val); end

  # source://rubyntlm//lib/net/ntlm/field_set.rb#76
  def workstation; end

  # source://rubyntlm//lib/net/ntlm/field_set.rb#80
  def workstation=(val); end
end

# @private false
#
# source://rubyntlm//lib/net/ntlm/message/type2.rb#6
class Net::NTLM::Message::Type2 < ::Net::NTLM::Message
  # source://rubyntlm//lib/net/ntlm/field_set.rb#76
  def challenge; end

  # source://rubyntlm//lib/net/ntlm/field_set.rb#80
  def challenge=(val); end

  # source://rubyntlm//lib/net/ntlm/field_set.rb#76
  def context; end

  # source://rubyntlm//lib/net/ntlm/field_set.rb#80
  def context=(val); end

  # source://rubyntlm//lib/net/ntlm/field_set.rb#76
  def flag; end

  # source://rubyntlm//lib/net/ntlm/field_set.rb#80
  def flag=(val); end

  # source://rubyntlm//lib/net/ntlm/field_set.rb#76
  def os_version; end

  # source://rubyntlm//lib/net/ntlm/field_set.rb#80
  def os_version=(val); end

  # Generates a Type 3 response based on the Type 2 Information
  #
  # @note An empty :domain option authenticates to the local machine.
  # @note The :use_default_target has precedence over the :domain option
  # @option arg
  # @option arg
  # @option arg
  # @option opt
  # @option opt
  # @param arg [Hash] a customizable set of options
  # @param opt [Hash] a customizable set of options
  # @return [Type3]
  #
  # source://rubyntlm//lib/net/ntlm/message/type2.rb#26
  def response(arg, opt = T.unsafe(nil)); end

  # source://rubyntlm//lib/net/ntlm/field_set.rb#76
  def sign; end

  # source://rubyntlm//lib/net/ntlm/field_set.rb#80
  def sign=(val); end

  # source://rubyntlm//lib/net/ntlm/field_set.rb#76
  def target_info; end

  # source://rubyntlm//lib/net/ntlm/field_set.rb#80
  def target_info=(val); end

  # source://rubyntlm//lib/net/ntlm/field_set.rb#76
  def target_name; end

  # source://rubyntlm//lib/net/ntlm/field_set.rb#80
  def target_name=(val); end

  # source://rubyntlm//lib/net/ntlm/field_set.rb#76
  def type; end

  # source://rubyntlm//lib/net/ntlm/field_set.rb#80
  def type=(val); end
end

# @private false
#
# source://rubyntlm//lib/net/ntlm/message/type3.rb#6
class Net::NTLM::Message::Type3 < ::Net::NTLM::Message
  # @param server_challenge [String] The server's {Type2#challenge challenge} from the
  #   {Type2} message for which this object is a response.
  # @return [Boolean]
  #
  # source://rubyntlm//lib/net/ntlm/message/type3.rb#55
  def blank_password?(server_challenge); end

  # source://rubyntlm//lib/net/ntlm/field_set.rb#76
  def domain; end

  # source://rubyntlm//lib/net/ntlm/field_set.rb#80
  def domain=(val); end

  # source://rubyntlm//lib/net/ntlm/field_set.rb#76
  def flag; end

  # source://rubyntlm//lib/net/ntlm/field_set.rb#80
  def flag=(val); end

  # source://rubyntlm//lib/net/ntlm/field_set.rb#76
  def lm_response; end

  # source://rubyntlm//lib/net/ntlm/field_set.rb#80
  def lm_response=(val); end

  # source://rubyntlm//lib/net/ntlm/field_set.rb#76
  def ntlm_response; end

  # source://rubyntlm//lib/net/ntlm/field_set.rb#80
  def ntlm_response=(val); end

  # @return [Symbol]
  #
  # source://rubyntlm//lib/net/ntlm/message/type3.rb#77
  def ntlm_version; end

  # source://rubyntlm//lib/net/ntlm/field_set.rb#76
  def os_version; end

  # source://rubyntlm//lib/net/ntlm/field_set.rb#80
  def os_version=(val); end

  # @param password [String]
  # @param server_challenge [String] The server's {Type2#challenge challenge} from the
  #   {Type2} message for which this object is a response.
  # @return [true] if +password+ was the password used to generate this
  #   {Type3} message
  # @return [false] otherwise
  #
  # source://rubyntlm//lib/net/ntlm/message/type3.rb#65
  def password?(password, server_challenge); end

  # source://rubyntlm//lib/net/ntlm/field_set.rb#76
  def session_key; end

  # source://rubyntlm//lib/net/ntlm/field_set.rb#80
  def session_key=(val); end

  # source://rubyntlm//lib/net/ntlm/field_set.rb#76
  def sign; end

  # source://rubyntlm//lib/net/ntlm/field_set.rb#80
  def sign=(val); end

  # source://rubyntlm//lib/net/ntlm/field_set.rb#76
  def type; end

  # source://rubyntlm//lib/net/ntlm/field_set.rb#80
  def type=(val); end

  # source://rubyntlm//lib/net/ntlm/field_set.rb#76
  def user; end

  # source://rubyntlm//lib/net/ntlm/field_set.rb#80
  def user=(val); end

  # source://rubyntlm//lib/net/ntlm/field_set.rb#76
  def workstation; end

  # source://rubyntlm//lib/net/ntlm/field_set.rb#80
  def workstation=(val); end

  private

  # @return [Boolean]
  #
  # source://rubyntlm//lib/net/ntlm/message/type3.rb#89
  def ntlm2_session_password?(password, server_challenge); end

  # @return [Boolean]
  #
  # source://rubyntlm//lib/net/ntlm/message/type3.rb#103
  def ntlmv2_password?(password, server_challenge); end

  class << self
    # Builds a Type 3 packet
    #
    # @note All options must be properly encoded with either unicode or oem encoding
    # @option arg
    # @option arg
    # @option arg
    # @option arg
    # @option arg
    # @option arg
    # @param arg [Hash] a customizable set of options
    # @return [Type3]
    #
    # source://rubyntlm//lib/net/ntlm/message/type3.rb#29
    def create(arg, opt = T.unsafe(nil)); end
  end
end

# source://rubyntlm//lib/net/ntlm/security_buffer.rb#5
class Net::NTLM::SecurityBuffer < ::Net::NTLM::FieldSet
  # @return [SecurityBuffer] a new instance of SecurityBuffer
  #
  # source://rubyntlm//lib/net/ntlm/security_buffer.rb#12
  def initialize(opts = T.unsafe(nil)); end

  # Returns the value of attribute active.
  #
  # source://rubyntlm//lib/net/ntlm/security_buffer.rb#11
  def active; end

  # Sets the attribute active
  #
  # @param value the value to set the attribute active to.
  #
  # source://rubyntlm//lib/net/ntlm/security_buffer.rb#11
  def active=(_arg0); end

  # @return [Int16LE]
  #
  # source://rubyntlm//lib/net/ntlm/field_set.rb#76
  def allocated; end

  # @return [Int16LE]
  #
  # source://rubyntlm//lib/net/ntlm/field_set.rb#80
  def allocated=(val); end

  # source://rubyntlm//lib/net/ntlm/security_buffer.rb#42
  def data_size; end

  # @return [Int16LE]
  #
  # source://rubyntlm//lib/net/ntlm/field_set.rb#76
  def length; end

  # @return [Int16LE]
  #
  # source://rubyntlm//lib/net/ntlm/field_set.rb#80
  def length=(val); end

  # @return [Int32LE]
  #
  # source://rubyntlm//lib/net/ntlm/field_set.rb#76
  def offset; end

  # @return [Int32LE]
  #
  # source://rubyntlm//lib/net/ntlm/field_set.rb#80
  def offset=(val); end

  # source://rubyntlm//lib/net/ntlm/security_buffer.rb#19
  def parse(str, offset = T.unsafe(nil)); end

  # source://rubyntlm//lib/net/ntlm/security_buffer.rb#29
  def serialize; end

  # source://rubyntlm//lib/net/ntlm/security_buffer.rb#33
  def value; end

  # source://rubyntlm//lib/net/ntlm/security_buffer.rb#37
  def value=(val); end
end

# source://rubyntlm//lib/net/ntlm/string.rb#4
class Net::NTLM::String < ::Net::NTLM::Field
  # @return [String] a new instance of String
  #
  # source://rubyntlm//lib/net/ntlm/string.rb#5
  def initialize(opts); end

  # source://rubyntlm//lib/net/ntlm/string.rb#10
  def parse(str, offset = T.unsafe(nil)); end

  # source://rubyntlm//lib/net/ntlm/string.rb#19
  def serialize; end

  # source://rubyntlm//lib/net/ntlm/string.rb#27
  def value=(val); end
end

# Represents a list of AV_PAIR structures
#
# @see https://msdn.microsoft.com/en-us/library/cc236646.aspx
#
# source://rubyntlm//lib/net/ntlm/target_info.rb#6
class Net::NTLM::TargetInfo
  # @param av_pair_sequence [String] AV_PAIR list from challenge message
  # @return [TargetInfo] a new instance of TargetInfo
  #
  # source://rubyntlm//lib/net/ntlm/target_info.rb#22
  def initialize(av_pair_sequence); end

  # Returns the value of attribute av_pairs.
  #
  # source://rubyntlm//lib/net/ntlm/target_info.rb#26
  def av_pairs; end

  # source://rubyntlm//lib/net/ntlm/target_info.rb#28
  def to_s; end

  private

  # source://rubyntlm//lib/net/ntlm/target_info.rb#56
  def read_pairs(av_pair_sequence); end

  # source://rubyntlm//lib/net/ntlm/target_info.rb#83
  def to_hex(str); end
end
