# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `rubyzip` gem.
# Please instead update this file by running `bin/tapioca gem rubyzip`.


# Rubyzip is a ruby module for reading and writing zip files.
#
# The main entry points are File, InputStream and OutputStream. For a
# file/directory interface in the style of the standard ruby ::File and
# ::Dir APIs then `require 'zip/filesystem'` and see FileSystem.
#
# source://rubyzip//lib/zip/version.rb#3
module Zip
  extend ::Zip

  # Returns the value of attribute case_insensitive_match.
  #
  # source://rubyzip//lib/zip.rb#48
  def case_insensitive_match; end

  # Sets the attribute case_insensitive_match
  #
  # @param value the value to set the attribute case_insensitive_match to.
  #
  # source://rubyzip//lib/zip.rb#48
  def case_insensitive_match=(_arg0); end

  # Returns the value of attribute continue_on_exists_proc.
  #
  # source://rubyzip//lib/zip.rb#48
  def continue_on_exists_proc; end

  # Sets the attribute continue_on_exists_proc
  #
  # @param value the value to set the attribute continue_on_exists_proc to.
  #
  # source://rubyzip//lib/zip.rb#48
  def continue_on_exists_proc=(_arg0); end

  # Returns the value of attribute default_compression.
  #
  # source://rubyzip//lib/zip.rb#48
  def default_compression; end

  # Sets the attribute default_compression
  #
  # @param value the value to set the attribute default_compression to.
  #
  # source://rubyzip//lib/zip.rb#48
  def default_compression=(_arg0); end

  # Returns the value of attribute force_entry_names_encoding.
  #
  # source://rubyzip//lib/zip.rb#48
  def force_entry_names_encoding; end

  # Sets the attribute force_entry_names_encoding
  #
  # @param value the value to set the attribute force_entry_names_encoding to.
  #
  # source://rubyzip//lib/zip.rb#48
  def force_entry_names_encoding=(_arg0); end

  # Returns the value of attribute on_exists_proc.
  #
  # source://rubyzip//lib/zip.rb#48
  def on_exists_proc; end

  # Sets the attribute on_exists_proc
  #
  # @param value the value to set the attribute on_exists_proc to.
  #
  # source://rubyzip//lib/zip.rb#48
  def on_exists_proc=(_arg0); end

  # source://rubyzip//lib/zip.rb#69
  def reset!; end

  # Set options for RubyZip in one block.
  #
  # @yield [_self]
  # @yieldparam _self [Zip] the object that the method was called on
  #
  # source://rubyzip//lib/zip.rb#84
  def setup; end

  # Returns the value of attribute sort_entries.
  #
  # source://rubyzip//lib/zip.rb#48
  def sort_entries; end

  # Sets the attribute sort_entries
  #
  # @param value the value to set the attribute sort_entries to.
  #
  # source://rubyzip//lib/zip.rb#48
  def sort_entries=(_arg0); end

  # Returns the value of attribute unicode_names.
  #
  # source://rubyzip//lib/zip.rb#48
  def unicode_names; end

  # Sets the attribute unicode_names
  #
  # @param value the value to set the attribute unicode_names to.
  #
  # source://rubyzip//lib/zip.rb#48
  def unicode_names=(_arg0); end

  # Returns the value of attribute validate_entry_sizes.
  #
  # source://rubyzip//lib/zip.rb#48
  def validate_entry_sizes; end

  # Sets the attribute validate_entry_sizes
  #
  # @param value the value to set the attribute validate_entry_sizes to.
  #
  # source://rubyzip//lib/zip.rb#48
  def validate_entry_sizes=(_arg0); end

  # Returns the value of attribute warn_invalid_date.
  #
  # source://rubyzip//lib/zip.rb#48
  def warn_invalid_date; end

  # Sets the attribute warn_invalid_date
  #
  # @param value the value to set the attribute warn_invalid_date to.
  #
  # source://rubyzip//lib/zip.rb#48
  def warn_invalid_date=(_arg0); end

  # Returns the value of attribute write_zip64_support.
  #
  # source://rubyzip//lib/zip.rb#48
  def write_zip64_support; end

  # Sets the attribute write_zip64_support
  #
  # @param value the value to set the attribute write_zip64_support to.
  #
  # source://rubyzip//lib/zip.rb#48
  def write_zip64_support=(_arg0); end
end

# source://rubyzip//lib/zip/crypto/aes_encryption.rb#64
class Zip::AESDecrypter < ::Zip::Decrypter
  include ::Zip::AESEncryption

  # @raise [Error]
  #
  # source://rubyzip//lib/zip/crypto/aes_encryption.rb#115
  def check_integrity!(io); end

  # source://rubyzip//lib/zip/crypto/aes_encryption.rb#67
  def decrypt(encrypted_data); end

  # @raise [Error]
  #
  # source://rubyzip//lib/zip/crypto/aes_encryption.rb#90
  def reset!(header); end
end

# source://rubyzip//lib/zip/crypto/aes_encryption.rb#6
module Zip::AESEncryption
  # source://rubyzip//lib/zip/crypto/aes_encryption.rb#47
  def initialize(password, strength); end

  # source://rubyzip//lib/zip/crypto/aes_encryption.rb#59
  def gp_flags; end

  # source://rubyzip//lib/zip/crypto/aes_encryption.rb#55
  def header_bytesize; end
end

# source://rubyzip//lib/zip/crypto/aes_encryption.rb#9
Zip::AESEncryption::AUTHENTICATION_CODE_LENGTH = T.let(T.unsafe(nil), Integer)

# source://rubyzip//lib/zip/crypto/aes_encryption.rb#29
Zip::AESEncryption::BITS = T.let(T.unsafe(nil), Hash)

# source://rubyzip//lib/zip/crypto/aes_encryption.rb#8
Zip::AESEncryption::BLOCK_SIZE = T.let(T.unsafe(nil), Integer)

# source://rubyzip//lib/zip/crypto/aes_encryption.rb#35
Zip::AESEncryption::KEY_LENGTHS = T.let(T.unsafe(nil), Hash)

# source://rubyzip//lib/zip/crypto/aes_encryption.rb#41
Zip::AESEncryption::SALT_LENGTHS = T.let(T.unsafe(nil), Hash)

# source://rubyzip//lib/zip/crypto/aes_encryption.rb#23
Zip::AESEncryption::STRENGTHS = T.let(T.unsafe(nil), Array)

# source://rubyzip//lib/zip/crypto/aes_encryption.rb#19
Zip::AESEncryption::STRENGTH_128_BIT = T.let(T.unsafe(nil), Integer)

# source://rubyzip//lib/zip/crypto/aes_encryption.rb#20
Zip::AESEncryption::STRENGTH_192_BIT = T.let(T.unsafe(nil), Integer)

# source://rubyzip//lib/zip/crypto/aes_encryption.rb#21
Zip::AESEncryption::STRENGTH_256_BIT = T.let(T.unsafe(nil), Integer)

# source://rubyzip//lib/zip/crypto/aes_encryption.rb#7
Zip::AESEncryption::VERIFIER_LENGTH = T.let(T.unsafe(nil), Integer)

# source://rubyzip//lib/zip/crypto/aes_encryption.rb#14
Zip::AESEncryption::VERSIONS = T.let(T.unsafe(nil), Array)

# source://rubyzip//lib/zip/crypto/aes_encryption.rb#11
Zip::AESEncryption::VERSION_AE_1 = T.let(T.unsafe(nil), Integer)

# source://rubyzip//lib/zip/crypto/aes_encryption.rb#12
Zip::AESEncryption::VERSION_AE_2 = T.let(T.unsafe(nil), Integer)

# source://rubyzip//lib/zip/constants.rb#9
Zip::CDIR_ENTRY_STATIC_HEADER_LENGTH = T.let(T.unsafe(nil), Integer)

# source://rubyzip//lib/zip/constants.rb#8
Zip::CENTRAL_DIRECTORY_ENTRY_SIGNATURE = T.let(T.unsafe(nil), Integer)

# source://rubyzip//lib/zip/constants.rb#95
Zip::COMPRESSION_METHODS = T.let(T.unsafe(nil), Hash)

# source://rubyzip//lib/zip/constants.rb#93
Zip::COMPRESSION_METHOD_AES = T.let(T.unsafe(nil), Integer)

# RESERVED = 11
#
# source://rubyzip//lib/zip/constants.rb#82
Zip::COMPRESSION_METHOD_BZIP2 = T.let(T.unsafe(nil), Integer)

# RESERVED = 7
#
# source://rubyzip//lib/zip/constants.rb#78
Zip::COMPRESSION_METHOD_DEFLATE = T.let(T.unsafe(nil), Integer)

# source://rubyzip//lib/zip/constants.rb#79
Zip::COMPRESSION_METHOD_DEFLATE_64 = T.let(T.unsafe(nil), Integer)

# RESERVED = 15
#
# source://rubyzip//lib/zip/constants.rb#86
Zip::COMPRESSION_METHOD_IBM_CMPSC = T.let(T.unsafe(nil), Integer)

# source://rubyzip//lib/zip/constants.rb#89
Zip::COMPRESSION_METHOD_IBM_LZ77 = T.let(T.unsafe(nil), Integer)

# RESERVED = 17
#
# source://rubyzip//lib/zip/constants.rb#88
Zip::COMPRESSION_METHOD_IBM_TERSE = T.let(T.unsafe(nil), Integer)

# source://rubyzip//lib/zip/constants.rb#76
Zip::COMPRESSION_METHOD_IMPLODE = T.let(T.unsafe(nil), Integer)

# source://rubyzip//lib/zip/constants.rb#90
Zip::COMPRESSION_METHOD_JPEG = T.let(T.unsafe(nil), Integer)

# RESERVED = 13
#
# source://rubyzip//lib/zip/constants.rb#84
Zip::COMPRESSION_METHOD_LZMA = T.let(T.unsafe(nil), Integer)

# source://rubyzip//lib/zip/constants.rb#80
Zip::COMPRESSION_METHOD_PKWARE_DCLI = T.let(T.unsafe(nil), Integer)

# source://rubyzip//lib/zip/constants.rb#92
Zip::COMPRESSION_METHOD_PPMD = T.let(T.unsafe(nil), Integer)

# source://rubyzip//lib/zip/constants.rb#72
Zip::COMPRESSION_METHOD_REDUCE_1 = T.let(T.unsafe(nil), Integer)

# source://rubyzip//lib/zip/constants.rb#73
Zip::COMPRESSION_METHOD_REDUCE_2 = T.let(T.unsafe(nil), Integer)

# source://rubyzip//lib/zip/constants.rb#74
Zip::COMPRESSION_METHOD_REDUCE_3 = T.let(T.unsafe(nil), Integer)

# source://rubyzip//lib/zip/constants.rb#75
Zip::COMPRESSION_METHOD_REDUCE_4 = T.let(T.unsafe(nil), Integer)

# source://rubyzip//lib/zip/constants.rb#71
Zip::COMPRESSION_METHOD_SHRINK = T.let(T.unsafe(nil), Integer)

# source://rubyzip//lib/zip/constants.rb#70
Zip::COMPRESSION_METHOD_STORE = T.let(T.unsafe(nil), Integer)

# source://rubyzip//lib/zip/constants.rb#91
Zip::COMPRESSION_METHOD_WAVPACK = T.let(T.unsafe(nil), Integer)

# source://rubyzip//lib/zip/central_directory.rb#8
class Zip::CentralDirectory
  include ::Zip::Dirtyable
  extend ::Forwardable
  extend ::Zip::Dirtyable::ClassMethods

  # @return [CentralDirectory] a new instance of CentralDirectory
  #
  # source://rubyzip//lib/zip/central_directory.rb#31
  def initialize(entries = T.unsafe(nil), comment = T.unsafe(nil)); end

  # source://rubyzip//lib/zip/central_directory.rb#25
  def <<(param); end

  # source://rubyzip//lib/zip/central_directory.rb#66
  def ==(other); end

  # Returns the value of attribute comment.
  #
  # source://rubyzip//lib/zip/central_directory.rb#23
  def comment; end

  # Sets the attribute comment
  #
  # @param value the value to set the attribute comment to.
  #
  # source://rubyzip//lib/zip/central_directory.rb#23
  def comment=(param); end

  # Reads the End of Central Directory Record (and the Zip64 equivalent if
  # needs be) and returns the number of entries in the archive. This is a
  # convenience method that avoids reading in all of the entry data to get a
  # very quick entry count.
  #
  # source://rubyzip//lib/zip/central_directory.rb#61
  def count_entries(io); end

  # source://rubyzip//lib/zip/central_directory.rb#25
  def delete(param); end

  # source://rubyzip//lib/zip/central_directory.rb#25
  def each(*args, **_arg1, &block); end

  # source://rubyzip//lib/zip/central_directory.rb#25
  def entries(*args, **_arg1, &block); end

  # source://rubyzip//lib/zip/central_directory.rb#25
  def find_entry(*args, **_arg1, &block); end

  # source://rubyzip//lib/zip/central_directory.rb#25
  def glob(*args, **_arg1, &block); end

  # source://rubyzip//lib/zip/central_directory.rb#25
  def include?(*args, **_arg1, &block); end

  # source://rubyzip//lib/zip/central_directory.rb#29
  def orig_comment=(_arg0); end

  # source://rubyzip//lib/zip/central_directory.rb#29
  def orig_delete(*args, **_arg1, &block); end

  # source://rubyzip//lib/zip/central_directory.rb#37
  def read_from_stream(io); end

  # source://rubyzip//lib/zip/central_directory.rb#25
  def size(*args, **_arg1, &block); end

  # source://rubyzip//lib/zip/central_directory.rb#42
  def write_to_stream(io, suppress_extra_fields: T.unsafe(nil)); end

  private

  # source://rubyzip//lib/zip/central_directory.rb#252
  def eocd_data(io); end

  # @raise [Error]
  #
  # source://rubyzip//lib/zip/central_directory.rb#169
  def read_central_directory_entries(io); end

  # @raise [Error]
  #
  # source://rubyzip//lib/zip/central_directory.rb#213
  def read_eocds(io); end

  # source://rubyzip//lib/zip/central_directory.rb#202
  def read_local_extra_field(io); end

  # source://rubyzip//lib/zip/central_directory.rb#115
  def unpack_64_e_o_c_d(buffer); end

  # source://rubyzip//lib/zip/central_directory.rb#139
  def unpack_64_eocd_locator(buffer); end

  # Unpack the EOCD and return a boolean indicating whether this header is
  # complete without needing Zip64 extensions.
  #
  # source://rubyzip//lib/zip/central_directory.rb#148
  def unpack_e_o_c_d(buffer); end

  # source://rubyzip//lib/zip/central_directory.rb#89
  def write_64_e_o_c_d(io, offset, cdir_size); end

  # source://rubyzip//lib/zip/central_directory.rb#105
  def write_64_eocd_locator(io, zip64_eocd_offset); end

  # source://rubyzip//lib/zip/central_directory.rb#74
  def write_e_o_c_d(io, offset, cdir_size); end
end

# source://rubyzip//lib/zip/central_directory.rb#12
Zip::CentralDirectory::END_OF_CD_SIG = T.let(T.unsafe(nil), Integer)

# source://rubyzip//lib/zip/central_directory.rb#20
Zip::CentralDirectory::MAX_END_OF_CD_SIZE = T.let(T.unsafe(nil), Integer)

# source://rubyzip//lib/zip/central_directory.rb#19
Zip::CentralDirectory::MAX_FILE_COMMENT_SIZE = T.let(T.unsafe(nil), Integer)

# source://rubyzip//lib/zip/central_directory.rb#16
Zip::CentralDirectory::STATIC_EOCD_SIZE = T.let(T.unsafe(nil), Integer)

# source://rubyzip//lib/zip/central_directory.rb#13
Zip::CentralDirectory::ZIP64_END_OF_CD_SIG = T.let(T.unsafe(nil), Integer)

# source://rubyzip//lib/zip/central_directory.rb#14
Zip::CentralDirectory::ZIP64_EOCD_LOCATOR_SIG = T.let(T.unsafe(nil), Integer)

# source://rubyzip//lib/zip/central_directory.rb#18
Zip::CentralDirectory::ZIP64_EOCD_LOC_SIZE = T.let(T.unsafe(nil), Integer)

# source://rubyzip//lib/zip/central_directory.rb#17
Zip::CentralDirectory::ZIP64_STATIC_EOCD_SIZE = T.let(T.unsafe(nil), Integer)

# Error raised if an unsupported compression method is used.
#
# source://rubyzip//lib/zip/errors.rb#9
class Zip::CompressionMethodError < ::Zip::Error
  # Create a new CompressionMethodError with the specified incorrect
  # compression method.
  #
  # @return [CompressionMethodError] a new instance of CompressionMethodError
  #
  # source://rubyzip//lib/zip/errors.rb#15
  def initialize(method); end

  # The compression method that has caused this error.
  #
  # source://rubyzip//lib/zip/errors.rb#11
  def compression_method; end

  # The message returned by this error.
  #
  # source://rubyzip//lib/zip/errors.rb#21
  def message; end
end

# source://rubyzip//lib/zip/compressor.rb#4
class Zip::Compressor
  # source://rubyzip//lib/zip/compressor.rb#5
  def finish; end
end

# source://rubyzip//lib/zip.rb#59
Zip::DEFAULT_RESTORE_OPTIONS = T.let(T.unsafe(nil), Hash)

# source://rubyzip//lib/zip/dos_time.rb#7
class Zip::DOSTime < ::Time
  include ::Zip::DOSTime::JRubyCMP

  # Dos time is only stored with two seconds accuracy.
  #
  # source://rubyzip//lib/zip/dos_time.rb#46
  def <=>(other); end

  # Register DX, the Date:
  # Bits 0-4 day (1-31)
  # bits 5-8 month (1-12)
  # bits 9-15 year (four digit year minus 1980)
  #
  # source://rubyzip//lib/zip/dos_time.rb#19
  def absolute_time=(_arg0); end

  # @return [Boolean]
  #
  # source://rubyzip//lib/zip/dos_time.rb#21
  def absolute_time?; end

  # Deprecated. Remove for version 4.
  #
  # source://rubyzip//lib/zip/dos_time.rb#40
  def dos_equals(other); end

  # source://rubyzip//lib/zip/dos_time.rb#33
  def to_binary_dos_date; end

  # source://rubyzip//lib/zip/dos_time.rb#27
  def to_binary_dos_time; end

  class << self
    # Create a DOSTime instance from a vanilla Time instance.
    #
    # source://rubyzip//lib/zip/dos_time.rb#53
    def from_time(time); end

    # source://rubyzip//lib/zip/dos_time.rb#57
    def parse_binary_dos_format(bin_dos_date, bin_dos_time); end
  end
end

# source://rubyzip//lib/zip/dos_time.rb#71
module Zip::DOSTime::JRubyCMP
  # source://rubyzip//lib/zip/dos_time.rb#76
  def <(other); end

  # source://rubyzip//lib/zip/dos_time.rb#80
  def <=(other); end

  # source://rubyzip//lib/zip/dos_time.rb#72
  def ==(other); end

  # source://rubyzip//lib/zip/dos_time.rb#84
  def >(other); end

  # source://rubyzip//lib/zip/dos_time.rb#88
  def >=(other); end
end

# Error raised if there is a problem while decompressing an archive entry.
#
# source://rubyzip//lib/zip/errors.rb#27
class Zip::DecompressionError < ::Zip::Error
  # Create a new DecompressionError with the specified underlying Zlib
  # error.
  #
  # @return [DecompressionError] a new instance of DecompressionError
  #
  # source://rubyzip//lib/zip/errors.rb#33
  def initialize(zlib_error); end

  # The message returned by this error.
  #
  # source://rubyzip//lib/zip/errors.rb#39
  def message; end

  # The error from the underlying Zlib library that caused this error.
  #
  # source://rubyzip//lib/zip/errors.rb#29
  def zlib_error; end
end

# source://rubyzip//lib/zip/decompressor.rb#4
class Zip::Decompressor
  # @return [Decompressor] a new instance of Decompressor
  #
  # source://rubyzip//lib/zip/decompressor.rb#21
  def initialize(input_stream, decompressed_size = T.unsafe(nil)); end

  # Returns the value of attribute decompressed_size.
  #
  # source://rubyzip//lib/zip/decompressor.rb#19
  def decompressed_size; end

  # Returns the value of attribute input_stream.
  #
  # source://rubyzip//lib/zip/decompressor.rb#19
  def input_stream; end

  class << self
    # source://rubyzip//lib/zip/decompressor.rb#7
    def decompressor_classes; end

    # source://rubyzip//lib/zip/decompressor.rb#15
    def find_by_compression_method(compression_method); end

    # source://rubyzip//lib/zip/decompressor.rb#11
    def register(compression_method, decompressor_class); end
  end
end

# source://rubyzip//lib/zip/decompressor.rb#5
Zip::Decompressor::CHUNK_SIZE = T.let(T.unsafe(nil), Integer)

# source://rubyzip//lib/zip/crypto/decrypted_io.rb#4
class Zip::DecryptedIo
  # @return [DecryptedIo] a new instance of DecryptedIo
  #
  # source://rubyzip//lib/zip/crypto/decrypted_io.rb#7
  def initialize(io, decrypter, compressed_size); end

  # source://rubyzip//lib/zip/crypto/decrypted_io.rb#14
  def read(length = T.unsafe(nil), outbuf = T.unsafe(nil)); end

  private

  # @return [Boolean]
  #
  # source://rubyzip//lib/zip/crypto/decrypted_io.rb#30
  def eof?; end

  # @return [Boolean]
  #
  # source://rubyzip//lib/zip/crypto/decrypted_io.rb#34
  def input_finished?; end

  # source://rubyzip//lib/zip/crypto/decrypted_io.rb#38
  def produce_input; end
end

# source://rubyzip//lib/zip/crypto/decrypted_io.rb#5
Zip::DecryptedIo::CHUNK_SIZE = T.let(T.unsafe(nil), Integer)

# source://rubyzip//lib/zip/crypto/encryption.rb#7
class Zip::Decrypter; end

# source://rubyzip//lib/zip/deflater.rb#4
class Zip::Deflater < ::Zip::Compressor
  # @return [Deflater] a new instance of Deflater
  #
  # source://rubyzip//lib/zip/deflater.rb#5
  def initialize(output_stream, level = T.unsafe(nil), encrypter = T.unsafe(nil)); end

  # source://rubyzip//lib/zip/deflater.rb#14
  def <<(data); end

  # Returns the value of attribute crc.
  #
  # source://rubyzip//lib/zip/deflater.rb#32
  def crc; end

  # source://rubyzip//lib/zip/deflater.rb#26
  def finish; end

  # Returns the value of attribute size.
  #
  # source://rubyzip//lib/zip/deflater.rb#32
  def size; end
end

# Error raised when trying to extract an archive entry over an
# existing file.
#
# source://rubyzip//lib/zip/errors.rb#46
class Zip::DestinationExistsError < ::Zip::Error
  # Create a new DestinationExistsError with the clashing destination.
  #
  # @return [DestinationExistsError] a new instance of DestinationExistsError
  #
  # source://rubyzip//lib/zip/errors.rb#48
  def initialize(destination); end

  # The message returned by this error.
  #
  # source://rubyzip//lib/zip/errors.rb#54
  def message; end
end

# source://rubyzip//lib/zip/dirtyable.rb#4
module Zip::Dirtyable
  mixes_in_class_methods ::Zip::Dirtyable::ClassMethods

  # source://rubyzip//lib/zip/dirtyable.rb#5
  def initialize(dirty_on_create: T.unsafe(nil)); end

  # @return [Boolean]
  #
  # source://rubyzip//lib/zip/dirtyable.rb#9
  def dirty?; end

  class << self
    # @private
    #
    # source://rubyzip//lib/zip/dirtyable.rb#28
    def included(base); end
  end
end

# source://rubyzip//lib/zip/dirtyable.rb#13
module Zip::Dirtyable::ClassMethods
  # source://rubyzip//lib/zip/dirtyable.rb#14
  def mark_dirty(*symbols); end
end

# source://rubyzip//lib/zip/crypto/encryption.rb#4
class Zip::Encrypter; end

# Zip::Entry represents an entry in a Zip archive.
#
# source://rubyzip//lib/zip/entry.rb#10
class Zip::Entry
  include ::Zip::Dirtyable
  extend ::Zip::Dirtyable::ClassMethods

  # Create a new Zip::Entry.
  #
  # @return [Entry] a new instance of Entry
  #
  # source://rubyzip//lib/zip/entry.rb#76
  def initialize(zipfile = T.unsafe(nil), name = T.unsafe(nil), comment: T.unsafe(nil), size: T.unsafe(nil), compressed_size: T.unsafe(nil), crc: T.unsafe(nil), compression_method: T.unsafe(nil), compression_level: T.unsafe(nil), time: T.unsafe(nil), extra: T.unsafe(nil)); end

  # source://rubyzip//lib/zip/entry.rb#636
  def <=>(other); end

  # source://rubyzip//lib/zip/entry.rb#627
  def ==(other); end

  # Does this entry return time fields with accurate timezone information?
  #
  # @return [Boolean]
  #
  # source://rubyzip//lib/zip/entry.rb#181
  def absolute_time?; end

  # Is this entry encrypted with AES encryption?
  #
  # @return [Boolean]
  #
  # source://rubyzip//lib/zip/entry.rb#207
  def aes?; end

  # Get the last access time of this entry, if available.
  #
  # source://rubyzip//lib/zip/entry.rb#144
  def atime; end

  # Set the last access time of this entry.
  #
  # source://rubyzip//lib/zip/entry.rb#171
  def atime=(value); end

  # source://rubyzip//lib/zip/entry.rb#259
  def calculate_local_header_size; end

  # source://rubyzip//lib/zip/entry.rb#275
  def cdir_header_size; end

  # @raise [::Zip::Error]
  #
  # source://rubyzip//lib/zip/entry.rb#492
  def check_c_dir_entry_comment_size; end

  # @raise [Error]
  #
  # source://rubyzip//lib/zip/entry.rb#486
  def check_c_dir_entry_signature; end

  # @raise [Error]
  #
  # source://rubyzip//lib/zip/entry.rb#480
  def check_c_dir_entry_static_header_length(buf); end

  # @raise [EntryNameError]
  #
  # source://rubyzip//lib/zip/entry.rb#70
  def check_name(name); end

  # source://rubyzip//lib/zip/entry.rb#730
  def clean_up; end

  # source://rubyzip//lib/zip/entry.rb#27
  def comment; end

  # source://rubyzip//lib/zip/entry.rb#27
  def comment=(param); end

  # source://rubyzip//lib/zip/entry.rb#255
  def comment_size; end

  # source://rubyzip//lib/zip/entry.rb#27
  def compressed_size; end

  # source://rubyzip//lib/zip/entry.rb#27
  def compressed_size=(param); end

  # source://rubyzip//lib/zip/entry.rb#34
  def compression_level; end

  # Return the compression method for this entry.
  #
  # Returns STORED if the entry is a directory or if the compression
  # level is 0.
  #
  # source://rubyzip//lib/zip/entry.rb#189
  def compression_method; end

  # Set the compression method for this entry.
  #
  # source://rubyzip//lib/zip/entry.rb#196
  def compression_method=(method); end

  # Returns the value of attribute crc.
  #
  # source://rubyzip//lib/zip/entry.rb#31
  def crc; end

  # Sets the attribute crc
  #
  # @param value the value to set the attribute crc to.
  #
  # source://rubyzip//lib/zip/entry.rb#31
  def crc=(_arg0); end

  # Get the creation time of this entry, if available.
  #
  # source://rubyzip//lib/zip/entry.rb#149
  def ctime; end

  # Set the creation time of this entry.
  #
  # source://rubyzip//lib/zip/entry.rb#176
  def ctime=(value); end

  # source://rubyzip//lib/zip/entry.rb#221
  def directory?; end

  # Is this entry encrypted?
  #
  # @return [Boolean]
  #
  # source://rubyzip//lib/zip/entry.rb#112
  def encrypted?; end

  # Returns the value of attribute external_file_attributes.
  #
  # source://rubyzip//lib/zip/entry.rb#31
  def external_file_attributes; end

  # Sets the attribute external_file_attributes
  #
  # @param value the value to set the attribute external_file_attributes to.
  #
  # source://rubyzip//lib/zip/entry.rb#31
  def external_file_attributes=(param); end

  # source://rubyzip//lib/zip/entry.rb#34
  def extra; end

  # source://rubyzip//lib/zip/entry.rb#251
  def extra_size; end

  # Extracts this entry to a file at `entry_path`, with
  # `destination_directory` as the base location in the filesystem.
  #
  # NB: The caller is responsible for making sure `destination_directory` is
  # safe, if it is passed.
  #
  # source://rubyzip//lib/zip/entry.rb#289
  def extract(entry_path = T.unsafe(nil), destination_directory: T.unsafe(nil), &block); end

  # source://rubyzip//lib/zip/entry.rb#221
  def file?; end

  # source://rubyzip//lib/zip/entry.rb#528
  def file_stat(path); end

  # @return [Boolean]
  #
  # source://rubyzip//lib/zip/entry.rb#211
  def file_type_is?(type); end

  # source://rubyzip//lib/zip/entry.rb#34
  def filepath; end

  # source://rubyzip//lib/zip/entry.rb#27
  def follow_symlinks; end

  # source://rubyzip//lib/zip/entry.rb#27
  def follow_symlinks=(_arg0); end

  # Returns the value of attribute fstype.
  #
  # source://rubyzip//lib/zip/entry.rb#31
  def fstype; end

  # Sets the attribute fstype
  #
  # @param value the value to set the attribute fstype to.
  #
  # source://rubyzip//lib/zip/entry.rb#31
  def fstype=(param); end

  # source://rubyzip//lib/zip/entry.rb#215
  def ftype; end

  # source://rubyzip//lib/zip/entry.rb#674
  def gather_fileinfo_from_srcpath(src_path); end

  # source://rubyzip//lib/zip/entry.rb#536
  def get_extra_attributes_from_path(path); end

  # Returns an IO like object for the given ZipEntry.
  # Warning: may behave weird with symlinks.
  #
  # source://rubyzip//lib/zip/entry.rb#642
  def get_input_stream(&block); end

  # source://rubyzip//lib/zip/entry.rb#722
  def get_raw_input_stream(&block); end

  # Returns the value of attribute gp_flags.
  #
  # source://rubyzip//lib/zip/entry.rb#31
  def gp_flags; end

  # Sets the attribute gp_flags
  #
  # @param value the value to set the attribute gp_flags to.
  #
  # source://rubyzip//lib/zip/entry.rb#31
  def gp_flags=(param); end

  # @return [Boolean]
  #
  # source://rubyzip//lib/zip/entry.rb#116
  def incomplete?; end

  # Returns the value of attribute internal_file_attributes.
  #
  # source://rubyzip//lib/zip/entry.rb#31
  def internal_file_attributes; end

  # Sets the attribute internal_file_attributes
  #
  # @param value the value to set the attribute internal_file_attributes to.
  #
  # source://rubyzip//lib/zip/entry.rb#31
  def internal_file_attributes=(_arg0); end

  # source://rubyzip//lib/zip/entry.rb#243
  def local_entry_offset; end

  # Returns the value of attribute local_header_offset.
  #
  # source://rubyzip//lib/zip/entry.rb#31
  def local_header_offset; end

  # Sets the attribute local_header_offset
  #
  # @param value the value to set the attribute local_header_offset to.
  #
  # source://rubyzip//lib/zip/entry.rb#31
  def local_header_offset=(_arg0); end

  # Get a timestamp component of this entry.
  #
  # Returns modification time by default.
  #
  # source://rubyzip//lib/zip/entry.rb#141
  def mtime(component: T.unsafe(nil)); end

  # Set a timestamp component of this entry.
  #
  # Sets modification time by default.
  #
  # source://rubyzip//lib/zip/entry.rb#168
  def mtime=(value, component: T.unsafe(nil)); end

  # source://rubyzip//lib/zip/entry.rb#27
  def name; end

  # source://rubyzip//lib/zip/entry.rb#27
  def name=(param); end

  # @return [Boolean]
  #
  # source://rubyzip//lib/zip/entry.rb#226
  def name_is_directory?; end

  # Is the name a relative path, free of `..` patterns that could lead to
  # path traversal attacks? This does NOT handle symlinks; if the path
  # contains symlinks, this check is NOT enough to guarantee safety.
  #
  # @return [Boolean]
  #
  # source://rubyzip//lib/zip/entry.rb#233
  def name_safe?; end

  # source://rubyzip//lib/zip/entry.rb#247
  def name_size; end

  # source://rubyzip//lib/zip/entry.rb#280
  def next_header_offset; end

  # source://rubyzip//lib/zip/entry.rb#38
  def orig_comment=(_arg0); end

  # source://rubyzip//lib/zip/entry.rb#38
  def orig_compressed_size=(_arg0); end

  # source://rubyzip//lib/zip/entry.rb#38
  def orig_external_file_attributes=(_arg0); end

  # source://rubyzip//lib/zip/entry.rb#38
  def orig_fstype=(_arg0); end

  # source://rubyzip//lib/zip/entry.rb#38
  def orig_gp_flags=(_arg0); end

  # source://rubyzip//lib/zip/entry.rb#38
  def orig_name=(_arg0); end

  # source://rubyzip//lib/zip/entry.rb#38
  def orig_size=(_arg0); end

  # source://rubyzip//lib/zip/entry.rb#38
  def orig_unix_gid=(_arg0); end

  # source://rubyzip//lib/zip/entry.rb#38
  def orig_unix_perms=(_arg0); end

  # source://rubyzip//lib/zip/entry.rb#38
  def orig_unix_uid=(_arg0); end

  # source://rubyzip//lib/zip/entry.rb#573
  def pack_c_dir_entry; end

  # source://rubyzip//lib/zip/entry.rb#394
  def pack_local_entry; end

  # source://rubyzip//lib/zip/entry.rb#716
  def parent_as_string; end

  # source://rubyzip//lib/zip/entry.rb#506
  def read_c_dir_entry(io); end

  # source://rubyzip//lib/zip/entry.rb#498
  def read_extra_field(buf, local: T.unsafe(nil)); end

  # source://rubyzip//lib/zip/entry.rb#350
  def read_local_entry(io); end

  # source://rubyzip//lib/zip/entry.rb#27
  def restore_ownership; end

  # source://rubyzip//lib/zip/entry.rb#27
  def restore_ownership=(_arg0); end

  # source://rubyzip//lib/zip/entry.rb#27
  def restore_permissions; end

  # source://rubyzip//lib/zip/entry.rb#27
  def restore_permissions=(_arg0); end

  # source://rubyzip//lib/zip/entry.rb#27
  def restore_times; end

  # source://rubyzip//lib/zip/entry.rb#27
  def restore_times=(_arg0); end

  # source://rubyzip//lib/zip/entry.rb#42
  def set_default_vars_values; end

  # source://rubyzip//lib/zip/entry.rb#559
  def set_extra_attributes_on_path(dest_path); end

  # source://rubyzip//lib/zip/entry.rb#450
  def set_ftype_from_c_dir_entry; end

  # source://rubyzip//lib/zip/entry.rb#547
  def set_unix_attributes_on_path(dest_path); end

  # The uncompressed size of the entry.
  #
  # source://rubyzip//lib/zip/entry.rb#121
  def size; end

  # source://rubyzip//lib/zip/entry.rb#36
  def size=(param); end

  # source://rubyzip//lib/zip/entry.rb#221
  def symlink?; end

  # Get a timestamp component of this entry.
  #
  # Returns modification time by default.
  #
  # source://rubyzip//lib/zip/entry.rb#128
  def time(component: T.unsafe(nil)); end

  # Set a timestamp component of this entry.
  #
  # Sets modification time by default.
  #
  # source://rubyzip//lib/zip/entry.rb#156
  def time=(value, component: T.unsafe(nil)); end

  # source://rubyzip//lib/zip/entry.rb#306
  def to_s; end

  # source://rubyzip//lib/zip/entry.rb#27
  def unix_gid; end

  # source://rubyzip//lib/zip/entry.rb#27
  def unix_gid=(param); end

  # source://rubyzip//lib/zip/entry.rb#27
  def unix_perms; end

  # source://rubyzip//lib/zip/entry.rb#27
  def unix_perms=(param); end

  # source://rubyzip//lib/zip/entry.rb#27
  def unix_uid; end

  # source://rubyzip//lib/zip/entry.rb#27
  def unix_uid=(param); end

  # source://rubyzip//lib/zip/entry.rb#429
  def unpack_c_dir_entry(buf); end

  # source://rubyzip//lib/zip/entry.rb#335
  def unpack_local_entry(buf); end

  # check before rewriting an entry (after file sizes are known)
  # that we didn't change the header size (and thus clobber file data or something)
  #
  # @raise [Error]
  #
  # source://rubyzip//lib/zip/entry.rb#265
  def verify_local_header_size!; end

  # source://rubyzip//lib/zip/entry.rb#597
  def write_c_dir_entry(io, suppress_extra_fields: T.unsafe(nil)); end

  # source://rubyzip//lib/zip/entry.rb#409
  def write_local_entry(io, suppress_extra_fields: T.unsafe(nil), rewrite: T.unsafe(nil)); end

  # source://rubyzip//lib/zip/entry.rb#703
  def write_to_zip_output_stream(zip_output_stream); end

  # Does this entry use the ZIP64 extensions?
  #
  # @return [Boolean]
  #
  # source://rubyzip//lib/zip/entry.rb#202
  def zip64?; end

  private

  # source://rubyzip//lib/zip/entry.rb#779
  def create_directory(dest_path); end

  # source://rubyzip//lib/zip/entry.rb#752
  def create_file(dest_path, _continue_on_exists_proc = T.unsafe(nil)); end

  # BUG: create_symlink() does not use &block
  #
  # source://rubyzip//lib/zip/entry.rb#793
  def create_symlink(dest_path); end

  # source://rubyzip//lib/zip/entry.rb#813
  def parse_aes_extra; end

  # apply missing data from the zip64 extra information field, if present
  # (required when file sizes exceed 2**32, but can be used for all files)
  #
  # source://rubyzip//lib/zip/entry.rb#801
  def parse_zip64_extra(for_local_header); end

  # source://rubyzip//lib/zip/entry.rb#865
  def prep_cdir_zip64_extra; end

  # source://rubyzip//lib/zip/entry.rb#849
  def prep_local_zip64_extra; end

  # source://rubyzip//lib/zip/entry.rb#736
  def read_local_header_fields(io); end

  # For DEFLATED compression *only*: set the general purpose flags 1 and 2 to
  # indicate compression level. This seems to be mainly cosmetic but they are
  # generally set by other tools - including in docx files. It is these flags
  # that are used by commandline tools (and elsewhere) to give an indication
  # of how compressed a file is. See the PKWARE APPNOTE for more information:
  # https://pkware.cachefly.net/webdocs/casestudies/APPNOTE.TXT
  #
  # It's safe to simply OR these flags here as compression_level is read only.
  #
  # source://rubyzip//lib/zip/entry.rb#835
  def set_compression_level_flags; end

  # source://rubyzip//lib/zip/entry.rb#746
  def set_time(binary_dos_date, binary_dos_time); end

  class << self
    # source://rubyzip//lib/zip/entry.rb#311
    def read_c_dir_entry(io); end

    # source://rubyzip//lib/zip/entry.rb#324
    def read_local_entry(io); end
  end
end

# source://rubyzip//lib/zip/entry.rb#24
Zip::Entry::COMPRESSION_LEVEL_FAST_GPFLAG = T.let(T.unsafe(nil), Integer)

# source://rubyzip//lib/zip/entry.rb#25
Zip::Entry::COMPRESSION_LEVEL_MAX_GPFLAG = T.let(T.unsafe(nil), Integer)

# Compression level flags (used as part of the gp flags).
#
# source://rubyzip//lib/zip/entry.rb#23
Zip::Entry::COMPRESSION_LEVEL_SUPERFAST_GPFLAG = T.let(T.unsafe(nil), Integer)

# Constant used to specify that the entry is deflated (i.e., compressed).
#
# source://rubyzip//lib/zip/entry.rb#17
Zip::Entry::DEFLATED = T.let(T.unsafe(nil), Integer)

# Language encoding flag (EFS) bit
#
# source://rubyzip//lib/zip/entry.rb#20
Zip::Entry::EFS = T.let(T.unsafe(nil), Integer)

# Constant used to specify that the entry is stored (i.e., not compressed).
#
# source://rubyzip//lib/zip/entry.rb#14
Zip::Entry::STORED = T.let(T.unsafe(nil), Integer)

# Error raised when trying to add an entry to an archive where the
# entry name already exists.
#
# source://rubyzip//lib/zip/errors.rb#62
class Zip::EntryExistsError < ::Zip::Error
  # Create a new EntryExistsError with the specified source and name.
  #
  # @return [EntryExistsError] a new instance of EntryExistsError
  #
  # source://rubyzip//lib/zip/errors.rb#64
  def initialize(source, name); end

  # The message returned by this error.
  #
  # source://rubyzip//lib/zip/errors.rb#71
  def message; end
end

# Error raised when an entry name is invalid.
#
# source://rubyzip//lib/zip/errors.rb#77
class Zip::EntryNameError < ::Zip::Error
  # Create a new EntryNameError with the specified name.
  #
  # @return [EntryNameError] a new instance of EntryNameError
  #
  # source://rubyzip//lib/zip/errors.rb#79
  def initialize(name = T.unsafe(nil)); end

  # The message returned by this error.
  #
  # source://rubyzip//lib/zip/errors.rb#85
  def message; end
end

# source://rubyzip//lib/zip/entry_set.rb#4
class Zip::EntrySet
  include ::Enumerable

  # @return [EntrySet] a new instance of EntrySet
  #
  # source://rubyzip//lib/zip/entry_set.rb#10
  def initialize(an_enumerable = T.unsafe(nil)); end

  # source://rubyzip//lib/zip/entry_set.rb#24
  def <<(entry); end

  # source://rubyzip//lib/zip/entry_set.rb#53
  def ==(other); end

  # source://rubyzip//lib/zip/entry_set.rb#36
  def delete(entry); end

  # deep clone
  #
  # source://rubyzip//lib/zip/entry_set.rb#49
  def dup; end

  # source://rubyzip//lib/zip/entry_set.rb#40
  def each(&block); end

  # source://rubyzip//lib/zip/entry_set.rb#44
  def entries; end

  # source://rubyzip//lib/zip/entry_set.rb#20
  def find_entry(entry); end

  # source://rubyzip//lib/zip/entry_set.rb#63
  def glob(pattern, flags = T.unsafe(nil)); end

  # @return [Boolean]
  #
  # source://rubyzip//lib/zip/entry_set.rb#16
  def include?(entry); end

  # source://rubyzip//lib/zip/entry_set.rb#34
  def length; end

  # source://rubyzip//lib/zip/entry_set.rb#59
  def parent(entry); end

  # source://rubyzip//lib/zip/entry_set.rb#28
  def push(entry); end

  # source://rubyzip//lib/zip/entry_set.rb#30
  def size; end

  protected

  # Returns the value of attribute entry_set.
  #
  # source://rubyzip//lib/zip/entry_set.rb#7
  def entry_set; end

  # source://rubyzip//lib/zip/entry_set.rb#74
  def sorted_entries; end

  private

  # source://rubyzip//lib/zip/entry_set.rb#80
  def to_key(entry); end
end

# Error raised if an entry is larger on extraction than it is advertised
# to be.
#
# source://rubyzip//lib/zip/errors.rb#96
class Zip::EntrySizeError < ::Zip::Error
  # Create a new EntrySizeError with the specified entry.
  #
  # @return [EntrySizeError] a new instance of EntrySizeError
  #
  # source://rubyzip//lib/zip/errors.rb#101
  def initialize(entry); end

  # The entry that has caused this error.
  #
  # source://rubyzip//lib/zip/errors.rb#98
  def entry; end

  # The message returned by this error.
  #
  # source://rubyzip//lib/zip/errors.rb#107
  def message; end
end

# The superclass for all rubyzip error types. Simply rescue this one if
# you don't need to know what sort of error has been raised.
#
# source://rubyzip//lib/zip/errors.rb#6
class Zip::Error < ::StandardError; end

# source://rubyzip//lib/zip/extra_field.rb#4
class Zip::ExtraField < ::Hash
  # @return [ExtraField] a new instance of ExtraField
  #
  # source://rubyzip//lib/zip/extra_field.rb#7
  def initialize(binstr = T.unsafe(nil), local: T.unsafe(nil)); end

  # source://rubyzip//lib/zip/extra_field.rb#81
  def c_dir_size; end

  # source://rubyzip//lib/zip/extra_field.rb#48
  def create(name); end

  # source://rubyzip//lib/zip/extra_field.rb#11
  def extra_field_type_exist(binstr, id, len, index); end

  # source://rubyzip//lib/zip/extra_field.rb#21
  def extra_field_type_unknown(binstr, len, index, local); end

  # source://rubyzip//lib/zip/extra_field.rb#89
  def length; end

  # source://rubyzip//lib/zip/extra_field.rb#85
  def local_size; end

  # source://rubyzip//lib/zip/extra_field.rb#32
  def merge(binstr, local: T.unsafe(nil)); end

  # Place Unknown last, so "extra" data that is missing the proper
  # signature/size does not prevent known fields from being read back in.
  #
  # source://rubyzip//lib/zip/extra_field.rb#58
  def ordered_values; end

  # source://rubyzip//lib/zip/extra_field.rb#90
  def size; end

  # Remove any extra fields that indicate they can be safely suppressed.
  #
  # source://rubyzip//lib/zip/extra_field.rb#65
  def suppress_fields!(fields); end

  # source://rubyzip//lib/zip/extra_field.rb#77
  def to_c_dir_bin; end

  # source://rubyzip//lib/zip/extra_field.rb#71
  def to_local_bin; end

  # source://rubyzip//lib/zip/extra_field.rb#75
  def to_s; end
end

# source://rubyzip//lib/zip/extra_field/aes.rb#5
class Zip::ExtraField::AES < ::Zip::ExtraField::Generic
  # source://rubyzip//lib/zip/extra_field/aes.rb#11
  def initialize(binstr = T.unsafe(nil)); end

  # source://rubyzip//lib/zip/extra_field/aes.rb#19
  def ==(other); end

  # source://rubyzip//lib/zip/extra_field/aes.rb#6
  def compression_method; end

  # source://rubyzip//lib/zip/extra_field/aes.rb#6
  def encryption_strength; end

  # source://rubyzip//lib/zip/extra_field/aes.rb#26
  def merge(binstr); end

  # source://rubyzip//lib/zip/extra_field/aes.rb#46
  def pack_for_c_dir; end

  # source://rubyzip//lib/zip/extra_field/aes.rb#41
  def pack_for_local; end

  # source://rubyzip//lib/zip/extra_field/aes.rb#37
  def suppress?; end

  # source://rubyzip//lib/zip/extra_field/aes.rb#6
  def vendor_id; end

  # source://rubyzip//lib/zip/extra_field/aes.rb#6
  def vendor_version; end
end

# source://rubyzip//lib/zip/extra_field/aes.rb#8
Zip::ExtraField::AES::HEADER_ID = T.let(T.unsafe(nil), String)

# source://rubyzip//lib/zip/extra_field/generic.rb#4
class Zip::ExtraField::Generic
  # source://rubyzip//lib/zip/extra_field/generic.rb#16
  def initial_parse(binstr); end

  # source://rubyzip//lib/zip/extra_field/generic.rb#29
  def suppress?; end

  # source://rubyzip//lib/zip/extra_field/generic.rb#38
  def to_c_dir_bin; end

  # source://rubyzip//lib/zip/extra_field/generic.rb#33
  def to_local_bin; end

  class << self
    # source://rubyzip//lib/zip/extra_field/generic.rb#11
    def name; end

    # source://rubyzip//lib/zip/extra_field/generic.rb#5
    def register_map; end
  end
end

# source://rubyzip//lib/zip/extra_field.rb#5
Zip::ExtraField::ID_MAP = T.let(T.unsafe(nil), Hash)

# source://rubyzip//lib/zip/extra_field/unix.rb#5
class Zip::ExtraField::IUnix < ::Zip::ExtraField::Generic
  # source://rubyzip//lib/zip/extra_field/unix.rb#9
  def initialize(binstr = T.unsafe(nil)); end

  # source://rubyzip//lib/zip/extra_field/unix.rb#29
  def ==(other); end

  # source://rubyzip//lib/zip/extra_field/unix.rb#15
  def gid; end

  # source://rubyzip//lib/zip/extra_field/unix.rb#15
  def gid=(_arg0); end

  # source://rubyzip//lib/zip/extra_field/unix.rb#17
  def merge(binstr); end

  # source://rubyzip//lib/zip/extra_field/unix.rb#37
  def pack_for_c_dir; end

  # source://rubyzip//lib/zip/extra_field/unix.rb#33
  def pack_for_local; end

  # source://rubyzip//lib/zip/extra_field/unix.rb#15
  def uid; end

  # source://rubyzip//lib/zip/extra_field/unix.rb#15
  def uid=(_arg0); end
end

# source://rubyzip//lib/zip/extra_field/unix.rb#6
Zip::ExtraField::IUnix::HEADER_ID = T.let(T.unsafe(nil), String)

# source://rubyzip//lib/zip/extra_field/ntfs.rb#6
class Zip::ExtraField::NTFS < ::Zip::ExtraField::Generic
  # source://rubyzip//lib/zip/extra_field/ntfs.rb#13
  def initialize(binstr = T.unsafe(nil)); end

  # source://rubyzip//lib/zip/extra_field/ntfs.rb#40
  def ==(other); end

  # source://rubyzip//lib/zip/extra_field/ntfs.rb#20
  def atime; end

  # source://rubyzip//lib/zip/extra_field/ntfs.rb#20
  def atime=(_arg0); end

  # source://rubyzip//lib/zip/extra_field/ntfs.rb#20
  def ctime; end

  # source://rubyzip//lib/zip/extra_field/ntfs.rb#20
  def ctime=(_arg0); end

  # source://rubyzip//lib/zip/extra_field/ntfs.rb#22
  def merge(binstr); end

  # source://rubyzip//lib/zip/extra_field/ntfs.rb#20
  def mtime; end

  # source://rubyzip//lib/zip/extra_field/ntfs.rb#20
  def mtime=(_arg0); end

  # source://rubyzip//lib/zip/extra_field/ntfs.rb#52
  def pack_for_c_dir; end

  # source://rubyzip//lib/zip/extra_field/ntfs.rb#47
  def pack_for_local; end

  private

  # source://rubyzip//lib/zip/extra_field/ntfs.rb#88
  def from_ntfs_time(ntfs_time); end

  # source://rubyzip//lib/zip/extra_field/ntfs.rb#70
  def parse_tags(content); end

  # source://rubyzip//lib/zip/extra_field/ntfs.rb#92
  def to_ntfs_time(time); end
end

# source://rubyzip//lib/zip/extra_field/ntfs.rb#7
Zip::ExtraField::NTFS::HEADER_ID = T.let(T.unsafe(nil), String)

# source://rubyzip//lib/zip/extra_field/ntfs.rb#11
Zip::ExtraField::NTFS::SEC_TO_UNIX_EPOCH = T.let(T.unsafe(nil), Integer)

# source://rubyzip//lib/zip/extra_field/ntfs.rb#10
Zip::ExtraField::NTFS::WINDOWS_TICK = T.let(T.unsafe(nil), Float)

# source://rubyzip//lib/zip/extra_field/old_unix.rb#5
class Zip::ExtraField::OldUnix < ::Zip::ExtraField::Generic
  # source://rubyzip//lib/zip/extra_field/old_unix.rb#9
  def initialize(binstr = T.unsafe(nil)); end

  # source://rubyzip//lib/zip/extra_field/old_unix.rb#33
  def ==(other); end

  # source://rubyzip//lib/zip/extra_field/old_unix.rb#17
  def atime; end

  # source://rubyzip//lib/zip/extra_field/old_unix.rb#17
  def atime=(_arg0); end

  # source://rubyzip//lib/zip/extra_field/old_unix.rb#17
  def gid; end

  # source://rubyzip//lib/zip/extra_field/old_unix.rb#17
  def gid=(_arg0); end

  # source://rubyzip//lib/zip/extra_field/old_unix.rb#19
  def merge(binstr); end

  # source://rubyzip//lib/zip/extra_field/old_unix.rb#17
  def mtime; end

  # source://rubyzip//lib/zip/extra_field/old_unix.rb#17
  def mtime=(_arg0); end

  # source://rubyzip//lib/zip/extra_field/old_unix.rb#44
  def pack_for_c_dir; end

  # source://rubyzip//lib/zip/extra_field/old_unix.rb#40
  def pack_for_local; end

  # source://rubyzip//lib/zip/extra_field/old_unix.rb#17
  def uid; end

  # source://rubyzip//lib/zip/extra_field/old_unix.rb#17
  def uid=(_arg0); end
end

# source://rubyzip//lib/zip/extra_field/old_unix.rb#6
Zip::ExtraField::OldUnix::HEADER_ID = T.let(T.unsafe(nil), String)

# source://rubyzip//lib/zip/extra_field/universal_time.rb#5
class Zip::ExtraField::UniversalTime < ::Zip::ExtraField::Generic
  # source://rubyzip//lib/zip/extra_field/universal_time.rb#13
  def initialize(binstr = T.unsafe(nil)); end

  # source://rubyzip//lib/zip/extra_field/universal_time.rb#59
  def ==(other); end

  # source://rubyzip//lib/zip/extra_field/universal_time.rb#22
  def atime; end

  # source://rubyzip//lib/zip/extra_field/universal_time.rb#24
  def atime=(time); end

  # source://rubyzip//lib/zip/extra_field/universal_time.rb#22
  def ctime; end

  # source://rubyzip//lib/zip/extra_field/universal_time.rb#29
  def ctime=(time); end

  # source://rubyzip//lib/zip/extra_field/universal_time.rb#22
  def flag; end

  # source://rubyzip//lib/zip/extra_field/universal_time.rb#39
  def merge(binstr); end

  # source://rubyzip//lib/zip/extra_field/universal_time.rb#22
  def mtime; end

  # source://rubyzip//lib/zip/extra_field/universal_time.rb#34
  def mtime=(time); end

  # source://rubyzip//lib/zip/extra_field/universal_time.rb#73
  def pack_for_c_dir; end

  # source://rubyzip//lib/zip/extra_field/universal_time.rb#65
  def pack_for_local; end
end

# source://rubyzip//lib/zip/extra_field/universal_time.rb#9
Zip::ExtraField::UniversalTime::ATIME_MASK = T.let(T.unsafe(nil), Integer)

# source://rubyzip//lib/zip/extra_field/universal_time.rb#10
Zip::ExtraField::UniversalTime::CTIME_MASK = T.let(T.unsafe(nil), Integer)

# source://rubyzip//lib/zip/extra_field/universal_time.rb#6
Zip::ExtraField::UniversalTime::HEADER_ID = T.let(T.unsafe(nil), String)

# source://rubyzip//lib/zip/extra_field/universal_time.rb#11
Zip::ExtraField::UniversalTime::MTIME_MASK = T.let(T.unsafe(nil), Integer)

# source://rubyzip//lib/zip/extra_field/unknown.rb#7
class Zip::ExtraField::Unknown < ::Zip::ExtraField::Generic
  # source://rubyzip//lib/zip/extra_field/unknown.rb#8
  def initialize; end

  # source://rubyzip//lib/zip/extra_field/unknown.rb#31
  def ==(other); end

  # source://rubyzip//lib/zip/extra_field/unknown.rb#13
  def merge(binstr, local: T.unsafe(nil)); end

  # source://rubyzip//lib/zip/extra_field/unknown.rb#27
  def to_c_dir_bin; end

  # source://rubyzip//lib/zip/extra_field/unknown.rb#23
  def to_local_bin; end
end

# source://rubyzip//lib/zip/extra_field/zip64.rb#5
class Zip::ExtraField::Zip64 < ::Zip::ExtraField::Generic
  # source://rubyzip//lib/zip/extra_field/zip64.rb#12
  def initialize(binstr = T.unsafe(nil)); end

  # source://rubyzip//lib/zip/extra_field/zip64.rb#24
  def ==(other); end

  # source://rubyzip//lib/zip/extra_field/zip64.rb#6
  def compressed_size; end

  # source://rubyzip//lib/zip/extra_field/zip64.rb#6
  def compressed_size=(_arg0); end

  # source://rubyzip//lib/zip/extra_field/zip64.rb#6
  def disk_start_number; end

  # source://rubyzip//lib/zip/extra_field/zip64.rb#6
  def disk_start_number=(_arg0); end

  # source://rubyzip//lib/zip/extra_field/zip64.rb#31
  def merge(binstr); end

  # source://rubyzip//lib/zip/extra_field/zip64.rb#6
  def original_size; end

  # source://rubyzip//lib/zip/extra_field/zip64.rb#6
  def original_size=(_arg0); end

  # source://rubyzip//lib/zip/extra_field/zip64.rb#74
  def pack_for_c_dir; end

  # source://rubyzip//lib/zip/extra_field/zip64.rb#66
  def pack_for_local; end

  # source://rubyzip//lib/zip/extra_field/zip64.rb#40
  def parse(original_size, compressed_size, relative_header_offset = T.unsafe(nil), disk_start_number = T.unsafe(nil)); end

  # source://rubyzip//lib/zip/extra_field/zip64.rb#6
  def relative_header_offset; end

  # source://rubyzip//lib/zip/extra_field/zip64.rb#6
  def relative_header_offset=(_arg0); end

  # source://rubyzip//lib/zip/extra_field/zip64.rb#61
  def suppress?; end

  private

  # source://rubyzip//lib/zip/extra_field/zip64.rb#54
  def extract(size, format); end
end

# source://rubyzip//lib/zip/extra_field/zip64.rb#9
Zip::ExtraField::Zip64::HEADER_ID = T.let(T.unsafe(nil), String)

# source://rubyzip//lib/zip/constants.rb#21
Zip::FILE_TYPE_DIR = T.let(T.unsafe(nil), Integer)

# source://rubyzip//lib/zip/constants.rb#20
Zip::FILE_TYPE_FILE = T.let(T.unsafe(nil), Integer)

# source://rubyzip//lib/zip/constants.rb#22
Zip::FILE_TYPE_SYMLINK = T.let(T.unsafe(nil), Integer)

# source://rubyzip//lib/zip/constants.rb#46
Zip::FSTYPES = T.let(T.unsafe(nil), Hash)

# source://rubyzip//lib/zip/constants.rb#37
Zip::FSTYPE_ACORN = T.let(T.unsafe(nil), Integer)

# source://rubyzip//lib/zip/constants.rb#25
Zip::FSTYPE_AMIGA = T.let(T.unsafe(nil), Integer)

# source://rubyzip//lib/zip/constants.rb#29
Zip::FSTYPE_ATARI = T.let(T.unsafe(nil), Integer)

# source://rubyzip//lib/zip/constants.rb#44
Zip::FSTYPE_ATHEOS = T.let(T.unsafe(nil), Integer)

# source://rubyzip//lib/zip/constants.rb#40
Zip::FSTYPE_BEOS = T.let(T.unsafe(nil), Integer)

# source://rubyzip//lib/zip/constants.rb#33
Zip::FSTYPE_CPM = T.let(T.unsafe(nil), Integer)

# source://rubyzip//lib/zip/constants.rb#24
Zip::FSTYPE_FAT = T.let(T.unsafe(nil), Integer)

# source://rubyzip//lib/zip/constants.rb#30
Zip::FSTYPE_HPFS = T.let(T.unsafe(nil), Integer)

# source://rubyzip//lib/zip/constants.rb#31
Zip::FSTYPE_MAC = T.let(T.unsafe(nil), Integer)

# source://rubyzip//lib/zip/constants.rb#43
Zip::FSTYPE_MAC_OSX = T.let(T.unsafe(nil), Integer)

# source://rubyzip//lib/zip/constants.rb#39
Zip::FSTYPE_MVS = T.let(T.unsafe(nil), Integer)

# source://rubyzip//lib/zip/constants.rb#35
Zip::FSTYPE_NTFS = T.let(T.unsafe(nil), Integer)

# source://rubyzip//lib/zip/constants.rb#36
Zip::FSTYPE_QDOS = T.let(T.unsafe(nil), Integer)

# source://rubyzip//lib/zip/constants.rb#41
Zip::FSTYPE_TANDEM = T.let(T.unsafe(nil), Integer)

# source://rubyzip//lib/zip/constants.rb#42
Zip::FSTYPE_THEOS = T.let(T.unsafe(nil), Integer)

# source://rubyzip//lib/zip/constants.rb#34
Zip::FSTYPE_TOPS20 = T.let(T.unsafe(nil), Integer)

# source://rubyzip//lib/zip/constants.rb#27
Zip::FSTYPE_UNIX = T.let(T.unsafe(nil), Integer)

# source://rubyzip//lib/zip/constants.rb#38
Zip::FSTYPE_VFAT = T.let(T.unsafe(nil), Integer)

# source://rubyzip//lib/zip/constants.rb#26
Zip::FSTYPE_VMS = T.let(T.unsafe(nil), Integer)

# source://rubyzip//lib/zip/constants.rb#28
Zip::FSTYPE_VM_CMS = T.let(T.unsafe(nil), Integer)

# source://rubyzip//lib/zip/constants.rb#32
Zip::FSTYPE_Z_SYSTEM = T.let(T.unsafe(nil), Integer)

# source://rubyzip//lib/zip/file.rb#52
class Zip::File
  include ::Enumerable
  extend ::Forwardable
  extend ::Zip::FileSplit

  # Opens a zip archive. Pass create: true to create
  # a new archive if it doesn't exist already.
  #
  # @return [File] a new instance of File
  #
  # source://rubyzip//lib/zip/file.rb#75
  def initialize(path_or_io, create: T.unsafe(nil), buffer: T.unsafe(nil), restore_ownership: T.unsafe(nil), restore_permissions: T.unsafe(nil), restore_times: T.unsafe(nil), compression_level: T.unsafe(nil), suppress_extra_fields: T.unsafe(nil)); end

  # Convenience method for adding the contents of a file to the archive
  #
  # source://rubyzip//lib/zip/file.rb#231
  def add(entry, src_path, &continue_on_exists_proc); end

  # Convenience method for adding the contents of a file to the archive
  # in Stored format (uncompressed)
  #
  # source://rubyzip//lib/zip/file.rb#248
  def add_stored(entry, src_path, &continue_on_exists_proc); end

  # Closes the zip file committing any changes that has been made.
  #
  # source://rubyzip//lib/zip/file.rb#318
  def close; end

  # source://rubyzip//lib/zip/file.rb#71
  def comment(*args, **_arg1, &block); end

  # source://rubyzip//lib/zip/file.rb#71
  def comment=(*args, **_arg1, &block); end

  # Commits changes that has been made since the previous commit to
  # the zip archive.
  #
  # source://rubyzip//lib/zip/file.rb#291
  def commit; end

  # Returns true if any changes has been made to this archive since
  # the previous commit
  #
  # @return [Boolean]
  #
  # source://rubyzip//lib/zip/file.rb#324
  def commit_required?; end

  # source://rubyzip//lib/zip/file.rb#71
  def each(*args, **_arg1, &block); end

  # source://rubyzip//lib/zip/file.rb#71
  def entries(*args, **_arg1, &block); end

  # Extracts `entry` to a file at `entry_path`, with `destination_directory`
  # as the base location in the filesystem.
  #
  # NB: The caller is responsible for making sure `destination_directory` is
  # safe, if it is passed.
  #
  # source://rubyzip//lib/zip/file.rb#282
  def extract(entry, entry_path = T.unsafe(nil), destination_directory: T.unsafe(nil), &block); end

  # Searches for entry with the specified name. Returns nil if
  # no entry is found. See also get_entry
  #
  # source://rubyzip//lib/zip/file.rb#336
  def find_entry(entry_name); end

  # Searches for an entry just as find_entry, but throws Errno::ENOENT
  # if no entry is found.
  #
  # @raise [Errno::ENOENT]
  #
  # source://rubyzip//lib/zip/file.rb#348
  def get_entry(entry); end

  # Returns an input stream to the specified entry. If a block is passed
  # the stream object is passed to the block and the stream is automatically
  # closed afterwards just as with ruby's builtin File.open method.
  #
  # source://rubyzip//lib/zip/file.rb#186
  def get_input_stream(entry, &a_proc); end

  # Returns an output stream to the specified entry. If entry is not an instance
  # of Zip::Entry, a new Zip::Entry will be initialized using the arguments
  # specified. If a block is passed the stream object is passed to the block and
  # the stream is automatically closed afterwards just as with ruby's builtin
  # File.open method.
  #
  # source://rubyzip//lib/zip/file.rb#195
  def get_output_stream(entry, permissions: T.unsafe(nil), comment: T.unsafe(nil), extra: T.unsafe(nil), compressed_size: T.unsafe(nil), crc: T.unsafe(nil), compression_method: T.unsafe(nil), compression_level: T.unsafe(nil), size: T.unsafe(nil), time: T.unsafe(nil), &a_proc); end

  # source://rubyzip//lib/zip/file.rb#71
  def glob(*args, **_arg1, &block); end

  # Creates a directory
  #
  # @raise [Errno::EEXIST]
  #
  # source://rubyzip//lib/zip/file.rb#356
  def mkdir(entry_name, permission = T.unsafe(nil)); end

  # The name of this zip archive.
  #
  # source://rubyzip//lib/zip/file.rb#60
  def name; end

  # Returns a string containing the contents of the specified entry
  #
  # source://rubyzip//lib/zip/file.rb#226
  def read(entry); end

  # Removes the specified entry.
  #
  # source://rubyzip//lib/zip/file.rb#256
  def remove(entry); end

  # Renames the specified entry.
  #
  # source://rubyzip//lib/zip/file.rb#261
  def rename(entry, new_name, &continue_on_exists_proc); end

  # Replaces the specified entry with the contents of src_path (from
  # the file system).
  #
  # source://rubyzip//lib/zip/file.rb#271
  def replace(entry, src_path); end

  # default -> false.
  #
  # source://rubyzip//lib/zip/file.rb#63
  def restore_ownership; end

  # default -> false.
  #
  # source://rubyzip//lib/zip/file.rb#63
  def restore_ownership=(_arg0); end

  # default -> true.
  #
  # source://rubyzip//lib/zip/file.rb#66
  def restore_permissions; end

  # default -> true.
  #
  # source://rubyzip//lib/zip/file.rb#66
  def restore_permissions=(_arg0); end

  # default -> true.
  #
  # source://rubyzip//lib/zip/file.rb#69
  def restore_times; end

  # default -> true.
  #
  # source://rubyzip//lib/zip/file.rb#69
  def restore_times=(_arg0); end

  # source://rubyzip//lib/zip/file.rb#71
  def size(*args, **_arg1, &block); end

  # Returns the name of the zip archive
  #
  # source://rubyzip//lib/zip/file.rb#221
  def to_s; end

  # Write buffer write changes to buffer and return
  #
  # source://rubyzip//lib/zip/file.rb#308
  def write_buffer(io = T.unsafe(nil)); end

  private

  # source://rubyzip//lib/zip/file.rb#398
  def check_entry_exists(entry_name, continue_on_exists_proc, proc_name); end

  # @raise [Errno::ENOENT]
  #
  # source://rubyzip//lib/zip/file.rb#407
  def check_file(path); end

  # source://rubyzip//lib/zip/file.rb#366
  def initialize_cdir(path_or_io, buffer: T.unsafe(nil)); end

  # source://rubyzip//lib/zip/file.rb#411
  def on_success_replace; end

  class << self
    # Count the entries in a zip archive without reading the whole set of
    # entry data into memory.
    #
    # source://rubyzip//lib/zip/file.rb#170
    def count_entries(path_or_io); end

    # Iterates over the contents of the ZipFile. This is more efficient
    # than using a ZipInputStream since this methods simply iterates
    # through the entries in the central directory structure in the archive
    # whereas ZipInputStream jumps through the entire archive accessing the
    # local entry headers (which contain the same information as the
    # central directory).
    #
    # source://rubyzip//lib/zip/file.rb#162
    def foreach(zip_file_name, &block); end

    # Similar to ::new. If a block is passed the Zip::File object is passed
    # to the block and is automatically closed afterwards, just as with
    # ruby's builtin File::open method.
    #
    # source://rubyzip//lib/zip/file.rb#99
    def open(file_name, create: T.unsafe(nil), restore_ownership: T.unsafe(nil), restore_permissions: T.unsafe(nil), restore_times: T.unsafe(nil), compression_level: T.unsafe(nil), suppress_extra_fields: T.unsafe(nil)); end

    # Like #open, but reads zip archive contents from a String or open IO
    # stream, and outputs data to a buffer.
    # (This can be used to extract data from a
    # downloaded zip archive without first saving it to disk.)
    #
    # @yield [zf]
    #
    # source://rubyzip//lib/zip/file.rb#125
    def open_buffer(io = T.unsafe(nil), create: T.unsafe(nil), restore_ownership: T.unsafe(nil), restore_permissions: T.unsafe(nil), restore_times: T.unsafe(nil), compression_level: T.unsafe(nil), suppress_extra_fields: T.unsafe(nil)); end
  end
end

# source://rubyzip//lib/zip/file.rb#57
Zip::File::IO_METHODS = T.let(T.unsafe(nil), Array)

# source://rubyzip//lib/zip/file_split.rb#4
module Zip::FileSplit
  # source://rubyzip//lib/zip/file_split.rb#13
  def get_partial_zip_file_name(zip_file_name, partial_zip_file_name); end

  # source://rubyzip//lib/zip/file_split.rb#24
  def get_segment_count_for_split(zip_file_size, segment_size); end

  # source://rubyzip//lib/zip/file_split.rb#9
  def get_segment_size_for_split(segment_size); end

  # source://rubyzip//lib/zip/file_split.rb#29
  def put_split_signature(szip_file, segment_size); end

  # TODO: Make the code more understandable
  #
  # source://rubyzip//lib/zip/file_split.rb#38
  def save_splited_part(zip_file, partial_zip_file_name, zip_file_size, szip_file_index, segment_size, segment_count); end

  # Splits an archive into parts with segment size
  #
  # @raise [Error]
  #
  # source://rubyzip//lib/zip/file_split.rb#63
  def split(zip_file_name, segment_size: T.unsafe(nil), delete_original: T.unsafe(nil), partial_zip_file_name: T.unsafe(nil)); end
end

# source://rubyzip//lib/zip/file_split.rb#7
Zip::FileSplit::DATA_BUFFER_SIZE = T.let(T.unsafe(nil), Integer)

# source://rubyzip//lib/zip/file_split.rb#5
Zip::FileSplit::MAX_SEGMENT_SIZE = T.let(T.unsafe(nil), Integer)

# source://rubyzip//lib/zip/file_split.rb#6
Zip::FileSplit::MIN_SEGMENT_SIZE = T.let(T.unsafe(nil), Integer)

# source://rubyzip//lib/zip/ioextras.rb#4
module Zip::IOExtras
  class << self
    # source://rubyzip//lib/zip/ioextras.rb#8
    def copy_stream(ostream, istream); end

    # source://rubyzip//lib/zip/ioextras.rb#12
    def copy_stream_n(ostream, istream, nbytes); end
  end
end

# Implements many of the convenience methods of IO
# such as gets, getc, readline and readlines
# depends on: input_finished?, produce_input and read
#
# source://rubyzip//lib/zip/ioextras/abstract_input_stream.rb#8
module Zip::IOExtras::AbstractInputStream
  include ::ActiveSupport::ToJsonWithActiveSupportEncoder
  include ::Enumerable
  include ::Zip::IOExtras::FakeIO

  # source://rubyzip//lib/zip/ioextras/abstract_input_stream.rb#12
  def initialize; end

  # source://rubyzip//lib/zip/ioextras/abstract_input_stream.rb#118
  def each(a_sep_string = T.unsafe(nil)); end

  # source://rubyzip//lib/zip/ioextras/abstract_input_stream.rb#112
  def each_line(a_sep_string = T.unsafe(nil)); end

  # Alias for compatibility. Remove for version 4.
  #
  # @return [Boolean]
  #
  # source://rubyzip//lib/zip/ioextras/abstract_input_stream.rb#125
  def eof; end

  # @return [Boolean]
  #
  # source://rubyzip//lib/zip/ioextras/abstract_input_stream.rb#120
  def eof?; end

  # source://rubyzip//lib/zip/ioextras/abstract_input_stream.rb#99
  def flush; end

  # source://rubyzip//lib/zip/ioextras/abstract_input_stream.rb#60
  def gets(a_sep_string = T.unsafe(nil), number_of_bytes = T.unsafe(nil)); end

  # Returns the value of attribute lineno.
  #
  # source://rubyzip//lib/zip/ioextras/abstract_input_stream.rb#19
  def lineno; end

  # Sets the attribute lineno
  #
  # @param value the value to set the attribute lineno to.
  #
  # source://rubyzip//lib/zip/ioextras/abstract_input_stream.rb#19
  def lineno=(_arg0); end

  # Returns the value of attribute pos.
  #
  # source://rubyzip//lib/zip/ioextras/abstract_input_stream.rb#20
  def pos; end

  # source://rubyzip//lib/zip/ioextras/abstract_input_stream.rb#22
  def read(number_of_bytes = T.unsafe(nil), buf = T.unsafe(nil)); end

  # @raise [EOFError]
  #
  # source://rubyzip//lib/zip/ioextras/abstract_input_stream.rb#105
  def readline(a_sep_string = T.unsafe(nil)); end

  # source://rubyzip//lib/zip/ioextras/abstract_input_stream.rb#54
  def readlines(a_sep_string = T.unsafe(nil)); end

  # source://rubyzip//lib/zip/ioextras/abstract_input_stream.rb#95
  def ungetc(byte); end
end

# Implements many of the output convenience methods of IO.
# relies on <<
#
# source://rubyzip//lib/zip/ioextras/abstract_output_stream.rb#7
module Zip::IOExtras::AbstractOutputStream
  include ::Zip::IOExtras::FakeIO

  # source://rubyzip//lib/zip/ioextras/abstract_output_stream.rb#15
  def print(*params); end

  # source://rubyzip//lib/zip/ioextras/abstract_output_stream.rb#26
  def printf(a_format_string, *params); end

  # source://rubyzip//lib/zip/ioextras/abstract_output_stream.rb#31
  def putc(an_object); end

  # source://rubyzip//lib/zip/ioextras/abstract_output_stream.rb#43
  def puts(*params); end

  # source://rubyzip//lib/zip/ioextras/abstract_output_stream.rb#10
  def write(data); end
end

# source://rubyzip//lib/zip/ioextras.rb#5
Zip::IOExtras::CHUNK_SIZE = T.let(T.unsafe(nil), Integer)

# Implements kind_of? in order to pretend to be an IO object
#
# source://rubyzip//lib/zip/ioextras.rb#23
module Zip::IOExtras::FakeIO
  # @return [Boolean]
  #
  # source://rubyzip//lib/zip/ioextras.rb#24
  def kind_of?(object); end
end

# source://rubyzip//lib/zip/inflater.rb#4
class Zip::Inflater < ::Zip::Decompressor
  # @return [Inflater] a new instance of Inflater
  #
  # source://rubyzip//lib/zip/inflater.rb#5
  def initialize(*args); end

  # Alias for compatibility. Remove for version 4.
  #
  # @return [Boolean]
  #
  # source://rubyzip//lib/zip/inflater.rb#29
  def eof; end

  # @return [Boolean]
  #
  # source://rubyzip//lib/zip/inflater.rb#24
  def eof?; end

  # source://rubyzip//lib/zip/inflater.rb#12
  def read(length = T.unsafe(nil), outbuf = T.unsafe(nil)); end

  private

  # @return [Boolean]
  #
  # source://rubyzip//lib/zip/inflater.rb#47
  def input_finished?; end

  # source://rubyzip//lib/zip/inflater.rb#33
  def produce_input; end
end

# InputStream is the basic class for reading zip entries in a
# zip file. It is possible to create a InputStream object directly,
# passing the zip file name to the constructor, but more often than not
# the InputStream will be obtained from a File (perhaps using the
# ZipFileSystem interface) object for a particular entry in the zip
# archive.
#
# A InputStream inherits IOExtras::AbstractInputStream in order
# to provide an IO-like interface for reading from a single zip
# entry. Beyond methods for mimicking an IO-object it contains
# the method get_next_entry for iterating through the entries of
# an archive. get_next_entry returns a Entry object that describes
# the zip entry the InputStream is currently reading from.
#
# Example that creates a zip archive with ZipOutputStream and reads it
# back again with a InputStream.
#
#   require 'zip'
#
#   Zip::OutputStream.open("my.zip") do |io|
#
#     io.put_next_entry("first_entry.txt")
#     io.write "Hello world!"
#
#     io.put_next_entry("adir/first_entry.txt")
#     io.write "Hello again!"
#   end
#
#
#   Zip::InputStream.open("my.zip") do |io|
#
#     while (entry = io.get_next_entry)
#       puts "Contents of #{entry.name}: '#{io.read}'"
#     end
#   end
#
# java.util.zip.ZipInputStream is the original inspiration for this
# class.
#
# source://rubyzip//lib/zip/input_stream.rb#43
class Zip::InputStream
  include ::Enumerable
  include ::Zip::IOExtras::FakeIO
  include ::Zip::IOExtras::AbstractInputStream

  # Opens the indicated zip file. An exception is thrown
  # if the specified offset in the specified filename is
  # not a local zip entry header.
  #
  # @param context [String||IO||StringIO] file path or IO/StringIO object
  # @param offset [Integer] offset in the IO/StringIO
  # @return [InputStream] a new instance of InputStream
  #
  # source://rubyzip//lib/zip/input_stream.rb#54
  def initialize(context, offset: T.unsafe(nil), decrypter: T.unsafe(nil)); end

  # Close this InputStream. All further IO will raise an IOError.
  #
  # source://rubyzip//lib/zip/input_stream.rb#64
  def close; end

  # Returns an Entry object and positions the stream at the beginning of
  # the entry data. It is necessary to call this method on a newly created
  # InputStream before reading from the first entry in the archive.
  # Returns nil when there are no more entries.
  #
  # source://rubyzip//lib/zip/input_stream.rb#72
  def get_next_entry; end

  # Rewinds the stream to the beginning of the current entry.
  #
  # source://rubyzip//lib/zip/input_stream.rb#83
  def rewind; end

  # Returns the size of the current entry, or `nil` if there isn't one.
  #
  # source://rubyzip//lib/zip/input_stream.rb#98
  def size; end

  # Modeled after IO.sysread
  #
  # source://rubyzip//lib/zip/input_stream.rb#93
  def sysread(length = T.unsafe(nil), outbuf = T.unsafe(nil)); end

  protected

  # source://rubyzip//lib/zip/input_stream.rb#147
  def assemble_io; end

  # source://rubyzip//lib/zip/input_stream.rb#179
  def get_decompressor(io); end

  # source://rubyzip//lib/zip/input_stream.rb#159
  def get_decrypted_io; end

  # source://rubyzip//lib/zip/input_stream.rb#122
  def get_io(io_or_file, offset = T.unsafe(nil)); end

  # @return [Boolean]
  #
  # source://rubyzip//lib/zip/input_stream.rb#204
  def input_finished?; end

  # source://rubyzip//lib/zip/input_stream.rb#134
  def open_entry; end

  # source://rubyzip//lib/zip/input_stream.rb#200
  def produce_input; end

  class << self
    # Same as #initialize but if a block is passed the opened
    # stream is passed to the block and closed when the block
    # returns.
    #
    # source://rubyzip//lib/zip/input_stream.rb#108
    def open(filename_or_io, offset: T.unsafe(nil), decrypter: T.unsafe(nil)); end
  end
end

# source://rubyzip//lib/zip/input_stream.rb#44
Zip::InputStream::CHUNK_SIZE = T.let(T.unsafe(nil), Integer)

# source://rubyzip//lib/zip/constants.rb#11
Zip::LOCAL_ENTRY_SIGNATURE = T.let(T.unsafe(nil), Integer)

# source://rubyzip//lib/zip/constants.rb#12
Zip::LOCAL_ENTRY_STATIC_HEADER_LENGTH = T.let(T.unsafe(nil), Integer)

# source://rubyzip//lib/zip/constants.rb#13
Zip::LOCAL_ENTRY_TRAILING_DESCRIPTOR_LENGTH = T.let(T.unsafe(nil), Integer)

# source://rubyzip//lib/zip/null_compressor.rb#4
class Zip::NullCompressor < ::Zip::Compressor
  include ::Singleton::SingletonInstanceMethods
  include ::Singleton
  extend ::Singleton::SingletonClassMethods

  # @raise [IOError]
  #
  # source://rubyzip//lib/zip/null_compressor.rb#7
  def <<(_data); end

  # Returns the value of attribute compressed_size.
  #
  # source://rubyzip//lib/zip/null_compressor.rb#11
  def compressed_size; end

  # Returns the value of attribute size.
  #
  # source://rubyzip//lib/zip/null_compressor.rb#11
  def size; end

  class << self
    private

    # source://rubyzip//lib/zip/null_compressor.rb#5
    def allocate; end

    # source://rubyzip//lib/zip/null_compressor.rb#5
    def new(*_arg0); end
  end
end

# source://rubyzip//lib/zip/null_decompressor.rb#4
module Zip::NullDecompressor
  private

  # Alias for compatibility. Remove for version 4.
  #
  # source://rubyzip//lib/zip/null_decompressor.rb#16
  def eof; end

  # source://rubyzip//lib/zip/null_decompressor.rb#11
  def eof?; end

  # source://rubyzip//lib/zip/null_decompressor.rb#7
  def read(_length = T.unsafe(nil), _outbuf = T.unsafe(nil)); end

  class << self
    # @return [Boolean]
    #
    # source://rubyzip//lib/zip/null_decompressor.rb#11
    def eof?; end

    # source://rubyzip//lib/zip/null_decompressor.rb#7
    def read(_length = T.unsafe(nil), _outbuf = T.unsafe(nil)); end
  end
end

# source://rubyzip//lib/zip/crypto/null_encryption.rb#14
class Zip::NullEncrypter < ::Zip::Encrypter
  include ::Zip::NullEncryption

  # source://rubyzip//lib/zip/crypto/null_encryption.rb#25
  def data_descriptor(_crc32, _compressed_size, _uncompressed_size); end

  # source://rubyzip//lib/zip/crypto/null_encryption.rb#21
  def encrypt(data); end

  # source://rubyzip//lib/zip/crypto/null_encryption.rb#17
  def header(_mtime); end

  # source://rubyzip//lib/zip/crypto/null_encryption.rb#29
  def reset!; end
end

# source://rubyzip//lib/zip/crypto/null_encryption.rb#4
module Zip::NullEncryption
  # source://rubyzip//lib/zip/crypto/null_encryption.rb#9
  def gp_flags; end

  # source://rubyzip//lib/zip/crypto/null_encryption.rb#5
  def header_bytesize; end
end

# source://rubyzip//lib/zip/null_input_stream.rb#4
module Zip::NullInputStream
  include ::Zip::NullDecompressor
  include ::ActiveSupport::ToJsonWithActiveSupportEncoder
  include ::Enumerable
  include ::Zip::IOExtras::FakeIO
  include ::Zip::IOExtras::AbstractInputStream
end

# ZipOutputStream is the basic class for writing zip files. It is
# possible to create a ZipOutputStream object directly, passing
# the zip file name to the constructor, but more often than not
# the ZipOutputStream will be obtained from a ZipFile (perhaps using the
# ZipFileSystem interface) object for a particular entry in the zip
# archive.
#
# A ZipOutputStream inherits IOExtras::AbstractOutputStream in order
# to provide an IO-like interface for writing to a single zip
# entry. Beyond methods for mimicking an IO-object it contains
# the method put_next_entry that closes the current entry
# and creates a new.
#
# Please refer to ZipInputStream for example code.
#
# java.util.zip.ZipOutputStream is the original inspiration for this
# class.
#
# source://rubyzip//lib/zip/output_stream.rb#24
class Zip::OutputStream
  include ::Zip::IOExtras::FakeIO
  include ::Zip::IOExtras::AbstractOutputStream
  extend ::Forwardable

  # Opens the indicated zip file. If a file with that name already
  # exists it will be overwritten.
  #
  # @return [OutputStream] a new instance of OutputStream
  #
  # source://rubyzip//lib/zip/output_stream.rb#32
  def initialize(file_name, stream: T.unsafe(nil), encrypter: T.unsafe(nil), suppress_extra_fields: T.unsafe(nil)); end

  # Modeled after IO.<<
  #
  # source://rubyzip//lib/zip/output_stream.rb#199
  def <<(data); end

  # Closes the stream and writes the central directory to the zip file
  #
  # source://rubyzip//lib/zip/output_stream.rb#76
  def close; end

  # Closes the stream and writes the central directory to the zip file
  #
  # source://rubyzip//lib/zip/output_stream.rb#87
  def close_buffer; end

  # source://rubyzip//lib/zip/output_stream.rb#28
  def comment(*args, **_arg1, &block); end

  # source://rubyzip//lib/zip/output_stream.rb#28
  def comment=(*args, **_arg1, &block); end

  # @raise [Error]
  #
  # source://rubyzip//lib/zip/output_stream.rb#120
  def copy_raw_entry(entry); end

  # Closes the current entry and opens a new for writing.
  # +entry+ can be a ZipEntry object or a string.
  #
  # @raise [Error]
  #
  # source://rubyzip//lib/zip/output_stream.rb#100
  def put_next_entry(entry_name, comment = T.unsafe(nil), extra = T.unsafe(nil), compression_method = T.unsafe(nil), level = T.unsafe(nil)); end

  protected

  # source://rubyzip//lib/zip/output_stream.rb#192
  def finish; end

  private

  # source://rubyzip//lib/zip/output_stream.rb#141
  def finalize_current_entry; end

  # source://rubyzip//lib/zip/output_stream.rb#169
  def get_compressor(entry); end

  # source://rubyzip//lib/zip/output_stream.rb#160
  def init_next_entry(entry); end

  # source://rubyzip//lib/zip/output_stream.rb#180
  def update_local_headers; end

  class << self
    # Same as #initialize but if a block is passed the opened
    # stream is passed to the block and closed when the block
    # returns.
    #
    # source://rubyzip//lib/zip/output_stream.rb#55
    def open(file_name, encrypter: T.unsafe(nil), suppress_extra_fields: T.unsafe(nil)); end

    # Same as #open but writes to a filestream instead
    #
    # @yield [zos]
    #
    # source://rubyzip//lib/zip/output_stream.rb#66
    def write_buffer(io = T.unsafe(nil), encrypter: T.unsafe(nil), suppress_extra_fields: T.unsafe(nil)); end
  end
end

# source://rubyzip//lib/zip/pass_thru_compressor.rb#4
class Zip::PassThruCompressor < ::Zip::Compressor
  # @return [PassThruCompressor] a new instance of PassThruCompressor
  #
  # source://rubyzip//lib/zip/pass_thru_compressor.rb#5
  def initialize(output_stream); end

  # source://rubyzip//lib/zip/pass_thru_compressor.rb#12
  def <<(data); end

  # Returns the value of attribute crc.
  #
  # source://rubyzip//lib/zip/pass_thru_compressor.rb#19
  def crc; end

  # Returns the value of attribute size.
  #
  # source://rubyzip//lib/zip/pass_thru_compressor.rb#19
  def size; end
end

# source://rubyzip//lib/zip/pass_thru_decompressor.rb#4
class Zip::PassThruDecompressor < ::Zip::Decompressor
  # @return [PassThruDecompressor] a new instance of PassThruDecompressor
  #
  # source://rubyzip//lib/zip/pass_thru_decompressor.rb#5
  def initialize(*args); end

  # Alias for compatibility. Remove for version 4.
  #
  # @return [Boolean]
  #
  # source://rubyzip//lib/zip/pass_thru_decompressor.rb#26
  def eof; end

  # @return [Boolean]
  #
  # source://rubyzip//lib/zip/pass_thru_decompressor.rb#21
  def eof?; end

  # source://rubyzip//lib/zip/pass_thru_decompressor.rb#10
  def read(length = T.unsafe(nil), outbuf = T.unsafe(nil)); end
end

# :stopdoc:
#
# source://rubyzip//lib/zip/constants.rb#6
Zip::RUNNING_ON_WINDOWS = T.let(T.unsafe(nil), T.untyped)

# source://rubyzip//lib/zip/constants.rb#18
Zip::SPLIT_FILE_SIGNATURE = T.let(T.unsafe(nil), Integer)

# Error raised if a split archive is read. Rubyzip does not support reading
# split archives.
#
# source://rubyzip//lib/zip/errors.rb#114
class Zip::SplitArchiveError < ::Zip::Error
  # The message returned by this error.
  #
  # source://rubyzip//lib/zip/errors.rb#116
  def message; end
end

# source://rubyzip//lib/zip/streamable_directory.rb#4
class Zip::StreamableDirectory < ::Zip::Entry
  # @return [StreamableDirectory] a new instance of StreamableDirectory
  #
  # source://rubyzip//lib/zip/streamable_directory.rb#5
  def initialize(zipfile, entry, src_path = T.unsafe(nil), permission = T.unsafe(nil)); end
end

# source://rubyzip//lib/zip/streamable_stream.rb#4
class Zip::StreamableStream
  # @return [StreamableStream] a new instance of StreamableStream
  #
  # source://rubyzip//lib/zip/streamable_stream.rb#5
  def initialize(entry); end

  # source://rubyzip//lib/zip/streamable_stream.rb#46
  def clean_up; end

  # source://rubyzip//lib/zip/streamable_stream.rb#23
  def get_input_stream; end

  # source://rubyzip//lib/zip/streamable_stream.rb#11
  def get_output_stream; end

  # source://rubyzip//lib/zip/streamable_stream.rb#41
  def write_to_zip_output_stream(output_stream); end
end

# Error raised if there is not enough metadata for the entry to be streamed.
#
# source://rubyzip//lib/zip/errors.rb#122
class Zip::StreamingError < ::Zip::Error
  # Create a new StreamingError with the specified entry.
  #
  # @return [StreamingError] a new instance of StreamingError
  #
  # source://rubyzip//lib/zip/errors.rb#127
  def initialize(entry); end

  # The entry that has caused this error.
  #
  # source://rubyzip//lib/zip/errors.rb#124
  def entry; end

  # The message returned by this error.
  #
  # source://rubyzip//lib/zip/errors.rb#133
  def message; end
end

# source://rubyzip//lib/zip/crypto/traditional_encryption.rb#75
class Zip::TraditionalDecrypter < ::Zip::Decrypter
  include ::Zip::TraditionalEncryption

  # source://rubyzip//lib/zip/crypto/traditional_encryption.rb#89
  def check_integrity!(_io); end

  # source://rubyzip//lib/zip/crypto/traditional_encryption.rb#78
  def decrypt(data); end

  # source://rubyzip//lib/zip/crypto/traditional_encryption.rb#82
  def reset!(header); end

  private

  # source://rubyzip//lib/zip/crypto/traditional_encryption.rb#93
  def decode(num); end
end

# source://rubyzip//lib/zip/crypto/traditional_encryption.rb#41
class Zip::TraditionalEncrypter < ::Zip::Encrypter
  include ::Zip::TraditionalEncryption

  # source://rubyzip//lib/zip/crypto/traditional_encryption.rb#58
  def data_descriptor(crc32, compressed_size, uncompressed_size); end

  # source://rubyzip//lib/zip/crypto/traditional_encryption.rb#54
  def encrypt(data); end

  # source://rubyzip//lib/zip/crypto/traditional_encryption.rb#44
  def header(mtime); end

  # source://rubyzip//lib/zip/crypto/traditional_encryption.rb#62
  def reset!; end

  private

  # source://rubyzip//lib/zip/crypto/traditional_encryption.rb#68
  def encode(num); end
end

# source://rubyzip//lib/zip/crypto/traditional_encryption.rb#4
module Zip::TraditionalEncryption
  # source://rubyzip//lib/zip/crypto/traditional_encryption.rb#5
  def initialize(password); end

  # source://rubyzip//lib/zip/crypto/traditional_encryption.rb#14
  def gp_flags; end

  # source://rubyzip//lib/zip/crypto/traditional_encryption.rb#10
  def header_bytesize; end

  protected

  # source://rubyzip//lib/zip/crypto/traditional_encryption.rb#35
  def decrypt_byte; end

  # source://rubyzip//lib/zip/crypto/traditional_encryption.rb#20
  def reset_keys!; end

  # source://rubyzip//lib/zip/crypto/traditional_encryption.rb#29
  def update_keys(num); end
end

# The version of the Rubyzip library.
#
# source://rubyzip//lib/zip/version.rb#5
Zip::VERSION = T.let(T.unsafe(nil), String)

# this library's version
#
# source://rubyzip//lib/zip/constants.rb#14
Zip::VERSION_MADE_BY = T.let(T.unsafe(nil), Integer)

# source://rubyzip//lib/zip/constants.rb#15
Zip::VERSION_NEEDED_TO_EXTRACT = T.let(T.unsafe(nil), Integer)

# source://rubyzip//lib/zip/constants.rb#16
Zip::VERSION_NEEDED_TO_EXTRACT_ZIP64 = T.let(T.unsafe(nil), Integer)

# Remove this when JRuby#3962 is fixed.
#
# source://rubyzip//lib/zip.rb#67
Zip::ZLIB_FLUSHING_STRATEGY = T.let(T.unsafe(nil), Integer)
