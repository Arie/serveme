# This file is autogenerated. Do not edit it by hand. Regenerate it with:
#   srb rbi gems

# typed: true
#
# If you would like to make changes to this file, great! Please create the gem's shim here:
#
#   https://github.com/sorbet/sorbet-typed/new/master?filename=lib/sass/all/sass.rbi
#
# sass-3.7.4

module Sass
  def self.compile(contents, options = nil); end
  def self.compile_file(filename, *args); end
  def self.load_paths; end
  def self.logger; end
  def self.logger=(l); end
  def self.tests_running; end
  def self.tests_running=(arg0); end
  extend Sass::Features
  extend Sass::Version
end
module Sass::Util
  def abstract(obj); end
  def ap_geq?(version); end
  def ap_geq_3?; end
  def array_minus(minuend, subtrahend); end
  def atomic_create_and_write_file(filename, perms = nil); end
  def av_template_class(name); end
  def caller_info(entry = nil); end
  def check_range(name, range, value, unit = nil); end
  def check_sass_encoding(str); end
  def cleanpath(path); end
  def deprecated(obj, message = nil); end
  def destructure(val); end
  def downcase(string); end
  def encode_vlq(value); end
  def escaped_char(escape); end
  def extract!(array); end
  def extract_values(arr); end
  def file_uri_from_path(path); end
  def find_encoding_error(str); end
  def flatten_vertically(arrs); end
  def glob(path); end
  def inject_values(str, values); end
  def inspect_obj(obj); end
  def intersperse(enum, val); end
  def ironruby?; end
  def jruby?; end
  def jruby_version; end
  def json_escape_string(s); end
  def json_value_of(v); end
  def lcs(x, y, &block); end
  def lcs_backtrace(c, x, y, i, j, &block); end
  def lcs_table(x, y); end
  def map_hash(hash); end
  def map_keys(hash); end
  def map_vals(hash); end
  def max(val1, val2); end
  def merge_adjacent_strings(arr); end
  def min(val1, val2); end
  def normalize_ident_escapes(ident, start: nil); end
  def pathname(path); end
  def paths(arrs); end
  def powerset(arr); end
  def rails_env; end
  def rails_root; end
  def rbx?; end
  def realpath(path); end
  def relative_path_from(path, from); end
  def replace_subseq(arr, subseq, replacement); end
  def restrict(value, range); end
  def retry_on_windows; end
  def round(value); end
  def rstrip_except_escapes(string); end
  def ruby2_4?; end
  def sass_warn(msg); end
  def scope(file); end
  def self.abstract(obj); end
  def self.ap_geq?(version); end
  def self.ap_geq_3?; end
  def self.array_minus(minuend, subtrahend); end
  def self.atomic_create_and_write_file(filename, perms = nil); end
  def self.av_template_class(name); end
  def self.caller_info(entry = nil); end
  def self.check_range(name, range, value, unit = nil); end
  def self.check_sass_encoding(str); end
  def self.cleanpath(path); end
  def self.deprecated(obj, message = nil); end
  def self.destructure(val); end
  def self.downcase(string); end
  def self.encode_vlq(value); end
  def self.escaped_char(escape); end
  def self.extract!(array); end
  def self.extract_values(arr); end
  def self.file_uri_from_path(path); end
  def self.flatten_vertically(arrs); end
  def self.glob(path); end
  def self.inject_values(str, values); end
  def self.inspect_obj(obj); end
  def self.intersperse(enum, val); end
  def self.ironruby?; end
  def self.jruby?; end
  def self.jruby_version; end
  def self.json_escape_string(s); end
  def self.json_value_of(v); end
  def self.lcs(x, y, &block); end
  def self.map_hash(hash); end
  def self.map_keys(hash); end
  def self.map_vals(hash); end
  def self.max(val1, val2); end
  def self.merge_adjacent_strings(arr); end
  def self.min(val1, val2); end
  def self.normalize_ident_escapes(ident, start: nil); end
  def self.pathname(path); end
  def self.paths(arrs); end
  def self.powerset(arr); end
  def self.rails_env; end
  def self.rails_root; end
  def self.rbx?; end
  def self.realpath(path); end
  def self.relative_path_from(path, from); end
  def self.replace_subseq(arr, subseq, replacement); end
  def self.restrict(value, range); end
  def self.retry_on_windows; end
  def self.round(value); end
  def self.rstrip_except_escapes(string); end
  def self.ruby2_4?; end
  def self.sass_warn(msg); end
  def self.scope(file); end
  def self.silence_sass_warnings; end
  def self.slice_by(enum); end
  def self.sourcemap_name(css); end
  def self.strip_except_escapes(string); end
  def self.strip_string_array(arr); end
  def self.subsequence?(seq1, seq2); end
  def self.substitute(ary, from, to); end
  def self.undefined_conversion_error_char(e); end
  def self.upcase(string); end
  def self.version_geq(v1, v2); end
  def self.version_gt(v1, v2); end
  def self.windows?; end
  def self.with_extracted_values(arr); end
  def silence_sass_warnings; end
  def slice_by(enum); end
  def sourcemap_name(css); end
  def strip_except_escapes(string); end
  def strip_string_array(arr); end
  def subsequence?(seq1, seq2); end
  def substitute(ary, from, to); end
  def undefined_conversion_error_char(e); end
  def upcase(string); end
  def version_geq(v1, v2); end
  def version_gt(v1, v2); end
  def windows?; end
  def with_extracted_values(arr); end
  extend Sass::Util
end
class Sass::Util::SubsetMap
  def [](set); end
  def []=(set, value); end
  def each_value; end
  def empty?; end
  def get(set); end
  def initialize; end
end
class Sass::Util::MultibyteStringScanner < StringScanner
  def _forward(str); end
  def _match(str); end
  def _matched(res); end
  def _size(str); end
  def byte_matched_size; end
  def byte_pos; end
  def check(pattern); end
  def check_until(pattern); end
  def clear; end
  def get_byte; end
  def getbyte; end
  def getch; end
  def initialize(str); end
  def match?(pattern); end
  def matched_size; end
  def peek(len); end
  def peep(len); end
  def pointer; end
  def pos; end
  def pos=(n); end
  def reset; end
  def rest_size; end
  def scan(pattern); end
  def scan_full(pattern, advance_pointer_p, return_string_p); end
  def scan_until(pattern); end
  def search_full(pattern, advance_pointer_p, return_string_p); end
  def self.new(str); end
  def skip(pattern); end
  def skip_until(pattern); end
  def string=(str); end
  def terminate; end
  def unscan; end
end
class Sass::Util::NormalizedMap
  def [](k); end
  def []=(k, v); end
  def as_stored; end
  def delete(k); end
  def denormalize(key); end
  def dup; end
  def each; end
  def empty?; end
  def has_key?(k); end
  def initialize(map = nil); end
  def keys; end
  def map; end
  def method_missing(method, *args, &block); end
  def normalize(key); end
  def respond_to_missing?(method, include_private = nil); end
  def size; end
  def sort_by; end
  def to_a; end
  def to_hash; end
  def update(map); end
  def values; end
end
class Sass::Util::StaticConditionalContext
  def initialize(set); end
  def method_missing(name, *args); end
end
module Sass::Version
  def revision_number; end
  def version; end
  def version_date; end
end
module Sass::Logger
end
module Sass::Logger::LogLevel
  def self.included(base); end
end
module Sass::Logger::LogLevel::ClassMethods
  def define_logger(name, options = nil); end
  def inherited(subclass); end
  def log_level(name, options = nil); end
  def log_level?(level, min_level); end
  def log_levels; end
  def log_levels=(arg0); end
end
class Sass::Logger::Base
  def _log(level, message); end
  def capture; end
  def debug(message); end
  def disabled; end
  def disabled=(arg0); end
  def error(message); end
  def info(message); end
  def initialize(log_level = nil, io = nil); end
  def io; end
  def io=(arg0); end
  def log(level, message); end
  def log_level; end
  def log_level=(arg0); end
  def logging_level?(level); end
  def trace(message); end
  def warn(message); end
  extend Sass::Logger::LogLevel::ClassMethods
  include Sass::Logger::LogLevel
end
class Sass::Logger::Delayed < Sass::Logger::Base
  def _log(level, message); end
  def flush; end
  def initialize(inner); end
  def self.install!; end
  def uninstall!; end
end
module Sass::CacheStores
end
class Sass::CacheStores::Base
  def _retrieve(key, version, sha); end
  def _store(key, version, sha, contents); end
  def key(sass_dirname, sass_basename); end
  def retrieve(key, sha); end
  def store(key, sha, root); end
end
class Sass::CacheStores::Filesystem < Sass::CacheStores::Base
  def _retrieve(key, version, sha); end
  def _store(key, version, sha, contents); end
  def cache_location; end
  def cache_location=(arg0); end
  def initialize(cache_location); end
  def path_to(key); end
end
class Sass::CacheStores::Memory < Sass::CacheStores::Base
  def _dump(depth); end
  def initialize; end
  def reset!; end
  def retrieve(key, sha); end
  def self._load(repr); end
  def store(key, sha, obj); end
end
class Sass::CacheStores::Chain < Sass::CacheStores::Base
  def initialize(*caches); end
  def retrieve(key, sha); end
  def store(key, sha, obj); end
end
class Sass::Deprecation
  def initialize; end
  def self.allow_double_warnings; end
  def warn(filename, line, column_or_message, message = nil); end
end
module Sass::Source
end
class Sass::Source::Position
  def after(str); end
  def initialize(line, offset); end
  def inspect; end
  def line; end
  def line=(arg0); end
  def offset; end
  def offset=(arg0); end
end
class Sass::Source::Range
  def end_pos; end
  def end_pos=(arg0); end
  def file; end
  def file=(arg0); end
  def importer; end
  def importer=(arg0); end
  def initialize(start_pos, end_pos, file, importer = nil); end
  def inspect; end
  def start_pos; end
  def start_pos=(arg0); end
end
class Sass::Source::Map
  def add(input, output); end
  def data; end
  def initialize; end
  def shift_output_lines(delta); end
  def shift_output_offsets(delta); end
  def to_json(options); end
  def write_json_field(out, name, value, is_first = nil); end
end
class Anonymous_Struct_89 < Struct
  def input; end
  def input=(_); end
  def output; end
  def output=(_); end
  def self.[](*arg0); end
  def self.inspect; end
  def self.keyword_init?; end
  def self.members; end
  def self.new(*arg0); end
end
class Sass::Source::Map::Mapping < Anonymous_Struct_89
  def inspect; end
end
module Sass::Tree
end
class Sass::Tree::Node
  def <<(child); end
  def ==(other); end
  def balance(*args); end
  def bubbles?; end
  def children; end
  def children=(children); end
  def css; end
  def css_with_sourcemap; end
  def deep_copy; end
  def each; end
  def filename; end
  def filename=(arg0); end
  def has_children; end
  def has_children=(arg0); end
  def initialize; end
  def inspect; end
  def invisible?; end
  def line; end
  def line=(arg0); end
  def options; end
  def options=(options); end
  def self.inherited(base); end
  def source_range; end
  def source_range=(arg0); end
  def style; end
  def to_sass(options = nil); end
  def to_scss(options = nil); end
  include Enumerable
end
class Sass::Tree::RootNode < Sass::Tree::Node
  def css_tree; end
  def initialize(template); end
  def render; end
  def render_with_sourcemap; end
  def self.invalid_child_method_name; end
  def self.invalid_parent_method_name; end
  def self.node_name; end
  def self.visit_method; end
  def template; end
end
class Sass::Tree::RuleNode < Sass::Tree::Node
  def ==(other); end
  def add_rules(node); end
  def continued?; end
  def debug_info; end
  def filename=(filename); end
  def group_end; end
  def group_end=(arg0); end
  def initialize(rule, selector_source_range = nil); end
  def invisible?; end
  def line=(line); end
  def parsed_rules; end
  def parsed_rules=(arg0); end
  def resolved_rules; end
  def resolved_rules=(arg0); end
  def rule; end
  def rule=(arg0); end
  def selector_source_range; end
  def selector_source_range=(arg0); end
  def self.invalid_child_method_name; end
  def self.invalid_parent_method_name; end
  def self.node_name; end
  def self.visit_method; end
  def stack_trace; end
  def stack_trace=(arg0); end
  def tabs; end
  def tabs=(arg0); end
  def try_to_parse_non_interpolated_rules; end
end
class Sass::Tree::CommentNode < Sass::Tree::Node
  def ==(other); end
  def initialize(value, type); end
  def invisible?; end
  def lines; end
  def normalize_indentation(str); end
  def resolved_value; end
  def resolved_value=(arg0); end
  def self.invalid_child_method_name; end
  def self.invalid_parent_method_name; end
  def self.node_name; end
  def self.visit_method; end
  def type; end
  def type=(arg0); end
  def value; end
  def value=(arg0); end
end
class Sass::Tree::PropNode < Sass::Tree::Node
  def ==(other); end
  def check!; end
  def custom_property?; end
  def declaration(opts = nil, fmt = nil); end
  def initialize(name, value, prop_syntax); end
  def invisible?; end
  def name; end
  def name=(arg0); end
  def name_source_range; end
  def name_source_range=(arg0); end
  def pseudo_class_selector_message; end
  def resolved_name; end
  def resolved_name=(arg0); end
  def resolved_value; end
  def resolved_value=(arg0); end
  def self.invalid_child_method_name; end
  def self.invalid_parent_method_name; end
  def self.node_name; end
  def self.visit_method; end
  def tabs; end
  def tabs=(arg0); end
  def value; end
  def value=(arg0); end
  def value_needs_parens?; end
  def value_source_range; end
  def value_source_range=(arg0); end
end
class Sass::Tree::DirectiveNode < Sass::Tree::Node
  def bubbles?; end
  def group_end; end
  def group_end=(arg0); end
  def initialize(value); end
  def name; end
  def normalized_name; end
  def resolved_value; end
  def resolved_value=(arg0); end
  def self.invalid_child_method_name; end
  def self.invalid_parent_method_name; end
  def self.node_name; end
  def self.resolved(value); end
  def self.visit_method; end
  def tabs; end
  def tabs=(arg0); end
  def value; end
  def value=(arg0); end
end
class Sass::Tree::MediaNode < Sass::Tree::DirectiveNode
  def initialize(query); end
  def invisible?; end
  def name; end
  def query; end
  def query=(arg0); end
  def resolved_query; end
  def resolved_query=(arg0); end
  def resolved_value; end
  def self.invalid_child_method_name; end
  def self.invalid_parent_method_name; end
  def self.node_name; end
  def self.visit_method; end
  def value; end
end
class Sass::Tree::SupportsNode < Sass::Tree::DirectiveNode
  def condition; end
  def condition=(arg0); end
  def initialize(name, condition); end
  def invisible?; end
  def name; end
  def name=(arg0); end
  def resolved_value; end
  def self.invalid_child_method_name; end
  def self.invalid_parent_method_name; end
  def self.node_name; end
  def self.visit_method; end
  def value; end
end
class Sass::Tree::CssImportNode < Sass::Tree::DirectiveNode
  def initialize(uri, query = nil, supports_condition = nil); end
  def query; end
  def query=(arg0); end
  def resolved_query; end
  def resolved_query=(arg0); end
  def resolved_uri; end
  def resolved_uri=(arg0); end
  def resolved_value; end
  def self.invalid_child_method_name; end
  def self.invalid_parent_method_name; end
  def self.node_name; end
  def self.resolved(uri); end
  def self.visit_method; end
  def supports_condition; end
  def supports_condition=(arg0); end
  def uri; end
  def uri=(arg0); end
  def value; end
end
class Sass::Tree::VariableNode < Sass::Tree::Node
  def expr; end
  def expr=(arg0); end
  def global; end
  def guarded; end
  def initialize(name, expr, guarded, global); end
  def name; end
  def self.invalid_child_method_name; end
  def self.invalid_parent_method_name; end
  def self.node_name; end
  def self.visit_method; end
end
class Sass::Tree::MixinDefNode < Sass::Tree::Node
  def args; end
  def args=(arg0); end
  def has_content; end
  def has_content=(arg0); end
  def initialize(name, args, splat); end
  def name; end
  def self.invalid_child_method_name; end
  def self.invalid_parent_method_name; end
  def self.node_name; end
  def self.visit_method; end
  def splat; end
  def splat=(arg0); end
end
class Sass::Tree::MixinNode < Sass::Tree::Node
  def args; end
  def args=(arg0); end
  def initialize(name, args, keywords, splat, kwarg_splat); end
  def keywords; end
  def keywords=(arg0); end
  def kwarg_splat; end
  def kwarg_splat=(arg0); end
  def name; end
  def self.invalid_child_method_name; end
  def self.invalid_parent_method_name; end
  def self.node_name; end
  def self.visit_method; end
  def splat; end
  def splat=(arg0); end
end
class Sass::Tree::TraceNode < Sass::Tree::Node
  def initialize(name); end
  def name; end
  def self.from_node(name, node); end
  def self.invalid_child_method_name; end
  def self.invalid_parent_method_name; end
  def self.node_name; end
  def self.visit_method; end
end
class Sass::Tree::ContentNode < Sass::Tree::Node
  def self.invalid_child_method_name; end
  def self.invalid_parent_method_name; end
  def self.node_name; end
  def self.visit_method; end
end
class Sass::Tree::FunctionNode < Sass::Tree::Node
  def args; end
  def args=(arg0); end
  def initialize(name, args, splat); end
  def name; end
  def normalized_name; end
  def self.invalid_child_method_name; end
  def self.invalid_parent_method_name; end
  def self.node_name; end
  def self.visit_method; end
  def splat; end
  def splat=(arg0); end
end
class Sass::Tree::ReturnNode < Sass::Tree::Node
  def expr; end
  def expr=(arg0); end
  def initialize(expr); end
  def self.invalid_child_method_name; end
  def self.invalid_parent_method_name; end
  def self.node_name; end
  def self.visit_method; end
end
class Sass::Tree::ExtendNode < Sass::Tree::Node
  def initialize(selector, optional, selector_source_range); end
  def optional?; end
  def resolved_selector; end
  def resolved_selector=(arg0); end
  def selector; end
  def selector=(arg0); end
  def selector_source_range; end
  def selector_source_range=(arg0); end
  def self.invalid_child_method_name; end
  def self.invalid_parent_method_name; end
  def self.node_name; end
  def self.visit_method; end
end
class Sass::Tree::IfNode < Sass::Tree::Node
  def _dump(f); end
  def add_else(node); end
  def else; end
  def else=(arg0); end
  def expr; end
  def expr=(arg0); end
  def initialize(expr); end
  def self._load(data); end
  def self.invalid_child_method_name; end
  def self.invalid_parent_method_name; end
  def self.node_name; end
  def self.visit_method; end
end
class Sass::Tree::WhileNode < Sass::Tree::Node
  def expr; end
  def expr=(arg0); end
  def initialize(expr); end
  def self.invalid_child_method_name; end
  def self.invalid_parent_method_name; end
  def self.node_name; end
  def self.visit_method; end
end
class Sass::Tree::ForNode < Sass::Tree::Node
  def exclusive; end
  def from; end
  def from=(arg0); end
  def initialize(var, from, to, exclusive); end
  def self.invalid_child_method_name; end
  def self.invalid_parent_method_name; end
  def self.node_name; end
  def self.visit_method; end
  def to; end
  def to=(arg0); end
  def var; end
end
class Sass::Tree::EachNode < Sass::Tree::Node
  def initialize(vars, list); end
  def list; end
  def list=(arg0); end
  def self.invalid_child_method_name; end
  def self.invalid_parent_method_name; end
  def self.node_name; end
  def self.visit_method; end
  def vars; end
end
class Sass::Tree::DebugNode < Sass::Tree::Node
  def expr; end
  def expr=(arg0); end
  def initialize(expr); end
  def self.invalid_child_method_name; end
  def self.invalid_parent_method_name; end
  def self.node_name; end
  def self.visit_method; end
end
class Sass::Tree::WarnNode < Sass::Tree::Node
  def expr; end
  def expr=(arg0); end
  def initialize(expr); end
  def self.invalid_child_method_name; end
  def self.invalid_parent_method_name; end
  def self.node_name; end
  def self.visit_method; end
end
class Sass::Tree::ImportNode < Sass::Tree::RootNode
  def css_import?; end
  def import; end
  def imported_file; end
  def imported_file=(arg0); end
  def imported_filename; end
  def initialize(imported_filename); end
  def invisible?; end
  def options_for_importer; end
  def self.invalid_child_method_name; end
  def self.invalid_parent_method_name; end
  def self.node_name; end
  def self.visit_method; end
end
class Sass::Tree::CharsetNode < Sass::Tree::Node
  def initialize(name); end
  def invisible?; end
  def name; end
  def name=(arg0); end
  def self.invalid_child_method_name; end
  def self.invalid_parent_method_name; end
  def self.node_name; end
  def self.visit_method; end
end
class Sass::Tree::AtRootNode < Sass::Tree::Node
  def bubbles?; end
  def exclude?(directive); end
  def exclude_node?(node); end
  def group_end; end
  def group_end=(arg0); end
  def initialize(query = nil); end
  def query; end
  def query=(arg0); end
  def resolved_type; end
  def resolved_type=(arg0); end
  def resolved_value; end
  def resolved_value=(arg0); end
  def self.invalid_child_method_name; end
  def self.invalid_parent_method_name; end
  def self.node_name; end
  def self.visit_method; end
  def tabs; end
  def tabs=(arg0); end
end
class Sass::Tree::KeyframeRuleNode < Sass::Tree::Node
  def initialize(resolved_value); end
  def resolved_value; end
  def resolved_value=(arg0); end
  def self.invalid_child_method_name; end
  def self.invalid_parent_method_name; end
  def self.node_name; end
  def self.visit_method; end
end
class Sass::Tree::ErrorNode < Sass::Tree::Node
  def expr; end
  def expr=(arg0); end
  def initialize(expr); end
  def self.invalid_child_method_name; end
  def self.invalid_parent_method_name; end
  def self.node_name; end
  def self.visit_method; end
end
module Sass::Tree::Visitors
end
class Sass::Tree::Visitors::Base
  def self.node_name(node); end
  def self.visit(root); end
  def visit(node); end
  def visit_children(parent); end
  def visit_if(node); end
end
class Sass::Tree::Visitors::Perform < Sass::Tree::Visitors::Base
  def handle_import_loop!(node); end
  def initialize(env); end
  def run_interp(text); end
  def run_interp_no_strip(text); end
  def self.arg_hash(map); end
  def self.perform_arguments(callable, args, splat, environment); end
  def self.perform_splat(splat, performed_keywords, kwarg_splat, environment); end
  def self.visit(root, environment = nil); end
  def visit(node); end
  def visit_atroot(node); end
  def visit_children(parent); end
  def visit_comment(node); end
  def visit_content(node); end
  def visit_cssimport(node); end
  def visit_debug(node); end
  def visit_directive(node); end
  def visit_each(node); end
  def visit_error(node); end
  def visit_extend(node); end
  def visit_for(node); end
  def visit_function(node); end
  def visit_if(node); end
  def visit_import(node); end
  def visit_media(node); end
  def visit_mixin(node); end
  def visit_mixindef(node); end
  def visit_prop(node); end
  def visit_return(node); end
  def visit_root(node); end
  def visit_rule(node); end
  def visit_supports(node); end
  def visit_variable(node); end
  def visit_warn(node); end
  def visit_while(node); end
  def with_environment(env); end
end
class Sass::Tree::Visitors::Cssize < Sass::Tree::Visitors::Base
  def bubblable?(node); end
  def bubble(node); end
  def debubble(children, parent = nil); end
  def initialize; end
  def parent; end
  def self.visit(root); end
  def visit(node); end
  def visit_atroot(node); end
  def visit_children(parent); end
  def visit_children_without_parent(node); end
  def visit_directive(node); end
  def visit_extend(node); end
  def visit_import(node); end
  def visit_keyframerule(node); end
  def visit_media(node); end
  def visit_prop(node); end
  def visit_root(node); end
  def visit_rule(node); end
  def visit_supports(node); end
  def visit_trace(node); end
  def with_parent(parent); end
end
class Sass::Tree::Visitors::Cssize::Extend < Struct
  def directives; end
  def directives=(_); end
  def extender; end
  def extender=(_); end
  def node; end
  def node=(_); end
  def self.[](*arg0); end
  def self.inspect; end
  def self.keyword_init?; end
  def self.members; end
  def self.new(*arg0); end
  def success; end
  def success=(_); end
  def target; end
  def target=(_); end
end
class Sass::Tree::Visitors::Cssize::Bubble
  def bubbles?; end
  def group_end; end
  def group_end=(arg0); end
  def initialize(node); end
  def inspect; end
  def node; end
  def node=(arg0); end
  def tabs; end
  def tabs=(arg0); end
end
class Sass::Tree::Visitors::Extend < Sass::Tree::Visitors::Base
  def initialize(extends); end
  def self.check_extends_fired!(extends); end
  def self.visit(root, extends); end
  def visit(node); end
  def visit_children(parent); end
  def visit_rule(node); end
end
class Sass::Tree::Visitors::Convert < Sass::Tree::Visitors::Base
  def dasherize(s); end
  def initialize(options, format); end
  def interp_to_src(interp); end
  def query_interp_to_src(interp); end
  def selector_to_sass(sel); end
  def selector_to_scss(sel); end
  def selector_to_src(sel); end
  def self.visit(root, options, format); end
  def semi; end
  def tab_str; end
  def visit_atroot(node); end
  def visit_charset(node); end
  def visit_children(parent); end
  def visit_comment(node); end
  def visit_content(node); end
  def visit_cssimport(node); end
  def visit_debug(node); end
  def visit_directive(node); end
  def visit_each(node); end
  def visit_error(node); end
  def visit_extend(node); end
  def visit_for(node); end
  def visit_function(node); end
  def visit_if(node); end
  def visit_import(node); end
  def visit_keyframerule(node); end
  def visit_media(node); end
  def visit_mixin(node); end
  def visit_mixindef(node); end
  def visit_prop(node); end
  def visit_return(node); end
  def visit_root(node); end
  def visit_rule(node); end
  def visit_rule_level(nodes); end
  def visit_supports(node); end
  def visit_variable(node); end
  def visit_warn(node); end
  def visit_while(node); end
end
class Sass::Tree::Visitors::ToCss < Sass::Tree::Visitors::Base
  def debug_info_rule(debug_info, options); end
  def erase!(chars); end
  def for_node(node, attr_prefix = nil); end
  def format_custom_property_value(node); end
  def initialize(build_source_mapping = nil); end
  def lstrip; end
  def output(s); end
  def prepend!(prefix); end
  def rstrip!; end
  def source_mapping; end
  def trailing_semicolon?; end
  def visit(node); end
  def visit_charset(node); end
  def visit_comment(node); end
  def visit_cssimport(node); end
  def visit_directive(node); end
  def visit_keyframerule(node); end
  def visit_media(node); end
  def visit_prop(node); end
  def visit_root(node); end
  def visit_rule(node); end
  def visit_supports(node); end
  def with_tabs(tabs); end
end
class Sass::Tree::Visitors::DeepCopy < Sass::Tree::Visitors::Base
  def visit(node); end
  def visit_children(parent); end
  def visit_debug(node); end
  def visit_directive(node); end
  def visit_each(node); end
  def visit_error(node); end
  def visit_extend(node); end
  def visit_for(node); end
  def visit_function(node); end
  def visit_if(node); end
  def visit_media(node); end
  def visit_mixin(node); end
  def visit_mixindef(node); end
  def visit_prop(node); end
  def visit_return(node); end
  def visit_rule(node); end
  def visit_supports(node); end
  def visit_variable(node); end
  def visit_warn(node); end
  def visit_while(node); end
end
class Sass::Tree::Visitors::SetOptions < Sass::Tree::Visitors::Base
  def initialize(options); end
  def self.visit(root, options); end
  def visit(node); end
  def visit_comment(node); end
  def visit_cssimport(node); end
  def visit_debug(node); end
  def visit_directive(node); end
  def visit_each(node); end
  def visit_error(node); end
  def visit_extend(node); end
  def visit_for(node); end
  def visit_function(node); end
  def visit_if(node); end
  def visit_import(node); end
  def visit_media(node); end
  def visit_mixin(node); end
  def visit_mixindef(node); end
  def visit_prop(node); end
  def visit_return(node); end
  def visit_rule(node); end
  def visit_supports(node); end
  def visit_variable(node); end
  def visit_warn(node); end
  def visit_while(node); end
end
class Sass::Tree::Visitors::CheckNesting < Sass::Tree::Visitors::Base
  def initialize; end
  def invalid_charset_parent?(parent, child); end
  def invalid_content_parent?(parent, child); end
  def invalid_extend_parent?(parent, child); end
  def invalid_function_child?(parent, child); end
  def invalid_function_parent?(parent, child); end
  def invalid_import_parent?(parent, child); end
  def invalid_mixindef_parent?(parent, child); end
  def invalid_prop_child?(parent, child); end
  def invalid_prop_parent?(parent, child); end
  def invalid_return_parent?(parent, child); end
  def is_any_of?(val, classes); end
  def transparent_parent?(parent, grandparent); end
  def try_send(method, *args); end
  def visit(node); end
  def visit_children(parent); end
  def visit_import(node); end
  def visit_mixindef(node); end
  def visit_root(node); end
end
module Sass::Selector
end
class Sass::Selector::Simple
  def ==(other); end
  def eql?(other); end
  def equality_key; end
  def filename; end
  def filename=(arg0); end
  def hash; end
  def inspect; end
  def line; end
  def line=(arg0); end
  def to_s(opts = nil); end
  def unify(sels); end
  def unify_namespaces(ns1, ns2); end
  def unique?; end
end
class Sass::Selector::AbstractSequence
  def ==(other); end
  def _specificity(arr); end
  def eql?(other); end
  def filename; end
  def filename=(filename); end
  def hash; end
  def invisible?; end
  def line; end
  def line=(line); end
  def specificity; end
  def to_s(opts = nil); end
end
class Sass::Selector::CommaSequence < Sass::Selector::AbstractSequence
  def _eql?(other); end
  def _hash; end
  def contains_parent_ref?; end
  def do_extend(extends, parent_directives = nil, replace = nil, seen = nil, original = nil); end
  def initialize(seqs); end
  def inspect; end
  def members; end
  def populate_extends(extends, extendee, extend_node = nil, parent_directives = nil, allow_compound_target = nil); end
  def resolve_parent_refs(super_cseq, implicit_parent = nil); end
  def superselector?(cseq); end
  def to_s(opts = nil); end
  def to_sass_script; end
  def unify(other); end
end
class Sass::Selector::Pseudo < Sass::Selector::Simple
  def arg; end
  def initialize(syntactic_type, name, arg, selector); end
  def invisible?; end
  def name; end
  def normalized_name; end
  def selector; end
  def specificity; end
  def superselector?(their_sseq, parents = nil); end
  def syntactic_type; end
  def to_s(opts = nil); end
  def type; end
  def unify(sels); end
  def unique?; end
  def with_selector(new_selector); end
end
class Sass::Selector::Sequence < Sass::Selector::AbstractSequence
  def _eql?(other); end
  def _hash; end
  def _sources(seq); end
  def _superselector?(seq1, seq2); end
  def add_sources!(sources); end
  def chunks(seq1, seq2); end
  def contains_parent_ref?; end
  def do_extend(extends, parent_directives, replace, seen, original); end
  def extended_not_expanded_to_s(extended_not_expanded); end
  def filename=(filename); end
  def group_selectors(seq); end
  def has_root?(sseq); end
  def initialize(seqs_and_ops); end
  def inspect; end
  def line=(line); end
  def members; end
  def merge_final_ops(seq1, seq2, res = nil); end
  def merge_initial_ops(seq1, seq2); end
  def must_unify?(seq1, seq2); end
  def parent_superselector?(seq1, seq2); end
  def path_has_two_subjects?(path); end
  def resolve_parent_refs(super_cseq, implicit_parent); end
  def subjectless; end
  def subweave(seq1, seq2); end
  def superselector?(seq); end
  def to_s(opts = nil); end
  def trim(seqses); end
  def unify(other); end
  def weave(path); end
end
class Sass::Selector::SimpleSequence < Sass::Selector::AbstractSequence
  def _eql?(other); end
  def _hash; end
  def base; end
  def check_directives_match!(extend, parent_directives); end
  def do_extend(extends, parent_directives, replace, seen); end
  def initialize(selectors, subject, source_range = nil); end
  def inspect; end
  def members; end
  def members=(arg0); end
  def pseudo_elements; end
  def resolve_parent_refs(super_cseq); end
  def rest; end
  def selector_pseudo_classes; end
  def source_range; end
  def source_range=(arg0); end
  def sources; end
  def sources=(arg0); end
  def subject=(arg0); end
  def subject?; end
  def superselector?(their_sseq, parents = nil); end
  def to_s(opts = nil); end
  def unify(other); end
  def with_more_sources(sources); end
end
class Sass::Selector::Parent < Sass::Selector::Simple
  def initialize(suffix = nil); end
  def suffix; end
  def to_s(opts = nil); end
  def unify(sels); end
end
class Sass::Selector::Class < Sass::Selector::Simple
  def initialize(name); end
  def name; end
  def specificity; end
  def to_s(opts = nil); end
end
class Sass::Selector::Id < Sass::Selector::Simple
  def initialize(name); end
  def name; end
  def specificity; end
  def to_s(opts = nil); end
  def unify(sels); end
  def unique?; end
end
class Sass::Selector::Placeholder < Sass::Selector::Simple
  def initialize(name); end
  def name; end
  def specificity; end
  def to_s(opts = nil); end
end
class Sass::Selector::Universal < Sass::Selector::Simple
  def initialize(namespace); end
  def namespace; end
  def specificity; end
  def to_s(opts = nil); end
  def unify(sels); end
end
class Sass::Selector::Element < Sass::Selector::Simple
  def initialize(name, namespace); end
  def name; end
  def namespace; end
  def specificity; end
  def to_s(opts = nil); end
  def unify(sels); end
end
class Sass::Selector::Attribute < Sass::Selector::Simple
  def flags; end
  def initialize(name, namespace, operator, value, flags); end
  def name; end
  def namespace; end
  def operator; end
  def specificity; end
  def to_s(opts = nil); end
  def value; end
end
class Sass::BaseEnvironment
  def _function(name); end
  def _mixin(name); end
  def _var(name); end
  def caller; end
  def caller=(arg0); end
  def content; end
  def content=(arg0); end
  def function(name); end
  def global?; end
  def global_env; end
  def initialize(parent = nil, options = nil); end
  def is_function_global?(name); end
  def is_mixin_global?(name); end
  def is_var_global?(name); end
  def mixin(name); end
  def options; end
  def selector; end
  def selector=(arg0); end
  def self.inherited_hash_accessor(name); end
  def self.inherited_hash_reader(name); end
  def self.inherited_hash_writer(name); end
  def stack; end
  def var(name); end
end
class Sass::Environment < Sass::BaseEnvironment
  def parent; end
  def set_function(name, value); end
  def set_global_function(name, value); end
  def set_global_mixin(name, value); end
  def set_global_var(name, value); end
  def set_local_function(name, value); end
  def set_local_mixin(name, value); end
  def set_local_var(name, value); end
  def set_mixin(name, value); end
  def set_var(name, value); end
  def try_set_function(name, value); end
  def try_set_mixin(name, value); end
  def try_set_var(name, value); end
end
class Sass::ReadOnlyEnvironment < Sass::BaseEnvironment
  def caller; end
  def content; end
  def initialize(parent = nil, options = nil); end
end
class Sass::SemiGlobalEnvironment < Sass::Environment
  def try_set_var(name, value); end
end
module Sass::SCSS
end
module Sass::SCSS::RX
  def self.escape_char(c); end
  def self.escape_ident(str); end
  def self.quote(str, flags = nil); end
end
module Sass::Script::Value
end
module Sass::Script::Value::Helpers
  def bool(value); end
  def calc?(literal); end
  def hex_color(value, alpha = nil); end
  def hsl_color(hue, saturation, lightness, alpha = nil); end
  def identifier(str); end
  def list(*elements, separator: nil, bracketed: nil); end
  def map(hash); end
  def normalize_selector(value, name); end
  def null; end
  def number(number, unit_string = nil); end
  def parse_complex_selector(value, name = nil, allow_parent_ref = nil); end
  def parse_compound_selector(value, name = nil, allow_parent_ref = nil); end
  def parse_selector(value, name = nil, allow_parent_ref = nil); end
  def parse_unit_string(unit_string); end
  def quoted_string(str); end
  def rgb_color(red, green, blue, alpha = nil); end
  def selector_to_str(value); end
  def special_number?(literal); end
  def unquoted_string(str); end
  def var?(literal); end
end
module Sass::Script
  def self.const_missing(name); end
  def self.parse(value, line, offset, options = nil); end
end
module Sass::Script::Functions
  def _adjust(color, amount, attr, range, op, units = nil); end
  def abs(number); end
  def adjust_color(color, kwargs); end
  def adjust_hue(color, degrees); end
  def alpha(*args); end
  def append(list, val, separator = nil); end
  def blue(color); end
  def call(name, *args); end
  def ceil(number); end
  def change_color(color, kwargs); end
  def comparable(number1, number2); end
  def complement(color); end
  def content_exists; end
  def counter(*args); end
  def counters(*args); end
  def darken(color, amount); end
  def desaturate(color, amount); end
  def fade_in(color, amount); end
  def fade_out(color, amount); end
  def feature_exists(feature); end
  def floor(number); end
  def function_exists(name); end
  def get_function(name, kwargs = nil); end
  def global_variable_exists(name); end
  def grayscale(color); end
  def green(color); end
  def hsl(hue, saturation = nil, lightness = nil); end
  def hsla(hue, saturation = nil, lightness = nil, alpha = nil); end
  def hue(color); end
  def ie_hex_str(color); end
  def if(condition, if_true, if_false); end
  def index(list, value); end
  def inspect(value); end
  def invert(color, weight = nil); end
  def is_bracketed(list); end
  def is_superselector(sup, sub); end
  def join(list1, list2, separator = nil, bracketed = nil, kwargs = nil, *rest); end
  def keywords(args); end
  def length(list); end
  def lighten(color, amount); end
  def lightness(color); end
  def list_separator(list); end
  def map_get(map, key); end
  def map_has_key(map, key); end
  def map_keys(map); end
  def map_merge(map1, map2); end
  def map_remove(map, *keys); end
  def map_values(map); end
  def max(*values); end
  def min(*numbers); end
  def mix(color1, color2, weight = nil); end
  def mixin_exists(name); end
  def nth(list, n); end
  def numeric_transformation(value); end
  def opacify(color, amount); end
  def opacity(color); end
  def percentage(number); end
  def percentage_or_unitless(number, max, name); end
  def quote(string); end
  def random(limit = nil); end
  def red(color); end
  def rgb(red, green = nil, blue = nil); end
  def rgba(*args); end
  def round(number); end
  def saturate(color, amount = nil); end
  def saturation(color); end
  def scale_color(color, kwargs); end
  def selector_append(*selectors); end
  def selector_extend(selector, extendee, extender); end
  def selector_nest(*selectors); end
  def selector_parse(selector); end
  def selector_replace(selector, original, replacement); end
  def selector_unify(selector1, selector2); end
  def self.callable?(*arg0); end
  def self.declare(method_name, args, options = nil); end
  def self.include(*args); end
  def self.random_number_generator; end
  def self.random_seed=(seed); end
  def self.signature(method_name, arg_arity, kwarg_arity); end
  def set_nth(list, n, value); end
  def simple_selectors(selector); end
  def str_index(string, substring); end
  def str_insert(original, insert, index); end
  def str_length(string); end
  def str_slice(string, start_at, end_at = nil); end
  def to_lower_case(string); end
  def to_upper_case(string); end
  def transparentize(color, amount); end
  def type_of(value); end
  def unique_id; end
  def unit(number); end
  def unitless(number); end
  def unquote(string); end
  def variable_exists(name); end
  def zip(*lists); end
end
class Sass::Script::Functions::Signature < Struct
  def args; end
  def args=(_); end
  def delayed_args; end
  def delayed_args=(_); end
  def deprecated; end
  def deprecated=(_); end
  def self.[](*arg0); end
  def self.inspect; end
  def self.keyword_init?; end
  def self.members; end
  def self.new(*arg0); end
  def var_args; end
  def var_args=(_); end
  def var_kwargs; end
  def var_kwargs=(_); end
end
class Sass::Script::Functions::EvaluationContext
  def assert_integer(number, name = nil); end
  def assert_type(value, type, name = nil); end
  def assert_unit(number, unit, name = nil); end
  def environment; end
  def initialize(environment); end
  def options; end
  def perform(node, env = nil); end
  include Sass::Script::Functions
  include Sass::Script::Value::Helpers
end
class Sass::Script::Lexer
  def _variable(rx); end
  def after_interpolation?; end
  def char(pos = nil); end
  def color; end
  def done?; end
  def expected!(name); end
  def id; end
  def ident; end
  def ident_op; end
  def initialize(str, line, offset, options); end
  def line; end
  def next; end
  def next_char; end
  def number; end
  def offset; end
  def op; end
  def peek; end
  def range(start_pos, end_pos = nil); end
  def raw(rx); end
  def read_token; end
  def scan(re); end
  def selector; end
  def self.string_re(open, close); end
  def source_position; end
  def special_fun; end
  def special_fun_body(parens, prefix = nil); end
  def special_val; end
  def str; end
  def string(re, open); end
  def token; end
  def try; end
  def unpeek!; end
  def variable; end
  def whitespace; end
  def whitespace?(tok = nil); end
  include Sass::SCSS::RX
end
class Sass::Script::Lexer::Token < Struct
  def pos; end
  def pos=(_); end
  def self.[](*arg0); end
  def self.inspect; end
  def self.keyword_init?; end
  def self.members; end
  def self.new(*arg0); end
  def source_range; end
  def source_range=(_); end
  def type; end
  def type=(_); end
  def value; end
  def value=(_); end
end
class Sass::Script::Parser
  def and_expr; end
  def arglist(subexpr, description); end
  def array_to_interpolation(array); end
  def assert_done; end
  def assert_expr(name, expected = nil); end
  def assert_tok(name); end
  def assert_toks(*names); end
  def check_for_interpolation(node); end
  def css_min_max; end
  def declaration_value; end
  def defn_arglist!(must_have_parens); end
  def eq_or_neq; end
  def equals; end
  def expr; end
  def fn_arglist; end
  def funcall; end
  def ident; end
  def initialize(str, line, offset, options = nil); end
  def interpolation(first: nil, inner: nil); end
  def interpolation_deprecation(interpolation); end
  def is_safe_value?(expr); end
  def is_unsafe_before?(expr, char_before); end
  def lexer_class; end
  def line; end
  def list(first, start_pos); end
  def literal; end
  def literal_node(value, source_range_or_start_pos, end_pos = nil); end
  def map; end
  def map_pair(key = nil); end
  def min_max_calc; end
  def min_max_contents(allow_comma: nil); end
  def min_max_function; end
  def min_max_interpolation; end
  def min_max_parens; end
  def mixin_arglist; end
  def nested_min_max; end
  def node(node, source_range_or_start_pos, end_pos = nil); end
  def number; end
  def offset; end
  def or_expr; end
  def paren; end
  def parse; end
  def parse_function_definition_arglist; end
  def parse_interpolated(warn_for_color = nil); end
  def parse_mixin_definition_arglist; end
  def parse_mixin_include_arglist; end
  def parse_string; end
  def parse_until(tokens); end
  def peek_tok(name); end
  def peek_toks(*names); end
  def plus_or_minus; end
  def range(start_pos, end_pos = nil); end
  def raw; end
  def relational; end
  def selector; end
  def self.associative?(op); end
  def self.parse(*args); end
  def self.precedence_of(op); end
  def self.production(name, sub, *ops); end
  def self.unary(op, sub); end
  def source_position; end
  def space; end
  def special_fun; end
  def square_list; end
  def string; end
  def times_div_or_mod; end
  def try_op_before_interp(op, prev = nil, after_interp = nil); end
  def try_ops_after_interp(ops, name, prev = nil); end
  def try_tok(name); end
  def try_toks(*names); end
  def unary_div; end
  def unary_minus; end
  def unary_not; end
  def unary_plus; end
  def variable; end
  def without_stop_at; end
end
module Sass::Script::Tree
end
class Sass::Script::Tree::Node
  def _perform(environment); end
  def children; end
  def dasherize(s, opts); end
  def deep_copy; end
  def filename; end
  def filename=(arg0); end
  def force_division!; end
  def line; end
  def line=(arg0); end
  def options; end
  def options=(options); end
  def opts(value); end
  def perform(environment); end
  def source_range; end
  def source_range=(arg0); end
  def to_sass(opts = nil); end
end
class Sass::Script::Tree::Variable < Sass::Script::Tree::Node
  def _perform(environment); end
  def children; end
  def deep_copy; end
  def initialize(name); end
  def inspect(opts = nil); end
  def name; end
  def to_sass(opts = nil); end
  def underscored_name; end
end
class Sass::Script::Tree::Funcall < Sass::Script::Tree::Node
  def _perform(environment); end
  def args; end
  def callable; end
  def children; end
  def construct_ruby_args(name, args, splat, environment); end
  def deep_copy; end
  def initialize(name_or_callable, args, keywords, splat, kwarg_splat); end
  def inspect; end
  def keywords; end
  def kwarg_splat; end
  def kwarg_splat=(arg0); end
  def name; end
  def perform_arg(argument, environment, name); end
  def perform_sass_fn(function, args, splat, environment); end
  def reformat_argument_error(e); end
  def ruby_name; end
  def signature; end
  def splat; end
  def splat=(arg0); end
  def to_literal(args); end
  def to_sass(opts = nil); end
  def to_value(args); end
  def without_original(value); end
end
class Sass::Script::Tree::Operation < Sass::Script::Tree::Node
  def _perform(environment); end
  def children; end
  def deep_copy; end
  def initialize(operand1, operand2, operator); end
  def inspect; end
  def operand1; end
  def operand2; end
  def operand_to_sass(op, side, opts); end
  def operator; end
  def to_sass(opts = nil); end
  def warn_for_color_arithmetic(value1, value2); end
  def warn_for_unitless_equals(value1, value2, result); end
end
class Sass::Script::Tree::UnaryOperation < Sass::Script::Tree::Node
  def _perform(environment); end
  def children; end
  def deep_copy; end
  def initialize(operand, operator); end
  def inspect; end
  def operand; end
  def operator; end
  def to_sass(opts = nil); end
end
class Sass::Script::Tree::Interpolation < Sass::Script::Tree::Node
  def _perform(environment); end
  def after; end
  def before; end
  def children; end
  def concat(string_or_interp1, string_or_interp2); end
  def deep_copy; end
  def deprecation; end
  def initialize(before, mid, after, wb, wa, opts = nil); end
  def inspect; end
  def mid; end
  def originally_text; end
  def string_literal(string); end
  def to_quoted_equivalent; end
  def to_sass(opts = nil); end
  def to_string_interpolation(node_or_interp); end
  def warn_for_color; end
  def whitespace_after; end
  def whitespace_before; end
end
class Sass::Script::Tree::StringInterpolation < Sass::Script::Tree::Node
  def _perform(environment); end
  def _to_sass(string_or_interp, opts); end
  def after; end
  def before; end
  def children; end
  def deep_copy; end
  def initialize(before, mid, after); end
  def inspect; end
  def mid; end
  def quote; end
  def quote_for(string_or_interp); end
  def to_sass(opts = nil); end
  def type; end
end
class Sass::Script::Tree::Literal < Sass::Script::Tree::Node
  def _perform(environment); end
  def children; end
  def deep_copy; end
  def force_division!; end
  def initialize(value); end
  def inspect; end
  def options=(options); end
  def to_sass(opts = nil); end
  def value; end
end
class Sass::Script::Tree::ListLiteral < Sass::Script::Tree::Node
  def _perform(environment); end
  def bracketed; end
  def children; end
  def deep_copy; end
  def element_needs_parens?(element); end
  def elements; end
  def force_division!; end
  def initialize(elements, separator: nil, bracketed: nil); end
  def inspect; end
  def is_literal_number?(value); end
  def sep_str(opts = nil); end
  def separator; end
  def to_sass(opts = nil); end
end
class Sass::Script::Tree::MapLiteral < Sass::Script::Tree::Node
  def _perform(environment); end
  def children; end
  def deep_copy; end
  def initialize(pairs); end
  def inspect(opts = nil); end
  def pairs; end
  def to_sass(opts = nil); end
end
class Sass::Script::Tree::Selector < Sass::Script::Tree::Node
  def _perform(environment); end
  def children; end
  def deep_copy; end
  def initialize; end
  def to_sass(opts = nil); end
end
class Sass::Script::Value::Base
  def ==(other); end
  def _perform(environment); end
  def assert_int!; end
  def bracketed; end
  def div(other); end
  def eq(other); end
  def eql?(other); end
  def hash; end
  def initialize(value = nil); end
  def inspect; end
  def minus(other); end
  def neq(other); end
  def null?; end
  def options; end
  def options=(arg0); end
  def plus(other); end
  def separator; end
  def single_eq(other); end
  def source_range; end
  def source_range=(arg0); end
  def to_a; end
  def to_bool; end
  def to_h; end
  def to_i; end
  def to_s(opts = nil); end
  def to_sass(opts = nil); end
  def unary_div; end
  def unary_minus; end
  def unary_not; end
  def unary_plus; end
  def value; end
  def with_contents(contents, separator: nil, bracketed: nil); end
end
class Sass::Script::Value::String < Sass::Script::Value::Base
  def check_deprecated_interp; end
  def initialize(value, type = nil, deprecated_interp_equivalent = nil); end
  def inspect; end
  def plus(other); end
  def self.quote(contents, opts = nil); end
  def self.value(contents); end
  def separator; end
  def to_a; end
  def to_s(opts = nil); end
  def to_sass(opts = nil); end
  def type; end
  def value; end
end
class Sass::Script::Value::Number < Sass::Script::Value::Base
  def basically_equal?(num1, num2); end
  def coerce(num_units, den_units); end
  def coercion_factor(from_units, to_units); end
  def comparable_to?(other); end
  def compute_units(this, other, operation); end
  def conversion_factor(from_unit, to_unit); end
  def convertable?(units); end
  def denominator_units; end
  def div(other); end
  def eq(other); end
  def eql?(other); end
  def gt(other); end
  def gte(other); end
  def hash; end
  def initialize(value, numerator_units = nil, denominator_units = nil); end
  def inspect(opts = nil); end
  def int?; end
  def is_unit?(unit); end
  def legal_units?; end
  def lt(other); end
  def lte(other); end
  def minus(other); end
  def mod(other); end
  def normalize!; end
  def numerator_units; end
  def operate(other, operation); end
  def original; end
  def original=(arg0); end
  def plus(other); end
  def sans_common_units(units1, units2); end
  def self.basically_equal?(num1, num2); end
  def self.epsilon; end
  def self.precision; end
  def self.precision=(digits); end
  def self.precision_factor; end
  def self.round(num); end
  def times(other); end
  def to_i; end
  def to_s(opts = nil); end
  def to_sass(opts = nil); end
  def unary_minus; end
  def unary_plus; end
  def unit_str; end
  def unitless?; end
  def value; end
end
class Sass::Script::Value::Color < Sass::Script::Value::Base
  def alpha; end
  def alpha?; end
  def blue; end
  def div(other); end
  def eq(other); end
  def green; end
  def hash; end
  def hex_str; end
  def hsl; end
  def hsl_to_rgb!; end
  def hsla; end
  def hue; end
  def hue_to_rgb(m1, m2, h); end
  def initialize(attrs, representation = nil, allow_both_rgb_and_hsl = nil); end
  def inspect; end
  def lightness; end
  def minus(other); end
  def mod(other); end
  def name; end
  def operation_name(operation); end
  def piecewise(other, operation); end
  def plus(other); end
  def red; end
  def representation; end
  def rgb; end
  def rgb_to_hsl!; end
  def rgba; end
  def rgba_str; end
  def saturation; end
  def self.from_hex(hex_string, alpha = nil); end
  def self.int_to_rgba(color); end
  def smallest; end
  def times(other); end
  def to_s(opts = nil); end
  def to_sass(opts = nil); end
  def with(attrs); end
end
class Sass::Script::Value::Bool < Sass::Script::Value::Base
  def self.new(value); end
  def to_bool; end
  def to_s(opts = nil); end
  def to_sass(opts = nil); end
  def value; end
end
class Sass::Script::Value::Null < Sass::Script::Value::Base
  def inspect; end
  def null?; end
  def self.new; end
  def to_bool; end
  def to_s(opts = nil); end
  def to_sass(opts = nil); end
end
class Sass::Script::Value::List < Sass::Script::Value::Base
  def bracketed; end
  def element_needs_parens?(element); end
  def eq(other); end
  def hash; end
  def initialize(value, separator: nil, bracketed: nil); end
  def inspect; end
  def options=(options); end
  def self.assert_valid_index(list, n); end
  def sep_str(opts = nil); end
  def separator; end
  def to_a; end
  def to_h; end
  def to_s(opts = nil); end
  def to_sass(opts = nil); end
  def value; end
end
class Sass::Script::Value::ArgList < Sass::Script::Value::List
  def initialize(value, keywords, separator); end
  def keywords; end
  def keywords_accessed; end
  def keywords_accessed=(arg0); end
end
class Sass::Script::Value::Map < Sass::Script::Value::Base
  def eq(other); end
  def hash; end
  def initialize(hash); end
  def inspect(opts = nil); end
  def options=(options); end
  def separator; end
  def to_a; end
  def to_h; end
  def to_s(opts = nil); end
  def to_sass(opts = nil); end
  def value; end
end
class Sass::Script::Value::Callable < Sass::Script::Value::Base
  def initialize(callable); end
  def inspect; end
  def to_s(opts = nil); end
  def to_sass; end
end
class Sass::Script::Value::Function < Sass::Script::Value::Callable
  def initialize(function); end
  def to_sass; end
end
class Sass::SCSS::Parser
  def _interp_string(type); end
  def _moz_document_directive(start_pos); end
  def almost_any_value; end
  def almost_any_value_token; end
  def at_root_directive(start_pos); end
  def at_root_directive_list; end
  def at_root_query; end
  def block(node, context); end
  def block_child(context); end
  def block_contents(node, context); end
  def catch_error(&block); end
  def charset_directive(start_pos); end
  def content_directive(start_pos); end
  def css_variable_declaration(name, name_start_pos, name_end_pos); end
  def debug_directive(start_pos); end
  def declaration; end
  def declaration_or_ruleset; end
  def declaration_value(top_level: nil); end
  def declaration_value_token(top_level); end
  def deprefix(str); end
  def directive; end
  def directive_body(value, start_pos); end
  def each_directive(start_pos); end
  def else_block(node); end
  def else_directive(start_pos); end
  def err(msg); end
  def error_directive(start_pos); end
  def expected(name); end
  def expr!(name); end
  def expr(allow_var = nil); end
  def extend_directive(start_pos); end
  def for_directive(start_pos); end
  def function(allow_var); end
  def function_directive(start_pos); end
  def has_children?(child_or_array); end
  def ident!; end
  def ident; end
  def if_directive(start_pos); end
  def import_arg; end
  def import_directive(start_pos); end
  def import_supports_condition; end
  def include_directive(start_pos); end
  def init_scanner!; end
  def initialize(str, filename, importer, line = nil, offset = nil); end
  def interp_ident; end
  def interp_ident_or_var; end
  def interp_string; end
  def interp_uri; end
  def interpolation(warn_for_color = nil); end
  def media_directive(start_pos); end
  def media_expr; end
  def media_query; end
  def media_query_list; end
  def merge(arr); end
  def mixin_directive(start_pos); end
  def moz_document_function; end
  def name!; end
  def name; end
  def nested_properties!(node); end
  def node(node, start_pos, end_pos = nil); end
  def offset; end
  def offset=(arg0); end
  def operator; end
  def parse; end
  def parse_at_root_query; end
  def parse_declaration_value; end
  def parse_interp_ident; end
  def parse_media_query_list; end
  def parse_supports_clause; end
  def parse_supports_condition; end
  def prefixed_directive(name, start_pos); end
  def process_comment(text, node); end
  def query_expr; end
  def range(start_pos, end_pos = nil); end
  def rethrow(err); end
  def return_directive(start_pos); end
  def ruleset; end
  def s(node); end
  def sass_script(*args); end
  def self.expected(scanner, expected, line); end
  def self.sass_script_parser; end
  def self.sass_script_parser=(arg0); end
  def source_position; end
  def special_directive(name, start_pos); end
  def ss; end
  def ss_comments(node); end
  def str; end
  def str?; end
  def string; end
  def stylesheet; end
  def supports_clause; end
  def supports_condition; end
  def supports_condition_in_parens; end
  def supports_declaration; end
  def supports_directive(name, start_pos); end
  def supports_interpolation; end
  def supports_negation; end
  def supports_operator; end
  def term(allow_var); end
  def throw_error; end
  def tok!(rx); end
  def tok(rx); end
  def tok?(rx); end
  def try_declaration; end
  def use_css_import?; end
  def value!; end
  def var_expr; end
  def variable; end
  def warn_directive(start_pos); end
  def while_directive(start_pos); end
  def whitespace; end
  include Sass::SCSS::RX
end
class Sass::Script::CssLexer < Sass::Script::Lexer
  def important; end
  def string(re, *args); end
  def token; end
end
class Sass::Script::CssParser < Sass::Script::Parser
  def div; end
  def interpolation(first: nil, inner: nil); end
  def lexer_class; end
  def or_expr; end
  def paren; end
  def string; end
  def unary_div; end
end
class Sass::SCSS::StaticParser < Sass::SCSS::Parser
  def a_n_plus_b; end
  def attrib; end
  def attrib_name!; end
  def class_selector; end
  def combinator; end
  def element_name; end
  def id_selector; end
  def initialize(str, filename, importer, line = nil, offset = nil, allow_parent_ref = nil); end
  def interp_ident; end
  def interp_string; end
  def interp_uri; end
  def interpolation(warn_for_color = nil); end
  def keyframes_selector; end
  def keyframes_selector_component; end
  def moz_document_function; end
  def parent_selector; end
  def parse_keyframes_selector; end
  def parse_selector; end
  def parse_static_at_root_query; end
  def placeholder_selector; end
  def prefixed_selector_pseudo; end
  def pseudo; end
  def qualified_name(allow_star_name = nil); end
  def reference_combinator; end
  def script_value; end
  def selector; end
  def selector_comma_sequence; end
  def selector_string; end
  def simple_selector_sequence; end
  def special_directive(name, start_pos); end
  def use_css_import?; end
  def var_expr; end
  def variable; end
end
class Sass::SCSS::CssParser < Sass::SCSS::StaticParser
  def block_child(context); end
  def block_contents(node, context); end
  def interpolation(warn_for_color = nil); end
  def keyframes_ruleset; end
  def nested_properties!(node); end
  def parent_selector; end
  def placeholder_selector; end
  def ruleset; end
  def use_css_import?; end
end
class Sass::Stack
  def frames; end
  def initialize; end
  def to_s; end
  def with_base(filename, line); end
  def with_directive(filename, line, name); end
  def with_frame(filename, line, type, name = nil); end
  def with_function(filename, line, name); end
  def with_import(filename, line); end
  def with_mixin(filename, line, name); end
end
class Sass::Stack::Frame
  def filename; end
  def initialize(filename, line, type, name = nil); end
  def is_base?; end
  def is_import?; end
  def is_mixin?; end
  def line; end
  def name; end
  def type; end
end
class Sass::SyntaxError < StandardError
  def add_backtrace(attrs); end
  def backtrace; end
  def initialize(msg, attrs = nil); end
  def modify_backtrace(attrs); end
  def sass_backtrace; end
  def sass_backtrace=(arg0); end
  def sass_backtrace_str(default_filename = nil); end
  def sass_filename; end
  def sass_line; end
  def sass_mixin; end
  def sass_template; end
  def sass_template=(arg0); end
  def self.exception_to_css(e, line_offset = nil); end
  def self.header_string(e, line_offset); end
  def to_s; end
end
class Sass::UnitConversionError < Sass::SyntaxError
end
module Sass::Importers
end
class Sass::Importers::Base
  def directories_to_watch; end
  def find(uri, options); end
  def find_relative(uri, base, options); end
  def key(uri, options); end
  def mtime(uri, options); end
  def public_url(uri, sourcemap_directory); end
  def to_s; end
  def watched_file?(filename); end
end
class Sass::Importers::Filesystem < Sass::Importers::Base
  def _find(dir, name, options); end
  def directories_to_watch; end
  def eql?(other); end
  def escape_glob_characters(name); end
  def extensions; end
  def find(name, options); end
  def find_real_file(dir, name, options); end
  def find_relative(name, base, options); end
  def hash; end
  def initialize(root); end
  def key(name, options); end
  def mtime(name, options); end
  def possible_files(name); end
  def public_url(name, sourcemap_directory); end
  def remove_root(name); end
  def root; end
  def root=(arg0); end
  def split(name); end
  def to_s; end
  def watched_file?(filename); end
end
class Sass::Importers::DeprecatedPath < Sass::Importers::Filesystem
  def deprecation_warning; end
  def directories_to_watch; end
  def find(*args); end
  def initialize(root); end
  def to_s; end
end
module Sass::Shared
  def balance(scanner, start, finish, count = nil); end
  def handle_interpolation(str); end
  def human_indentation(indentation, was = nil); end
  extend Sass::Shared
end
module Sass::Media
  def self._interp_to_src(interp, options); end
end
class Sass::Media::QueryList
  def deep_copy; end
  def initialize(queries); end
  def merge(other); end
  def queries; end
  def queries=(arg0); end
  def to_a; end
  def to_css; end
  def to_src(options); end
end
class Sass::Media::Query
  def deep_copy; end
  def expressions; end
  def expressions=(arg0); end
  def initialize(modifier, type, expressions); end
  def merge(other); end
  def modifier; end
  def modifier=(arg0); end
  def resolved_modifier; end
  def resolved_type; end
  def to_a; end
  def to_css; end
  def to_src(options); end
  def type; end
  def type=(arg0); end
end
module Sass::Supports
end
class Sass::Supports::Condition
  def deep_copy; end
  def options=(options); end
  def perform(environment); end
  def to_css; end
  def to_src(options); end
end
class Sass::Supports::Operator < Sass::Supports::Condition
  def deep_copy; end
  def initialize(left, right, op); end
  def left; end
  def left=(arg0); end
  def op; end
  def op=(arg0); end
  def options=(options); end
  def parens(condition, str); end
  def perform(env); end
  def right; end
  def right=(arg0); end
  def to_css; end
  def to_src(options); end
end
class Sass::Supports::Negation < Sass::Supports::Condition
  def condition; end
  def condition=(arg0); end
  def deep_copy; end
  def initialize(condition); end
  def options=(options); end
  def parens(str); end
  def perform(env); end
  def to_css; end
  def to_src(options); end
end
class Sass::Supports::Declaration < Sass::Supports::Condition
  def deep_copy; end
  def initialize(name, value); end
  def name; end
  def name=(arg0); end
  def options=(options); end
  def perform(env); end
  def resolved_name; end
  def resolved_name=(arg0); end
  def resolved_value; end
  def resolved_value=(arg0); end
  def to_css; end
  def to_src(options); end
  def value; end
  def value=(arg0); end
end
class Sass::Supports::Interpolation < Sass::Supports::Condition
  def deep_copy; end
  def initialize(value); end
  def options=(options); end
  def perform(env); end
  def resolved_value; end
  def resolved_value=(arg0); end
  def to_css; end
  def to_src(options); end
  def value; end
  def value=(arg0); end
end
class Sass::Callable < Struct
  def args; end
  def args=(_); end
  def environment; end
  def environment=(_); end
  def has_content; end
  def has_content=(_); end
  def name; end
  def name=(_); end
  def origin; end
  def origin=(_); end
  def self.[](*arg0); end
  def self.inspect; end
  def self.keyword_init?; end
  def self.members; end
  def self.new(*arg0); end
  def splat; end
  def splat=(_); end
  def tree; end
  def tree=(_); end
  def type; end
  def type=(_); end
end
class Sass::Engine
  def _dependencies(seen, engines); end
  def _render_with_sourcemap(sourcemap_uri); end
  def _to_tree; end
  def append_children(parent, children, root); end
  def build_tree(parent, line, root = nil); end
  def check_encoding!; end
  def check_for_no_children(node); end
  def dependencies; end
  def format_comment_text(text, silent); end
  def full_line_range(line); end
  def initialize(template, options = nil); end
  def options; end
  def parse_at_root_directive(parent, line, root, value, offset); end
  def parse_charset_directive(parent, line, root, value, offset); end
  def parse_comment(line); end
  def parse_content_directive(parent, line, root, value, offset); end
  def parse_debug_directive(parent, line, root, value, offset); end
  def parse_directive(parent, line, root); end
  def parse_each_directive(parent, line, root, value, offset); end
  def parse_else_directive(parent, line, root, value, offset); end
  def parse_error_directive(parent, line, root, value, offset); end
  def parse_extend_directive(parent, line, root, value, offset); end
  def parse_for_directive(parent, line, root, value, offset); end
  def parse_function_directive(parent, line, root, value, offset); end
  def parse_if_directive(parent, line, root, value, offset); end
  def parse_import_arg(scanner, offset); end
  def parse_import_directive(parent, line, root, value, offset); end
  def parse_include_directive(parent, line, root, value, offset); end
  def parse_interp(text, offset = nil); end
  def parse_line(parent, line, root); end
  def parse_media_directive(parent, line, root, value, offset); end
  def parse_mixin_definition(line); end
  def parse_mixin_directive(parent, line, root, value, offset); end
  def parse_mixin_include(line, root); end
  def parse_property(name, parsed_name, value, prop, line, start_offset); end
  def parse_property_or_rule(line); end
  def parse_return_directive(parent, line, root, value, offset); end
  def parse_script(script, options = nil); end
  def parse_variable(line); end
  def parse_warn_directive(parent, line, root, value, offset); end
  def parse_while_directive(parent, line, root, value, offset); end
  def render; end
  def render_with_sourcemap(sourcemap_uri); end
  def sassc_key; end
  def self.for_file(filename, options); end
  def self.normalize_options(options); end
  def self.parse_interp(text, line, offset, options); end
  def source_encoding; end
  def tabulate(string); end
  def to_css; end
  def to_parser_offset(offset); end
  def to_tree; end
  def tree(arr, i = nil); end
  def try_comment(line, last, tab_str, comment_tab_str, index); end
  def validate_and_append_child(parent, child, line, root); end
end
class Anonymous_Struct_90 < Struct
  def children; end
  def children=(_); end
  def comment_tab_str; end
  def comment_tab_str=(_); end
  def filename; end
  def filename=(_); end
  def index; end
  def index=(_); end
  def offset; end
  def offset=(_); end
  def self.[](*arg0); end
  def self.inspect; end
  def self.keyword_init?; end
  def self.members; end
  def self.new(*arg0); end
  def tabs; end
  def tabs=(_); end
  def text; end
  def text=(_); end
end
class Sass::Engine::Line < Anonymous_Struct_90
  def comment?; end
end
module Sass::Features
  def add_feature(feature_name); end
  def has_feature?(feature_name); end
end
