# This file is autogenerated. Do not edit it by hand. Regenerate it with:
#   srb rbi gems

# typed: true
#
# If you would like to make changes to this file, great! Please create the gem's shim here:
#
#   https://github.com/sorbet/sorbet-typed/new/master?filename=lib/sentry-ruby/all/sentry-ruby.rbi
#
# sentry-ruby-5.19.0

module Sentry
  def self.add_attachment(**opts); end
  def self.add_breadcrumb(breadcrumb, **options); end
  def self.add_global_event_processor(&block); end
  def self.apply_patches(config); end
  def self.background_worker; end
  def self.background_worker=(arg0); end
  def self.backpressure_monitor; end
  def self.capture_check_in(slug, status, **options); end
  def self.capture_event(event); end
  def self.capture_exception(exception, **options, &block); end
  def self.capture_message(message, **options, &block); end
  def self.clone_hub_to_current_thread; end
  def self.close; end
  def self.configuration; end
  def self.configure_scope(&block); end
  def self.continue_trace(env, **options); end
  def self.csp_report_uri; end
  def self.exception_captured?(exc); end
  def self.exception_locals_tp; end
  def self.get_baggage; end
  def self.get_current_client; end
  def self.get_current_hub; end
  def self.get_current_scope; end
  def self.get_main_hub; end
  def self.get_trace_propagation_headers; end
  def self.get_trace_propagation_meta; end
  def self.get_traceparent; end
  def self.init(&block); end
  def self.initialized?; end
  def self.integrations; end
  def self.last_event_id; end
  def self.logger; end
  def self.metrics_aggregator; end
  def self.register_integration(name, version); end
  def self.register_patch(key, patch = nil, target = nil, &block); end
  def self.registered_patches; end
  def self.sdk_meta; end
  def self.send_event(*args); end
  def self.session_flusher; end
  def self.set_context(*args); end
  def self.set_extras(*args); end
  def self.set_tags(*args); end
  def self.set_user(*args); end
  def self.start_transaction(**options); end
  def self.sys_command(command); end
  def self.utc_now; end
  def self.with_child_span(**attributes, &block); end
  def self.with_exception_captured(**options, &block); end
  def self.with_scope(&block); end
  def self.with_session_tracking(&block); end
end
class Sentry::Error < StandardError
end
class Sentry::ExternalError < Sentry::Error
end
module Sentry::ArgumentCheckingHelper
  def check_argument_includes!(argument, values); end
  def check_argument_type!(argument, *expected_types); end
  def check_callable!(name, value); end
end
module Sentry::Utils
end
module Sentry::Utils::EncodingHelper
  def self.encode_to_utf_8(value); end
  def self.valid_utf_8?(value); end
end
module Sentry::LoggingHelper
  def log_debug(message); end
  def log_error(message, exception, debug: nil); end
  def log_warn(message); end
end
module Sentry::Utils::ExceptionCauseChain
  def self.exception_to_array(exception); end
end
module Sentry::CustomInspection
  def inspect; end
end
class Sentry::DSN
  def csp_report_uri; end
  def envelope_endpoint; end
  def host; end
  def initialize(dsn_string); end
  def path; end
  def port; end
  def project_id; end
  def public_key; end
  def scheme; end
  def secret_key; end
  def server; end
  def to_s; end
  def valid?; end
end
class Sentry::ReleaseDetector
  def self.detect_release(project_root:, running_on_heroku:); end
  def self.detect_release_from_capistrano(project_root); end
  def self.detect_release_from_env; end
  def self.detect_release_from_git; end
  def self.detect_release_from_heroku(running_on_heroku); end
end
class Sentry::Transport
  def any_rate_limited?; end
  def discarded_events; end
  def envelope_from_event(event); end
  def fetch_pending_client_report(force: nil); end
  def flush; end
  def initialize(configuration); end
  def is_rate_limited?(data_category); end
  def last_client_report_sent; end
  def logger; end
  def rate_limits; end
  def record_lost_event(reason, data_category, num: nil); end
  def reject_rate_limited_items(envelope); end
  def send_data(data, options = nil); end
  def send_envelope(envelope); end
  def send_event(event); end
  def serialize_envelope(envelope); end
  include Sentry::LoggingHelper
end
class Sentry::Transport::Configuration
  def encoding; end
  def encoding=(arg0); end
  def initialize; end
  def open_timeout; end
  def open_timeout=(arg0); end
  def proxy; end
  def proxy=(arg0); end
  def ssl; end
  def ssl=(arg0); end
  def ssl_ca_file; end
  def ssl_ca_file=(arg0); end
  def ssl_verification; end
  def ssl_verification=(arg0); end
  def timeout; end
  def timeout=(arg0); end
  def transport_class; end
  def transport_class=(klass); end
end
module Sentry::Cron
end
class Sentry::Cron::Configuration
  def default_checkin_margin; end
  def default_checkin_margin=(arg0); end
  def default_max_runtime; end
  def default_max_runtime=(arg0); end
  def default_timezone; end
  def default_timezone=(arg0); end
end
module Sentry::Metrics
  def self.distribution(key, value, unit: nil, tags: nil, timestamp: nil); end
  def self.gauge(key, value, unit: nil, tags: nil, timestamp: nil); end
  def self.increment(key, value = nil, unit: nil, tags: nil, timestamp: nil); end
  def self.set(key, value, unit: nil, tags: nil, timestamp: nil); end
  def self.timing(key, unit: nil, tags: nil, timestamp: nil, &block); end
end
class Sentry::Metrics::Configuration
  def before_emit; end
  def before_emit=(value); end
  def enable_code_locations; end
  def enable_code_locations=(arg0); end
  def enabled; end
  def enabled=(arg0); end
  def initialize; end
  include Sentry::ArgumentCheckingHelper
end
class Sentry::LineCache
  def get_file_context(filename, lineno, context); end
  def getline(path, n); end
  def getlines(path); end
  def initialize; end
  def valid_path?(path); end
end
class Sentry::StacktraceBuilder
  def app_dirs_pattern; end
  def backtrace_cleanup_callback; end
  def build(backtrace:, &frame_callback); end
  def context_lines; end
  def convert_parsed_line_into_frame(line); end
  def initialize(project_root:, app_dirs_pattern:, linecache:, context_lines:, backtrace_cleanup_callback: nil); end
  def linecache; end
  def metrics_code_location(unparsed_line); end
  def parse_backtrace_lines(backtrace); end
  def project_root; end
end
class Sentry::Configuration
  def app_dirs_pattern; end
  def app_dirs_pattern=(arg0); end
  def async; end
  def async=(value); end
  def auto_session_tracking; end
  def auto_session_tracking=(arg0); end
  def background_worker_max_queue; end
  def background_worker_max_queue=(arg0); end
  def background_worker_threads; end
  def background_worker_threads=(arg0); end
  def backtrace_cleanup_callback; end
  def backtrace_cleanup_callback=(arg0); end
  def before_breadcrumb; end
  def before_breadcrumb=(value); end
  def before_send; end
  def before_send=(value); end
  def before_send_transaction; end
  def before_send_transaction=(value); end
  def breadcrumbs_logger; end
  def breadcrumbs_logger=(logger); end
  def capture_exception_frame_locals; end
  def capture_exception_frame_locals=(value); end
  def capture_in_environment?; end
  def context_lines; end
  def context_lines=(arg0); end
  def cron; end
  def csp_report_uri; end
  def debug; end
  def debug=(arg0); end
  def detect_release; end
  def dsn; end
  def dsn=(value); end
  def enable_backpressure_handling; end
  def enable_backpressure_handling=(arg0); end
  def enable_tracing; end
  def enable_tracing=(enable_tracing); end
  def enabled_environments; end
  def enabled_environments=(arg0); end
  def enabled_in_current_env?; end
  def enabled_patches; end
  def enabled_patches=(arg0); end
  def environment; end
  def environment=(environment); end
  def environment_from_env; end
  def error_messages; end
  def errors; end
  def exception_class_allowed?(exc); end
  def exclude_loggers; end
  def exclude_loggers=(arg0); end
  def excluded_exception?(incoming_exception); end
  def excluded_exception_classes; end
  def excluded_exceptions; end
  def excluded_exceptions=(arg0); end
  def gem_specs; end
  def get_exception_class(x); end
  def include_local_variables; end
  def include_local_variables=(arg0); end
  def init_dsn(dsn_string); end
  def initialize; end
  def inspect_exception_causes_for_exclusion; end
  def inspect_exception_causes_for_exclusion=(arg0); end
  def inspect_exception_causes_for_exclusion?; end
  def instrumenter; end
  def instrumenter=(instrumenter); end
  def is_numeric_or_nil?(value); end
  def linecache; end
  def linecache=(arg0); end
  def logger; end
  def logger=(arg0); end
  def matches_exception?(excluded_exception_class, incoming_exception); end
  def max_breadcrumbs; end
  def max_breadcrumbs=(arg0); end
  def metrics; end
  def processor_count; end
  def profiles_sample_rate; end
  def profiles_sample_rate=(profiles_sample_rate); end
  def profiling_enabled?; end
  def project_root; end
  def project_root=(arg0); end
  def propagate_traces; end
  def propagate_traces=(arg0); end
  def rack_env_whitelist; end
  def rack_env_whitelist=(arg0); end
  def release; end
  def release=(value); end
  def run_post_initialization_callbacks; end
  def running_on_heroku?; end
  def safe_const_get(x); end
  def sample_allowed?; end
  def sample_rate; end
  def sample_rate=(arg0); end
  def self.add_post_initialization_callback(&block); end
  def self.post_initialization_callbacks; end
  def send_client_reports; end
  def send_client_reports=(arg0); end
  def send_default_pii; end
  def send_default_pii=(arg0); end
  def send_modules; end
  def send_modules=(arg0); end
  def sending_allowed?; end
  def sending_to_dsn_allowed?; end
  def server=(value); end
  def server_name; end
  def server_name=(arg0); end
  def server_name_from_env; end
  def session_tracking?; end
  def skip_rake_integration; end
  def skip_rake_integration=(arg0); end
  def spotlight; end
  def spotlight=(arg0); end
  def stacktrace_builder; end
  def trace_propagation_targets; end
  def trace_propagation_targets=(arg0); end
  def traces_sample_rate; end
  def traces_sample_rate=(traces_sample_rate); end
  def traces_sampler; end
  def traces_sampler=(arg0); end
  def tracing_enabled?; end
  def transport; end
  def trusted_proxies; end
  def trusted_proxies=(arg0); end
  def valid?; end
  def valid_sample_rate?(sample_rate); end
  include Sentry::ArgumentCheckingHelper
  include Sentry::CustomInspection
  include Sentry::LoggingHelper
end
class Sentry::Logger < Logger
  def initialize(*); end
end
class Sentry::ExceptionInterface < Sentry::Interface
  def initialize(exceptions:); end
  def self.build(exception:, stacktrace_builder:, mechanism:); end
  def to_hash; end
  def values; end
end
class Sentry::RequestInterface < Sentry::Interface
  def cookies; end
  def cookies=(arg0); end
  def data; end
  def data=(arg0); end
  def env; end
  def env=(arg0); end
  def filter_and_format_env(env, rack_env_whitelist); end
  def filter_and_format_headers(env, send_default_pii); end
  def headers; end
  def headers=(arg0); end
  def initialize(env:, send_default_pii:, rack_env_whitelist:); end
  def is_server_protocol?(key, value, protocol_version); end
  def is_skippable_header?(key); end
  def method; end
  def method=(arg0); end
  def query_string; end
  def query_string=(arg0); end
  def read_data_from(request); end
  def url; end
  def url=(arg0); end
end
class Sentry::SingleExceptionInterface < Sentry::Interface
  def initialize(exception:, mechanism:, stacktrace: nil); end
  def mechanism; end
  def module; end
  def self.build_with_stacktrace(exception:, stacktrace_builder:, mechanism:); end
  def stacktrace; end
  def thread_id; end
  def to_hash; end
  def type; end
  def value; end
  def value=(arg0); end
  include Sentry::CustomInspection
end
class Sentry::StacktraceInterface
  def frames; end
  def initialize(frames:); end
  def inspect; end
  def to_hash; end
end
class Sentry::StacktraceInterface::Frame < Sentry::Interface
  def abs_path; end
  def abs_path=(arg0); end
  def compute_filename; end
  def context_line; end
  def context_line=(arg0); end
  def filename; end
  def filename=(arg0); end
  def function; end
  def function=(arg0); end
  def in_app; end
  def in_app=(arg0); end
  def initialize(project_root, line); end
  def lineno; end
  def lineno=(arg0); end
  def longest_load_path; end
  def module; end
  def module=(arg0); end
  def post_context; end
  def post_context=(arg0); end
  def pre_context; end
  def pre_context=(arg0); end
  def set_context(linecache, context_lines); end
  def to_hash(*args); end
  def to_s; end
  def under_project_root?; end
  def vars; end
  def vars=(arg0); end
end
class Sentry::ThreadsInterface
  def initialize(crashed: nil, stacktrace: nil); end
  def self.build(backtrace:, stacktrace_builder:, **options); end
  def to_hash; end
end
class Sentry::Mechanism < Sentry::Interface
  def handled; end
  def handled=(arg0); end
  def initialize(type: nil, handled: nil); end
  def type; end
  def type=(arg0); end
end
class Sentry::Interface
  def to_hash; end
end
class Sentry::Backtrace
  def ==(other); end
  def initialize(lines); end
  def inspect; end
  def lines; end
  def self.parse(backtrace, project_root, app_dirs_pattern, &backtrace_cleanup_callback); end
  def to_s; end
end
class Sentry::Backtrace::Line
  def ==(other); end
  def file; end
  def in_app; end
  def in_app_pattern; end
  def initialize(file, number, method, module_name, in_app_pattern); end
  def inspect; end
  def method; end
  def module_name; end
  def number; end
  def self.parse(unparsed_line, in_app_pattern = nil); end
  def to_s; end
end
class Sentry::Utils::RealIp
  def calculate_ip; end
  def filter_trusted_proxy_addresses(ips); end
  def initialize(remote_addr: nil, client_ip: nil, real_ip: nil, forwarded_for: nil, trusted_proxies: nil); end
  def ip; end
  def ips_from(header); end
end
module Sentry::Utils::RequestId
  def self.read_from(env); end
end
class Sentry::Event
  def add_request_interface(env); end
  def attachments; end
  def attachments=(arg0); end
  def breadcrumbs; end
  def breadcrumbs=(arg0); end
  def calculate_real_ip_from_rack(env); end
  def configuration; end
  def contexts; end
  def contexts=(arg0); end
  def dynamic_sampling_context; end
  def dynamic_sampling_context=(arg0); end
  def environment; end
  def environment=(arg0); end
  def event_id; end
  def event_id=(arg0); end
  def extra; end
  def extra=(arg0); end
  def fingerprint; end
  def fingerprint=(arg0); end
  def initialize(configuration:, integration_meta: nil, message: nil); end
  def level; end
  def level=(level); end
  def message; end
  def message=(arg0); end
  def modules; end
  def modules=(arg0); end
  def platform; end
  def platform=(arg0); end
  def rack_env=(env); end
  def release; end
  def release=(arg0); end
  def request; end
  def sdk; end
  def sdk=(arg0); end
  def serialize_attributes; end
  def server_name; end
  def server_name=(arg0); end
  def tags; end
  def tags=(arg0); end
  def timestamp; end
  def timestamp=(time); end
  def to_hash; end
  def to_json_compatible; end
  def transaction; end
  def transaction=(arg0); end
  def transaction_info; end
  def transaction_info=(arg0); end
  def type; end
  def user; end
  def user=(arg0); end
  include Sentry::CustomInspection
end
class Sentry::ErrorEvent < Sentry::Event
  def add_exception_interface(exception, mechanism:); end
  def add_threads_interface(backtrace: nil, **options); end
  def exception; end
  def threads; end
  def to_hash; end
end
class Sentry::TransactionEvent < Sentry::Event
  def initialize(transaction:, **options); end
  def measurements; end
  def measurements=(arg0); end
  def metrics_summary; end
  def metrics_summary=(arg0); end
  def populate_profile(transaction); end
  def profile; end
  def profile=(arg0); end
  def spans; end
  def spans=(arg0); end
  def start_timestamp; end
  def start_timestamp=(time); end
  def to_hash; end
end
module Sentry::Cron::MonitorSchedule
end
class Sentry::Cron::MonitorSchedule::Crontab
  def initialize(value); end
  def to_hash; end
  def value; end
  def value=(arg0); end
end
class Sentry::Cron::MonitorSchedule::Interval
  def initialize(value, unit); end
  def to_hash; end
  def unit; end
  def unit=(arg0); end
  def value; end
  def value=(arg0); end
end
class Sentry::Cron::MonitorConfig
  def checkin_margin; end
  def checkin_margin=(arg0); end
  def initialize(schedule, checkin_margin: nil, max_runtime: nil, timezone: nil); end
  def max_runtime; end
  def max_runtime=(arg0); end
  def schedule; end
  def schedule=(arg0); end
  def self.from_crontab(crontab, **options); end
  def self.from_interval(num, unit, **options); end
  def timezone; end
  def timezone=(arg0); end
  def to_hash; end
end
class Sentry::CheckInEvent < Sentry::Event
  def check_in_id; end
  def check_in_id=(arg0); end
  def duration; end
  def duration=(arg0); end
  def initialize(slug:, status:, duration: nil, monitor_config: nil, check_in_id: nil, **options); end
  def monitor_config; end
  def monitor_config=(arg0); end
  def monitor_slug; end
  def monitor_slug=(arg0); end
  def status; end
  def status=(arg0); end
  def to_hash; end
end
class Sentry::Metrics::LocalAggregator
  def add(key, value); end
  def buckets; end
  def deserialize_tags(tags); end
  def initialize; end
  def to_hash; end
end
class Sentry::Span
  def data; end
  def deep_dup; end
  def description; end
  def finish(end_timestamp: nil); end
  def get_trace_context; end
  def initialize(transaction:, description: nil, op: nil, status: nil, trace_id: nil, span_id: nil, parent_span_id: nil, sampled: nil, start_timestamp: nil, timestamp: nil, origin: nil); end
  def metrics_local_aggregator; end
  def metrics_summary; end
  def op; end
  def origin; end
  def parent_span_id; end
  def sampled; end
  def set_data(key, value); end
  def set_description(description); end
  def set_http_status(status_code); end
  def set_op(op); end
  def set_origin(origin); end
  def set_status(status); end
  def set_tag(key, value); end
  def set_timestamp(timestamp); end
  def span_id; end
  def span_recorder; end
  def span_recorder=(arg0); end
  def start_child(**attributes); end
  def start_timestamp; end
  def status; end
  def tags; end
  def timestamp; end
  def to_baggage; end
  def to_hash; end
  def to_sentry_trace; end
  def trace_id; end
  def transaction; end
  def with_child_span(**attributes, &block); end
end
module Sentry::Span::DataConventions
end
class Sentry::Baggage
  def dynamic_sampling_context; end
  def freeze!; end
  def initialize(items, mutable: nil); end
  def items; end
  def mutable; end
  def self.from_incoming_header(header); end
  def serialize; end
end
class Sentry::Profiler
  def compute_filename(abs_path, in_app); end
  def event_id; end
  def in_app?(abs_path); end
  def initialize(configuration); end
  def log(message); end
  def record_lost_event(reason); end
  def sampled; end
  def set_initial_sample_decision(transaction_sampled); end
  def split_module(name); end
  def start; end
  def started; end
  def stop; end
  def to_hash; end
end
class Sentry::PropagationContext
  def baggage; end
  def get_baggage; end
  def get_dynamic_sampling_context; end
  def get_trace_context; end
  def get_traceparent; end
  def incoming_trace; end
  def initialize(scope, env = nil); end
  def parent_sampled; end
  def parent_span_id; end
  def populate_head_baggage; end
  def self.extract_sentry_trace(sentry_trace); end
  def span_id; end
  def trace_id; end
end
class Sentry::Transaction < Sentry::Span
  def baggage; end
  def configuration; end
  def contexts; end
  def deep_dup; end
  def effective_sample_rate; end
  def finish(hub: nil, end_timestamp: nil); end
  def generate_transaction_description; end
  def get_baggage; end
  def hub; end
  def init_span_recorder(limit = nil); end
  def initialize(hub:, name: nil, source: nil, parent_sampled: nil, baggage: nil, **options); end
  def logger; end
  def measurements; end
  def name; end
  def parent_sampled; end
  def populate_head_baggage; end
  def profiler; end
  def self.extract_sentry_trace(sentry_trace); end
  def self.from_sentry_trace(sentry_trace, baggage: nil, hub: nil, **options); end
  def set_context(key, value); end
  def set_initial_sample_decision(sampling_context:); end
  def set_measurement(name, value, unit = nil); end
  def set_name(name, source: nil); end
  def source; end
  def source_low_quality?; end
  def start_profiler!; end
  def to_hash; end
  include Sentry::LoggingHelper
end
class Sentry::Transaction::SpanRecorder
  def add(span); end
  def initialize(max_length); end
  def max_length; end
  def spans; end
end
class Sentry::Breadcrumb
  def category; end
  def category=(arg0); end
  def data; end
  def data=(arg0); end
  def initialize(category: nil, data: nil, message: nil, timestamp: nil, level: nil, type: nil); end
  def level; end
  def level=(level); end
  def message; end
  def message=(message); end
  def serialized_data; end
  def timestamp; end
  def timestamp=(arg0); end
  def to_hash; end
  def type; end
  def type=(arg0); end
end
class Sentry::BreadcrumbBuffer
  def buffer; end
  def buffer=(arg0); end
  def dup; end
  def each(&block); end
  def empty?; end
  def initialize(size = nil); end
  def members; end
  def peek; end
  def record(crumb); end
  def to_hash; end
  include Enumerable
end
class Sentry::Attachment
  def bytes; end
  def content_type; end
  def filename; end
  def infer_filename(filename, path); end
  def initialize(bytes: nil, filename: nil, content_type: nil, path: nil); end
  def path; end
  def payload; end
  def to_envelope_headers; end
end
class Sentry::Attachment::PathNotFoundError < StandardError
end
class Sentry::Scope
  def add_attachment(**opts); end
  def add_breadcrumb(breadcrumb); end
  def add_event_processor(&block); end
  def apply_to_event(event, hint = nil); end
  def attachments; end
  def attachments=(arg0); end
  def breadcrumbs; end
  def breadcrumbs=(arg0); end
  def clear; end
  def clear_breadcrumbs; end
  def contexts; end
  def contexts=(arg0); end
  def dup; end
  def event_processors; end
  def event_processors=(arg0); end
  def extra; end
  def extra=(arg0); end
  def fingerprint; end
  def fingerprint=(arg0); end
  def generate_propagation_context(env = nil); end
  def get_span; end
  def get_transaction; end
  def initialize(max_breadcrumbs: nil); end
  def level; end
  def level=(arg0); end
  def propagation_context; end
  def propagation_context=(arg0); end
  def rack_env; end
  def rack_env=(arg0); end
  def self.add_global_event_processor(&block); end
  def self.global_event_processors; end
  def self.os_context; end
  def self.runtime_context; end
  def session; end
  def session=(arg0); end
  def set_context(key, value); end
  def set_contexts(contexts_hash); end
  def set_default_value; end
  def set_extra(key, value); end
  def set_extras(extras_hash); end
  def set_fingerprint(fingerprint); end
  def set_level(level); end
  def set_new_breadcrumb_buffer; end
  def set_rack_env(env); end
  def set_session(session); end
  def set_span(span); end
  def set_tag(key, value); end
  def set_tags(tags_hash); end
  def set_transaction_name(transaction_name, source: nil); end
  def set_user(user_hash); end
  def span; end
  def span=(arg0); end
  def tags; end
  def tags=(arg0); end
  def transaction_name; end
  def transaction_name=(arg0); end
  def transaction_source; end
  def transaction_source=(arg0); end
  def transaction_source_low_quality?; end
  def update_from_options(contexts: nil, extra: nil, tags: nil, user: nil, level: nil, fingerprint: nil, attachments: nil, **options); end
  def update_from_scope(scope); end
  def user; end
  def user=(arg0); end
  include Sentry::ArgumentCheckingHelper
end
class Sentry::Envelope
  def add_item(headers, payload); end
  def event_id; end
  def headers; end
  def headers=(arg0); end
  def initialize(headers = nil); end
  def item_types; end
  def items; end
  def items=(arg0); end
end
class Sentry::Envelope::Item
  def data_category; end
  def headers; end
  def headers=(arg0); end
  def initialize(headers, payload); end
  def payload; end
  def payload=(arg0); end
  def reduce_stacktrace!; end
  def remove_breadcrumbs!; end
  def self.data_category(type); end
  def serialize; end
  def size_breakdown; end
  def to_s; end
  def type; end
end
class Sentry::DummyTransport < Sentry::Transport
  def envelopes; end
  def envelopes=(arg0); end
  def events; end
  def events=(arg0); end
  def initialize(*); end
  def send_envelope(envelope); end
  def send_event(event); end
end
class Sentry::HTTPTransport < Sentry::Transport
  def conn; end
  def endpoint; end
  def generate_auth_header; end
  def handle_rate_limited_response(headers); end
  def has_rate_limited_header?(headers); end
  def initialize(*args); end
  def normalize_proxy(proxy); end
  def parse_rate_limit_header(rate_limit_header); end
  def send_data(data); end
  def should_compress?(data); end
  def ssl_configuration; end
end
class Sentry::SpotlightTransport < Sentry::HTTPTransport
  def conn; end
  def endpoint; end
  def initialize(configuration); end
  def on_error; end
  def send_data(data); end
end
class Sentry::Client
  def capture_envelope(envelope); end
  def capture_event(event, scope, hint = nil); end
  def configuration; end
  def dispatch_async_event(async_block, event, hint); end
  def dispatch_background_event(event, hint); end
  def event_from_check_in(slug, status, hint = nil, duration: nil, monitor_config: nil, check_in_id: nil); end
  def event_from_exception(exception, hint = nil); end
  def event_from_message(message, hint = nil, backtrace: nil); end
  def event_from_transaction(transaction); end
  def flush; end
  def generate_baggage(span); end
  def generate_sentry_trace(span); end
  def initialize(configuration); end
  def logger; end
  def send_envelope(envelope); end
  def send_event(event, hint = nil); end
  def spotlight_transport; end
  def transport; end
  include Sentry::LoggingHelper
end
class Sentry::Session
  def aggregation_key; end
  def close; end
  def deep_dup; end
  def initialize; end
  def started; end
  def status; end
  def update_from_exception(_exception = nil); end
end
class Sentry::Hub
  def add_breadcrumb(breadcrumb, hint: nil); end
  def bind_client(client); end
  def capture_check_in(slug, status, **options); end
  def capture_event(event, **options, &block); end
  def capture_exception(exception, **options, &block); end
  def capture_message(message, **options, &block); end
  def clone; end
  def configuration; end
  def configure_scope(&block); end
  def continue_trace(env, **options); end
  def current_client; end
  def current_layer; end
  def current_scope; end
  def end_session; end
  def get_baggage; end
  def get_trace_propagation_headers; end
  def get_trace_propagation_meta; end
  def get_traceparent; end
  def initialize(client, scope); end
  def last_event_id; end
  def new_from_top; end
  def pop_scope; end
  def push_scope; end
  def start_session; end
  def start_transaction(transaction: nil, custom_sampling_context: nil, instrumenter: nil, **options); end
  def with_background_worker_disabled(&block); end
  def with_child_span(instrumenter: nil, **attributes, &block); end
  def with_scope(&block); end
  def with_session_tracking(&block); end
  include Sentry::ArgumentCheckingHelper
end
class Sentry::Hub::Layer
  def client; end
  def client=(arg0); end
  def initialize(client, scope); end
  def scope; end
end
class Sentry::BackgroundWorker
  def _perform(&block); end
  def full?; end
  def initialize(configuration); end
  def logger; end
  def max_queue; end
  def number_of_threads; end
  def perform(&block); end
  def shutdown; end
  def shutdown_timeout; end
  def shutdown_timeout=(arg0); end
  include Sentry::LoggingHelper
end
class Sentry::ThreadedPeriodicWorker
  def ensure_thread; end
  def initialize(logger, internal); end
  def kill; end
  include Sentry::LoggingHelper
end
class Sentry::SessionFlusher < Sentry::ThreadedPeriodicWorker
  def add_session(session); end
  def attrs; end
  def flush; end
  def init_aggregates(aggregation_key); end
  def initialize(configuration, client); end
  def pending_envelope; end
  def run; end
end
class Sentry::BackpressureMonitor < Sentry::ThreadedPeriodicWorker
  def check_health; end
  def downsample_factor; end
  def healthy?; end
  def initialize(configuration, client, interval: nil); end
  def run; end
  def set_downsample_factor; end
end
module Sentry::Cron::MonitorCheckIns
  def self.included(base); end
end
module Sentry::Cron::MonitorCheckIns::Patch
  def perform(*args, **opts); end
end
module Sentry::Cron::MonitorCheckIns::ClassMethods
  def sentry_monitor_check_ins(slug: nil, monitor_config: nil); end
  def sentry_monitor_config; end
  def sentry_monitor_slug(name: nil); end
end
class Sentry::Metrics::Metric
  def add(value); end
  def serialize; end
  def weight; end
end
class Sentry::Metrics::CounterMetric < Sentry::Metrics::Metric
  def add(value); end
  def initialize(value); end
  def serialize; end
  def value; end
  def weight; end
end
class Sentry::Metrics::DistributionMetric < Sentry::Metrics::Metric
  def add(value); end
  def initialize(value); end
  def serialize; end
  def value; end
  def weight; end
end
class Sentry::Metrics::GaugeMetric < Sentry::Metrics::Metric
  def add(value); end
  def count; end
  def initialize(value); end
  def last; end
  def max; end
  def min; end
  def serialize; end
  def sum; end
  def weight; end
end
class Sentry::Metrics::SetMetric < Sentry::Metrics::Metric
  def add(value); end
  def initialize(value); end
  def serialize; end
  def value; end
  def weight; end
end
module Sentry::Metrics::Timing
  def self.day; end
  def self.hour; end
  def self.microsecond; end
  def self.millisecond; end
  def self.minute; end
  def self.nanosecond; end
  def self.second; end
  def self.week; end
end
class Sentry::Metrics::Aggregator < Sentry::ThreadedPeriodicWorker
  def add(type, key, value, unit: nil, tags: nil, timestamp: nil, stacklevel: nil); end
  def buckets; end
  def client; end
  def code_locations; end
  def flush(force: nil); end
  def flush_shift; end
  def get_code_locations!; end
  def get_flushable_buckets!(force); end
  def get_transaction_name; end
  def get_updated_tags(tags); end
  def initialize(configuration, client); end
  def process_bucket(timestamp, key, type, value); end
  def process_span_aggregator(key, value); end
  def record_code_location(type, key, unit, timestamp, stacklevel: nil); end
  def run(force: nil); end
  def sanitize_key(key); end
  def sanitize_tag_key(key); end
  def sanitize_tag_value(value); end
  def sanitize_unit(unit); end
  def serialize_buckets(buckets); end
  def serialize_locations(timestamp, locations); end
  def serialize_tags(tags); end
  def thread; end
end
module Sentry::Rake
end
module Sentry::Rake::Application
  def display_error_message(ex); end
end
module Rake
end
class Rake::Application
end
module Sentry::Rack
end
class Sentry::Rack::CaptureExceptions
  def call(env); end
  def capture_exception(exception, env); end
  def collect_exception(env); end
  def finish_transaction(transaction, status_code); end
  def initialize(app); end
  def mechanism; end
  def start_transaction(env, scope); end
  def transaction_op; end
end
module Sentry::Utils::HttpTracing
  def propagate_trace?(url); end
  def record_sentry_breadcrumb(request_info, response_status); end
  def record_sentry_breadcrumb?; end
  def set_propagation_headers(req); end
  def set_span_info(sentry_span, request_info, response_status); end
end
module Sentry::Net
end
module Sentry::Net::HTTP
  def extract_request_info(req); end
  def from_sentry_sdk?; end
  def request(req, body = nil, &block); end
  include Sentry::Utils::HttpTracing
end
class Sentry::Redis
  def commands; end
  def commands_description; end
  def db; end
  def host; end
  def initialize(commands, host, port, db); end
  def instrument; end
  def parsed_commands; end
  def port; end
  def record_breadcrumb; end
  def server_description; end
end
module Sentry::Redis::OldClientPatch
  def logging(commands, &block); end
end
module Sentry::Redis::GlobalRedisInstrumentation
  def call(command, redis_config); end
  def call_pipelined(commands, redis_config); end
end
module Sentry::Puma
end
module Sentry::Puma::Server
  def lowlevel_error(e, env, status = nil); end
end
module Sentry::Faraday
end
module Sentry::Faraday::Connection
  def initialize(url = nil, options = nil); end
end
class Sentry::Faraday::Instrumenter
  def extract_request_info(env); end
  def instrument(op_name, env, &block); end
  include Sentry::Utils::HttpTracing
end
module Sentry::Integrable
  def capture_check_in(slug, status, **options, &block); end
  def capture_exception(exception, **options, &block); end
  def capture_message(message, **options, &block); end
  def integration_name; end
  def register_integration(name:, version:); end
end
