# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `sentry-sidekiq` gem.
# Please instead update this file by running `bin/tapioca gem sentry-sidekiq`.


# source://sentry-sidekiq//lib/sentry/sidekiq/version.rb#3
module Sentry; end

# source://sentry-sidekiq//lib/sentry/sidekiq/configuration.rb#4
class Sentry::Configuration
  # Returns the value of attribute sidekiq.
  #
  # source://sentry-sidekiq//lib/sentry/sidekiq/configuration.rb#5
  def sidekiq; end
end

# source://sentry-sidekiq//lib/sentry/sidekiq/version.rb#4
module Sentry::Sidekiq
  extend ::Sentry::Integrable
end

# source://sentry-sidekiq//lib/sentry/sidekiq/configuration.rb#19
class Sentry::Sidekiq::Configuration
  # @return [Configuration] a new instance of Configuration
  #
  # source://sentry-sidekiq//lib/sentry/sidekiq/configuration.rb#30
  def initialize; end

  # Whether we should inject headers while enqueuing the job in order to have a connected trace
  #
  # source://sentry-sidekiq//lib/sentry/sidekiq/configuration.rb#28
  def propagate_traces; end

  # Whether we should inject headers while enqueuing the job in order to have a connected trace
  #
  # source://sentry-sidekiq//lib/sentry/sidekiq/configuration.rb#28
  def propagate_traces=(_arg0); end

  # Set this option to true if you want Sentry to only capture the last job
  # retry if it fails.
  #
  # source://sentry-sidekiq//lib/sentry/sidekiq/configuration.rb#22
  def report_after_job_retries; end

  # Set this option to true if you want Sentry to only capture the last job
  # retry if it fails.
  #
  # source://sentry-sidekiq//lib/sentry/sidekiq/configuration.rb#22
  def report_after_job_retries=(_arg0); end

  # Only report jobs that don't have `dead: false` set in the job's `sidekiq_options`
  #
  # source://sentry-sidekiq//lib/sentry/sidekiq/configuration.rb#25
  def report_only_dead_jobs; end

  # Only report jobs that don't have `dead: false` set in the job's `sidekiq_options`
  #
  # source://sentry-sidekiq//lib/sentry/sidekiq/configuration.rb#25
  def report_only_dead_jobs=(_arg0); end
end

# source://sentry-sidekiq//lib/sentry/sidekiq/context_filter.rb#5
class Sentry::Sidekiq::ContextFilter
  # @return [ContextFilter] a new instance of ContextFilter
  #
  # source://sentry-sidekiq//lib/sentry/sidekiq/context_filter.rb#11
  def initialize(context); end

  # Returns the value of attribute context.
  #
  # source://sentry-sidekiq//lib/sentry/sidekiq/context_filter.rb#9
  def context; end

  # Once an ActiveJob is queued, ActiveRecord references get serialized into
  # some internal reserved keys, such as _aj_globalid.
  #
  # The problem is, if this job in turn gets queued back into ActiveJob with
  # these magic reserved keys, ActiveJob will throw up and error. We want to
  # capture these and mutate the keys so we can sanely report it.
  #
  # source://sentry-sidekiq//lib/sentry/sidekiq/context_filter.rb#22
  def filtered; end

  # source://sentry-sidekiq//lib/sentry/sidekiq/context_filter.rb#37
  def transaction_name; end

  private

  # source://sentry-sidekiq//lib/sentry/sidekiq/context_filter.rb#53
  def filter_context(hash); end

  # source://sentry-sidekiq//lib/sentry/sidekiq/context_filter.rb#68
  def filter_context_hash(key, value); end

  # @return [Boolean]
  #
  # source://sentry-sidekiq//lib/sentry/sidekiq/context_filter.rb#73
  def has_global_id?; end
end

# source://sentry-sidekiq//lib/sentry/sidekiq/context_filter.rb#6
Sentry::Sidekiq::ContextFilter::ACTIVEJOB_RESERVED_PREFIX_REGEX = T.let(T.unsafe(nil), Regexp)

# source://sentry-sidekiq//lib/sentry/sidekiq/context_filter.rb#7
Sentry::Sidekiq::ContextFilter::SIDEKIQ_NAME = T.let(T.unsafe(nil), String)

# source://sentry-sidekiq//lib/sentry/sidekiq/cron/helpers.rb#5
module Sentry::Sidekiq::Cron; end

# source://sentry-sidekiq//lib/sentry/sidekiq/cron/helpers.rb#6
module Sentry::Sidekiq::Cron::Helpers
  class << self
    # This is used by Cron::Job and Scheduler
    #
    # source://sentry-sidekiq//lib/sentry/sidekiq/cron/helpers.rb#8
    def monitor_config(cron); end
  end
end

# source://sentry-sidekiq//lib/sentry/sidekiq/cron/job.rb#14
module Sentry::Sidekiq::Cron::Job
  # source://sentry-sidekiq//lib/sentry/sidekiq/cron/job.rb#19
  def enqueue!(*args); end

  # source://sentry-sidekiq//lib/sentry/sidekiq/cron/job.rb#79
  def finish_transaction(transaction, status_code); end

  # source://sentry-sidekiq//lib/sentry/sidekiq/cron/job.rb#41
  def save; end

  # source://sentry-sidekiq//lib/sentry/sidekiq/cron/job.rb#70
  def start_transaction(scope); end

  class << self
    # source://sentry-sidekiq//lib/sentry/sidekiq/cron/job.rb#15
    def enqueueing_method; end
  end
end

# source://sentry-sidekiq//lib/sentry/sidekiq/error_handler.rb#7
class Sentry::Sidekiq::ErrorHandler
  # @param ex [Exception] the exception / error that occured
  # @param context [Hash or Array] Sidekiq error context
  # @param sidekiq_config [Sidekiq::Config, Hash] Sidekiq configuration,
  #   Defaults to nil.
  #   Sidekiq will pass the config in starting Sidekiq 7.1.5, see
  #   https://github.com/sidekiq/sidekiq/pull/6051
  #
  # source://sentry-sidekiq//lib/sentry/sidekiq/error_handler.rb#16
  def call(ex, context, sidekiq_config = T.unsafe(nil)); end

  private

  # Tries to fetch the retry limit from the job config first,
  # then falls back to Sidekiq's configuration.
  #
  # @return [Integer] the number of retries allowed for the job
  #
  # source://sentry-sidekiq//lib/sentry/sidekiq/error_handler.rb#70
  def retry_limit(context, sidekiq_config); end

  # @return [Boolean]
  #
  # source://sentry-sidekiq//lib/sentry/sidekiq/error_handler.rb#61
  def retryable?(context); end
end

# source://sentry-sidekiq//lib/sentry/sidekiq/error_handler.rb#8
Sentry::Sidekiq::ErrorHandler::WITH_SIDEKIQ_7 = T.let(T.unsafe(nil), TrueClass)

# source://sentry-sidekiq//lib/sentry/sidekiq/sentry_context_middleware.rb#7
module Sentry::Sidekiq::Helpers
  # source://sentry-sidekiq//lib/sentry/sidekiq/sentry_context_middleware.rb#18
  def calculate_latency(job); end

  # source://sentry-sidekiq//lib/sentry/sidekiq/sentry_context_middleware.rb#27
  def now_in_ms; end

  # source://sentry-sidekiq//lib/sentry/sidekiq/sentry_context_middleware.rb#8
  def set_span_data(span, id:, queue:, latency: T.unsafe(nil), retry_count: T.unsafe(nil)); end
end

# source://sentry-sidekiq//lib/sentry/sidekiq/configuration.rb#14
Sentry::Sidekiq::IGNORE_DEFAULT = T.let(T.unsafe(nil), Array)

# source://sentry-sidekiq//lib/sentry-sidekiq.rb#18
class Sentry::Sidekiq::Railtie < ::Rails::Railtie; end

# source://sentry-sidekiq//lib/sentry/sidekiq/sentry_context_middleware.rb#105
class Sentry::Sidekiq::SentryContextClientMiddleware
  include ::Sentry::Sidekiq::Helpers

  # source://sentry-sidekiq//lib/sentry/sidekiq/sentry_context_middleware.rb#108
  def call(worker_class, job, queue, _redis_pool); end
end

# source://sentry-sidekiq//lib/sentry/sidekiq/sentry_context_middleware.rb#32
class Sentry::Sidekiq::SentryContextServerMiddleware
  include ::Sentry::Sidekiq::Helpers

  # source://sentry-sidekiq//lib/sentry/sidekiq/sentry_context_middleware.rb#81
  def build_tags(tags); end

  # source://sentry-sidekiq//lib/sentry/sidekiq/sentry_context_middleware.rb#38
  def call(worker, job, queue); end

  # source://sentry-sidekiq//lib/sentry/sidekiq/sentry_context_middleware.rb#97
  def finish_transaction(transaction, status); end

  # source://sentry-sidekiq//lib/sentry/sidekiq/sentry_context_middleware.rb#85
  def start_transaction(scope, env); end
end

# source://sentry-sidekiq//lib/sentry/sidekiq/sentry_context_middleware.rb#35
Sentry::Sidekiq::SentryContextServerMiddleware::OP_NAME = T.let(T.unsafe(nil), String)

# source://sentry-sidekiq//lib/sentry/sidekiq/sentry_context_middleware.rb#36
Sentry::Sidekiq::SentryContextServerMiddleware::SPAN_ORIGIN = T.let(T.unsafe(nil), String)

# source://sentry-sidekiq//lib/sentry/sidekiq/version.rb#5
Sentry::Sidekiq::VERSION = T.let(T.unsafe(nil), String)
