# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `sexp_processor` gem.
# Please instead update this file by running `bin/tapioca gem sexp_processor`.


class Object < ::BasicObject
  include ::Kernel
  include ::PP::ObjectMixin

  private

  # source://sexp_processor//lib/sexp.rb#391
  def s(*args, &blk); end
end

# source://sexp_processor//lib/sexp.rb#11
class Sexp < ::Array
  # Create a new Sexp containing +args+.
  #
  # @return [Sexp] a new instance of Sexp
  #
  # source://sexp_processor//lib/sexp.rb#35
  def initialize(*args); end

  # Verifies that +pattern+ is a Matcher and then dispatches to its #/
  # method.
  #
  # TODO: rename grep? match_all ? find_all ?
  #
  # @raise [ArgumentError]
  #
  # source://sexp_processor//lib/sexp_matcher.rb#30
  def /(pattern); end

  # source://sexp_processor//lib/sexp.rb#76
  def ==(obj); end

  # Verifies that +pattern+ is a Matcher and then dispatches to its
  # #=~ method.
  #
  # See Matcher.=~
  #
  # @raise [ArgumentError]
  #
  # source://sexp_processor//lib/sexp_matcher.rb#8
  def =~(pattern); end

  def _concat(*_arg0); end

  # Returns true if the node_type is +array+ or +args+.
  #
  # REFACTOR: to TypedSexp - we only care when we have units.
  #
  # @return [Boolean]
  #
  # source://sexp_processor//lib/sexp.rb#93
  def array_type?; end

  # source://ruby_parser/3.21.1/lib/rp_extensions.rb#47
  def block_pass?; end

  # source://ruby_parser/3.21.1/lib/ruby_parser_extras.rb#12
  def check_line_numbers; end

  # Optional comments above/aside this sexp. Usually set by ruby_parser.
  #
  # source://sexp_processor//lib/sexp.rb#28
  def comments; end

  # Optional comments above/aside this sexp. Usually set by ruby_parser.
  #
  # source://sexp_processor//lib/sexp.rb#28
  def comments=(_arg0); end

  # source://sexp_processor//lib/sexp.rb#99
  def compact; end

  # Recursively enumerates the sexp yielding to +block+ for every sub-Sexp.
  #
  # Returning :skip will stop traversing that subtree:
  #
  #   sexp.deep_each do |s|
  #     next :skip if s.sexp_type == :if
  #     # ...
  #   end
  #
  # source://sexp_processor//lib/sexp.rb#113
  def deep_each(&block); end

  # Return the maximum depth of the sexp. One-based.
  #
  # source://sexp_processor//lib/sexp.rb#125
  def depth; end

  # Enumeratates the sexp yielding to +b+ when the node_type == +t+.
  #
  # source://sexp_processor//lib/sexp.rb#132
  def each_of_type(t, &b); end

  # Enumerates all sub-sexps skipping non-Sexp elements.
  #
  # source://sexp_processor//lib/sexp.rb#144
  def each_sexp; end

  # @return [Boolean]
  #
  # source://sexp_processor//lib/sexp.rb#80
  def eql?(o); end

  # Accessors for the file. Usually set by ruby_parser.
  #
  # source://sexp_processor//lib/sexp.rb#23
  def file; end

  # Accessors for the file. Usually set by ruby_parser.
  #
  # source://sexp_processor//lib/sexp.rb#23
  def file=(_arg0); end

  # Replaces all elements whose node_type is +from+ with +to+. Used
  # only for the most trivial of rewrites.
  #
  # source://sexp_processor//lib/sexp.rb#158
  def find_and_replace_all(from, to); end

  # source://sexp_processor//lib/sexp.rb#199
  def find_node(name, delete = T.unsafe(nil)); end

  # Find every node with type +name+.
  #
  # source://sexp_processor//lib/sexp.rb#217
  def find_nodes(name); end

  # Replaces all Sexps matching +pattern+ with Sexp +repl+.
  #
  # source://sexp_processor//lib/sexp.rb#171
  def gsub(pattern, repl); end

  # source://sexp_processor//lib/sexp.rb#84
  def hash; end

  # Returns the node type of the Sexp.
  #
  # source://sexp_processor//lib/sexp.rb#284
  def head; end

  # source://sexp_processor//lib/sexp.rb#190
  def inspect; end

  # If passed a line number, sets the line and returns self. Otherwise
  # returns the line number. This allows you to do message cascades
  # and still get the sexp back.
  #
  # source://sexp_processor//lib/sexp.rb#228
  def line(n = T.unsafe(nil)); end

  # A setter for the line this sexp was found on. Usually set by ruby_parser.
  #
  # source://sexp_processor//lib/sexp.rb#13
  def line=(_arg0); end

  # Returns the maximum line number of the children of self.
  #
  # source://sexp_processor//lib/sexp.rb#241
  def line_max; end

  # Set the maximum line number for this sexp. Often set by ruby_parser.
  #
  # source://sexp_processor//lib/sexp.rb#18
  def line_max=(_arg0); end

  # source://ruby_parser/3.21.1/lib/ruby_parser_extras.rb#23
  def line_min; end

  # source://sexp_processor//lib/sexp.rb#72
  def map(&blk); end

  # Returns the size of the sexp, flattened.
  #
  # source://sexp_processor//lib/sexp.rb#248
  def mass; end

  # Returns the node named +node+, deleting it if +delete+ is true.
  #
  # source://sexp_processor//lib/sexp.rb#255
  def method_missing(meth, delete = T.unsafe(nil)); end

  # Creates a new sexp with the new contents of +body+, but with the
  # same +file+, +line+, and +comment+ as self.
  #
  # source://sexp_processor//lib/sexp.rb#63
  def new(*body); end

  # source://ruby_parser/3.21.1/lib/ruby_parser_extras.rb#27
  def nil_line?; end

  # source://ruby_parser/3.21.1/lib/rp_extensions.rb#43
  def paren; end

  # source://ruby_parser/3.21.1/lib/rp_extensions.rb#41
  def paren=(_arg0); end

  # source://sexp_processor//lib/sexp.rb#272
  def pretty_print(q); end

  # Recursively searches for the +pattern+ yielding each match, and
  # replacing it with the result of the block.
  #
  # @raise [ArgumentError]
  #
  # source://sexp_processor//lib/sexp_matcher.rb#57
  def replace_sexp(pattern, &block); end

  # @return [Boolean]
  #
  # source://sexp_processor//lib/sexp.rb#267
  def respond_to?(msg, private = T.unsafe(nil)); end

  # Returns the Sexp body (starting at +from+, defaulting to 1), ie
  # the values without the node type.
  #
  # source://sexp_processor//lib/sexp.rb#299
  def rest(from = T.unsafe(nil)); end

  # Verifies that +pattern+ is a Matcher and then dispatches to its
  # #satisfy? method.
  #
  # TODO: rename match?
  #
  # @raise [ArgumentError]
  # @return [Boolean]
  #
  # source://sexp_processor//lib/sexp_matcher.rb#19
  def satisfy?(pattern); end

  # Recursively searches for the +pattern+ yielding the matches.
  #
  # @raise [ArgumentError]
  #
  # source://sexp_processor//lib/sexp_matcher.rb#38
  def search_each(pattern, &block); end

  # Returns the Sexp body (starting at +from+, defaulting to 1), ie
  # the values without the node type.
  #
  # source://sexp_processor//lib/sexp.rb#299
  def sexp_body(from = T.unsafe(nil)); end

  # Sets the Sexp body to new content.
  #
  # source://sexp_processor//lib/sexp.rb#306
  def sexp_body=(v); end

  # Returns the node type of the Sexp.
  #
  # source://sexp_processor//lib/sexp.rb#284
  def sexp_type; end

  # Sets the node type of the Sexp.
  #
  # source://sexp_processor//lib/sexp.rb#291
  def sexp_type=(v); end

  # Returns the bare bones structure of the sexp.
  # s(:a, :b, s(:c, :d), :e) => s(:a, s(:c))
  #
  # source://sexp_processor//lib/sexp.rb#326
  def structure; end

  # Replaces the Sexp matching +pattern+ with +repl+.
  #
  # source://sexp_processor//lib/sexp.rb#338
  def sub(pattern, repl); end

  # source://sexp_processor//lib/sexp.rb#368
  def to_a; end

  # source://sexp_processor//lib/sexp.rb#190
  def to_s; end

  # Return the value (last item) of a single element sexp (eg `s(:lit, 42)`).
  #
  # source://sexp_processor//lib/sexp.rb#377
  def value; end

  class << self
    # Matches when sub-expression does not match.
    #
    # This is also available via Matcher#-@.
    #
    # See Not for examples.
    #
    # @return [Boolean]
    #
    # source://sexp_processor//lib/sexp_matcher.rb#155
    def -(arg); end

    # Matches any single item.
    #
    # See Wild for examples.
    #
    # source://sexp_processor//lib/sexp_matcher.rb#93
    def _; end

    # Matches all remaining input.
    #
    # See Remaining for examples.
    #
    # source://sexp_processor//lib/sexp_matcher.rb#104
    def ___; end

    # Matches only when all sub-expressions match.
    #
    # This is also available via Matcher#&.
    #
    # See All for examples.
    #
    # source://sexp_processor//lib/sexp_matcher.rb#144
    def all(*args); end

    # Matches when any of the sub-expressions match.
    #
    # This is also available via Matcher#|.
    #
    # See Any for examples.
    #
    # source://sexp_processor//lib/sexp_matcher.rb#133
    def any(*args); end

    # Matches any atom.
    #
    # See Atom for examples.
    #
    # source://sexp_processor//lib/sexp_matcher.rb#122
    def atom; end

    # Matches anything that has a child matching the sub-expression.
    #
    # See Child for examples.
    #
    # source://sexp_processor//lib/sexp_matcher.rb#170
    def child(child); end

    # Creates a new Sexp from Array +a+.
    #
    # source://sexp_processor//lib/sexp.rb#44
    def from_array(a); end

    # Matches an expression or any expression that includes the child.
    #
    # See Include for examples.
    #
    # source://sexp_processor//lib/sexp_matcher.rb#113
    def include(child); end

    # Matches an atom of the specified +klass+ (or module).
    #
    # See Pattern for examples.
    #
    # source://sexp_processor//lib/sexp_matcher.rb#208
    def k(klass); end

    # Matches any atom who's string representation matches the patterns
    # passed in.
    #
    # See Pattern for examples.
    #
    # source://sexp_processor//lib/sexp_matcher.rb#190
    def m(*values); end

    # Matches when sub-expression does not match.
    #
    # This is also available via Matcher#-@.
    #
    # See Not for examples.
    #
    # @return [Boolean]
    #
    # source://sexp_processor//lib/sexp_matcher.rb#155
    def not?(arg); end

    # Matches an S-Expression.
    #
    # See Matcher for examples.
    #
    # source://sexp_processor//lib/sexp_matcher.rb#78
    def q(*args); end

    # source://sexp_processor//lib/sexp_matcher.rb#82
    def s(*args); end

    # Matches anything having the same sexp_type, which is the first
    # value in a Sexp.
    #
    # See Type for examples.
    #
    # source://sexp_processor//lib/sexp_matcher.rb#180
    def t(name); end
  end
end

# Matches only when all sub-expressions match.
#
# This is also available via Matcher#&.
#
# examples:
#
#   s(:a)     / s{ all(s(:a), s(:b)) }    #=> []
#   s(:a, :b) / s{ t(:a) & include(:b)) } #=> [s(:a, :b)]
#
# source://sexp_processor//lib/sexp_matcher.rb#647
class Sexp::All < ::Sexp::Matcher
  # Create an All matcher which will match all of the +options+.
  #
  # @return [All] a new instance of All
  #
  # source://sexp_processor//lib/sexp_matcher.rb#656
  def initialize(*options); end

  # source://sexp_processor//lib/sexp_matcher.rb#669
  def ==(o); end

  # source://sexp_processor//lib/sexp_matcher.rb#673
  def inspect; end

  # The collection of sub-matchers to match against.
  #
  # source://sexp_processor//lib/sexp_matcher.rb#651
  def options; end

  # source://sexp_processor//lib/sexp_matcher.rb#677
  def pretty_print(q); end

  # Satisfied when all sub expressions match +o+
  #
  # @return [Boolean]
  #
  # source://sexp_processor//lib/sexp_matcher.rb#663
  def satisfy?(o); end
end

# Matches when any of the sub-expressions match.
#
# This is also available via Matcher#|.
#
# examples:
#
#   s(:a) / s{ any(s(:a), s(:b)) } #=> [s(:a)]
#   s(:a) / s{     s(:a) | s(:b) } #=> [s(:a)] # same thing via |
#   s(:a) / s{ any(s(:b), s(:c)) } #=> []
#
# source://sexp_processor//lib/sexp_matcher.rb#598
class Sexp::Any < ::Sexp::Matcher
  # Create an Any matcher which will match any of the +options+.
  #
  # @return [Any] a new instance of Any
  #
  # source://sexp_processor//lib/sexp_matcher.rb#607
  def initialize(*options); end

  # source://sexp_processor//lib/sexp_matcher.rb#620
  def ==(o); end

  # source://sexp_processor//lib/sexp_matcher.rb#624
  def inspect; end

  # The collection of sub-matchers to match against.
  #
  # source://sexp_processor//lib/sexp_matcher.rb#602
  def options; end

  # source://sexp_processor//lib/sexp_matcher.rb#628
  def pretty_print(q); end

  # Satisfied when any sub expressions match +o+
  #
  # @return [Boolean]
  #
  # source://sexp_processor//lib/sexp_matcher.rb#614
  def satisfy?(o); end
end

# Matches any atom (non-Sexp).
#
# examples:
#
#   s(:a)        / s{ s(atom) } #=> [s(:a)]
#   s(:a, s(:b)) / s{ s(atom) } #=> [s(:b)]
#
# source://sexp_processor//lib/sexp_matcher.rb#790
class Sexp::Atom < ::Sexp::Matcher
  # source://sexp_processor//lib/sexp_matcher.rb#798
  def inspect; end

  # source://sexp_processor//lib/sexp_matcher.rb#802
  def pretty_print(q); end

  # Satisfied when +o+ is an atom.
  #
  # @return [Boolean]
  #
  # source://sexp_processor//lib/sexp_matcher.rb#794
  def satisfy?(o); end
end

# Matches anything that has a child matching the sub-expression
#
# example:
#
#   s(s(s(s(s(:a))))) / s{ child(s(:a)) } #=> [s(s(s(s(s(:a))))),
#                                              s(s(s(s(:a)))),
#                                              s(s(s(:a))),
#                                              s(s(:a)),
#                                              s(:a)]
#
# source://sexp_processor//lib/sexp_matcher.rb#744
class Sexp::Child < ::Sexp::Matcher
  # Create a Child matcher which will match anything having a
  # descendant matching +child+.
  #
  # @return [Child] a new instance of Child
  #
  # source://sexp_processor//lib/sexp_matcher.rb#754
  def initialize(child); end

  # source://sexp_processor//lib/sexp_matcher.rb#767
  def ==(o); end

  # The child to match.
  #
  # source://sexp_processor//lib/sexp_matcher.rb#748
  def child; end

  # source://sexp_processor//lib/sexp_matcher.rb#771
  def inspect; end

  # source://sexp_processor//lib/sexp_matcher.rb#775
  def pretty_print(q); end

  # Satisfied if matches +child+ or +o+ has a descendant matching
  # +child+.
  #
  # @return [Boolean]
  #
  # source://sexp_processor//lib/sexp_matcher.rb#762
  def satisfy?(o); end
end

# Matches an expression or any expression that includes the child.
#
# examples:
#
#   s(:a, :b)   / s{ include(:b) } #=> [s(:a, :b)]
#   s(s(s(:a))) / s{ include(:a) } #=> [s(:a)]
#
# source://sexp_processor//lib/sexp_matcher.rb#938
class Sexp::Include < ::Sexp::Matcher
  # Creates a Matcher which will match any Sexp that contains the
  # +value+.
  #
  # @return [Include] a new instance of Include
  #
  # source://sexp_processor//lib/sexp_matcher.rb#948
  def initialize(value); end

  # source://sexp_processor//lib/sexp_matcher.rb#963
  def ==(o); end

  # source://sexp_processor//lib/sexp_matcher.rb#967
  def inspect; end

  # source://sexp_processor//lib/sexp_matcher.rb#971
  def pretty_print(q); end

  # Satisfied if a +o+ is a Sexp and one of +o+'s elements matches
  # value
  #
  # @return [Boolean]
  #
  # source://sexp_processor//lib/sexp_matcher.rb#956
  def satisfy?(o); end

  # The value that should be included in the match.
  #
  # source://sexp_processor//lib/sexp_matcher.rb#942
  def value; end
end

# Matches any atom that is an instance of the specified class or module.
#
# examples:
#
#   s(:lit, 6.28) / s{ q(:lit, k(Float)) }                   #=> [s(:lit, 6.28)]
#
# source://sexp_processor//lib/sexp_matcher.rb#871
class Sexp::Klass < ::Sexp::Pattern
  # source://sexp_processor//lib/sexp_matcher.rb#876
  def inspect; end

  # source://sexp_processor//lib/sexp_matcher.rb#880
  def pretty_print(q); end

  # @return [Boolean]
  #
  # source://sexp_processor//lib/sexp_matcher.rb#872
  def satisfy?(o); end
end

# Wraps the results of a Sexp query. MatchCollection defines
# MatchCollection#/ so that you can chain queries.
#
# For instance:
#   res = s(:a, s(:b)) / s{ s(:a,_) } / s{ s(:b) }
#
# source://sexp_processor//lib/sexp_matcher.rb#1078
class Sexp::MatchCollection < ::Array
  # See Traverse#search
  #
  # source://sexp_processor//lib/sexp_matcher.rb#1082
  def /(pattern); end

  # source://sexp_processor//lib/sexp_matcher.rb#1088
  def inspect; end

  # source://sexp_processor//lib/sexp_matcher.rb#1094
  def pretty_print(q); end

  # source://sexp_processor//lib/sexp_matcher.rb#1088
  def to_s; end
end

# Defines a family of objects that can be used to match sexps to
# certain types of patterns, much like regexps can be used on
# strings. Generally you won't use this class directly.
#
# You would normally create a matcher using the top-level #s method,
# but with a block, calling into the Sexp factory methods. For example:
#
#   s{ s(:class, m(/^Test/), _, ___) }
#
# This creates a matcher for classes whose names start with "Test".
# It uses Sexp.m to create a Sexp::Matcher::Pattern matcher, Sexp._
# to create a Sexp::Matcher::Wild matcher, and Sexp.___ to create a
# Sexp::Matcher::Remaining matcher. It works like this:
#
#   s{              # start to create a pattern
#     s(            # create a sexp matcher
#       :class.     # for class nodes
#       m(/^Test/), # matching name slots that start with "Test"
#       _,          # any superclass value
#       ___         # and whatever is in the class
#      )
#    }
#
# Then you can use that with #=~, #/, Sexp#replace_sexp, and others.
#
# For more examples, see the various Sexp class methods, the examples,
# and the tests supplied with Sexp.
#
# * For pattern creation, see factory methods: Sexp::_, Sexp::___, etc.
# * For matching returning truthy/falsey results, see Sexp#=~.
# * For case expressions, see Matcher#===.
# * For getting all subtree matches, see Sexp#/.
#
# If rdoc didn't suck, these would all be links.
#
# source://sexp_processor//lib/sexp_matcher.rb#248
class Sexp::Matcher < ::Sexp
  # Combines the Matcher with another Matcher, the resulting one will
  # be satisfied only if both Matchers would be satisfied.
  #
  # TODO: redirect
  # Example:
  #   t(:a) & include(:b)
  #
  # source://sexp_processor//lib/sexp_matcher.rb#341
  def &(other); end

  # Returns a Matcher that matches whenever this Matcher would not have matched
  #
  # Example:
  #   -s(:a)
  #
  # source://sexp_processor//lib/sexp_matcher.rb#351
  def -@; end

  # Searches through +sexp+ for all sub-trees that match this
  # matcher and returns a MatchCollection for each match.
  #
  # TODO: redirect?
  # Example:
  #   Q{ s(:b) } / s(:a, s(:b)) => [s(:b)]
  #
  # @raise [ArgumentError]
  #
  # source://sexp_processor//lib/sexp_matcher.rb#314
  def /(sexp); end

  # Tree equivalent to String#=~, returns true if +self+ matches
  # +sexp+ as a whole or in a sub-tree (if +match_subs?+).
  #
  # TODO: maybe this should NOT be aliased to === ?
  #
  # TODO: example
  # TODO?: alias === satisfy?
  #
  # @raise [ArgumentError]
  #
  # source://sexp_processor//lib/sexp_matcher.rb#297
  def ===(sexp); end

  # Tree equivalent to String#=~, returns true if +self+ matches
  # +sexp+ as a whole or in a sub-tree (if +match_subs?+).
  #
  # TODO: maybe this should NOT be aliased to === ?
  #
  # TODO: example
  #
  # @raise [ArgumentError]
  #
  # source://sexp_processor//lib/sexp_matcher.rb#297
  def =~(sexp); end

  # Returns a Matcher that matches if this has a sibling +o+
  #
  # Example:
  #   s(:a) >> s(:b)
  #
  # source://sexp_processor//lib/sexp_matcher.rb#361
  def >>(other); end

  # Is this matcher greedy? Defaults to false.
  #
  # @return [Boolean]
  #
  # source://sexp_processor//lib/sexp_matcher.rb#368
  def greedy?; end

  # source://sexp_processor//lib/sexp_matcher.rb#372
  def inspect; end

  # source://sexp_processor//lib/sexp_matcher.rb#378
  def pretty_print(q); end

  # Does this matcher actually match +o+? Returns falsey if +o+ is
  # not a Sexp or if any sub-tree of +o+ is not satisfied by or
  # equal to its corresponding sub-matcher.
  #
  # --
  # TODO: push this up to Sexp and make this the workhorse
  # TODO: do the same with ===/satisfy?
  #
  # @return [Boolean]
  #
  # source://sexp_processor//lib/sexp_matcher.rb#274
  def satisfy?(o); end

  # Combines the Matcher with another Matcher, the resulting one will
  # be satisfied if either Matcher would be satisfied.
  #
  # TODO: redirect
  # Example:
  #   s(:a) | s(:b)
  #
  # source://sexp_processor//lib/sexp_matcher.rb#329
  def |(other); end

  class << self
    # Setter for +match_subs?+.
    #
    # source://sexp_processor//lib/sexp_matcher.rb#259
    def match_subs=(o); end

    # Should #=~ match sub-trees?
    #
    # @return [Boolean]
    #
    # source://sexp_processor//lib/sexp_matcher.rb#252
    def match_subs?; end

    # Parse a lispy string representation of a matcher into a Matcher.
    # See +Parser+.
    #
    # source://sexp_processor//lib/sexp_matcher.rb#390
    def parse(s); end
  end
end

# Converts from a lispy string to Sexp matchers in a safe manner.
#
#   "(a 42 _ (c) [t x] ___)" => s{ s(:a, 42, _, s(:c), t(:x), ___) }
#
# source://sexp_processor//lib/sexp_matcher.rb#399
class Sexp::Matcher::Parser
  # Create a new Parser instance on +s+
  #
  # @return [Parser] a new instance of Parser
  #
  # source://sexp_processor//lib/sexp_matcher.rb#409
  def initialize(s); end

  # Converts +s+ into a stream of tokens and adds them to +tokens+.
  #
  # source://sexp_processor//lib/sexp_matcher.rb#416
  def lex(s); end

  # Returns the next token and removes it from the stream or raises if empty.
  #
  # @raise [SyntaxError]
  #
  # source://sexp_processor//lib/sexp_matcher.rb#423
  def next_token; end

  # Parses tokens and returns a +Matcher+ instance.
  #
  # source://sexp_processor//lib/sexp_matcher.rb#438
  def parse; end

  # Parses a balanced command. A command is denoted by square
  # brackets and must conform to a whitelisted set of allowed
  # commands (see +ALLOWED+).
  #
  # @raise [SyntaxError]
  #
  # source://sexp_processor//lib/sexp_matcher.rb#515
  def parse_cmd; end

  # Parses a balanced list of expressions and returns the
  # equivalent matcher.
  #
  # source://sexp_processor//lib/sexp_matcher.rb#496
  def parse_list; end

  # Parses a string into a sexp matcher:
  #
  #   SEXP : "(" SEXP:args* ")"          => Sexp.q(*args)
  #        | "[" CMD:cmd sexp:args* "]"  => Sexp.cmd(*args)
  #        | "nil"                       => nil
  #        | /\d+/:n                     => n.to_i
  #        | "___"                       => Sexp.___
  #        | "_"                         => Sexp._
  #        | /^\/(.*)\/$/:re             => Regexp.new re[0]
  #        | /^"(.*)"$/:s                => String.new s[0]
  #        | UP_NAME:name                => Object.const_get name
  #        | NAME:name                   => name.to_sym
  # UP_NAME: /[A-Z]\w*/
  #   NAME : /:?[\w?!=~-]+/
  #    CMD : t | k | m | atom | not? | - | any | child | include
  #
  # source://sexp_processor//lib/sexp_matcher.rb#460
  def parse_sexp; end

  # Returns the next token without removing it from the stream.
  #
  # source://sexp_processor//lib/sexp_matcher.rb#431
  def peek_token; end

  # The stream of tokens to parse. See #lex.
  #
  # source://sexp_processor//lib/sexp_matcher.rb#404
  def tokens; end

  # The stream of tokens to parse. See #lex.
  #
  # source://sexp_processor//lib/sexp_matcher.rb#404
  def tokens=(_arg0); end
end

# A collection of allowed commands to convert into matchers.
#
# source://sexp_processor//lib/sexp_matcher.rb#508
Sexp::Matcher::Parser::ALLOWED = T.let(T.unsafe(nil), Array)

# Matches when sub-expression does not match.
#
# This is also available via Matcher#-@.
#
# examples:
#
#   s(:a) / s{ not?(s(:b)) } #=> [s(:a)]
#   s(:a) / s{ -s(:b) }      #=> [s(:a)]
#   s(:a) / s{ s(not? :a) } #=> []
#
# source://sexp_processor//lib/sexp_matcher.rb#697
class Sexp::Not < ::Sexp::Matcher
  # Creates a Matcher which will match any Sexp that does not match the +value+
  #
  # @return [Not] a new instance of Not
  #
  # source://sexp_processor//lib/sexp_matcher.rb#707
  def initialize(value); end

  # source://sexp_processor//lib/sexp_matcher.rb#711
  def ==(o); end

  # source://sexp_processor//lib/sexp_matcher.rb#722
  def inspect; end

  # source://sexp_processor//lib/sexp_matcher.rb#726
  def pretty_print(q); end

  # Satisfied if a +o+ does not match the +value+
  #
  # @return [Boolean]
  #
  # source://sexp_processor//lib/sexp_matcher.rb#718
  def satisfy?(o); end

  # The value to negate in the match.
  #
  # source://sexp_processor//lib/sexp_matcher.rb#702
  def value; end
end

# Matches any atom who's string representation matches the patterns
# passed in.
#
# examples:
#
#   s(:a) / s{ m('a') }                                      #=> [s(:a)]
#   s(:a) / s{ m(/\w/,/\d/) }                                #=> [s(:a)]
#   s(:tests, s(s(:test_a), s(:test_b))) / s{ m(/test_\w/) } #=> [s(:test_a),
#
# TODO: maybe don't require non-sexps? This does respond to =~ now.
#
# source://sexp_processor//lib/sexp_matcher.rb#819
class Sexp::Pattern < ::Sexp::Matcher
  # Create a Patten matcher which will match any atom that either
  # matches the input +pattern+.
  #
  # @return [Pattern] a new instance of Pattern
  #
  # source://sexp_processor//lib/sexp_matcher.rb#834
  def initialize(pattern); end

  # source://sexp_processor//lib/sexp_matcher.rb#826
  def ==(o); end

  # @return [Boolean]
  #
  # source://sexp_processor//lib/sexp_matcher.rb#855
  def eql?(o); end

  # source://sexp_processor//lib/sexp_matcher.rb#859
  def hash; end

  # source://sexp_processor//lib/sexp_matcher.rb#845
  def inspect; end

  # The regexp to match for the pattern.
  #
  # source://sexp_processor//lib/sexp_matcher.rb#824
  def pattern; end

  # source://sexp_processor//lib/sexp_matcher.rb#849
  def pretty_print(q); end

  # Satisfied if +o+ is an atom, and +o+ matches +pattern+
  #
  # @return [Boolean]
  #
  # source://sexp_processor//lib/sexp_matcher.rb#841
  def satisfy?(o); end
end

# Matches all remaining input. If remaining comes before any other
# matchers, they will be ignored.
#
# examples:
#
#   s(:a)         / s{ s(:a, ___ ) } #=> [s(:a)]
#   s(:a, :b, :c) / s{ s(:a, ___ ) } #=> [s(:a, :b, :c)]
#
# source://sexp_processor//lib/sexp_matcher.rb#566
class Sexp::Remaining < ::Sexp::Matcher
  # @return [Boolean]
  #
  # source://sexp_processor//lib/sexp_matcher.rb#574
  def greedy?; end

  # source://sexp_processor//lib/sexp_matcher.rb#578
  def inspect; end

  # source://sexp_processor//lib/sexp_matcher.rb#582
  def pretty_print(q); end

  # Always satisfied once this is reached. Think of it as a var arg.
  #
  # @return [Boolean]
  #
  # source://sexp_processor//lib/sexp_matcher.rb#570
  def satisfy?(o); end
end

# See Matcher for sibling relations: <,<<,>>,>
#
# source://sexp_processor//lib/sexp_matcher.rb#981
class Sexp::Sibling < ::Sexp::Matcher
  # Creates a Matcher which will match any pair of Sexps that are siblings.
  # Defaults to matching the immediate following sibling.
  #
  # @return [Sibling] a new instance of Sibling
  #
  # source://sexp_processor//lib/sexp_matcher.rb#1002
  def initialize(subject, sibling, distance = T.unsafe(nil)); end

  # source://sexp_processor//lib/sexp_matcher.rb#1027
  def ==(o); end

  # An optional distance requirement for the matcher.
  #
  # source://sexp_processor//lib/sexp_matcher.rb#996
  def distance; end

  # source://sexp_processor//lib/sexp_matcher.rb#1034
  def inspect; end

  # source://sexp_processor//lib/sexp_matcher.rb#1038
  def pretty_print(q); end

  # Satisfied if o contains +subject+ followed by +sibling+
  #
  # @return [Boolean]
  #
  # source://sexp_processor//lib/sexp_matcher.rb#1011
  def satisfy?(o); end

  # The RHS of the matcher.
  #
  # source://sexp_processor//lib/sexp_matcher.rb#991
  def sibling; end

  # The LHS of the matcher.
  #
  # source://sexp_processor//lib/sexp_matcher.rb#986
  def subject; end

  private

  # source://sexp_processor//lib/sexp_matcher.rb#1056
  def index_matches(pattern, o); end
end

# Matches anything having the same sexp_type, which is the first
# value in a Sexp.
#
# examples:
#
#   s(:a, :b) / s{ t(:a) }        #=> [s(:a, :b)]
#   s(:a, :b) / s{ t(:b) }        #=> []
#   s(:a, s(:b, :c)) / s{ t(:b) } #=> [s(:b, :c)]
#
# source://sexp_processor//lib/sexp_matcher.rb#897
class Sexp::Type < ::Sexp::Matcher
  # Creates a Matcher which will match any Sexp who's type is +type+, where a type is
  # the first element in the Sexp.
  #
  # @return [Type] a new instance of Type
  #
  # source://sexp_processor//lib/sexp_matcher.rb#904
  def initialize(type); end

  # source://sexp_processor//lib/sexp_matcher.rb#908
  def ==(o); end

  # source://sexp_processor//lib/sexp_matcher.rb#919
  def inspect; end

  # source://sexp_processor//lib/sexp_matcher.rb#923
  def pretty_print(q); end

  # Satisfied if the sexp_type of +o+ is +type+.
  #
  # @return [Boolean]
  #
  # source://sexp_processor//lib/sexp_matcher.rb#915
  def satisfy?(o); end

  # Returns the value of attribute sexp_type.
  #
  # source://sexp_processor//lib/sexp_matcher.rb#898
  def sexp_type; end
end

# source://sexp_processor//lib/sexp.rb#221
Sexp::UNASSIGNED = T.let(T.unsafe(nil), Object)

# Matches any single item.
#
# examples:
#
#   s(:a)           / s{ _ }    #=> [s(:a)]
#   s(:a, s(s(:b))) / s{ s(_) } #=> [s(s(:b))]
#
# source://sexp_processor//lib/sexp_matcher.rb#540
class Sexp::Wild < ::Sexp::Matcher
  # source://sexp_processor//lib/sexp_matcher.rb#548
  def inspect; end

  # source://sexp_processor//lib/sexp_matcher.rb#552
  def pretty_print(q); end

  # Matches any single element.
  #
  # @return [Boolean]
  #
  # source://sexp_processor//lib/sexp_matcher.rb#544
  def satisfy?(o); end
end
