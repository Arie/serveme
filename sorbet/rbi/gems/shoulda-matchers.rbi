# This file is autogenerated. Do not edit it by hand. Regenerate it with:
#   srb rbi gems

# typed: true
#
# If you would like to make changes to this file, great! Please create the gem's shim here:
#
#   https://github.com/sorbet/sorbet-typed/new/master?filename=lib/shoulda-matchers/all/shoulda-matchers.rbi
#
# shoulda-matchers-6.3.1

module Shoulda
end
module Shoulda::Matchers
  def self.assertion_exception_class; end
  def self.assertion_exception_class=(arg0); end
  def self.configuration; end
  def self.configure; end
  def self.integrations; end
  def self.warn(message); end
  def self.warn_about_deprecated_method(old_method, new_method); end
  extend Shoulda::Matchers::WordWrap
end
class Shoulda::Matchers::Configuration
  def initialize; end
  def integrate(&block); end
  def integrations; end
end
module Shoulda::Matchers::Doublespeak
  def self.debug(&block); end
  def self.debugging_enabled?; end
  def self.double_collection_for(*args, **, &block); end
  def self.with_doubles_activated(*args, **, &block); end
  def self.world; end
end
class Shoulda::Matchers::Doublespeak::Double
  def activate; end
  def activated?; end
  def call_original_method(call); end
  def calls; end
  def deactivate; end
  def implementation; end
  def initialize(world, klass, method_name, implementation); end
  def klass; end
  def method_name; end
  def original_method; end
  def record_call(call); end
  def replace_method_with_double; end
  def restore_original_method; end
  def store_original_method; end
  def to_return(value = nil, &block); end
  def world; end
end
class Shoulda::Matchers::Doublespeak::DoubleCollection
  def activate; end
  def calls_by_method_name; end
  def calls_to(method_name); end
  def deactivate; end
  def doubles_by_method_name; end
  def initialize(world, klass); end
  def klass; end
  def register_double(method_name, implementation_type); end
  def register_proxy(method_name); end
  def register_stub(method_name); end
  def world; end
end
module Shoulda::Matchers::Doublespeak::DoubleImplementationRegistry
  def self.find(type); end
  def self.find_class!(type); end
  def self.register(klass, type); end
  def self.registry; end
end
class Shoulda::Matchers::Doublespeak::MethodCall
  def ==(other); end
  def args; end
  def block; end
  def caller; end
  def double; end
  def initialize(args); end
  def inspect; end
  def method_name; end
  def object; end
  def return_value; end
  def return_value=(arg0); end
  def to_hash; end
  def with_return_value(return_value); end
end
class Shoulda::Matchers::Doublespeak::ObjectDouble < BasicObject
  def calls; end
  def calls_by_method_name; end
  def calls_to(method_name); end
  def initialize; end
  def method_missing(method_name, *args, &block); end
  def respond_to?(_name, _include_private = nil); end
  def respond_to_missing?(_name, _include_all); end
end
class Shoulda::Matchers::Doublespeak::ProxyImplementation
  def call(call); end
  def initialize(stub_implementation); end
  def returns(*args, **, &block); end
  def self.create; end
  def stub_implementation; end
  extend Forwardable
end
class Shoulda::Matchers::Doublespeak::StubImplementation
  def call(call); end
  def implementation; end
  def initialize; end
  def returns(value = nil, &block); end
  def self.create; end
end
class Shoulda::Matchers::Doublespeak::World
  def activate; end
  def deactivate; end
  def double_collection_for(klass); end
  def double_collections_by_class; end
  def doubles_activated?; end
  def initialize; end
  def original_method_for(klass, method_name); end
  def original_methods_by_class; end
  def original_methods_for_class(klass); end
  def store_original_method_for(klass, method_name); end
  def with_doubles_activated; end
end
class Shoulda::Matchers::Error < StandardError
  def initialize(*args); end
  def inspect; end
  def message; end
  def self.create(attributes); end
end
class Shoulda::Matchers::MatcherContext
  def assume_that_subject_is_not_a_class; end
  def context; end
  def initialize(context); end
  def inside_a_shoulda_context_project?; end
  def outside_a_should_block?; end
  def subject_is_a_class?; end
end
module Shoulda::Matchers::Independent
  def delegate_method(delegating_method); end
end
class Shoulda::Matchers::Independent::DelegateMethodMatcher
  def allow_nil; end
  def as(delegate_method); end
  def build_delegating_method_prefix(prefix); end
  def call_delegating_method_with_delegate_method_returning(value); end
  def calls_on_delegate_object; end
  def calls_to_delegate_method; end
  def class_or_instance_method_indicator; end
  def class_under_test; end
  def context; end
  def delegate_method; end
  def delegate_object; end
  def delegate_object_reader_method; end
  def delegate_object_received_call?; end
  def delegate_object_received_call_with_delegated_arguments?; end
  def delegated_arguments; end
  def delegating_method; end
  def description; end
  def ensure_delegate_object_has_been_specified!; end
  def expects_to_allow_nil_delegate_object?; end
  def failed_to_allow_nil_delegate_object?; end
  def failure_message; end
  def failure_message_when_negated; end
  def formatted_calls_on_delegate_object; end
  def formatted_delegate_method(options = nil); end
  def formatted_delegate_object_reader_method_name(options = nil); end
  def formatted_delegating_method_name(options = nil); end
  def formatted_method_name_for(method_name, options); end
  def in_context(context); end
  def initialize(delegating_method); end
  def matches?(subject); end
  def method; end
  def possible_class_under_test(options); end
  def register_subject_double_collection_to(returned_value); end
  def subject; end
  def subject_delegates_to_delegate_object_correctly?; end
  def subject_handles_nil_delegate_object?; end
  def subject_has_delegate_object_reader_method?; end
  def subject_has_delegating_method?; end
  def subject_is_a_class?; end
  def to(delegate_object_reader_method); end
  def with_arguments(*arguments); end
  def with_prefix(prefix = nil); end
end
class Shoulda::Matchers::Independent::DelegateMethodMatcher::DelegateObjectNotSpecified < StandardError
  def message; end
end
module Shoulda::Matchers::Integrations
  def self.find_library!(name); end
  def self.find_test_framework!(name); end
  def self.library_registry; end
  def self.register_library(klass, name); end
  def self.register_test_framework(klass, name); end
  def self.test_framework_registry; end
end
class Shoulda::Matchers::Integrations::Configuration
  def apply; end
  def clear_default_test_framework; end
  def initialize(&block); end
  def library(name); end
  def no_libraries_added?; end
  def no_test_frameworks_added?; end
  def self.apply(&block); end
  def test_framework(name); end
  def test_frameworks; end
end
class Shoulda::Matchers::Integrations::ConfigurationError < StandardError
end
module Shoulda::Matchers::Integrations::Inclusion
  def include_into(mod, *other_mods, &block); end
end
module Shoulda::Matchers::Integrations::Rails
  def rails?; end
end
class Shoulda::Matchers::Integrations::Registry
  def find!(name); end
  def find_class!(name); end
  def register(klass, name); end
  def registry; end
end
module Shoulda::Matchers::Integrations::Libraries
end
class Shoulda::Matchers::Integrations::Libraries::ActionController
  def integrate_with(test_framework); end
  def matchers_module; end
  include Shoulda::Matchers::Integrations::Inclusion
  include Shoulda::Matchers::Integrations::Rails
end
class Shoulda::Matchers::Integrations::Libraries::ActiveModel
  def integrate_with(test_framework); end
  def matchers_module; end
  include Shoulda::Matchers::Integrations::Inclusion
  include Shoulda::Matchers::Integrations::Rails
end
class Shoulda::Matchers::Integrations::Libraries::ActiveRecord
  def integrate_with(test_framework); end
  def matchers_module; end
  include Shoulda::Matchers::Integrations::Inclusion
  include Shoulda::Matchers::Integrations::Rails
end
class Shoulda::Matchers::Integrations::Libraries::MissingLibrary
  def integrate_with(test_framework); end
  def rails?; end
end
class Shoulda::Matchers::Integrations::Libraries::Rails
  def integrate_with(test_framework); end
  include Shoulda::Matchers::Integrations::Rails
end
class Shoulda::Matchers::Integrations::Libraries::Routing
  def integrate_with(test_framework); end
  def matchers_module; end
  include Shoulda::Matchers::Integrations::Inclusion
  include Shoulda::Matchers::Integrations::Rails
end
module Shoulda::Matchers::Integrations::TestFrameworks
end
class Shoulda::Matchers::Integrations::TestFrameworks::ActiveSupportTestCase
  def configuration; end
  def include(*modules, **_options); end
  def n_unit?; end
  def present?; end
  def test_case_class; end
  def validate!; end
end
class Shoulda::Matchers::Integrations::TestFrameworks::Minitest4
  def include(*modules, **_options); end
  def n_unit?; end
  def present?; end
  def test_case_class; end
  def validate!; end
end
class Shoulda::Matchers::Integrations::TestFrameworks::Minitest5
  def include(*modules, **_options); end
  def n_unit?; end
  def present?; end
  def test_case_class; end
  def validate!; end
end
class Shoulda::Matchers::Integrations::TestFrameworks::MissingTestFramework
  def include(*modules, **options); end
  def n_unit?; end
  def present?; end
  def validate!; end
end
class Shoulda::Matchers::Integrations::TestFrameworks::Rspec
  def include(*modules, **options); end
  def n_unit?; end
  def present?; end
  def validate!; end
end
class Shoulda::Matchers::Integrations::TestFrameworks::TestUnit
  def include(*modules, **_options); end
  def n_unit?; end
  def present?; end
  def test_case_class; end
  def validate!; end
end
module Shoulda::Matchers::RailsShim
  def self.action_pack_version; end
  def self.active_model_lt_7?; end
  def self.active_model_st_6_1?; end
  def self.active_model_version; end
  def self.active_record_version; end
  def self.attribute_serialization_coder_for(model, attribute_name); end
  def self.attribute_type_for(model, attribute_name); end
  def self.attribute_types_for(model); end
  def self.digestible_attributes_in(record); end
  def self.generate_validation_message(record, attribute, type, model_name, options); end
  def self.has_secure_password?(record, attribute_name); end
  def self.parent_of(mod); end
  def self.secure_password_module; end
  def self.serialized_attributes_for(model); end
  def self.simply_generate_validation_message(attribute, type, model_name, options); end
  def self.supports_full_attributes_api?(model); end
  def self.validates_column_options?; end
  def self.verb_for_update; end
end
class InvalidName___Class_0x00___FakeAttributeType_667
  def attribute_name; end
  def coder; end
  def initialize(model, attribute_name); end
  def model; end
end
module Shoulda::Matchers::WordWrap
  def word_wrap(document, options = nil); end
end
class Shoulda::Matchers::Document
  def document; end
  def indent; end
  def initialize(document, indent: nil); end
  def paragraphs; end
  def wrap; end
  def wrapped_paragraphs; end
end
class Shoulda::Matchers::Text < String
  def indented?; end
  def list_item?; end
  def match_as_list_item; end
end
class Shoulda::Matchers::Paragraph
  def combine_list_item_lines(lines); end
  def combine_paragraph_into_one_line; end
  def indent; end
  def initialize(paragraph, indent: nil); end
  def lines; end
  def paragraph; end
  def wrap; end
  def wrap_generic_paragraph; end
  def wrap_lines(lines); end
  def wrap_list_item; end
end
class Shoulda::Matchers::Line
  def determine_where_to_break_line(line, args); end
  def indent; end
  def indentation; end
  def initialize(line, indent: nil); end
  def line_to_wrap; end
  def normalize_whitespace(string); end
  def original_line; end
  def previous_line_to_wrap; end
  def read_indentation; end
  def wrap; end
  def wrap_line(line); end
end
module Shoulda::Matchers::Util
  def self.a_or_an(next_word); end
  def self.deconstantize(path); end
  def self.dummy_value_for(column_type, array: nil); end
  def self.indent(string, width); end
  def self.inspect_hash(hash); end
  def self.inspect_range(range); end
  def self.inspect_value(value); end
  def self.inspect_values(values); end
  def self.safe_constantize(camel_cased_word); end
end
module Shoulda::Matchers::ActionController
  def filter_param(key); end
  def permit(*params); end
  def redirect_to(url_or_description, &block); end
  def render_template(options = nil, message = nil); end
  def render_with_layout(expected_layout = nil); end
  def rescue_from(exception); end
  def respond_with(status); end
  def route(method, path, port: nil); end
  def set_flash; end
  def set_session; end
  def use_after_action(callback); end
  def use_around_action(callback); end
  def use_before_action(callback); end
end
class Shoulda::Matchers::ActionController::FilterParamMatcher
  def description; end
  def failure_message; end
  def failure_message_when_negated; end
  def filtered_keys; end
  def filters_key?; end
  def initialize(key); end
  def matches?(_controller); end
end
class Shoulda::Matchers::ActionController::RouteParams
  def args; end
  def controller_and_action_given_as_string?; end
  def extract_params_from_string; end
  def initialize(args); end
  def normalize; end
  def normalize_values(hash); end
  def stringify(value); end
  def stringify_params; end
  def symbolize_or_stringify(key, value); end
end
class Shoulda::Matchers::ActionController::SetFlashMatcher
  def [](key); end
  def description(*args, **, &block); end
  def expected_value; end
  def failure_message(*args, **, &block); end
  def failure_message_for_should(*args, **, &block); end
  def failure_message_for_should_not(*args, **, &block); end
  def failure_message_when_negated(*args, **, &block); end
  def in_context(context); end
  def initialize; end
  def key; end
  def matches?(*args, **, &block); end
  def now; end
  def to(expected_value = nil, &block); end
  def underlying_matcher; end
  extend Forwardable
end
class Shoulda::Matchers::ActionController::SetFlashMatcher::QualifierOrderError < StandardError
  def message; end
end
class Shoulda::Matchers::ActionController::RenderWithLayoutMatcher
  def description; end
  def expectation; end
  def failure_message; end
  def failure_message_when_negated; end
  def in_context(context); end
  def initialize(expected_layout); end
  def matches?(controller); end
  def recorded_layouts; end
  def rendered_layouts; end
  def rendered_with_expected_layout?; end
  def rendered_with_layout?; end
  def result; end
end
class Shoulda::Matchers::ActionController::RespondWithMatcher
  def correct_status_code?; end
  def correct_status_code_range?; end
  def description; end
  def expectation; end
  def failure_message; end
  def failure_message_when_negated; end
  def initialize(status); end
  def matches?(controller); end
  def response_code; end
  def symbol_to_status_code(potential_symbol); end
end
class Shoulda::Matchers::ActionController::SetSessionMatcher
  def [](key); end
  def description(*args, **, &block); end
  def failure_message(*args, **, &block); end
  def failure_message_for_should(*args, **, &block); end
  def failure_message_for_should_not(*args, **, &block); end
  def failure_message_when_negated(*args, **, &block); end
  def in_context(context); end
  def initialize; end
  def matches?(*args, **, &block); end
  def to(expected_value = nil, &block); end
  def underlying_matcher; end
  extend Forwardable
end
class Shoulda::Matchers::ActionController::RouteMatcher
  def add_port_to_path(path, port); end
  def context; end
  def description; end
  def failure_message; end
  def failure_message_when_negated; end
  def guess_controller_if_necessary(controller); end
  def in_context(context); end
  def initialize(context, method, path, port: nil); end
  def matches?(controller); end
  def method; end
  def normalize_path(path); end
  def params; end
  def path; end
  def route_recognized?; end
  def to(*args); end
end
class Shoulda::Matchers::ActionController::RedirectToMatcher
  def description; end
  def failure_message; end
  def failure_message_when_negated; end
  def in_context(context); end
  def initialize(url_or_description, context, &block); end
  def matches?(controller); end
  def redirects_to_url?; end
  def url; end
end
class Shoulda::Matchers::ActionController::RenderTemplateMatcher
  def description; end
  def failure_message; end
  def failure_message_when_negated; end
  def in_context(context); end
  def initialize(options, message, context); end
  def matches?(controller); end
  def renders_template?; end
end
class Shoulda::Matchers::ActionController::RescueFromMatcher
  def controller; end
  def description; end
  def exception; end
  def expectation; end
  def expected_method; end
  def failure_message; end
  def failure_message_when_negated; end
  def handler_exists?; end
  def handlers; end
  def initialize(exception); end
  def matches?(controller); end
  def method_name_matches?; end
  def rescues_from_exception?; end
  def with(method); end
end
class Shoulda::Matchers::ActionController::CallbackMatcher
  def callback_type; end
  def callbacks; end
  def controller; end
  def controller_class; end
  def description; end
  def failure_message; end
  def failure_message_when_negated; end
  def initialize(method_name, kind, callback_type); end
  def kind; end
  def matches?(controller); end
  def method_name; end
end
class Shoulda::Matchers::ActionController::PermitMatcher
  def action; end
  def actual_permitted_parameter_names; end
  def add_params(params); end
  def context; end
  def controller; end
  def default_verb; end
  def description; end
  def double_collections_by_parameter_name; end
  def ensure_action_and_verb_present!; end
  def expectation; end
  def expected_permitted_parameter_names; end
  def failure_message; end
  def failure_message_when_negated; end
  def for(action, options = nil); end
  def format_parameter_names(parameter_names); end
  def in_context(context); end
  def initialize(expected_permitted_parameter_names); end
  def matches?(controller); end
  def on(subparameter_name); end
  def parameter_names_as_sentence; end
  def parameters_double_registry; end
  def reality; end
  def request_params; end
  def stubbed_params=(arg0); end
  def subparameter_name; end
  def unpermitted_parameter_names; end
  def verb; end
end
class Shoulda::Matchers::ActionController::PermitMatcher::CompositeParametersDoubleRegistry
  def initialize; end
  def parameters_double_registries; end
  def permitted_parameter_names(options = nil); end
  def register; end
end
class Shoulda::Matchers::ActionController::PermitMatcher::ParametersDoubleRegistry
  def double_collections_by_parameter_name; end
  def initialize(params); end
  def params; end
  def permitted_parameter_names(args = nil); end
  def register; end
  def register_double_for_permit_against(params, subparameter_name); end
  def register_double_for_permit_on(double_collection); end
  def register_double_for_require_on(double_collection); end
  def self.permitted_parameter_names_within(double_collection); end
end
class Shoulda::Matchers::ActionController::PermitMatcher::ActionNotDefinedError < StandardError
  def message; end
end
class Shoulda::Matchers::ActionController::PermitMatcher::VerbNotDefinedError < StandardError
  def message; end
end
class Shoulda::Matchers::ActionController::SetSessionOrFlashMatcher
  def [](key); end
  def context; end
  def context_set?; end
  def controller; end
  def description; end
  def expectation_description; end
  def expected_value; end
  def expected_value_matches?; end
  def expected_value_set?; end
  def failure_message; end
  def failure_message_for_should; end
  def failure_message_for_should_not; end
  def failure_message_when_negated; end
  def in_context(context); end
  def initialize(store); end
  def key; end
  def key_matches?; end
  def key_set?; end
  def matches?(controller); end
  def store; end
  def to(expected_value = nil, &block); end
end
class Shoulda::Matchers::ActionController::FlashStore
  def controller; end
  def controller=(arg0); end
  def copy_discard_if_necessary(original_flash, new_flash); end
  def copy_flashes(original_flash, new_flash); end
  def copy_of_flash_from_controller; end
  def empty?(*, **, &); end
  def flash; end
  def has_key?(key); end
  def has_value?(expected_value); end
  def initialize; end
  def keys_to_discard; end
  def name; end
  def self.future; end
  def self.now; end
  def set_values; end
  def use_now!; end
  def values_to_check; end
end
class Shoulda::Matchers::ActionController::SessionStore
  def controller; end
  def controller=(arg0); end
  def empty?; end
  def has_key?(key); end
  def has_value?(expected_value); end
  def name; end
  def session; end
end
module Shoulda::Matchers::ActiveModel
  def allow_value(*values); end
  def allow_values(*values); end
  def have_secure_password(attr = nil); end
  def validate_absence_of(attr); end
  def validate_acceptance_of(attr); end
  def validate_comparison_of(attr); end
  def validate_confirmation_of(attr); end
  def validate_exclusion_of(attr); end
  def validate_inclusion_of(attr); end
  def validate_length_of(attr); end
  def validate_numericality_of(attr); end
  def validate_presence_of(attr); end
end
module Shoulda::Matchers::ActiveModel::Helpers
  def default_error_message(type, options = nil); end
  def format_validation_errors(errors); end
  def pretty_error_messages(object); end
end
module Shoulda::Matchers::ActiveModel::Qualifiers
end
module Shoulda::Matchers::ActiveModel::Qualifiers::AllowNil
  def allow_nil; end
  def expects_to_allow_nil?; end
  def initialize(*args); end
end
module Shoulda::Matchers::ActiveModel::Qualifiers::AllowBlank
  def allow_blank; end
  def expects_to_allow_blank?; end
  def initialize(*args); end
end
class Shoulda::Matchers::ActiveModel::Qualifiers::IgnoreInterferenceByWriter
  def always?; end
  def changed?; end
  def condition; end
  def condition_matches?(value); end
  def considering?(value); end
  def default_to(argument); end
  def initialize(argument = nil); end
  def invalid_argument_error(invalid_argument); end
  def never?; end
  def set(argument); end
  def setting; end
end
module Shoulda::Matchers::ActiveModel::Qualifiers::IgnoringInterferenceByWriter
  def ignore_interference_by_writer; end
  def ignoring_interference_by_writer(value = nil); end
  def initialize(*); end
end
class Shoulda::Matchers::ActiveModel::ValidationMatcher
  def allow_blank; end
  def allow_blank_does_not_match?; end
  def allow_blank_matches?; end
  def allow_value_matcher(value, message = nil, &block); end
  def allows_value_of(value, message = nil, &block); end
  def array_column?; end
  def attribute; end
  def blank_values; end
  def build_allow_or_disallow_value_matcher(args); end
  def context; end
  def description; end
  def disallow_value_matcher(value, message = nil, &block); end
  def disallows_value_of(value, message = nil, &block); end
  def does_not_match?(subject); end
  def expects_custom_validation_message?; end
  def expects_strict?; end
  def expects_to_allow_blank?; end
  def failure_message; end
  def failure_message_when_negated; end
  def failure_reason; end
  def failure_reason_when_negated; end
  def initialize(attribute); end
  def last_submatcher_run; end
  def matches?(subject); end
  def model; end
  def on(context); end
  def options; end
  def overall_failure_message; end
  def overall_failure_message_when_negated; end
  def run_allow_or_disallow_matcher(matcher); end
  def strict; end
  def subject; end
  def with_message(expected_message); end
  include Shoulda::Matchers::ActiveModel::Qualifiers::IgnoringInterferenceByWriter
end
class Shoulda::Matchers::ActiveModel::ValidationMatcher::BuildDescription
  def call; end
  def clause_for_allow_blank_or_nil; end
  def description_clauses_for_qualifiers; end
  def initialize(matcher, main_description); end
  def main_description; end
  def matcher; end
  def self.call(matcher, main_description); end
end
class Shoulda::Matchers::ActiveModel::Validator
  def all_formatted_validation_error_messages; end
  def all_validation_errors; end
  def attribute; end
  def call; end
  def captured_range_error?; end
  def captured_validation_exception?; end
  def context; end
  def expects_strict?; end
  def has_any_errors?; end
  def has_messages?; end
  def initialize(record, attribute, options = nil); end
  def matched_messages; end
  def messages; end
  def messages_match?; end
  def perform_validation; end
  def record; end
  def type_of_message_matched?; end
  def validation_error_messages; end
  def validation_exception_message; end
  def validation_result; end
  include Shoulda::Matchers::ActiveModel::Helpers
end
class Shoulda::Matchers::ActiveModel::AllowValueMatcher
  def _after_setting_value(&callback); end
  def after_setting_value_callback; end
  def against(attribute); end
  def attribute_changed_value_message; end
  def attribute_changed_value_message=(arg0); end
  def attribute_setters_and_validators_for_values_to_set; end
  def attribute_setters_for_values_to_preset; end
  def attribute_to_check_message_against; end
  def attribute_to_set; end
  def context; end
  def default_attribute_changed_value_message; end
  def default_attribute_message; end
  def default_attribute_message_values; end
  def default_expected_message; end
  def default_failure_message_preface; end
  def description; end
  def description_for_resulting_attribute_setter; end
  def descriptions_for_preset_values; end
  def does_not_match?(instance); end
  def expected_message; end
  def expects_custom_validation_message?; end
  def expects_strict?; end
  def failure_message; end
  def failure_message_preface; end
  def failure_message_preface=(arg0); end
  def failure_message_when_negated; end
  def for(attribute_name); end
  def has_any_errors?; end
  def human_attribute_name; end
  def include_attribute_changed_value_message?; end
  def initialize(*values); end
  def inspected_values_to_set; end
  def instance; end
  def last_attribute_setter_used; end
  def last_value_set; end
  def matches?(instance); end
  def model; end
  def model_name; end
  def on(context); end
  def options; end
  def result; end
  def run(strategy); end
  def simple_description; end
  def strict(expects_strict = nil); end
  def values_to_preset; end
  def values_to_preset=(arg0); end
  def values_to_set; end
  def with_message(message, given_options = nil); end
  include Shoulda::Matchers::ActiveModel::Helpers
  include Shoulda::Matchers::ActiveModel::Qualifiers::IgnoringInterferenceByWriter
end
class Shoulda::Matchers::ActiveModel::AllowValueMatcher::AttributeChangedValueError < Shoulda::Matchers::Error
  def attribute_name; end
  def attribute_name=(arg0); end
  def matcher_name; end
  def matcher_name=(arg0); end
  def message; end
  def model; end
  def model=(arg0); end
  def successful?; end
  def value_read; end
  def value_read=(arg0); end
  def value_written; end
  def value_written=(arg0); end
end
class Shoulda::Matchers::ActiveModel::AllowValueMatcher::AttributeDoesNotExistError < Shoulda::Matchers::Error
  def attribute_name; end
  def attribute_name=(arg0); end
  def message; end
  def model; end
  def model=(arg0); end
  def successful?; end
  def value; end
  def value=(arg0); end
end
class Shoulda::Matchers::ActiveModel::AllowValueMatcher::AttributeSetter
  def active_resource_object?; end
  def after_set_callback; end
  def args; end
  def attribute_changed_value!; end
  def attribute_changed_value?; end
  def attribute_changed_value_error; end
  def attribute_does_not_exist!; end
  def attribute_does_not_exist_error; end
  def attribute_exists?; end
  def attribute_is_an_enum?; end
  def attribute_name; end
  def check; end
  def checked?; end
  def defined_enums; end
  def description; end
  def enum_values; end
  def failure_message; end
  def ignore_interference_by_writer; end
  def initialize(args); end
  def matcher_name; end
  def model; end
  def object; end
  def raise_attribute_changed_value_error?; end
  def result_of_checking; end
  def result_of_setting; end
  def run!; end
  def run; end
  def self.set(args); end
  def set!; end
  def set; end
  def set?; end
  def successful?; end
  def successful_check; end
  def successful_setting; end
  def successfully_checked?; end
  def successfully_set?; end
  def unsuccessful?; end
  def unsuccessfully_checked?; end
  def value_read; end
  def value_read_is_expected_for_an_enum?; end
  def value_written; end
end
class Shoulda::Matchers::ActiveModel::AllowValueMatcher::AttributeSetterAndValidator
  def after_setting_value_callback(*args, **, &block); end
  def allow_value_matcher; end
  def attribute_name; end
  def attribute_setter; end
  def attribute_setter_description; end
  def attribute_to_check_message_against(*args, **, &block); end
  def context(*args, **, &block); end
  def expected_message(*args, **, &block); end
  def expects_strict?(*args, **, &block); end
  def ignore_interference_by_writer(*args, **, &block); end
  def initialize(allow_value_matcher, attribute_name, value); end
  def instance(*args, **, &block); end
  def validator; end
  def value; end
  extend Forwardable
end
class Shoulda::Matchers::ActiveModel::AllowValueMatcher::AttributeSetters
  def does_not_match?(tuple); end
  def each(&block); end
  def first_failing; end
  def initialize(allow_value_matcher, values); end
  def tuples; end
  include Enumerable
end
class Shoulda::Matchers::ActiveModel::AllowValueMatcher::AttributeSettersAndValidators
  def does_not_match?(tuple); end
  def each(&block); end
  def first_failing; end
  def first_passing; end
  def initialize(allow_value_matcher, values); end
  def matches?(tuple); end
  def tuples; end
  include Enumerable
end
class Shoulda::Matchers::ActiveModel::AllowValueMatcher::SuccessfulCheck
  def successful?; end
end
class Shoulda::Matchers::ActiveModel::AllowValueMatcher::SuccessfulSetting
  def successful?; end
end
class Shoulda::Matchers::ActiveModel::DisallowValueMatcher
  def _after_setting_value(*args, **, &block); end
  def allow_matcher; end
  def attribute_changed_value_message=(*args, **, &block); end
  def attribute_to_set(*args, **, &block); end
  def description(*args, **, &block); end
  def does_not_match?(subject); end
  def expects_strict?(*args, **, &block); end
  def failure_message; end
  def failure_message_preface(*args, **, &block); end
  def failure_message_preface=(*args, **, &block); end
  def failure_message_when_negated; end
  def for(attribute); end
  def ignore_interference_by_writer(*args, **, &block); end
  def ignoring_interference_by_writer(value = nil); end
  def initialize(value); end
  def last_attribute_setter_used(*args, **, &block); end
  def last_value_set(*args, **, &block); end
  def matches?(subject); end
  def model(*args, **, &block); end
  def on(context); end
  def simple_description(*args, **, &block); end
  def strict(strict = nil); end
  def values_to_preset=(*args, **, &block); end
  def with_message(message, options = nil); end
  extend Forwardable
end
class Shoulda::Matchers::ActiveModel::ValidateLengthOfMatcher < Shoulda::Matchers::ActiveModel::ValidationMatcher
  def allow_nil; end
  def allow_nil_does_not_match?; end
  def allow_nil_matches?; end
  def allows_higher_length?; end
  def allows_length_of?(length, message); end
  def allows_lower_length?; end
  def allows_maximum_length?; end
  def allows_minimum_length?; end
  def array_column?; end
  def as_array; end
  def association?; end
  def association_reflection; end
  def collection_association?; end
  def disallows_higher_length?; end
  def disallows_length_of?(length, message); end
  def disallows_lower_length?; end
  def disallows_maximum_length?; end
  def disallows_minimum_length?; end
  def does_not_match?(subject); end
  def expects_to_allow_nil?; end
  def initialize(attribute); end
  def is_at_least(length); end
  def is_at_most(length); end
  def is_equal_to(length); end
  def lower_bound_does_not_match?; end
  def lower_bound_matches?; end
  def matches?(subject); end
  def simple_description; end
  def translated_long_message; end
  def translated_short_message; end
  def upper_bound_does_not_match?; end
  def upper_bound_matches?; end
  def value_of_length(length); end
  def with_long_message(message); end
  def with_message(message); end
  def with_short_message(message); end
  include Shoulda::Matchers::ActiveModel::Helpers
end
class Shoulda::Matchers::ExampleClass
end
class Shoulda::Matchers::ActiveModel::ValidateInclusionOfMatcher < Shoulda::Matchers::ActiveModel::ValidationMatcher
  def allow_nil; end
  def allows_all_values_in_array?; end
  def allows_any_value_outside_of_array?; end
  def allows_higher_value; end
  def allows_lower_value; end
  def allows_maximum_value; end
  def allows_minimum_value; end
  def allows_nil_value?; end
  def attribute_allows_nil?; end
  def attribute_column; end
  def attribute_type; end
  def boolean_outside_values; end
  def column_type_to_attribute_type(type); end
  def disallows_all_values_outside_of_array?; end
  def disallows_any_values_in_array?; end
  def disallows_higher_value; end
  def disallows_lower_value; end
  def disallows_maximum_value; end
  def disallows_minimum_value; end
  def disallows_nil_value?; end
  def does_not_match?(subject); end
  def does_not_match_for_array?; end
  def does_not_match_for_range?; end
  def expects_to_allow_nil?; end
  def in_array(array); end
  def in_range(range); end
  def initialize(attribute); end
  def inspected_array; end
  def matches?(subject); end
  def matches_for_array?; end
  def matches_for_range?; end
  def maximum_range_value; end
  def minimum_range_value; end
  def outside_values; end
  def simple_description; end
  def value_to_attribute_type(value); end
  def values_outside_of_array; end
  def with_high_message(message); end
  def with_low_message(message); end
  def with_message(message); end
end
class Shoulda::Matchers::ActiveModel::ValidateExclusionOfMatcher < Shoulda::Matchers::ActiveModel::ValidationMatcher
  def allows_any_values_in_array?; end
  def allows_higher_value; end
  def allows_lower_value; end
  def allows_maximum_value; end
  def allows_minimum_value; end
  def disallows_all_values_in_array?; end
  def disallows_higher_value; end
  def disallows_lower_value; end
  def disallows_maximum_value; end
  def disallows_minimum_value; end
  def does_not_match?(subject); end
  def in_array(array); end
  def in_range(range); end
  def initialize(attribute); end
  def inspect_message; end
  def inspected_array; end
  def matches?(subject); end
  def simple_description; end
end
class Shoulda::Matchers::ActiveModel::ValidateAbsenceOfMatcher < Shoulda::Matchers::ActiveModel::ValidationMatcher
  def collection?; end
  def column_type; end
  def does_not_match?(subject); end
  def enum_column?; end
  def enum_values; end
  def initialize(attribute); end
  def matches?(subject); end
  def reflection; end
  def simple_description; end
  def value; end
end
class Shoulda::Matchers::ActiveModel::ValidatePresenceOfMatcher < Shoulda::Matchers::ActiveModel::ValidationMatcher
  def allows_and_double_checks_value_of!(value); end
  def allows_original_or_typecast_value?(value); end
  def association?; end
  def association_name; end
  def association_options; end
  def association_reflection; end
  def attachment?; end
  def attribute_accepts_string_values?; end
  def attribute_serialization_coder; end
  def attribute_type; end
  def belongs_to_association_being_validated?; end
  def belongs_to_association_configured_to_be_required?; end
  def collection_association?; end
  def disallowed_values; end
  def disallows_and_double_checks_value_of!(value); end
  def disallows_original_or_typecast_value?(value); end
  def does_not_match?(subject); end
  def example_of_belongs_to(with: nil); end
  def failure_message; end
  def initialize(attribute); end
  def matches?(subject); end
  def model; end
  def model_has_associations?(associations); end
  def possibly_ignore_interference_by_writer; end
  def presence_validation_exists_on_attribute?; end
  def reason_for_existing_presence_validation; end
  def secure_password_being_validated?; end
  def should_add_footnote_about_belongs_to?; end
  def simple_description; end
  def suggestions_for_belongs_to; end
  include Shoulda::Matchers::ActiveModel::Qualifiers::AllowBlank
  include Shoulda::Matchers::ActiveModel::Qualifiers::AllowNil
end
class Shoulda::Matchers::ActiveModel::ValidateAcceptanceOfMatcher < Shoulda::Matchers::ActiveModel::ValidationMatcher
  def does_not_match?(subject); end
  def initialize(attribute); end
  def matches?(subject); end
  def simple_description; end
end
class Shoulda::Matchers::ActiveModel::ValidateConfirmationOfMatcher < Shoulda::Matchers::ActiveModel::ValidationMatcher
  def allows_different_value; end
  def allows_missing_confirmation; end
  def allows_same_value; end
  def attribute; end
  def confirmation_attribute; end
  def disallows_different_value; end
  def disallows_missing_confirmation; end
  def disallows_same_value; end
  def does_not_match?(subject); end
  def initialize(attribute); end
  def matches?(subject); end
  def qualify_matcher(matcher, confirmation_attribute_value); end
  def simple_description; end
  include Shoulda::Matchers::ActiveModel::Helpers
end
class Shoulda::Matchers::ActiveModel::ValidateNumericalityOfMatcher < Shoulda::Matchers::ActiveModel::ValidationMatcher
  def add_disallow_non_numeric_value_matcher; end
  def add_submatcher(submatcher); end
  def allow_nil; end
  def attribute_is_active_record_column?; end
  def build_submatcher_failure_message_for(submatcher, failure_message_method); end
  def column_type; end
  def columns_hash; end
  def comparison_descriptions; end
  def comparison_matcher_for(value, operator); end
  def diff_to_compare; end
  def does_not_match?(subject); end
  def even; end
  def expects_to_allow_nil?; end
  def failure_message; end
  def failure_message_for_first_submatcher_that_fails_to_match; end
  def failure_message_for_first_submatcher_that_fails_to_not_match; end
  def failure_message_when_negated; end
  def first_submatcher_that_fails_to_match; end
  def first_submatcher_that_fails_to_not_match; end
  def full_allowed_type; end
  def given_numeric_column?; end
  def has_been_qualified?; end
  def initialize(attribute); end
  def is_equal_to(value); end
  def is_greater_than(value); end
  def is_greater_than_or_equal_to(value); end
  def is_in(range); end
  def is_less_than(value); end
  def is_less_than_or_equal_to(value); end
  def is_other_than(value); end
  def matches?(subject); end
  def matches_or_does_not_match?(subject); end
  def non_numeric_value; end
  def number_of_submatchers_for_failure_message; end
  def odd; end
  def only_integer; end
  def prepare_submatcher(submatcher); end
  def qualify_submatchers; end
  def range_description; end
  def simple_description; end
  def submatcher_comparison_descriptions; end
  def submatcher_qualified?(submatcher); end
end
class Shoulda::Matchers::ActiveModel::ValidateComparisonOfMatcher < Shoulda::Matchers::ActiveModel::ValidationMatcher
  def add_submatcher(submatcher); end
  def allow_nil; end
  def allowed_type_name; end
  def attribute_is_active_record_column?; end
  def build_submatcher_failure_message_for(submatcher, failure_message_method); end
  def column_type; end
  def columns_hash; end
  def comparison_descriptions; end
  def comparison_matcher_for(value, operator); end
  def diff_to_compare; end
  def does_not_match?(subject); end
  def expects_to_allow_nil?; end
  def failure_message; end
  def failure_message_for_first_submatcher_that_fails_to_match; end
  def failure_message_for_first_submatcher_that_fails_to_not_match; end
  def failure_message_when_negated; end
  def first_submatcher_that_fails_to_match; end
  def first_submatcher_that_fails_to_not_match; end
  def given_numeric_column?; end
  def has_been_qualified?; end
  def initialize(attribute); end
  def is_equal_to(value); end
  def is_greater_than(value); end
  def is_greater_than_or_equal_to(value); end
  def is_less_than(value); end
  def is_less_than_or_equal_to(value); end
  def is_other_than(value); end
  def matches?(subject); end
  def non_numeric_value; end
  def number_of_submatchers; end
  def number_of_submatchers_for_failure_message; end
  def prepare_submatcher(submatcher); end
  def qualify_submatchers; end
  def simple_description; end
  def submatcher_comparison_descriptions; end
  def submatcher_qualified?(submatcher); end
end
class Shoulda::Matchers::ActiveModel::ComparisonMatcher < Shoulda::Matchers::ActiveModel::ValidationMatcher
  def assertions; end
  def build_comparison_submatchers; end
  def comparison_combos; end
  def comparison_description; end
  def comparison_expectation; end
  def comparison_submatchers; end
  def diffs_to_compare; end
  def diffs_when_string(diff_to_compare); end
  def expects_custom_validation_message?; end
  def failure_message(*, **, &); end
  def failure_message_when_negated(*, **, &); end
  def for(attribute); end
  def initialize(matcher, value, operator); end
  def matches?(subject); end
  def option_value; end
  def simple_description; end
  def submatcher_method_names; end
  def with_message(message); end
end
module Shoulda::Matchers::ActiveModel::NumericalityMatchers
end
class Shoulda::Matchers::ActiveModel::NumericalityMatchers::NumericTypeMatcher
  def allowed_type_adjective; end
  def allowed_type_name; end
  def attribute; end
  def diff_to_compare; end
  def disallow_value_matcher; end
  def disallowed_value; end
  def does_not_match?(*args, **, &block); end
  def expects_custom_validation_message?(*args, **, &block); end
  def expects_strict?(*args, **, &block); end
  def failure_message(*args, **, &block); end
  def failure_message_when_negated(*args, **, &block); end
  def ignore_interference_by_writer(*args, **, &block); end
  def ignoring_interference_by_writer(*args, **, &block); end
  def initialize(numeric_type_matcher, attribute); end
  def matches?(*args, **, &block); end
  def on(*args, **, &block); end
  def strict(*args, **, &block); end
  def with_message(*args, **, &block); end
  def wrap_disallow_value_matcher(_matcher); end
  extend Forwardable
end
class Shoulda::Matchers::ActiveModel::NumericalityMatchers::OddNumberMatcher < Shoulda::Matchers::ActiveModel::NumericalityMatchers::NumericTypeMatcher
  def allowed_type_adjective; end
  def diff_to_compare; end
  def disallowed_value; end
  def simple_description; end
  def wrap_disallow_value_matcher(matcher); end
end
class Shoulda::Matchers::ActiveModel::NumericalityMatchers::EvenNumberMatcher < Shoulda::Matchers::ActiveModel::NumericalityMatchers::NumericTypeMatcher
  def allowed_type_adjective; end
  def diff_to_compare; end
  def disallowed_value; end
  def simple_description; end
  def wrap_disallow_value_matcher(matcher); end
end
class Shoulda::Matchers::ActiveModel::NumericalityMatchers::OnlyIntegerMatcher < Shoulda::Matchers::ActiveModel::NumericalityMatchers::NumericTypeMatcher
  def allowed_type_name; end
  def diff_to_compare; end
  def disallowed_value; end
  def simple_description; end
  def wrap_disallow_value_matcher(matcher); end
end
class Shoulda::Matchers::ActiveModel::NumericalityMatchers::RangeMatcher < Shoulda::Matchers::ActiveModel::ValidationMatcher
  def build_comparison_submatcher(value, operator); end
  def build_submatchers; end
  def failure_message(*, **, &); end
  def initialize(numericality_matcher, attribute, range); end
  def matches?(subject); end
  def range_description; end
  def simple_description; end
  def submatcher_combos; end
  def submatchers; end
end
class Shoulda::Matchers::ActiveModel::NumericalityMatchers::Submatchers
  def add(submatcher); end
  def failing_submatcher; end
  def failing_submatchers; end
  def failure_message; end
  def failure_message_when_negated; end
  def initialize(submatchers); end
  def matches?(subject); end
  def non_failing_submatcher; end
  def non_failing_submatchers; end
end
class Shoulda::Matchers::ActiveModel::CouldNotDetermineValueOutsideOfArray < RuntimeError
end
class Shoulda::Matchers::ActiveModel::NonNullableBooleanError < Shoulda::Matchers::Error
  def attribute; end
  def attribute=(arg0); end
  def message; end
  def self.create(attribute); end
end
class Shoulda::Matchers::ActiveModel::CouldNotSetPasswordError < Shoulda::Matchers::Error
  def message; end
  def model; end
  def model=(arg0); end
  def model_name; end
  def record_name; end
  def self.create(model); end
end
class Shoulda::Matchers::ActiveModel::HaveSecurePasswordMatcher
  def authenticate_method; end
  def description; end
  def expected_methods; end
  def failure_message; end
  def failure_message_when_negated; end
  def initialize(attribute); end
  def matches?(subject); end
  def subject; end
  def validate; end
end
module Shoulda::Matchers::ActiveRecord
  def accept_nested_attributes_for(name); end
  def belong_to(name); end
  def define_enum_for(attribute_name); end
  def encrypt(value); end
  def have_and_belong_to_many(name); end
  def have_db_column(column); end
  def have_db_index(columns); end
  def have_delegated_type(name); end
  def have_implicit_order_column(column_name); end
  def have_many(name); end
  def have_many_attached(name); end
  def have_one(name); end
  def have_one_attached(name); end
  def have_readonly_attribute(value); end
  def have_rich_text(rich_text_attribute); end
  def have_secure_token(token_attribute = nil); end
  def normalize(*attributes); end
  def serialize(name); end
  def validate_uniqueness_of(attr); end
end
class Shoulda::Matchers::ActiveRecord::AssociationMatcher
  def actual_foreign_key; end
  def add_submatcher(matcher_class, *args); end
  def associated_class(*, **, &); end
  def association_exists?; end
  def autosave(autosave); end
  def autosave_correct?; end
  def belongs_foreign_key_missing?; end
  def belongs_foreign_type_missing?; end
  def belongs_to_required_by_default?; end
  def class_exists?; end
  def class_has_foreign_key?(klass); end
  def class_has_foreign_type?(klass); end
  def class_name(class_name); end
  def class_name_correct?; end
  def column_names_for(klass); end
  def conditions(conditions); end
  def conditions_correct?; end
  def counter_cache(counter_cache = nil); end
  def dependent(dependent); end
  def description; end
  def expectation; end
  def failing_submatchers; end
  def failure_message; end
  def failure_message_when_negated; end
  def foreign_key_correct?; end
  def foreign_key_exists?; end
  def foreign_key_failure_message(klass, foreign_key); end
  def foreign_key_reflection; end
  def foreign_type; end
  def foreign_type_correct?; end
  def foreign_type_failure_message(klass, foreign_type); end
  def foreign_type_matches?; end
  def has_association_not_through?; end
  def has_column?(klass, column); end
  def has_foreign_key_missing?; end
  def has_foreign_type_missing?; end
  def index_errors(index_errors); end
  def index_errors_correct?; end
  def initialize(macro, name); end
  def inverse_of(inverse_of); end
  def join_table(join_table_name); end
  def join_table_correct?; end
  def join_table_matcher; end
  def join_table_name; end
  def macro; end
  def macro_correct?; end
  def macro_description; end
  def macro_is_not_through?; end
  def matches?(subject); end
  def missing; end
  def missing_options; end
  def missing_options_for_failing_submatchers; end
  def model_class(*, **, &); end
  def name; end
  def option_verifier; end
  def optional(optional = nil); end
  def options; end
  def order(order); end
  def polymorphic?(*, **, &); end
  def primary_key_correct?(klass); end
  def primary_key_exists?; end
  def query_constraints_correct?; end
  def query_constraints_exists?; end
  def reflection(*, **, &); end
  def reflector; end
  def remove_submatcher(matcher_class); end
  def required(required = nil); end
  def source(source); end
  def strict_loading(strict_loading = nil); end
  def strict_loading_correct?; end
  def subject; end
  def submatchers; end
  def submatchers_match?; end
  def through(through); end
  def through?(*, **, &); end
  def touch(touch = nil); end
  def touch_correct?; end
  def types(types); end
  def types_correct?; end
  def validate(validate = nil); end
  def validate_correct?; end
  def validate_foreign_key(klass); end
  def validate_inverse_of_through_association; end
  def with_foreign_key(foreign_key); end
  def with_foreign_type(foreign_type); end
  def with_primary_key(primary_key); end
  def with_query_constraints(query_constraints); end
  def without_validating_presence; end
end
module Shoulda::Matchers::ActiveRecord::AssociationMatchers
end
class Shoulda::Matchers::ActiveRecord::AssociationMatchers::CounterCacheMatcher
  def counter_cache; end
  def counter_cache=(arg0); end
  def description; end
  def initialize(counter_cache, name); end
  def matches?(subject); end
  def missing_option; end
  def missing_option=(arg0); end
  def name; end
  def name=(arg0); end
  def option_verifier; end
  def subject; end
  def subject=(arg0); end
end
class Shoulda::Matchers::ActiveRecord::AssociationMatchers::InverseOfMatcher
  def description; end
  def initialize(inverse_of, name); end
  def inverse_of; end
  def inverse_of=(arg0); end
  def matches?(subject); end
  def missing_option; end
  def missing_option=(arg0); end
  def name; end
  def name=(arg0); end
  def option_verifier; end
  def subject; end
  def subject=(arg0); end
end
class Shoulda::Matchers::ActiveRecord::AssociationMatchers::JoinTableMatcher
  def actual_join_table_columns; end
  def associated_class(*, **, &); end
  def association_foreign_key(*, **, &); end
  def association_matcher; end
  def column_label; end
  def connection(*, **, &); end
  def expected_join_table_columns; end
  def failure_message; end
  def foreign_key(*, **, &); end
  def initialize(association_matcher, reflector); end
  def join_table_exists?; end
  def join_table_has_correct_columns?; end
  def join_table_name(*, **, &); end
  def join_table_option_correct?; end
  def matches?(_subject); end
  def missing_columns; end
  def missing_columns_message; end
  def missing_option; end
  def missing_table_message; end
  def model_class(*, **, &); end
  def name(*, **, &); end
  def option_verifier(*, **, &); end
  def options(*, **, &); end
  def reflector; end
end
class Shoulda::Matchers::ActiveRecord::AssociationMatchers::OrderMatcher
  def description; end
  def initialize(order, name); end
  def matches?(subject); end
  def missing_option; end
  def missing_option=(arg0); end
  def name; end
  def name=(arg0); end
  def option_verifier; end
  def order; end
  def order=(arg0); end
  def subject; end
  def subject=(arg0); end
end
class Shoulda::Matchers::ActiveRecord::AssociationMatchers::ThroughMatcher
  def association_set_properly?; end
  def description; end
  def initialize(through, name); end
  def matches?(subject); end
  def missing_option; end
  def missing_option=(arg0); end
  def name; end
  def name=(arg0); end
  def option_verifier; end
  def subject; end
  def subject=(arg0); end
  def through; end
  def through=(arg0); end
  def through_association_correct?; end
  def through_association_exists?; end
  def through_reflection; end
end
class Shoulda::Matchers::ActiveRecord::AssociationMatchers::DependentMatcher
  def dependent; end
  def dependent=(arg0); end
  def description; end
  def generate_missing_option; end
  def initialize(dependent, name); end
  def matches?(subject); end
  def missing_option; end
  def missing_option=(arg0); end
  def name; end
  def name=(arg0); end
  def option_matches?; end
  def option_type; end
  def option_verifier; end
  def subject; end
  def subject=(arg0); end
end
class Shoulda::Matchers::ActiveRecord::AssociationMatchers::RequiredMatcher
  def attribute_name; end
  def build_missing_option; end
  def description; end
  def initialize(attribute_name, required); end
  def matches?(subject); end
  def missing_option; end
  def required; end
  def submatcher; end
  def submatcher_passes?(subject); end
  def validation_message_key; end
end
class Shoulda::Matchers::ActiveRecord::AssociationMatchers::OptionalMatcher
  def attribute_name; end
  def build_missing_option; end
  def description; end
  def initialize(attribute_name, optional); end
  def matches?(subject); end
  def missing_option; end
  def optional; end
  def submatcher; end
  def submatcher_passes?(subject); end
end
class Shoulda::Matchers::ActiveRecord::AssociationMatchers::SourceMatcher
  def description; end
  def initialize(source, name); end
  def matches?(subject); end
  def missing_option; end
  def missing_option=(arg0); end
  def name; end
  def name=(arg0); end
  def option_verifier; end
  def source; end
  def source=(arg0); end
  def subject; end
  def subject=(arg0); end
end
class Shoulda::Matchers::ActiveRecord::AssociationMatchers::ModelReflector
  def associated_class(*, **, &); end
  def association_foreign_key(*, **, &); end
  def association_relation; end
  def build_relation_with_clause(name, value); end
  def extract_relation_clause_from(relation, name); end
  def foreign_key(*, **, &); end
  def foreign_type(*, **, &); end
  def has_and_belongs_to_many_name(*, **, &); end
  def initialize(subject, name); end
  def join_table_name(*, **, &); end
  def model_class; end
  def name; end
  def polymorphic?(*, **, &); end
  def reflect_on_association(name); end
  def reflection; end
  def subject; end
  def through?(*, **, &); end
  def validate_inverse_of_through_association!(*, **, &); end
  def value_as_sql(value); end
end
class Shoulda::Matchers::ActiveRecord::AssociationMatchers::ModelReflection < SimpleDelegator
  def associated_class; end
  def association_foreign_key; end
  def association_relation(related_instance); end
  def foreign_key; end
  def has_and_belongs_to_many_name; end
  def has_and_belongs_to_many_name_table_name; end
  def has_and_belongs_to_many_reflection; end
  def initialize(reflection); end
  def join_table_name; end
  def polymorphic?; end
  def reflection; end
  def strict_loading?; end
  def subject; end
  def through?; end
  def validate_inverse_of_through_association!; end
end
class Shoulda::Matchers::ActiveRecord::AssociationMatchers::OptionVerifier
  def actual_value_for(name); end
  def actual_value_for_class_name; end
  def actual_value_for_option(name); end
  def actual_value_for_relation_clause(name); end
  def actual_value_for_strict_loading; end
  def correct_for?(*args); end
  def correct_for_boolean?(name, expected_value); end
  def correct_for_constant?(name, expected_unresolved_value); end
  def correct_for_hash?(name, expected_value); end
  def correct_for_relation_clause?(name, expected_value); end
  def correct_for_string?(name, expected_value); end
  def expected_value_for(type, name, value); end
  def expected_value_for_constant(name); end
  def expected_value_for_relation_clause(name, value); end
  def initialize(reflector); end
  def reflection(*, **, &); end
  def reflector; end
  def type_cast(type, value); end
end
class Shoulda::Matchers::ActiveRecord::HaveDbColumnMatcher
  def actual_primary?; end
  def actual_scale; end
  def column_exists?; end
  def correct_array?; end
  def correct_column_type?; end
  def correct_default?; end
  def correct_limit?; end
  def correct_null?; end
  def correct_precision?; end
  def correct_primary?; end
  def correct_scale?; end
  def correct_sql_column_type?; end
  def description; end
  def expectation; end
  def failure_message; end
  def failure_message_when_negated; end
  def initialize(column); end
  def matched_column; end
  def matches?(subject); end
  def model_class; end
  def of_sql_type(sql_column_type); end
  def of_type(column_type); end
  def validate_options(opts); end
  def with_options(opts = nil); end
end
class Shoulda::Matchers::ActiveRecord::HaveDbColumnMatcher::DecoratedColumn < SimpleDelegator
  def initialize(model, column); end
  def model; end
  def primary?; end
  def type_cast_default; end
end
class Shoulda::Matchers::ActiveRecord::HaveDbIndexMatcher
  def correct_unique?; end
  def described_table_name; end
  def description; end
  def expected_columns; end
  def failure_message; end
  def failure_message_when_negated; end
  def formatted_expected_columns; end
  def index_exists?; end
  def index_type; end
  def initialize(columns); end
  def inspected_expected_columns; end
  def matched_index; end
  def matches?(subject); end
  def model; end
  def negative_expectation; end
  def normalize_columns_to_array(columns); end
  def positive_expectation; end
  def qualifiers; end
  def reason; end
  def sorted_indexes; end
  def subject; end
  def table_name; end
  def unique(unique = nil); end
  def unsorted_indexes; end
end
class Shoulda::Matchers::ActiveRecord::HaveImplicitOrderColumnMatcher
  def check_column_exists!; end
  def check_implicit_order_column_matches!; end
  def column_name; end
  def description; end
  def expectation; end
  def failure_message; end
  def failure_message_when_negated; end
  def initialize(column_name); end
  def matches?(subject); end
  def model; end
  def subject; end
end
class Shoulda::Matchers::ActiveRecord::HaveImplicitOrderColumnMatcher::SecondaryCheckFailedError < StandardError
end
class Shoulda::Matchers::ActiveRecord::HaveImplicitOrderColumnMatcher::PrimaryCheckFailedError < StandardError
end
class Shoulda::Matchers::ActiveRecord::HaveReadonlyAttributeMatcher
  def class_name; end
  def description; end
  def failure_message; end
  def failure_message_when_negated; end
  def initialize(attribute); end
  def matches?(subject); end
  def readonly_attributes; end
end
class Shoulda::Matchers::ActiveRecord::HaveRichTextMatcher
  def description; end
  def error; end
  def error_description; end
  def failure_message; end
  def failure_message_when_negated; end
  def has_attribute?; end
  def has_expected_action_text?; end
  def initialize(rich_text_attribute); end
  def matches?(subject); end
  def rich_text_attribute; end
  def run_checks; end
  def subject; end
end
class Shoulda::Matchers::ActiveRecord::HaveSecureTokenMatcher
  def description; end
  def failure_message; end
  def failure_message_when_negated; end
  def has_expected_db_column?; end
  def has_expected_db_index?; end
  def has_expected_instance_methods?; end
  def ignoring_check_for_db_index; end
  def initialize(token_attribute); end
  def matches?(subject); end
  def run_checks; end
  def table_and_column; end
  def table_name; end
  def token_attribute; end
end
class Shoulda::Matchers::ActiveRecord::SerializeMatcher
  def as(type); end
  def as_instance_of(type); end
  def attribute_is_serialized?; end
  def class_valid?; end
  def description; end
  def expectation; end
  def failure_message; end
  def failure_message_when_negated; end
  def initialize(name); end
  def instance_class_valid?; end
  def matches?(subject); end
  def model; end
  def model_class; end
  def serialization_coder; end
  def serialization_valid?; end
  def type_valid?; end
end
class Shoulda::Matchers::ActiveRecord::AcceptNestedAttributesForMatcher
  def allow_destroy(allow_destroy); end
  def allow_destroy_correct?; end
  def config; end
  def description; end
  def exists?; end
  def expectation; end
  def failure_message; end
  def failure_message_when_negated; end
  def initialize(name); end
  def limit(limit); end
  def limit_correct?; end
  def matches?(subject); end
  def model_class; end
  def model_config; end
  def should_or_should_not(value); end
  def update_only(update_only); end
  def update_only_correct?; end
  def verify_option_is_correct(option, failure_message); end
end
class Shoulda::Matchers::ActiveRecord::DefineEnumForMatcher
  def actual_default_value; end
  def actual_enum_values; end
  def attribute_name; end
  def backed_by_column_of_type(expected_column_type); end
  def column; end
  def column_type_matches?; end
  def default_value_matches?; end
  def description; end
  def enum_defined?; end
  def enum_value_methods_exist?; end
  def enum_values_match?; end
  def exclude_scopes?; end
  def expectation; end
  def expected_allowing_nil?; end
  def expected_column_type; end
  def expected_default_value; end
  def expected_enum_value_names; end
  def expected_enum_values; end
  def expected_instance_methods; end
  def expected_instance_methods?; end
  def expected_prefix; end
  def expected_singleton_methods; end
  def expected_suffix; end
  def expected_validating?; end
  def failure_message; end
  def failure_message_continuation; end
  def failure_message_when_negated; end
  def find_enum_validator; end
  def initialize(attribute_name); end
  def instance_methods_exist?; end
  def matches?(subject); end
  def missing_methods_message; end
  def model; end
  def normalized_actual_enum_values; end
  def normalized_expected_enum_values; end
  def options; end
  def presented_enum_mapping(enum_values); end
  def record; end
  def scope_presence_matches?; end
  def simple_description; end
  def singleton_methods_exist?; end
  def to_array(value); end
  def to_hash(value); end
  def validating(value = nil, allowing_nil: nil); end
  def validating_matches?; end
  def with_default(default_value); end
  def with_prefix(expected_prefix = nil); end
  def with_suffix(expected_suffix = nil); end
  def with_values(expected_enum_values); end
  def without_instance_methods; end
  def without_scopes; end
end
module Shoulda::Matchers::ActiveRecord::Uniqueness
end
class Shoulda::Matchers::ActiveRecord::Uniqueness::Model
  def already_exists?; end
  def initialize(name, namespace); end
  def name; end
  def namespace; end
  def next; end
  def self.next_unique_copy_of(model_name, namespace); end
  def symlink_to(parent); end
  def to_s; end
end
class Shoulda::Matchers::ActiveRecord::Uniqueness::Namespace
  def clear; end
  def constant; end
  def has?(name); end
  def initialize(constant); end
  def set(name, value); end
  def to_s; end
end
class Shoulda::Matchers::ActiveRecord::Uniqueness::TestModelCreator
  def create; end
  def existing_model; end
  def initialize(model_name, namespace); end
  def model_name; end
  def model_name_without_namespace; end
  def namespace; end
  def new_model; end
  def self.create(model_name, namespace); end
end
module Shoulda::Matchers::ActiveRecord::Uniqueness::TestModels
  def self.create(model_name); end
  def self.remove_all; end
  def self.root_namespace; end
end
class Shoulda::Matchers::ActiveRecord::ValidateUniquenessOfMatcher < Shoulda::Matchers::ActiveModel::ValidationMatcher
  def actual_sets_of_scopes; end
  def all_scopes_are_booleans?; end
  def allow_blank; end
  def allow_nil; end
  def arbitrary_non_blank_value; end
  def attribute_changed_value_message; end
  def attribute_names_under_test; end
  def attribute_present_on_model?; end
  def attribute_setter_descriptions_for_new_record; end
  def attribute_setter_for_existing_record; end
  def attribute_setters_for_new_record; end
  def available_enum_values_for(scope, previous_value); end
  def boolean_value?(value); end
  def build_allow_or_disallow_value_matcher(args); end
  def build_attribute_setter(record, attribute_name, value); end
  def build_failure_reason; end
  def build_new_record; end
  def case_insensitive; end
  def case_sensitivity_strategy; end
  def column_for(scope); end
  def column_limit_for(attribute); end
  def create_existing_record; end
  def defined_as_enum?(scope); end
  def description_for_attribute_setter(attribute_setter, same_as_existing: nil); end
  def description_for_case_sensitive_qualifier; end
  def descriptions_for_attribute_setters_for_new_record; end
  def does_not_match?(given_record); end
  def does_not_match_allow_blank?; end
  def does_not_match_allow_nil?; end
  def does_not_match_presence_of_attribute?; end
  def does_not_match_presence_of_scopes?; end
  def does_not_match_scopes_configuration?; end
  def does_not_match_uniqueness_with_case_sensitivity_strategy?; end
  def does_not_match_uniqueness_with_scopes?; end
  def does_not_match_uniqueness_without_scopes?; end
  def dummy_scalar_value_for(column); end
  def dummy_value_for(scope); end
  def existing_and_new_values_are_same?; end
  def existing_record; end
  def existing_value_read; end
  def existing_value_written; end
  def expected_scopes; end
  def expects_to_allow_blank?; end
  def expects_to_allow_nil?; end
  def failure_message_preface; end
  def failure_reason; end
  def failure_reason_when_negated; end
  def find_existing_record; end
  def find_or_create_existing_record; end
  def has_secure_password?; end
  def ignoring_case_sensitivity; end
  def initialize(attribute); end
  def inspected_actual_scopes; end
  def inspected_actual_sets_of_scopes; end
  def inspected_expected_scopes; end
  def last_attribute_setter_used_on_new_record; end
  def last_value_set_on_new_record; end
  def matches?(given_record); end
  def matches_allow_blank?; end
  def matches_allow_nil?; end
  def matches_presence_of_attribute?; end
  def matches_presence_of_scopes?; end
  def matches_scopes_configuration?; end
  def matches_uniqueness_with_case_sensitivity_strategy?; end
  def matches_uniqueness_with_scopes?; end
  def matches_uniqueness_without_scopes?; end
  def model; end
  def model_class?(model_name); end
  def new_record; end
  def next_scalar_value_for(scope, previous_value); end
  def next_value_for(scope, previous_value); end
  def polymorphic_type_attribute?(scope, previous_value); end
  def scoped_to(*scopes); end
  def scopes_match?; end
  def scopes_missing_on_model; end
  def scopes_present_on_model; end
  def set_attribute_on!(record_type, record, attribute_name, value); end
  def set_attribute_on_existing_record!(attribute_name, value); end
  def set_attribute_on_new_record!(attribute_name, value); end
  def setting_next_value_for(scope); end
  def should_test_case_sensitivity?; end
  def simple_description; end
  def subject; end
  def update_existing_record!(value); end
  def validations; end
  include Shoulda::Matchers::ActiveModel::Helpers
end
class Shoulda::Matchers::ActiveRecord::ValidateUniquenessOfMatcher::AttributeSetters
  def +(other_attribute_setters); end
  def <<(given_attribute_setter); end
  def each(&block); end
  def find_index_of(given_attribute_setter); end
  def initialize; end
  def last; end
  include Enumerable
end
class Shoulda::Matchers::ActiveRecord::ValidateUniquenessOfMatcher::NonCaseSwappableValueError < Shoulda::Matchers::Error
  def attribute; end
  def attribute=(arg0); end
  def message; end
  def model; end
  def model=(arg0); end
  def value; end
  def value=(arg0); end
end
class Shoulda::Matchers::ActiveRecord::ValidateUniquenessOfMatcher::ExistingRecordInvalid < Shoulda::Matchers::Error
  def message; end
  def underlying_exception; end
  def underlying_exception=(arg0); end
  include Shoulda::Matchers::ActiveModel::Helpers
end
class Shoulda::Matchers::ActiveRecord::HaveAttachedMatcher
  def attachments_association_exists?; end
  def attachments_association_matcher; end
  def attachments_association_name; end
  def blobs_association_exists?; end
  def blobs_association_matcher; end
  def blobs_association_name; end
  def description; end
  def eager_loading_scope_exists?; end
  def expectation; end
  def failure_message; end
  def failure_message_when_negated; end
  def initialize(macro, name); end
  def macro; end
  def matches?(subject); end
  def model_class; end
  def name; end
  def reader_attribute_exists?; end
  def subject; end
  def writer_attribute_exists?; end
end
class Shoulda::Matchers::ActiveRecord::NormalizeMatcher
  def attribute_does_not_match?(subject, attribute); end
  def attribute_matches?(subject, attribute); end
  def attributes; end
  def build_failure_message(attribute, attribute_value); end
  def build_failure_message_when_negated(attribute); end
  def description; end
  def does_not_match?(subject); end
  def failure_message; end
  def failure_message_when_negated; end
  def from(value); end
  def from_value; end
  def initialize(*attributes); end
  def matches?(subject); end
  def normalize_attribute?(subject, attribute); end
  def to(value); end
  def to_value; end
end
class Shoulda::Matchers::ActiveRecord::EncryptMatcher
  def class_name; end
  def description; end
  def deterministic(deterministic); end
  def downcase(downcase); end
  def encrypted_attribute_scheme; end
  def encrypted_attributes; end
  def encrypted_attributes_included?; end
  def failure_message; end
  def failure_message_when_negated; end
  def ignore_case(ignore_case); end
  def initialize(attribute); end
  def matches?(subject); end
  def options_correct?(*opts); end
  def with_option(option_name, value); end
end
module Shoulda::Matchers::Routing
  def route(method, path, port: nil); end
end
