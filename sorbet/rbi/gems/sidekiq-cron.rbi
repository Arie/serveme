# This file is autogenerated. Do not edit it by hand. Regenerate it with:
#   srb rbi gems

# typed: true
#
# If you would like to make changes to this file, great! Please create the gem's shim here:
#
#   https://github.com/sorbet/sorbet-typed/new/master?filename=lib/sidekiq-cron/all/sidekiq-cron.rbi
#
# sidekiq-cron-1.12.0

module Sidekiq
end
module Sidekiq::Cron
end
module Sidekiq::Cron::Support
  def self.constantize(camel_cased_word); end
  def self.load_yaml(src); end
end
module Sidekiq::Options
  def self.[](key); end
  def self.[]=(key, value); end
  def self.config; end
  def self.options_field; end
end
class Sidekiq::Cron::Job
  def active_job_message; end
  def add_jid_history(jid); end
  def args; end
  def args=(args); end
  def convert_to_global_id_hash(argument); end
  def cron; end
  def cron=(arg0); end
  def date_as_argument?; end
  def description; end
  def description=(arg0); end
  def deserialize_argument(argument); end
  def deserialize_global_id(hash); end
  def destroy; end
  def disable!; end
  def disabled?; end
  def enable!; end
  def enabled?; end
  def enque!(time = nil); end
  def enqueue_active_job(klass_const); end
  def enqueue_args; end
  def enqueue_sidekiq_worker(klass_const); end
  def errors; end
  def exists?; end
  def fetch_missing_args; end
  def formatted_enqueue_time(now = nil); end
  def formatted_last_time(now = nil); end
  def initialize(input_args = nil); end
  def is_active_job?(klass = nil); end
  def jid_history_from_redis; end
  def jid_history_key; end
  def job_enqueued_key; end
  def klass; end
  def klass=(arg0); end
  def klass_valid; end
  def last_enqueue_time; end
  def last_enqueue_time_from_redis; end
  def last_time(now = nil); end
  def message; end
  def message=(arg0); end
  def name; end
  def name=(arg0); end
  def not_enqueued_after?(time); end
  def not_past_scheduled_time?(current_time); end
  def parse_args(args); end
  def parse_enqueue_time(timestamp); end
  def parsed_cron; end
  def pretty_message; end
  def queue_name_with_prefix; end
  def redis_key; end
  def remove_previous_enques(time); end
  def save; end
  def save_last_enqueue_time; end
  def self.all; end
  def self.count; end
  def self.create(hash); end
  def self.destroy(name); end
  def self.destroy_all!; end
  def self.destroy_removed_jobs(new_job_names); end
  def self.exists?(name); end
  def self.find(name); end
  def self.jid_history_key(name); end
  def self.job_enqueued_key(name); end
  def self.jobs_key; end
  def self.load_from_array!(array, options = nil); end
  def self.load_from_array(array, options = nil); end
  def self.load_from_hash!(hash, options = nil); end
  def self.load_from_hash(hash, options = nil); end
  def self.redis_key(name); end
  def serialize_argument(argument); end
  def serialized_global_id?(hash); end
  def serialized_last_enqueue_time; end
  def should_enque?(time); end
  def sidekiq_worker_message; end
  def sort_name; end
  def source; end
  def status; end
  def status_from_redis; end
  def symbolize_args(input); end
  def symbolize_args?; end
  def test_and_enque_for_time!(time); end
  def to_hash; end
  def valid?; end
end
class Sidekiq::Cron::Poller < Sidekiq::Scheduled::Poller
  def enqueue; end
  def enqueue_job(job, time = nil); end
  def initialize(config = nil); end
  def poll_interval_average(process_count = nil); end
end
module Sidekiq::Cron::Launcher
  def cron_poller; end
  def initialize(config, **kwargs); end
  def quiet; end
  def run; end
  def stop; end
end
module Sidekiq::Cron::WebExtension
  def self.registered(app); end
end
