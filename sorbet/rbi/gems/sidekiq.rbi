# This file is autogenerated. Do not edit it by hand. Regenerate it with:
#   srb rbi gems

# typed: true
#
# If you would like to make changes to this file, great! Please create the gem's shim here:
#
#   https://github.com/sorbet/sorbet-typed/new/master?filename=lib/sidekiq/all/sidekiq.rbi
#
# sidekiq-7.3.1

module Sidekiq
  def self.configure_client; end
  def self.configure_embed(&block); end
  def self.configure_server(&block); end
  def self.default_configuration; end
  def self.default_job_options; end
  def self.default_job_options=(hash); end
  def self.dump_json(object); end
  def self.ent?; end
  def self.freeze!; end
  def self.load_json(string); end
  def self.logger; end
  def self.pro?; end
  def self.redis(&block); end
  def self.redis_pool; end
  def self.server?; end
  def self.strict_args!(mode = nil); end
  def self.transactional_push!; end
end
class Sidekiq::RedisClientAdapter
  def client_opts(options); end
  def initialize(options); end
  def new_client; end
end
module Sidekiq::RedisClientAdapter::CompatMethods
  def bitfield(*args, **kwargs); end
  def bitfield_ro(*args, **kwargs); end
  def del(*args, **kwargs); end
  def evalsha(sha, keys, argv); end
  def exists(*args, **kwargs); end
  def expire(*args, **kwargs); end
  def flushdb(*args, **kwargs); end
  def get(*args, **kwargs); end
  def hdel(*args, **kwargs); end
  def hget(*args, **kwargs); end
  def hgetall(*args, **kwargs); end
  def hincrby(*args, **kwargs); end
  def hlen(*args, **kwargs); end
  def hmget(*args, **kwargs); end
  def hset(*args, **kwargs); end
  def hsetnx(*args, **kwargs); end
  def incr(*args, **kwargs); end
  def incrby(*args, **kwargs); end
  def info; end
  def lindex(*args, **kwargs); end
  def llen(*args, **kwargs); end
  def lmove(*args, **kwargs); end
  def lpop(*args, **kwargs); end
  def lpush(*args, **kwargs); end
  def lrange(*args, **kwargs); end
  def lrem(*args, **kwargs); end
  def method_missing(*args, **, &block); end
  def mget(*args, **kwargs); end
  def mset(*args, **kwargs); end
  def ping(*args, **kwargs); end
  def pttl(*args, **kwargs); end
  def publish(*args, **kwargs); end
  def respond_to_missing?(name, include_private = nil); end
  def rpop(*args, **kwargs); end
  def rpush(*args, **kwargs); end
  def sadd(*args, **kwargs); end
  def scard(*args, **kwargs); end
  def script(*args, **kwargs); end
  def set(*args, **kwargs); end
  def sismember(*args, **kwargs); end
  def smembers(*args, **kwargs); end
  def srem(*args, **kwargs); end
  def ttl(*args, **kwargs); end
  def type(*args, **kwargs); end
  def unlink(*args, **kwargs); end
  def zadd(*args, **kwargs); end
  def zcard(*args, **kwargs); end
  def zincrby(*args, **kwargs); end
  def zrange(*args, **kwargs); end
  def zrem(*args, **kwargs); end
  def zremrangebyrank(*args, **kwargs); end
  def zremrangebyscore(*args, **kwargs); end
end
class Sidekiq::RedisClientAdapter::CompatClient < RedisClient::Decorator::Client
  def config; end
  include Sidekiq::RedisClientAdapter::CompatMethods
end
class Sidekiq::RedisClientAdapter::CompatClient::Pipeline < RedisClient::Decorator::Pipeline
  include Sidekiq::RedisClientAdapter::CompatMethods
end
module Sidekiq::RedisConnection
  def self.create(options = nil); end
  def self.deep_symbolize_keys(object); end
  def self.determine_redis_provider; end
  def self.scrub(options); end
end
class Sidekiq::Config
  def [](*args, **, &block); end
  def []=(*args, **, &block); end
  def average_scheduled_poll_interval=(interval); end
  def capsule(name); end
  def capsules; end
  def client_middleware; end
  def concurrency; end
  def concurrency=(val); end
  def death_handlers; end
  def default_capsule(&block); end
  def dig(*args, **, &block); end
  def error_handlers; end
  def fetch(*args, **, &block); end
  def handle_exception(ex, ctx = nil); end
  def has_key?(*args, **, &block); end
  def initialize(options = nil); end
  def key?(*args, **, &block); end
  def local_redis_pool; end
  def logger; end
  def logger=(logger); end
  def lookup(name, default_class = nil); end
  def merge!(*args, **, &block); end
  def new_redis_pool(size, name = nil); end
  def on(event, &block); end
  def parameter_size(handler); end
  def queues; end
  def queues=(val); end
  def redis; end
  def redis=(hash); end
  def redis_info; end
  def redis_pool; end
  def register(name, instance); end
  def server_middleware; end
  def to_json(*); end
  def total_concurrency; end
  extend Forwardable
end
module Sidekiq::Context
  def self.add(k, v); end
  def self.current; end
  def self.with(hash); end
end
module Sidekiq::LoggingUtils
  def debug?; end
  def error?; end
  def fatal?; end
  def info?; end
  def level; end
  def local_level; end
  def local_level=(level); end
  def log_at(level); end
  def warn?; end
end
class Sidekiq::Logger < Logger
  include Sidekiq::LoggingUtils
end
module Sidekiq::Logger::Formatters
end
class Sidekiq::Logger::Formatters::Base < Logger::Formatter
  def ctx; end
  def format_context; end
  def tid; end
end
class Sidekiq::Logger::Formatters::Pretty < Sidekiq::Logger::Formatters::Base
  def call(severity, time, program_name, message); end
end
class Sidekiq::Logger::Formatters::WithoutTimestamp < Sidekiq::Logger::Formatters::Pretty
  def call(severity, time, program_name, message); end
end
class Sidekiq::Logger::Formatters::JSON < Sidekiq::Logger::Formatters::Base
  def call(severity, time, program_name, message); end
end
module Sidekiq::ServerMiddleware
  def config; end
  def config=(arg0); end
  def logger; end
  def redis(&block); end
  def redis_pool; end
end
module Sidekiq::Middleware
end
class Sidekiq::Middleware::Chain
  def add(klass, *args); end
  def clear; end
  def copy_for(capsule); end
  def each(&block); end
  def empty?; end
  def entries; end
  def exists?(klass); end
  def include?(klass); end
  def initialize(config = nil); end
  def insert_after(oldklass, newklass, *args); end
  def insert_before(oldklass, newklass, *args); end
  def invoke(*args, &block); end
  def prepend(klass, *args); end
  def remove(klass); end
  def retrieve; end
  def traverse(chain, index, args, &block); end
  include Enumerable
end
class Sidekiq::Middleware::Entry
  def initialize(config, klass, *args); end
  def klass; end
  def make_new; end
end
module Sidekiq::JobUtil
  def json_unsafe?(item); end
  def normalize_item(item); end
  def normalized_hash(item_class); end
  def validate(item); end
  def verify_json(item); end
end
class Sidekiq::Client
  def atomic_push(conn, payloads); end
  def initialize(*args, **kwargs); end
  def middleware(&block); end
  def push(item); end
  def push_bulk(items); end
  def raw_push(payloads); end
  def redis_pool; end
  def redis_pool=(arg0); end
  def self.enqueue(klass, *args); end
  def self.enqueue_in(interval, klass, *args); end
  def self.enqueue_to(queue, klass, *args); end
  def self.enqueue_to_in(queue, interval, klass, *args); end
  def self.push(item); end
  def self.push_bulk(*, **, &); end
  def self.via(pool); end
  include Sidekiq::JobUtil
end
class Sidekiq::TransactionAwareClient
  def batching?; end
  def initialize(pool: nil, config: nil); end
  def push(item); end
  def push_bulk(items); end
end
module Sidekiq::Job
  def _context; end
  def _context=(arg0); end
  def interrupted?; end
  def jid; end
  def jid=(arg0); end
  def logger; end
  def self.clear_all; end
  def self.drain_all; end
  def self.included(base); end
  def self.jobs; end
end
module Sidekiq::Job::Options
  def self.included(base); end
end
module Sidekiq::Job::Options::ClassMethods
  def get_sidekiq_options; end
  def sidekiq_class_attribute(*attrs); end
  def sidekiq_options(opts = nil); end
  def sidekiq_retries_exhausted(&block); end
  def sidekiq_retry_in(&block); end
end
class Sidekiq::Job::Setter
  def at(interval); end
  def initialize(klass, opts); end
  def perform_async(*args); end
  def perform_at(interval, *args); end
  def perform_bulk(args, batch_size: nil); end
  def perform_in(interval, *args); end
  def perform_inline(*args); end
  def perform_sync(*args); end
  def set(options); end
  include Sidekiq::JobUtil
end
module Sidekiq::Job::ClassMethods
  def build_client; end
  def clear; end
  def client_push(item); end
  def delay(*args); end
  def delay_for(*args); end
  def delay_until(*args); end
  def drain; end
  def execute_job(worker, args); end
  def jobs; end
  def perform_async(*args); end
  def perform_at(interval, *args); end
  def perform_bulk(*args, **kwargs); end
  def perform_in(interval, *args); end
  def perform_inline(*args); end
  def perform_one; end
  def perform_sync(*args); end
  def process_job(job); end
  def queue; end
  def queue_as(q); end
  def set(options); end
  def sidekiq_options(opts = nil); end
end
module Sidekiq::Job::Iterable
  def around_iteration; end
  def assert_enumerator!(enum); end
  def build_enumerator(*); end
  def cleanup; end
  def each_iteration(*); end
  def fetch_previous_iteration_state; end
  def flush_state; end
  def handle_completed(completed); end
  def initialize; end
  def iterate_with_enumerator(enumerator, arguments); end
  def iteration_key; end
  def on_complete; end
  def on_resume; end
  def on_start; end
  def on_stop; end
  def perform(*arguments); end
  def reenqueue_iteration_job; end
  def self.included(base); end
  include Sidekiq::Job::Iterable::Enumerators
end
class Sidekiq::Job::Iterable::ActiveRecordEnumerator
  def batches; end
  def initialize(relation, cursor: nil, **options); end
  def records; end
  def relations; end
  def relations_size; end
end
class Sidekiq::Job::Iterable::CsvEnumerator
  def batches(cursor:, batch_size: nil); end
  def count_of_rows_in_file; end
  def initialize(csv); end
  def rows(cursor:); end
end
module Sidekiq::Job::Iterable::Enumerators
  def active_record_batches_enumerator(relation, cursor:, **options); end
  def active_record_records_enumerator(relation, cursor:, **options); end
  def active_record_relations_enumerator(relation, cursor:, **options); end
  def array_enumerator(array, cursor:); end
  def csv_batches_enumerator(csv, cursor:, **options); end
  def csv_enumerator(csv, cursor:); end
end
class Sidekiq::Job::Interrupted < RuntimeError
end
module Sidekiq::Job::Iterable::ClassMethods
  def method_added(method_name); end
end
module Sidekiq::IterableJob
  def self.included(base); end
end
class Sidekiq::Rails < Rails::Engine
end
class Sidekiq::Rails::Reloader
  def call; end
  def initialize(app = nil); end
  def inspect; end
  def to_hash; end
end
class Sidekiq::Shutdown < Interrupt
end
module Sidekiq::Component
  def config; end
  def fire_event(event, options = nil); end
  def handle_exception(ex, ctx = nil); end
  def hostname; end
  def identity; end
  def logger; end
  def process_nonce; end
  def redis(&block); end
  def safe_thread(name, &block); end
  def tid; end
  def watchdog(last_words); end
end
module Sidekiq::Scheduled
end
class Sidekiq::Scheduled::Enq
  def enqueue_jobs(sorted_sets = nil); end
  def initialize(container); end
  def terminate; end
  def zpopbyscore(conn, keys: nil, argv: nil); end
  include Sidekiq::Component
end
class Sidekiq::Scheduled::Poller
  def cleanup; end
  def enqueue; end
  def initial_wait; end
  def initialize(config); end
  def poll_interval_average(count); end
  def process_count; end
  def random_poll_interval; end
  def scaled_poll_interval(process_count); end
  def start; end
  def terminate; end
  def wait; end
  include Sidekiq::Component
end
module Sidekiq::Metrics
end
class Sidekiq::Metrics::Histogram
  def buckets; end
  def each; end
  def fetch(conn, now = nil); end
  def initialize(klass); end
  def label(idx); end
  def persist(conn, now = nil); end
  def record_time(ms); end
  include Enumerable
end
class Sidekiq::Metrics::Query
  def fetch_marks(time_range); end
  def for_job(klass, minutes: nil); end
  def initialize(pool: nil, now: nil); end
  def top_jobs(class_filter: nil, minutes: nil); end
end
class Anonymous_Struct_91 < Struct
  def buckets; end
  def buckets=(_); end
  def ends_at; end
  def ends_at=(_); end
  def job_results; end
  def job_results=(_); end
  def marks; end
  def marks=(_); end
  def self.[](*arg0); end
  def self.inspect; end
  def self.keyword_init?; end
  def self.members; end
  def self.new(*arg0); end
  def size; end
  def size=(_); end
  def starts_at; end
  def starts_at=(_); end
end
class Sidekiq::Metrics::Query::Result < Anonymous_Struct_91
  def initialize; end
  def prepend_bucket(time); end
end
class Anonymous_Struct_92 < Struct
  def hist; end
  def hist=(_); end
  def self.[](*arg0); end
  def self.inspect; end
  def self.keyword_init?; end
  def self.members; end
  def self.new(*arg0); end
  def series; end
  def series=(_); end
  def totals; end
  def totals=(_); end
end
class Sidekiq::Metrics::Query::JobResult < Anonymous_Struct_92
  def add_hist(time, hist_result); end
  def add_metric(metric, time, value); end
  def initialize; end
  def series_avg(metric = nil); end
  def total_avg(metric = nil); end
end
class Anonymous_Struct_93 < Struct
  def label; end
  def label=(_); end
  def self.[](*arg0); end
  def self.inspect; end
  def self.keyword_init?; end
  def self.members; end
  def self.new(*arg0); end
  def time; end
  def time=(_); end
end
class Sidekiq::Metrics::Query::MarkResult < Anonymous_Struct_93
  def bucket; end
end
class Sidekiq::Stats
  def dead_size; end
  def default_queue_latency; end
  def enqueued; end
  def failed; end
  def fetch_stats!; end
  def fetch_stats_fast!; end
  def fetch_stats_slow!; end
  def initialize; end
  def processed; end
  def processes_size; end
  def queues; end
  def reset(*stats); end
  def retry_size; end
  def scheduled_size; end
  def stat(s); end
  def workers_size; end
end
class Sidekiq::Stats::History
  def date_stat_hash(stat); end
  def failed; end
  def initialize(days_previous, start_date = nil, pool: nil); end
  def processed; end
end
class Sidekiq::Queue
  def as_json(options = nil); end
  def clear; end
  def each; end
  def find_job(jid); end
  def initialize(name = nil); end
  def latency; end
  def name; end
  def paused?; end
  def self.all; end
  def size; end
  include Enumerable
end
class Sidekiq::JobRecord
  def [](name); end
  def args; end
  def bid; end
  def created_at; end
  def delete; end
  def deserialize_argument(argument); end
  def display_args; end
  def display_class; end
  def enqueued_at; end
  def error_backtrace; end
  def initialize(item, queue_name = nil); end
  def item; end
  def jid; end
  def klass; end
  def latency; end
  def parse(item); end
  def queue; end
  def serialized_global_id?(hash); end
  def tags; end
  def uncompress_backtrace(backtrace); end
  def value; end
end
class Sidekiq::SortedEntry < Sidekiq::JobRecord
  def add_to_queue; end
  def at; end
  def delete; end
  def error?; end
  def initialize(parent, score, item); end
  def kill; end
  def parent; end
  def remove_job; end
  def reschedule(at); end
  def retry; end
  def score; end
end
class Sidekiq::SortedSet
  def as_json(options = nil); end
  def clear; end
  def initialize(name); end
  def name; end
  def scan(match, count = nil); end
  def size; end
  include Enumerable
end
class Sidekiq::JobSet < Sidekiq::SortedSet
  def delete(score, jid); end
  def delete_by_jid(score, jid); end
  def delete_by_value(name, value); end
  def each; end
  def fetch(score, jid = nil); end
  def find_job(jid); end
  def schedule(timestamp, job); end
end
class Sidekiq::ScheduledSet < Sidekiq::JobSet
  def initialize; end
end
class Sidekiq::RetrySet < Sidekiq::JobSet
  def initialize; end
  def kill_all; end
  def retry_all; end
end
class Sidekiq::DeadSet < Sidekiq::JobSet
  def initialize; end
  def kill(message, opts = nil); end
  def retry_all; end
end
class Sidekiq::ProcessSet
  def cleanup; end
  def each; end
  def initialize(clean_plz = nil); end
  def leader; end
  def self.[](identity); end
  def size; end
  def total_concurrency; end
  def total_rss; end
  def total_rss_in_kb; end
  include Enumerable
end
class Sidekiq::Process
  def [](key); end
  def dump_threads; end
  def embedded?; end
  def identity; end
  def initialize(hash); end
  def labels; end
  def queues; end
  def quiet!; end
  def signal(sig); end
  def stop!; end
  def stopping?; end
  def tag; end
  def version; end
  def weights; end
end
class Sidekiq::WorkSet
  def each(&block); end
  def find_work_by_jid(jid); end
  def size; end
  include Enumerable
end
class Sidekiq::Work
  def [](key); end
  def initialize(pid, tid, hsh); end
  def job; end
  def method_missing(*all); end
  def payload; end
  def process_id; end
  def queue; end
  def raw(name); end
  def respond_to_missing?(name, *args); end
  def run_at; end
  def thread_id; end
end
module Sidekiq::Paginator
  def page(key, pageidx = nil, page_size = nil, opts = nil); end
  def page_items(items, pageidx = nil, page_size = nil); end
end
module Sidekiq::WebHelpers
  def add_to_head; end
  def available_locales; end
  def busy_weights(capsule_weights); end
  def clear_caches; end
  def csp_nonce; end
  def csrf_tag; end
  def current_path; end
  def current_status; end
  def delete_or_add_queue(job, params); end
  def display_args(args, truncate_after_chars = nil); end
  def display_custom_head; end
  def display_tags(job, within = nil); end
  def environment_title_prefix; end
  def filter_link(jid, within = nil); end
  def filtering(which); end
  def find_locale_files(lang); end
  def format_memory(rss_kb); end
  def get_locale; end
  def h(text); end
  def html_tag(tagname, attrs); end
  def job_params(job, score); end
  def locale; end
  def locale_files; end
  def number_with_delimiter(number, options = nil); end
  def parse_params(params); end
  def pollable?; end
  def processes; end
  def product_version; end
  def qparams(options); end
  def redirect_with_query(url); end
  def redis_info; end
  def redis_url; end
  def relative_time(time); end
  def retry_extra_items(retry_job); end
  def retry_or_delete_or_kill(job, params); end
  def root_path; end
  def rtl?; end
  def script_tag(location, **kwargs); end
  def search(jobset, substr); end
  def server_utc_time; end
  def singularize(str, count); end
  def sort_direction_label; end
  def sorted_processes; end
  def stats; end
  def strings(lang); end
  def style_tag(location, **kwargs); end
  def t(msg, options = nil); end
  def text_direction; end
  def to_display(arg); end
  def to_json(x); end
  def to_query_string(params); end
  def truncate(text, truncate_after_chars = nil); end
  def unfiltered?; end
  def user_preferred_languages; end
  def workset; end
end
module Sidekiq::WebRouter
  def delete(path, &block); end
  def get(path, &block); end
  def head(path, &block); end
  def match(env); end
  def patch(path, &block); end
  def post(path, &block); end
  def put(path, &block); end
  def route(method, path, &block); end
end
class Sidekiq::WebRoute
  def block; end
  def block=(arg0); end
  def compile; end
  def initialize(request_method, pattern, block); end
  def match(request_method, path); end
  def matcher; end
  def name; end
  def name=(arg0); end
  def pattern; end
  def pattern=(arg0); end
  def request_method; end
  def request_method=(arg0); end
end
class Sidekiq::WebAction
  def _erb(file, locals); end
  def _render; end
  def block; end
  def block=(arg0); end
  def env; end
  def env=(arg0); end
  def erb(content, options = nil); end
  def halt(res); end
  def initialize(env, block); end
  def json(payload); end
  def params; end
  def redirect(location); end
  def reload_page; end
  def render(engine, content, options = nil); end
  def request; end
  def route_params; end
  def session; end
  def settings; end
  def type; end
  def type=(arg0); end
  include Sidekiq::Paginator
  include Sidekiq::WebHelpers
end
class Sidekiq::WebApplication
  def call(env); end
  def initialize(klass); end
  def process_csp(env, input); end
  def self.after(path = nil, &block); end
  def self.afters; end
  def self.before(path = nil, &block); end
  def self.befores; end
  def self.helpers(mod = nil, &block); end
  def self.run_afters(app, action); end
  def self.run_befores(app, action); end
  def self.run_hooks(hooks, app, action); end
  def self.set(key, val); end
  def self.settings; end
  def self.tabs; end
  def settings; end
  extend Sidekiq::WebRouter
end
class Sidekiq::Web
  def app; end
  def build; end
  def call(env); end
  def disable(*opts); end
  def enable(*opts); end
  def middlewares; end
  def self.app_url; end
  def self.app_url=(arg0); end
  def self.call(env); end
  def self.custom_job_info_rows; end
  def self.custom_tabs; end
  def self.default_tabs; end
  def self.disable(*opts); end
  def self.enable(*opts); end
  def self.inherited(child); end
  def self.locales; end
  def self.locales=(arg0); end
  def self.middlewares; end
  def self.redis_pool; end
  def self.redis_pool=(arg0); end
  def self.register(extension, name: nil, tab: nil, index: nil, root_dir: nil, cache_for: nil, asset_paths: nil); end
  def self.set(attribute, value); end
  def self.settings; end
  def self.tabs; end
  def self.use(*args, &block); end
  def self.views; end
  def self.views=(arg0); end
  def set(attribute, value); end
  def settings; end
  def use(*args, &block); end
end
class Sidekiq::Web::CsrfProtection
  def accept?(env); end
  def admit(env); end
  def call(env); end
  def compare_with_real_token(token, local); end
  def decode_token(token); end
  def deny(env); end
  def encode_token(token); end
  def initialize(app, options = nil); end
  def logger(env); end
  def mask_token(token); end
  def masked_token?(token); end
  def safe?(env); end
  def session(env); end
  def unmask_token(masked_token); end
  def unmasked_token?(token); end
  def valid_token?(env, giventoken); end
  def xor_byte_strings(s1, s2); end
end
class Sidekiq::Testing
  def self.__global_test_mode; end
  def self.__global_test_mode=(arg0); end
  def self.__local_test_mode; end
  def self.__local_test_mode=(value); end
  def self.__set_test_mode(mode); end
  def self.__test_mode; end
  def self.disable!(&block); end
  def self.disabled?; end
  def self.enabled?; end
  def self.fake!(&block); end
  def self.fake?; end
  def self.inline!(&block); end
  def self.inline?; end
  def self.server_middleware; end
end
class Sidekiq::Testing::TestModeAlreadySetError < RuntimeError
end
class Sidekiq::EmptyQueueError < RuntimeError
end
module Sidekiq::TestingClient
  def atomic_push(conn, payloads); end
end
module Sidekiq::Queues
  def self.[](queue); end
  def self.clear_all; end
  def self.clear_for(queue, klass); end
  def self.delete_for(jid, queue, klass); end
  def self.jobs_by_class; end
  def self.jobs_by_queue; end
  def self.jobs_by_worker; end
  def self.push(queue, klass, job); end
end
module Sidekiq::TestingExtensions
  def jobs_for(klass); end
end
