# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `text` gem.
# Please instead update this file by running `bin/tapioca gem text`.

# Ruby implementation of the Soundex algorithm,
# as described by Knuth in volume 3 of The Art of Computer Programming.
#
# Author: Michael Neumann (neumann@s-direktnet.de)
#
# source://text//lib/text/double_metaphone.rb#11
module Text; end

# source://text//lib/text/levenshtein.rb#15
module Text::Levenshtein
  extend ::Text::Levenshtein

  # Calculate the Levenshtein distance between two strings +str1+ and +str2+.
  #
  # The optional argument max_distance can reduce the number of iterations by
  # stopping if the Levenshtein distance exceeds this value. This increases
  # performance where it is only necessary to compare the distance with a
  # reference value instead of calculating the exact distance.
  #
  # The distance is calculated in terms of Unicode codepoints. Be aware that
  # this algorithm does not perform normalisation: if there is a possibility
  # of different normalised forms being used, normalisation should be performed
  # beforehand.
  #
  # source://text//lib/text/levenshtein.rb#29
  def distance(str1, str2, max_distance = T.unsafe(nil)); end

  private

  # source://text//lib/text/levenshtein.rb#38
  def distance_with_maximum(str1, str2, max_distance); end

  # source://text//lib/text/levenshtein.rb#125
  def distance_without_maximum(str1, str2); end
end

# source://text//lib/text/double_metaphone.rb#12
module Text::Metaphone
  extend ::Text::Metaphone

  # Returns the primary and secondary double metaphone tokens
  # (the secondary will be nil if equal to the primary).
  #
  # source://text//lib/text/double_metaphone.rb#16
  def double_metaphone(str); end

  # Returns the Metaphone representation of a string. If the string contains
  # multiple words, each word in turn is converted into its Metaphone
  # representation. Note that only the letters A-Z are supported, so any
  # language-specific processing should be done beforehand.
  #
  # If the :buggy option is set, alternate 'buggy' rules are used.
  #
  # source://text//lib/text/metaphone.rb#79
  def metaphone(str, options = T.unsafe(nil)); end

  private

  # source://text//lib/text/double_metaphone.rb#49
  def double_metaphone_lookup(str, pos, length, last); end

  # source://text//lib/text/metaphone.rb#85
  def metaphone_word(w, options = T.unsafe(nil)); end

  # @return [Boolean]
  #
  # source://text//lib/text/double_metaphone.rb#41
  def slavo_germanic?(str); end

  # @return [Boolean]
  #
  # source://text//lib/text/double_metaphone.rb#45
  def vowel?(str); end
end

# source://text//lib/text/metaphone.rb#27
module Text::Metaphone::Rules; end

# The rules for the 'buggy' alternate implementation used by PHP etc.
#
# source://text//lib/text/metaphone.rb#67
Text::Metaphone::Rules::BUGGY = T.let(T.unsafe(nil), Array)

# Metaphone rules.  These are simply applied in order.
#
# source://text//lib/text/metaphone.rb#31
Text::Metaphone::Rules::STANDARD = T.let(T.unsafe(nil), Array)

# source://text//lib/text/porter_stemming.rb#12
module Text::PorterStemming
  class << self
    # source://text//lib/text/porter_stemming.rb#82
    def stem(word); end
  end
end

# consonant
#
# source://text//lib/text/porter_stemming.rb#72
Text::PorterStemming::C = T.let(T.unsafe(nil), String)

# consonant sequence
#
# source://text//lib/text/porter_stemming.rb#74
Text::PorterStemming::CC = T.let(T.unsafe(nil), String)

# [cc]vvcc[vv] is m=1
#
# source://text//lib/text/porter_stemming.rb#78
Text::PorterStemming::MEQ1 = T.let(T.unsafe(nil), Regexp)

# [cc]vvcc... is m>0
#
# source://text//lib/text/porter_stemming.rb#77
Text::PorterStemming::MGR0 = T.let(T.unsafe(nil), Regexp)

# [cc]vvccvvcc... is m>1
#
# source://text//lib/text/porter_stemming.rb#79
Text::PorterStemming::MGR1 = T.let(T.unsafe(nil), Regexp)

# source://text//lib/text/porter_stemming.rb#14
Text::PorterStemming::STEP_2_LIST = T.let(T.unsafe(nil), Hash)

# source://text//lib/text/porter_stemming.rb#24
Text::PorterStemming::STEP_3_LIST = T.let(T.unsafe(nil), Hash)

# source://text//lib/text/porter_stemming.rb#29
Text::PorterStemming::SUFFIX_1_REGEXP = T.let(T.unsafe(nil), Regexp)

# source://text//lib/text/porter_stemming.rb#52
Text::PorterStemming::SUFFIX_2_REGEXP = T.let(T.unsafe(nil), Regexp)

# vowel
#
# source://text//lib/text/porter_stemming.rb#73
Text::PorterStemming::V = T.let(T.unsafe(nil), String)

# vowel in stem
#
# source://text//lib/text/porter_stemming.rb#80
Text::PorterStemming::VOWEL_IN_STEM = T.let(T.unsafe(nil), Regexp)

# vowel sequence
#
# source://text//lib/text/porter_stemming.rb#75
Text::PorterStemming::VV = T.let(T.unsafe(nil), String)

# source://text//lib/text/soundex.rb#9
module Text::Soundex
  private

  # source://text//lib/text/soundex.rb#53
  def get_code(char); end

  # source://text//lib/text/soundex.rb#11
  def soundex(str_or_arr); end

  # returns nil if the value couldn't be calculated (empty-string, wrong-character)
  # do not change the parameter "str"
  #
  # source://text//lib/text/soundex.rb#29
  def soundex_str(str); end

  class << self
    # source://text//lib/text/soundex.rb#53
    def get_code(char); end

    # source://text//lib/text/soundex.rb#11
    def soundex(str_or_arr); end

    # returns nil if the value couldn't be calculated (empty-string, wrong-character)
    # do not change the parameter "str"
    #
    # source://text//lib/text/soundex.rb#29
    def soundex_str(str); end
  end
end

# source://text//lib/text/version.rb#2
module Text::VERSION; end

# source://text//lib/text/version.rb#3
Text::VERSION::MAJOR = T.let(T.unsafe(nil), Integer)

# source://text//lib/text/version.rb#4
Text::VERSION::MINOR = T.let(T.unsafe(nil), Integer)

# source://text//lib/text/version.rb#7
Text::VERSION::STRING = T.let(T.unsafe(nil), String)

# source://text//lib/text/version.rb#5
Text::VERSION::TINY = T.let(T.unsafe(nil), Integer)

# Ruby implementation of the string similarity described by Simon White
# at: http://www.catalysoft.com/articles/StrikeAMatch.html
#
#                        2 * |pairs(s1) INTERSECT pairs(s2)|
#   similarity(s1, s2) = -----------------------------------
#                            |pairs(s1)| + |pairs(s2)|
#
# e.g.
#                                             2 * |{FR, NC}|
#   similarity(FRANCE, FRENCH) = ---------------------------------------
#                                |{FR,RA,AN,NC,CE}| + |{FR,RE,EN,NC,CH}|
#
#                              = (2 * 2) / (5 + 5)
#
#                              = 0.4
#
#   WhiteSimilarity.new.similarity("FRANCE", "FRENCH")
#
# source://text//lib/text/white_similarity.rb#26
class Text::WhiteSimilarity
  # @return [WhiteSimilarity] a new instance of WhiteSimilarity
  #
  # source://text//lib/text/white_similarity.rb#32
  def initialize; end

  # source://text//lib/text/white_similarity.rb#36
  def similarity(str1, str2); end

  private

  # source://text//lib/text/white_similarity.rb#54
  def word_letter_pairs(str); end

  class << self
    # source://text//lib/text/white_similarity.rb#28
    def similarity(str1, str2); end
  end
end
