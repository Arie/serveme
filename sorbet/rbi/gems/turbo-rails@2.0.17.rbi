# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `turbo-rails` gem.
# Please instead update this file by running `bin/tapioca gem turbo-rails`.


class ActionController::Base < ::ActionController::Metal
  include ::ActionDispatch::Routing::PolymorphicRoutes
  include ::ActionController::Head
  include ::AbstractController::Caching::ConfigMethods
  include ::ActionController::BasicImplicitRender
  include ::Devise::Controllers::SignInOut
  include ::Devise::Controllers::StoreLocation
  extend ::AbstractController::Helpers::Resolution
end

module ActionController::Base::HelperMethods
  include ::ActionText::ContentHelper
  include ::ActionText::TagHelper
  include ::Turbo::DriveHelper
  include ::Turbo::FramesHelper
  include ::Turbo::IncludesHelper
  include ::Turbo::StreamsHelper
  include ::ActionView::Helpers::CaptureHelper
  include ::ActionView::Helpers::OutputSafetyHelper
  include ::ActionView::Helpers::TagHelper
  include ::Turbo::Streams::ActionHelper
end

# source://turbo-rails//lib/turbo/engine.rb#3
module Turbo
  extend ::ActiveSupport::Autoload

  # source://turbo-rails//lib/turbo-rails.rb#9
  def current_request_id; end

  # source://turbo-rails//lib/turbo-rails.rb#9
  def current_request_id=(obj); end

  # source://turbo-rails//lib/turbo-rails.rb#7
  def draw_routes; end

  # source://turbo-rails//lib/turbo-rails.rb#7
  def draw_routes=(val); end

  class << self
    # source://turbo-rails//lib/turbo-rails.rb#9
    def current_request_id; end

    # source://turbo-rails//lib/turbo-rails.rb#9
    def current_request_id=(obj); end

    # source://turbo-rails//lib/turbo-rails.rb#7
    def draw_routes; end

    # source://turbo-rails//lib/turbo-rails.rb#7
    def draw_routes=(val); end

    # source://turbo-rails//lib/turbo/engine.rb#5
    def railtie_helpers_paths; end

    # source://turbo-rails//lib/turbo/engine.rb#5
    def railtie_namespace; end

    # source://turbo-rails//lib/turbo/engine.rb#5
    def railtie_routes_url_helpers(include_path_helpers = T.unsafe(nil)); end

    # source://turbo-rails//lib/turbo-rails.rb#14
    def signed_stream_verifier; end

    # source://turbo-rails//lib/turbo-rails.rb#18
    def signed_stream_verifier_key; end

    # Sets the attribute signed_stream_verifier_key
    #
    # @param value the value to set the attribute signed_stream_verifier_key to.
    #
    # source://turbo-rails//lib/turbo-rails.rb#12
    def signed_stream_verifier_key=(_arg0); end

    # source://turbo-rails//lib/turbo/engine.rb#5
    def table_name_prefix; end

    # source://turbo-rails//lib/turbo/engine.rb#5
    def use_relative_model_naming?; end

    # source://turbo-rails//lib/turbo-rails.rb#22
    def with_request_id(request_id); end
  end
end

module Turbo::Broadcastable
  extend ::ActiveSupport::Concern

  mixes_in_class_methods ::Turbo::Broadcastable::ClassMethods

  def broadcast_action(action, target: T.unsafe(nil), attributes: T.unsafe(nil), **rendering); end
  def broadcast_action_later(action:, target: T.unsafe(nil), attributes: T.unsafe(nil), **rendering); end
  def broadcast_action_later_to(*streamables, action:, target: T.unsafe(nil), attributes: T.unsafe(nil), **rendering); end
  def broadcast_action_to(*streamables, action:, target: T.unsafe(nil), attributes: T.unsafe(nil), **rendering); end
  def broadcast_after_to(*streamables, target: T.unsafe(nil), targets: T.unsafe(nil), **rendering); end
  def broadcast_append(target: T.unsafe(nil), **rendering); end
  def broadcast_append_later(target: T.unsafe(nil), **rendering); end
  def broadcast_append_later_to(*streamables, target: T.unsafe(nil), **rendering); end
  def broadcast_append_to(*streamables, target: T.unsafe(nil), **rendering); end
  def broadcast_before_to(*streamables, target: T.unsafe(nil), targets: T.unsafe(nil), **rendering); end
  def broadcast_prepend(target: T.unsafe(nil), **rendering); end
  def broadcast_prepend_later(target: T.unsafe(nil), **rendering); end
  def broadcast_prepend_later_to(*streamables, target: T.unsafe(nil), **rendering); end
  def broadcast_prepend_to(*streamables, target: T.unsafe(nil), **rendering); end
  def broadcast_refresh; end
  def broadcast_refresh_later; end
  def broadcast_refresh_later_to(*streamables); end
  def broadcast_refresh_to(*streamables); end
  def broadcast_remove(**rendering); end
  def broadcast_remove_to(*streamables, target: T.unsafe(nil), **rendering); end
  def broadcast_render(**rendering); end
  def broadcast_render_later(**rendering); end
  def broadcast_render_later_to(*streamables, **rendering); end
  def broadcast_render_to(*streamables, **rendering); end
  def broadcast_replace(**rendering); end
  def broadcast_replace_later(**rendering); end
  def broadcast_replace_later_to(*streamables, **rendering); end
  def broadcast_replace_to(*streamables, **rendering); end
  def broadcast_update(**rendering); end
  def broadcast_update_later(**rendering); end
  def broadcast_update_later_to(*streamables, **rendering); end
  def broadcast_update_to(*streamables, **rendering); end

  private

  def broadcast_rendering_with_defaults(options); end
  def broadcast_target_default; end
  def extract_options_and_add_target(rendering = T.unsafe(nil), target: T.unsafe(nil)); end
end

module Turbo::Broadcastable::ClassMethods
  def broadcast_target_default; end
  def broadcasts(stream = T.unsafe(nil), inserts_by: T.unsafe(nil), target: T.unsafe(nil), **rendering); end
  def broadcasts_refreshes(stream = T.unsafe(nil)); end
  def broadcasts_refreshes_to(stream); end
  def broadcasts_to(stream, inserts_by: T.unsafe(nil), target: T.unsafe(nil), **rendering); end
  def suppressed_turbo_broadcasts?; end
  def suppressing_turbo_broadcasts(&block); end
end

# source://turbo-rails//lib/turbo/broadcastable/test_helper.rb#3
module Turbo::Broadcastable::TestHelper
  extend ::ActiveSupport::Concern
  include ::ActionCable::TestHelper
  include ::Turbo::Streams::StreamName

  # Asserts that no `<turbo-stream>` elements were broadcast over Action Cable
  #
  # ==== Arguments
  #
  # * <tt>stream_name_or_object</tt> the objects used to generate the
  #   channel Action Cable name, or the name itself
  # * <tt>&block</tt> optional block executed before the
  #   assertion
  #
  # Asserts that no `<turbo-stream>` elements were broadcast:
  #
  #     message = Message.find(1)
  #     message.broadcast_replace_to "messages"
  #
  #     assert_no_turbo_stream_broadcasts "messages" # fails with MiniTest::Assertion error
  #
  # You can pass a block to run before the assertion:
  #
  #     message = Message.find(1)
  #
  #     assert_no_turbo_stream_broadcasts "messages" do
  #       # do something other than broadcast to "messages"
  #     end
  #
  # In addition to a String, the helper also accepts an Object or Array to
  # determine the name of the channel the elements are broadcast to:
  #
  #     message = Message.find(1)
  #
  #     assert_no_turbo_stream_broadcasts message do
  #       # do something other than broadcast to "message_1"
  #     end
  #
  # source://turbo-rails//lib/turbo/broadcastable/test_helper.rb#104
  def assert_no_turbo_stream_broadcasts(stream_name_or_object, &block); end

  # Asserts that `<turbo-stream>` elements were broadcast over Action Cable
  #
  # ==== Arguments
  #
  # * <tt>stream_name_or_object</tt> the objects used to generate the
  #   channel Action Cable name, or the name itself
  # * <tt>&block</tt> optional block executed before the
  #   assertion
  #
  # ==== Options
  #
  # * <tt>count:</tt> the number of `<turbo-stream>` elements that are
  # expected to be broadcast
  #
  # Asserts `<turbo-stream>` elements were broadcast:
  #
  #     message = Message.find(1)
  #     message.broadcast_replace_to "messages"
  #
  #     assert_turbo_stream_broadcasts "messages"
  #
  # Asserts that two `<turbo-stream>` elements were broadcast:
  #
  #     message = Message.find(1)
  #     message.broadcast_replace_to "messages"
  #     message.broadcast_remove_to "messages"
  #
  #     assert_turbo_stream_broadcasts "messages", count: 2
  #
  # You can pass a block to run before the assertion:
  #
  #     message = Message.find(1)
  #
  #     assert_turbo_stream_broadcasts "messages" do
  #       message.broadcast_append_to "messages"
  #     end
  #
  # In addition to a String, the helper also accepts an Object or Array to
  # determine the name of the channel the elements are broadcast to:
  #
  #     message = Message.find(1)
  #
  #     assert_turbo_stream_broadcasts message do
  #       message.broadcast_replace
  #     end
  #
  # source://turbo-rails//lib/turbo/broadcastable/test_helper.rb#58
  def assert_turbo_stream_broadcasts(stream_name_or_object, count: T.unsafe(nil), &block); end

  # Captures any `<turbo-stream>` elements that were broadcast over Action Cable
  #
  # ==== Arguments
  #
  # * <tt>stream_name_or_object</tt> the objects used to generate the
  #   channel Action Cable name, or the name itself
  # * <tt>&block</tt> optional block to capture broadcasts during execution
  #
  # Returns any `<turbo-stream>` elements that have been broadcast as an
  # Array of <tt>Nokogiri::XML::Element</tt> instances
  #
  #     message = Message.find(1)
  #     message.broadcast_append_to "messages"
  #     message.broadcast_prepend_to "messages"
  #
  #     turbo_streams = capture_turbo_stream_broadcasts "messages"
  #
  #     assert_equal "append", turbo_streams.first["action"]
  #     assert_equal "prepend", turbo_streams.second["action"]
  #
  # You can pass a block to limit the scope of the broadcasts being captured:
  #
  #     message = Message.find(1)
  #
  #     turbo_streams = capture_turbo_stream_broadcasts "messages" do
  #       message.broadcast_append_to "messages"
  #     end
  #
  #     assert_equal "append", turbo_streams.first["action"]
  #
  # In addition to a String, the helper also accepts an Object or Array to
  # determine the name of the channel the elements are broadcast to:
  #
  #     message = Message.find(1)
  #
  #     replace, remove = capture_turbo_stream_broadcasts message do
  #       message.broadcast_replace
  #       message.broadcast_remove
  #     end
  #
  #     assert_equal "replace", replace["action"]
  #     assert_equal "replace", remove["action"]
  #
  # source://turbo-rails//lib/turbo/broadcastable/test_helper.rb#157
  def capture_turbo_stream_broadcasts(stream_name_or_object, &block); end
end

class Turbo::Debouncer
  def initialize(delay: T.unsafe(nil)); end

  def debounce(&block); end
  def delay; end
  def scheduled_task; end
  def wait; end

  private

  def wait_timeout; end
end

Turbo::Debouncer::DEFAULT_DELAY = T.let(T.unsafe(nil), Float)

module Turbo::DriveHelper
  def turbo_exempts_page_from_cache; end
  def turbo_exempts_page_from_cache_tag; end
  def turbo_exempts_page_from_preview; end
  def turbo_exempts_page_from_preview_tag; end
  def turbo_page_requires_reload; end
  def turbo_page_requires_reload_tag; end
  def turbo_refresh_method_tag(method = T.unsafe(nil)); end
  def turbo_refresh_scroll_tag(scroll = T.unsafe(nil)); end
  def turbo_refreshes_with(method: T.unsafe(nil), scroll: T.unsafe(nil)); end
end

# source://turbo-rails//lib/turbo/engine.rb#4
class Turbo::Engine < ::Rails::Engine; end

# If you don't want to precompile Turbo's assets (eg. because you're using webpack),
# you can do this in an intiailzer:
#
# config.after_initialize do
#   config.assets.precompile -= Turbo::Engine::PRECOMPILE_ASSETS
# end
#
# source://turbo-rails//lib/turbo/engine.rb#67
Turbo::Engine::PRECOMPILE_ASSETS = T.let(T.unsafe(nil), Array)

module Turbo::Frames; end

module Turbo::Frames::FrameRequest
  extend ::ActiveSupport::Concern

  private

  def turbo_frame_request?; end
  def turbo_frame_request_id; end
end

module Turbo::FramesHelper
  def turbo_frame_tag(*ids, src: T.unsafe(nil), target: T.unsafe(nil), **attributes, &block); end
end

module Turbo::IncludesHelper
  def turbo_include_tags; end
end

module Turbo::Native; end

module Turbo::Native::Navigation
  extend ::ActiveSupport::Concern

  def hotwire_native_app?; end
  def recede_or_redirect_back_or_to(url, **options); end
  def recede_or_redirect_to(url, **options); end
  def refresh_or_redirect_back_or_to(url, **options); end
  def refresh_or_redirect_to(url, **options); end
  def resume_or_redirect_back_or_to(url, **options); end
  def resume_or_redirect_to(url, **options); end
  def turbo_native_app?; end

  private

  def turbo_native_action_or_redirect(url, action, redirect_type, options = T.unsafe(nil)); end
end

class Turbo::Native::NavigationController < ::ActionController::Base
  def recede; end
  def refresh; end
  def resume; end

  private

  def _layout(lookup_context, formats, keys); end
  def _layout_from_proc; end

  class << self
    private

    def __class_attr_middleware_stack; end
    def __class_attr_middleware_stack=(new_value); end
  end
end

module Turbo::RequestIdTracking
  extend ::ActiveSupport::Concern

  private

  def turbo_tracking_request_id(&block); end
end

# source://turbo-rails//lib/turbo/system_test_helper.rb#107
module Turbo::Streams; end

class Turbo::Streams::ActionBroadcastJob < ::ActiveJob::Base
  def perform(stream, action:, target:, attributes: T.unsafe(nil), **rendering); end

  class << self
    private

    def __class_attr_rescue_handlers; end
    def __class_attr_rescue_handlers=(new_value); end
  end
end

module Turbo::Streams::ActionHelper
  include ::ActionView::Helpers::CaptureHelper
  include ::ActionView::Helpers::OutputSafetyHelper
  include ::ActionView::Helpers::TagHelper

  def turbo_stream_action_tag(action, target: T.unsafe(nil), targets: T.unsafe(nil), template: T.unsafe(nil), **attributes); end
  def turbo_stream_refresh_tag(request_id: T.unsafe(nil), **attributes); end

  private

  def convert_to_turbo_stream_dom_id(target, include_selector: T.unsafe(nil)); end
end

class Turbo::Streams::BroadcastJob < ::ActiveJob::Base
  def perform(stream, **rendering); end

  class << self
    private

    def __class_attr_rescue_handlers; end
    def __class_attr_rescue_handlers=(new_value); end
  end
end

class Turbo::Streams::BroadcastStreamJob < ::ActiveJob::Base
  def perform(stream, content:); end

  class << self
    private

    def __class_attr_rescue_handlers; end
    def __class_attr_rescue_handlers=(new_value); end
  end
end

module Turbo::Streams::Broadcasts
  include ::ActionView::Helpers::CaptureHelper
  include ::ActionView::Helpers::OutputSafetyHelper
  include ::ActionView::Helpers::TagHelper
  include ::Turbo::Streams::ActionHelper

  def broadcast_action_later_to(*streamables, action:, target: T.unsafe(nil), targets: T.unsafe(nil), attributes: T.unsafe(nil), **rendering); end
  def broadcast_action_to(*streamables, action:, target: T.unsafe(nil), targets: T.unsafe(nil), attributes: T.unsafe(nil), **rendering); end
  def broadcast_after_later_to(*streamables, **opts); end
  def broadcast_after_to(*streamables, **opts); end
  def broadcast_append_later_to(*streamables, **opts); end
  def broadcast_append_to(*streamables, **opts); end
  def broadcast_before_later_to(*streamables, **opts); end
  def broadcast_before_to(*streamables, **opts); end
  def broadcast_prepend_later_to(*streamables, **opts); end
  def broadcast_prepend_to(*streamables, **opts); end
  def broadcast_refresh_later_to(*streamables, request_id: T.unsafe(nil), **opts); end
  def broadcast_refresh_to(*streamables, **opts); end
  def broadcast_remove_to(*streamables, **opts); end
  def broadcast_render_later_to(*streamables, **rendering); end
  def broadcast_render_to(*streamables, **rendering); end
  def broadcast_replace_later_to(*streamables, **opts); end
  def broadcast_replace_to(*streamables, **opts); end
  def broadcast_stream_to(*streamables, content:); end
  def broadcast_update_later_to(*streamables, **opts); end
  def broadcast_update_to(*streamables, **opts); end
  def refresh_debouncer_for(*streamables, request_id: T.unsafe(nil)); end

  private

  def render_broadcast_action(rendering); end
  def render_format(format, **rendering); end
end

module Turbo::Streams::StreamName
  def signed_stream_name(streamables); end
  def verified_stream_name(signed_stream_name); end

  private

  def stream_name_from(streamables); end
end

module Turbo::Streams::StreamName::ClassMethods
  def verified_stream_name_from_params; end
end

class Turbo::Streams::TagBuilder
  include ::ActionView::Helpers::CaptureHelper
  include ::ActionView::Helpers::OutputSafetyHelper
  include ::ActionView::Helpers::TagHelper
  include ::Turbo::Streams::ActionHelper

  def initialize(view_context); end

  def action(name, target, content = T.unsafe(nil), method: T.unsafe(nil), allow_inferred_rendering: T.unsafe(nil), **rendering, &block); end
  def action_all(name, targets, content = T.unsafe(nil), method: T.unsafe(nil), allow_inferred_rendering: T.unsafe(nil), **rendering, &block); end
  def after(target, content = T.unsafe(nil), **rendering, &block); end
  def after_all(targets, content = T.unsafe(nil), **rendering, &block); end
  def append(target, content = T.unsafe(nil), **rendering, &block); end
  def append_all(targets, content = T.unsafe(nil), **rendering, &block); end
  def before(target, content = T.unsafe(nil), **rendering, &block); end
  def before_all(targets, content = T.unsafe(nil), **rendering, &block); end
  def prepend(target, content = T.unsafe(nil), **rendering, &block); end
  def prepend_all(targets, content = T.unsafe(nil), **rendering, &block); end
  def refresh(*_arg0, **_arg1, &_arg2); end
  def remove(target); end
  def remove_all(targets); end
  def replace(target, content = T.unsafe(nil), method: T.unsafe(nil), **rendering, &block); end
  def replace_all(targets, content = T.unsafe(nil), method: T.unsafe(nil), **rendering, &block); end
  def update(target, content = T.unsafe(nil), method: T.unsafe(nil), **rendering, &block); end
  def update_all(targets, content = T.unsafe(nil), method: T.unsafe(nil), **rendering, &block); end

  private

  def render_record(possible_record); end
  def render_template(target, content = T.unsafe(nil), allow_inferred_rendering: T.unsafe(nil), **rendering, &block); end
end

module Turbo::Streams::TurboStreamsTagBuilder
  private

  def turbo_stream; end
end

class Turbo::StreamsChannel < ::ActionCable::Channel::Base
  include ::Turbo::Streams::StreamName::ClassMethods
  extend ::Turbo::Streams::StreamName
  extend ::ActionView::Helpers::CaptureHelper
  extend ::ActionView::Helpers::OutputSafetyHelper
  extend ::ActionView::Helpers::TagHelper
  extend ::Turbo::Streams::ActionHelper
  extend ::Turbo::Streams::Broadcasts

  def subscribed; end
end

module Turbo::StreamsHelper
  def turbo_stream; end
  def turbo_stream_from(*streamables, **attributes); end
end

# source://turbo-rails//lib/turbo/system_test_helper.rb#1
module Turbo::SystemTestHelper
  # Asserts that a `<turbo-cable-stream-source>` element is absent from the
  # document
  #
  # ==== Arguments
  #
  # * <tt>locator</tt> optional locator to determine the element's
  #   `[signed-stream-name]` attribute. Can be of any type that is a valid
  #   argument to <tt>Turbo::Streams::StreamName#signed_stream_name</tt>.
  #
  # ==== Options
  #
  # * <tt>:connected</tt> matches the `[connected]` attribute
  # * <tt>:channel</tt> matches the `[channel]` attribute. Can be a Class,
  #   String, Symbol, or Regexp
  # * <tt>:signed_stream_name</tt> matches the element's `[signed-stream-name]`
  #   attribute. Can be of any type that is a valid
  #   argument to <tt>Turbo::Streams::StreamName#signed_stream_name</tt>.
  #
  # In addition to the filters listed above, accepts any valid Capybara global
  # filter option.
  #
  # source://turbo-rails//lib/turbo/system_test_helper.rb#78
  def assert_no_turbo_cable_stream_source(*_arg0, **_arg1, &_arg2); end

  # Asserts that a `<turbo-cable-stream-source>` element is present in the
  # document
  #
  # ==== Arguments
  #
  # * <tt>locator</tt> optional locator to determine the element's
  #   `[signed-stream-name]` attribute. Can be of any type that is a valid
  #   argument to <tt>Turbo::Streams::StreamName#signed_stream_name</tt>.
  #
  # ==== Options
  #
  # * <tt>:connected</tt> matches the `[connected]` attribute
  # * <tt>:channel</tt> matches the `[channel]` attribute. Can be a Class,
  #   String, Symbol, or Regexp
  # * <tt>:signed_stream_name</tt> matches the element's `[signed-stream-name]`
  #   attribute. Can be of any type that is a valid
  #   argument to <tt>Turbo::Streams::StreamName#signed_stream_name</tt>.
  #
  # In addition to the filters listed above, accepts any valid Capybara global
  # filter option.
  #
  # source://turbo-rails//lib/turbo/system_test_helper.rb#54
  def assert_turbo_cable_stream_source(*_arg0, **_arg1, &_arg2); end

  # Delay until every `<turbo-cable-stream-source>` element present in the page
  # is ready to receive broadcasts
  #
  #   test "renders broadcasted Messages" do
  #     message = Message.new content: "Hello, from Action Cable"
  #
  #     visit "/"
  #     click_link "All Messages"
  #     message.save! # execute server-side code to broadcast a Message
  #
  #     assert_text message.content
  #   end
  #
  # By default, calls to `#visit` will wait for all `<turbo-cable-stream-source>`
  # elements to connect. You can control this by modifying the
  # `config.turbo.test_connect_after_actions`. For example, to wait after calls to
  # `#click_link`, add the following to `config/environments/test.rb`:
  #
  #   # config/environments/test.rb
  #   config.turbo.test_connect_after_actions << :click_link
  #
  # To disable automatic connecting, set the configuration to `[]`:
  #
  #   # config/environments/test.rb
  #   config.turbo.test_connect_after_actions = []
  #
  # source://turbo-rails//lib/turbo/system_test_helper.rb#28
  def connect_turbo_cable_stream_sources(**options, &block); end
end

# source://turbo-rails//lib/turbo/system_test_helper.rb#106
class Turbo::SystemTestHelper::SignedStreamNameConditions
  include ::Enumerable
  include ::Turbo::Streams::StreamName

  # @return [SignedStreamNameConditions] a new instance of SignedStreamNameConditions
  #
  # source://turbo-rails//lib/turbo/system_test_helper.rb#109
  def initialize(value); end

  # source://turbo-rails//lib/turbo/system_test_helper.rb#113
  def attribute; end

  # source://turbo-rails//lib/turbo/system_test_helper.rb#117
  def each; end
end

# source://turbo-rails//lib/turbo/test_assertions.rb#2
module Turbo::TestAssertions
  extend ::ActiveSupport::Concern

  # Assert that the rendered fragment of HTML does not contain a `<turbo-stream>`
  # element.
  #
  # ==== Options
  #
  # * <tt>:action</tt> [String] matches the element's <tt>[action]</tt>
  #   attribute
  # * <tt>:target</tt> [String, #to_key] matches the element's
  #   <tt>[target]</tt> attribute. If the value responds to <tt>#to_key</tt>,
  #   the value will be transformed by calling <tt>dom_id</tt>
  # * <tt>:targets</tt> [String] matches the element's <tt>[targets]</tt>
  #   attribute
  #
  #   Given the following HTML fragment:
  #
  #     <turbo-stream action="remove" target="message_1"></turbo-stream>
  #
  #   The following assertion would fail:
  #
  #     assert_no_turbo_stream action: "remove", target: "message_1"
  #
  # source://turbo-rails//lib/turbo/test_assertions.rb#76
  def assert_no_turbo_stream(action:, target: T.unsafe(nil), targets: T.unsafe(nil)); end

  # Assert that the rendered fragment of HTML contains a `<turbo-stream>`
  # element.
  #
  # ==== Options
  #
  # * <tt>:action</tt> [String] matches the element's <tt>[action]</tt>
  #   attribute
  # * <tt>:target</tt> [String, #to_key] matches the element's
  #   <tt>[target]</tt> attribute. If the value responds to <tt>#to_key</tt>,
  #   the value will be transformed by calling <tt>dom_id</tt>
  # * <tt>:targets</tt> [String] matches the element's <tt>[targets]</tt>
  #   attribute
  # * <tt>:count</tt> [Integer] indicates how many turbo streams are expected.
  #   Defaults to <tt>1</tt>.
  #
  #   Given the following HTML fragment:
  #
  #     <turbo-stream action="remove" target="message_1"></turbo-stream>
  #
  #   The following assertion would pass:
  #
  #     assert_turbo_stream action: "remove", target: "message_1"
  #
  # You can also pass a block make assertions about the contents of the
  # element. Given the following HTML fragment:
  #
  #     <turbo-stream action="replace" target="message_1">
  #       <template>
  #         <p>Hello!</p>
  #       <template>
  #     </turbo-stream>
  #
  #   The following assertion would pass:
  #
  #     assert_turbo_stream action: "replace", target: "message_1" do
  #       assert_select "template p", text: "Hello!"
  #     end
  #
  # source://turbo-rails//lib/turbo/test_assertions.rb#48
  def assert_turbo_stream(action:, target: T.unsafe(nil), targets: T.unsafe(nil), count: T.unsafe(nil), &block); end
end

# source://turbo-rails//lib/turbo/test_assertions/integration_test_assertions.rb#3
module Turbo::TestAssertions::IntegrationTestAssertions
  # Assert that the Turbo Stream request's response body's HTML does not
  # contain a `<turbo-stream>` element.
  #
  # ==== Options
  #
  # * <tt>:status</tt> [Integer, Symbol] the HTTP response status
  # * <tt>:action</tt> [String] matches the element's <tt>[action]</tt>
  #   attribute
  # * <tt>:target</tt> [String, #to_key] matches the element's
  #   <tt>[target]</tt> attribute. If the value responds to <tt>#to_key</tt>,
  #   the value will be transformed by calling <tt>dom_id</tt>
  # * <tt>:targets</tt> [String] matches the element's <tt>[targets]</tt>
  #   attribute
  #
  #   Given the following HTML response body:
  #
  #     <turbo-stream action="remove" target="message_1"></turbo-stream>
  #
  #   The following assertion would fail:
  #
  #     assert_no_turbo_stream action: "remove", target: "message_1"
  #
  # source://turbo-rails//lib/turbo/test_assertions/integration_test_assertions.rb#69
  def assert_no_turbo_stream(status: T.unsafe(nil), **attributes); end

  # Assert that the Turbo Stream request's response body's HTML contains a
  # `<turbo-stream>` element.
  #
  # ==== Options
  #
  # * <tt>:status</tt> [Integer, Symbol] the HTTP response status
  # * <tt>:action</tt> [String] matches the element's <tt>[action]</tt>
  #   attribute
  # * <tt>:target</tt> [String, #to_key] matches the element's
  #   <tt>[target]</tt> attribute. If the value responds to <tt>#to_key</tt>,
  #   the value will be transformed by calling <tt>dom_id</tt>
  # * <tt>:targets</tt> [String] matches the element's <tt>[targets]</tt>
  #   attribute
  #
  #   Given the following HTML response body:
  #
  #     <turbo-stream action="remove" target="message_1"></turbo-stream>
  #
  #   The following assertion would pass:
  #
  #     assert_turbo_stream action: "remove", target: "message_1"
  #
  # You can also pass a block make assertions about the contents of the
  # element. Given the following HTML response body:
  #
  #     <turbo-stream action="replace" target="message_1">
  #       <template>
  #         <p>Hello!</p>
  #       <template>
  #     </turbo-stream>
  #
  #   The following assertion would pass:
  #
  #     assert_turbo_stream action: "replace", target: "message_1" do
  #       assert_select "template p", text: "Hello!"
  #     end
  #
  # source://turbo-rails//lib/turbo/test_assertions/integration_test_assertions.rb#41
  def assert_turbo_stream(status: T.unsafe(nil), **attributes, &block); end
end

class Turbo::ThreadDebouncer
  def initialize(key, thread, delay:); end

  def debounce; end
  def wait(*_arg0, **_arg1, &_arg2); end

  private

  def debouncer; end
  def key; end
  def thread; end

  class << self
    def for(key, delay: T.unsafe(nil)); end

    private

    def new(*_arg0); end
  end
end
