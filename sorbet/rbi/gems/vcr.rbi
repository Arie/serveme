# This file is autogenerated. Do not edit it by hand. Regenerate it with:
#   srb rbi gems

# typed: true
#
# If you would like to make changes to this file, great! Please create the gem's shim here:
#
#   https://github.com/sorbet/sorbet-typed/new/master?filename=lib/vcr/all/vcr.rbi
#
# vcr-6.2.0

module VCR
  def cassette_persisters; end
  def cassette_serializers; end
  def cassettes(context = nil); end
  def config; end
  def configuration; end
  def configure; end
  def context_cassettes; end
  def context_value(name); end
  def cucumber_tags(&block); end
  def current_cassette; end
  def current_context; end
  def dup_context(context); end
  def eject_cassette(options = nil); end
  def fibers_available?; end
  def get_context(thread_key, fiber_key = nil); end
  def http_interactions; end
  def ignore_cassettes?; end
  def initialize_fibers; end
  def initialize_ivars; end
  def insert_cassette(name, options = nil); end
  def library_hooks; end
  def link_context(from_thread, to_key); end
  def real_http_connections_allowed?; end
  def record_http_interaction(interaction); end
  def request_ignorer; end
  def request_matchers; end
  def self.const_missing(const); end
  def set_context_value(name, value); end
  def turn_off!(options = nil); end
  def turn_on!; end
  def turned_off(options = nil); end
  def turned_on(options = nil); end
  def turned_on?; end
  def unlink_context(key); end
  def use_cassette(name, options = nil, &block); end
  def use_cassettes(cassettes, &block); end
  def version; end
  extend VCR
  extend VCR
  include VCR::Errors
  include VCR::VariableArgsBlockCaller
end
class VCR::Logger
  def initialize(stream); end
  def log(message, log_prefix, indentation_level = nil); end
  def request_summary(request, request_matchers); end
  def response_summary(response); end
end
module VCR::Logger::Null
  def log(*); end
  def request_summary(*); end
  def response_summary(*); end
  def self.log(*); end
  def self.request_summary(*); end
  def self.response_summary(*); end
end
module VCR::Logger::Mixin
  def log(message, indentation_level = nil); end
  def request_summary(*args); end
  def response_summary(*args); end
end
module VCR::VariableArgsBlockCaller
  def call_block(block, *args); end
end
class VCR::Cassette
  def assert_valid_options!; end
  def assign_tags; end
  def clean_outdated_http_interactions; end
  def deserialized_hash; end
  def drop_unused_requests; end
  def eject(options = nil); end
  def erb; end
  def extract_options; end
  def file; end
  def http_interactions; end
  def initialize(name, options = nil); end
  def interactions_to_record; end
  def invoke_hook(type, interactions); end
  def linked?; end
  def log_prefix; end
  def match_requests_on; end
  def merged_interactions; end
  def name; end
  def new_recorded_interactions; end
  def originally_recorded_at; end
  def previously_recorded_interactions; end
  def raise_error_unless_valid_record_mode; end
  def raw_cassette_bytes; end
  def re_record_interval; end
  def record_http_interaction(interaction); end
  def record_mode; end
  def record_on_error; end
  def recording?; end
  def request_summary(request); end
  def run_failed!; end
  def run_failed?; end
  def self.const_missing(const); end
  def serializable_hash; end
  def should_assert_no_unused_interactions?; end
  def should_re_record?(record_mode); end
  def should_remove_matching_existing_interactions?; end
  def should_remove_unused_interactions?; end
  def should_stub_requests?; end
  def should_write_recorded_interactions_to_disk?; end
  def storage_key; end
  def tags; end
  def up_to_date_interactions(interactions); end
  def write_recorded_interactions_to_disk; end
  include VCR::Logger::Mixin
end
class VCR::Cassette::HTTPInteractionList
  def allow_playback_repeats; end
  def assert_no_unused_interactions!; end
  def has_interaction_matching?(request); end
  def has_unused_interactions?; end
  def has_used_interaction_matching?(request); end
  def initialize(interactions, request_matchers, allow_playback_repeats = nil, parent_list = nil, log_prefix = nil); end
  def interaction_matches_request?(request, interaction); end
  def interactions; end
  def log_prefix; end
  def matching_interaction_index_for(request); end
  def matching_used_interaction_for(request); end
  def parent_list; end
  def remaining_unused_interaction_count; end
  def request_matchers; end
  def request_summary(request); end
  def response_for(request); end
  include VCR::Logger::Mixin
end
module VCR::Cassette::HTTPInteractionList::NullList
  def has_interaction_matching?(*a); end
  def has_used_interaction_matching?(*a); end
  def remaining_unused_interaction_count(*a); end
  def response_for(*a); end
  extend VCR::Cassette::HTTPInteractionList::NullList
end
class VCR::Cassette::ERBRenderer
  def binding_for_variables; end
  def erb_variables; end
  def handle_name_error(e); end
  def initialize(raw_template, erb, cassette_name = nil); end
  def render; end
  def template; end
  def use_erb?; end
  def variables_object; end
end
class VCR::Cassette::Serializers
  def [](name); end
  def []=(name, value); end
  def initialize; end
end
module VCR::Cassette::EncodingErrorHandling
  def handle_encoding_errors; end
end
module VCR::Cassette::SyntaxErrorHandling
  def handle_syntax_errors; end
end
class VCR::Cassette::Persisters
  def [](name); end
  def []=(name, value); end
  def initialize; end
end
module VCR::Errors
end
class VCR::Errors::Error < StandardError
end
class VCR::Errors::CassetteInUseError < VCR::Errors::Error
end
class VCR::Errors::TurnedOffError < VCR::Errors::Error
end
class VCR::Errors::MissingERBVariableError < VCR::Errors::Error
end
class VCR::Errors::LibraryVersionTooLowError < VCR::Errors::Error
end
class VCR::Errors::UnregisteredMatcherError < VCR::Errors::Error
end
class VCR::Errors::InvalidCassetteFormatError < VCR::Errors::Error
end
class VCR::Errors::AroundHTTPRequestHookError < VCR::Errors::Error
end
class VCR::Errors::NotSupportedError < VCR::Errors::Error
end
class VCR::Errors::UnknownContentEncodingError < VCR::Errors::Error
end
class VCR::Errors::UnusedHTTPInteractionError < VCR::Errors::Error
end
class VCR::Errors::EjectLinkedCassetteError < VCR::Errors::Error
end
class VCR::Errors::UnhandledHTTPRequestError < VCR::Errors::Error
  def cassettes_description; end
  def cassettes_list; end
  def construct_message; end
  def current_cassettes; end
  def current_matchers; end
  def format_bullet_point(lines, index); end
  def format_foot_note(url, index); end
  def formatted_headers; end
  def formatted_suggestions; end
  def has_used_interaction_matching?; end
  def initialize(request); end
  def match_request_on_body?; end
  def match_request_on_headers?; end
  def match_requests_on_suggestion; end
  def no_cassette_suggestions; end
  def record_mode_suggestion; end
  def relish_version_slug; end
  def request; end
  def request_description; end
  def suggestion_for(key); end
  def suggestions; end
end
class VCR::LinkedCassette < SimpleDelegator
  def eject(*args); end
  def linked?; end
  def self.list(cassettes, linked_cassettes); end
end
class VCR::LinkedCassette::CassetteList
  def each; end
  def initialize(cassettes, linked_cassettes); end
  def last; end
  def size; end
  def wrap(cassette); end
  include Enumerable
end
module VCR::Hooks
  def clear_hooks; end
  def has_hooks_for?(hook_type); end
  def hooks; end
  def invoke_hook(hook_type, *args); end
  def self.included(klass); end
  include VCR::VariableArgsBlockCaller
end
class VCR::Hooks::FilteredHook < Struct
  def conditionally_invoke(*args); end
  def filters; end
  def filters=(_); end
  def hook; end
  def hook=(_); end
  def self.[](*arg0); end
  def self.inspect; end
  def self.keyword_init?; end
  def self.members; end
  def self.new(*arg0); end
  include VCR::VariableArgsBlockCaller
end
module VCR::Hooks::ClassMethods
  def define_hook(hook_type, prepend = nil); end
end
class VCR::Configuration
  def after_http_request(*filters); end
  def allow_http_connections_when_no_cassette=(arg0); end
  def allow_http_connections_when_no_cassette?; end
  def around_http_request(*filters, &block); end
  def before_playback(tag = nil, &block); end
  def before_record(tag = nil, &block); end
  def cassette_library_dir; end
  def cassette_library_dir=(dir); end
  def cassette_persisters; end
  def cassette_serializers; end
  def configure_rspec_metadata!; end
  def create_fiber_for(fiber_errors, hook_declaration, proc); end
  def debug_logger; end
  def debug_logger=(value); end
  def default_cassette_options; end
  def default_cassette_options=(overrides); end
  def define_cassette_placeholder(placeholder, tag = nil, &block); end
  def filter_sensitive_data(placeholder, tag = nil, &block); end
  def hook_into(*hooks); end
  def ignore_host(*hosts); end
  def ignore_hosts(*hosts); end
  def ignore_localhost=(value); end
  def ignore_request(&block); end
  def initialize; end
  def load_library_hook(hook); end
  def log_prefix; end
  def logger; end
  def preserve_exact_body_bytes_for?(http_message); end
  def query_parser; end
  def query_parser=(arg0); end
  def register_built_in_hooks; end
  def register_request_matcher(name, &block); end
  def request_filter_from(object); end
  def resume_fiber(fiber, fiber_errors, response, hook_declaration); end
  def start_new_fiber_for(request, fibers, fiber_errors, hook_declaration, proc); end
  def stub_with(*adapters); end
  def tag_filter_from(tag); end
  def unignore_host(*hosts); end
  def unignore_hosts(*hosts); end
  def uri_parser; end
  def uri_parser=(arg0); end
  extend VCR::Hooks::ClassMethods
  include VCR::Configuration::DefinedHooks
  include VCR::Hooks
  include VCR::Logger::Mixin
  include VCR::VariableArgsBlockCaller
end
module VCR::Configuration::DefinedHooks
  def after_http_request(*filters, &hook); end
  def after_library_hooks_loaded(*filters, &hook); end
  def before_http_request(*filters, &hook); end
  def before_playback(*filters, &hook); end
  def before_record(*filters, &hook); end
  def preserve_exact_body_bytes(*filters, &hook); end
end
module VCR::Deprecations
end
module VCR::Deprecations::Middleware
end
module VCR::Deprecations::Middleware::Faraday
  def initialize(*args); end
end
class VCR::LibraryHooks
  def disabled?(hook); end
  def exclusive_hook; end
  def exclusive_hook=(arg0); end
  def exclusively_enabled(hook); end
end
class VCR::RequestIgnorer
  def ignore?(request); end
  def ignore_hosts(*hosts); end
  def ignore_localhost=(value); end
  def ignored_hosts; end
  def initialize; end
  def localhost_ignored?; end
  def unignore_hosts(*hosts); end
  extend VCR::Hooks::ClassMethods
  include VCR::Hooks
  include VCR::RequestIgnorer::DefinedHooks
end
module VCR::RequestIgnorer::DefinedHooks
  def ignore_request(*filters, &hook); end
end
class VCR::RequestMatcherRegistry
  def [](matcher); end
  def initialize; end
  def raise_unregistered_matcher_error(name); end
  def register(name, &block); end
  def register_built_ins; end
  def try_to_register_body_as_json; end
  def uri_without_param(*ignores); end
  def uri_without_param_matchers; end
  def uri_without_params(*ignores); end
end
class Anonymous_Struct_668 < Struct
  def callable; end
  def callable=(_); end
  def self.[](*arg0); end
  def self.inspect; end
  def self.keyword_init?; end
  def self.members; end
  def self.new(*arg0); end
end
class VCR::RequestMatcherRegistry::Matcher < Anonymous_Struct_668
  def matches?(request_1, request_2); end
end
class Anonymous_Struct_669 < Struct
  def params_to_ignore; end
  def params_to_ignore=(_); end
  def self.[](*arg0); end
  def self.inspect; end
  def self.keyword_init?; end
  def self.members; end
  def self.new(*arg0); end
end
class VCR::RequestMatcherRegistry::URIWithoutParamsMatcher < Anonymous_Struct_669
  def call(request_1, request_2); end
  def partial_uri_from(request); end
  def to_proc; end
end
module VCR::Normalizers
end
module VCR::Normalizers::Body
  def base_body_hash(body); end
  def initialize(*args); end
  def self.included(klass); end
  def serializable_body; end
end
module VCR::Normalizers::Body::ClassMethods
  def body_from(hash_or_string); end
  def force_encode_string(string, encoding); end
  def try_encode_string(string, encoding); end
end
module VCR::Normalizers::Header
  def convert_to_raw_strings(array); end
  def delete_header(key); end
  def edit_header(key, value = nil); end
  def get_header(key); end
  def header_key(key); end
  def initialize(*args); end
  def normalize_headers; end
end
class Anonymous_Struct_670 < Struct
  def body; end
  def body=(_); end
  def headers; end
  def headers=(_); end
  def method; end
  def method=(_); end
  def self.[](*arg0); end
  def self.inspect; end
  def self.keyword_init?; end
  def self.members; end
  def self.new(*arg0); end
  def uri; end
  def uri=(_); end
end
class VCR::Request < Anonymous_Struct_670
  def initialize(*args); end
  def method(*args); end
  def parsed_uri; end
  def self.from_hash(hash); end
  def to_hash; end
  def without_standard_port(uri); end
  extend VCR::Normalizers::Body::ClassMethods
  include VCR::Normalizers::Body
  include VCR::Normalizers::Header
end
class VCR::Request::Typed < Anonymous_Delegator_671
  def externally_stubbed?; end
  def ignored?; end
  def initialize(request, type); end
  def real?; end
  def recordable?; end
  def stubbed?; end
  def stubbed_by_vcr?; end
  def type; end
  def unhandled?; end
end
class VCR::Request::FiberAware < Anonymous_Delegator_672
  def proceed; end
  def to_proc; end
end
class Anonymous_Struct_673 < Struct
  def adapter_metadata; end
  def adapter_metadata=(_); end
  def body; end
  def body=(_); end
  def headers; end
  def headers=(_); end
  def http_version; end
  def http_version=(_); end
  def self.[](*arg0); end
  def self.inspect; end
  def self.keyword_init?; end
  def self.members; end
  def self.new(*arg0); end
  def status; end
  def status=(_); end
end
class VCR::Response < Anonymous_Struct_673
  def compressed?; end
  def content_encoding; end
  def decompress; end
  def initialize(*args); end
  def recompress; end
  def self.decompress(body, type); end
  def self.from_hash(hash); end
  def to_hash; end
  def update_content_length_header; end
  def vcr_decompressed?; end
  extend VCR::Normalizers::Body::ClassMethods
  include VCR::Normalizers::Body
  include VCR::Normalizers::Header
end
class Anonymous_Struct_674 < Struct
  def code; end
  def code=(_); end
  def message; end
  def message=(_); end
  def self.[](*arg0); end
  def self.inspect; end
  def self.keyword_init?; end
  def self.members; end
  def self.new(*arg0); end
end
class VCR::ResponseStatus < Anonymous_Struct_674
  def self.from_hash(hash); end
  def to_hash; end
end
class Anonymous_Struct_675 < Struct
  def recorded_at; end
  def recorded_at=(_); end
  def request; end
  def request=(_); end
  def response; end
  def response=(_); end
  def self.[](*arg0); end
  def self.inspect; end
  def self.keyword_init?; end
  def self.members; end
  def self.new(*arg0); end
end
class VCR::HTTPInteraction < Anonymous_Struct_675
  def hook_aware; end
  def initialize(*args); end
  def self.from_hash(hash); end
  def to_hash; end
end
class VCR::HTTPInteraction::HookAware < Anonymous_Delegator_676
  def filter!(text, replacement_text); end
  def filter_hash!(hash, text, replacement_text); end
  def filter_object!(object, text, replacement_text); end
  def ignore!; end
  def ignored?; end
  def initialize(http_interaction); end
end
module VCR::RSpec
end
module VCR::Middleware
end
class VCR::CucumberTags
  def initialize(main_object); end
  def self.add_tag(tag); end
  def self.tags; end
  def tag(*tag_names); end
  def tags(*tag_names); end
end
class VCR::CucumberTags::ScenarioNameBuilder
  def cassette_name; end
  def examples_table(*); end
  def examples_table_row(row); end
  def feature(feature); end
  def initialize(test_case); end
  def scenario(*); end
  def scenario_outline(feature); end
end
module VCR::Cassette::Persisters::FileSystem
  def [](file_name); end
  def []=(file_name, content); end
  def absolute_path_for(path); end
  def absolute_path_to_file(file_name); end
  def downcase_cassette_names?; end
  def sanitized_file_name_from(file_name); end
  def storage_location; end
  def storage_location=(dir); end
  extend VCR::Cassette::Persisters::FileSystem
end
class VCR::VersionChecker
  def check_version!; end
  def compare_version; end
  def initialize(library_name, library_version, min_version); end
  def parse_version(version); end
  def raise_too_low_error; end
  def too_low?; end
  def version_requirement; end
end
class VCR::RequestHandler
  def disabled?; end
  def externally_stubbed?; end
  def handle; end
  def has_response_stub?(consume_stub); end
  def invoke_after_request_hook(vcr_response); end
  def invoke_before_request_hook; end
  def library_name; end
  def log_prefix; end
  def on_externally_stubbed_request; end
  def on_ignored_request; end
  def on_recordable_request; end
  def on_stubbed_by_vcr_request; end
  def on_unhandled_request; end
  def request_summary; end
  def request_type(consume_stub = nil); end
  def set_typed_request_for_after_hook(request_type); end
  def should_ignore?; end
  def stubbed_response; end
  include VCR::Logger::Mixin
end
module VCR::LibraryHooks::WebMock
  def global_hook_disabled?(request); end
  def global_hook_disabled_requests; end
  def with_global_hook_disabled(request); end
  extend VCR::LibraryHooks::WebMock
  extend VCR::LibraryHooks::WebMock::Helpers
end
module VCR::LibraryHooks::WebMock::Helpers
  def request_headers_for(webmock_request); end
  def typed_request_for(webmock_request, remove = nil); end
  def vcr_request_for(webmock_request); end
  def vcr_response_for(webmock_response); end
end
class VCR::LibraryHooks::WebMock::RequestHandler < VCR::RequestHandler
  def externally_stubbed?; end
  def initialize(request); end
  def on_externally_stubbed_request; end
  def on_stubbed_by_vcr_request; end
  def on_unhandled_request; end
  def request; end
  def set_typed_request_for_after_hook(*args); end
  def vcr_request; end
  include VCR::LibraryHooks::WebMock::Helpers
end
module WebMock
  def self.net_connect_allowed_with_vcr?(*args); end
  def self.net_connect_allowed_without_vcr?(uri = nil); end
end
class VCR::Middleware::Faraday
  def call(env); end
  def close; end
  def initialize(app); end
  include VCR::Deprecations::Middleware::Faraday
end
class VCR::Middleware::Faraday::RequestHandler < VCR::RequestHandler
  def app; end
  def collect_chunks; end
  def delay_finishing?; end
  def env; end
  def handle; end
  def initialize(app, env); end
  def invoke_after_request_hook(response); end
  def on_ignored_request; end
  def on_recordable_request; end
  def on_stubbed_by_vcr_request; end
  def raw_body_from(body); end
  def response_for(response); end
  def restore_body_from_chunks(request); end
  def vcr_request; end
end
module VCR::LibraryHooks::Faraday
end
module VCR::LibraryHooks::Faraday::BuilderClassExtension
  def new(*args); end
end
class Faraday::RackBuilder
  extend VCR::LibraryHooks::Faraday::BuilderClassExtension
end
module VCR::LibraryHooks::Faraday::BuilderInstanceExtension
  def insert_vcr_middleware; end
  def lock!(*args); end
  def warn_about_after_adapter_middleware(adapter_index); end
end
module VCR::RSpec::Metadata
  def configure!; end
  def vcr_cassette_name_for(metadata); end
  extend VCR::RSpec::Metadata
end
