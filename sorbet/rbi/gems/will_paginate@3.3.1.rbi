# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `will_paginate` gem.
# Please instead update this file by running `bin/tapioca gem will_paginate`.


class ActionView::Base
  include ::ERB::Escape
  include ::ActiveSupport::CoreExt::ERBUtil
  include ::ActiveSupport::CoreExt::ERBUtilPrivate
  include ::ActiveSupport::Benchmarkable
  include ::ActionView::Helpers::ActiveModelHelper
  include ::ActionView::Helpers::AssetUrlHelper
  include ::ActionView::Helpers::CaptureHelper
  include ::ActionView::Helpers::OutputSafetyHelper
  include ::ActionView::Helpers::TagHelper
  include ::ActionView::Helpers::AssetTagHelper
  include ::ActionView::Helpers::AtomFeedHelper
  include ::ActionView::Helpers::CacheHelper
  include ::ActionView::Helpers::ContentExfiltrationPreventionHelper
  include ::ActionView::Helpers::ControllerHelper
  include ::ActionView::Helpers::CspHelper
  include ::ActionView::Helpers::CsrfHelper
  include ::ActionView::Helpers::DateHelper
  include ::ActionView::Helpers::DebugHelper
  include ::ActionView::ModelNaming
  include ::ActionView::RecordIdentifier
  include ::ActionView::Helpers::FormOptionsHelper
  include ::ActionView::Helpers::JavaScriptHelper
  include ::ActionView::Helpers::NumberHelper
  include ::ActionView::Helpers::RenderingHelper
  include ::WillPaginate::I18n
  include ::WillPaginate::ViewHelpers
  include ::WillPaginate::ActionView
end

module ERB::Escape; end

# You will paginate!
#
# source://will_paginate//lib/will_paginate.rb#2
module WillPaginate
  extend ::WillPaginate::PerPage

  class << self
    # An idemptotent coercion method
    #
    # source://will_paginate//lib/will_paginate/page_number.rb#47
    def PageNumber(value, name = T.unsafe(nil)); end
  end
end

# = ActionView helpers
#
# This module serves for availability in ActionView templates. It also adds a new
# view helper: +paginated_section+.
#
# == Using the helper without arguments
# If the helper is called without passing in the collection object, it will
# try to read from the instance variable inferred by the controller name.
# For example, calling +will_paginate+ while the current controller is
# PostsController will result in trying to read from the <tt>@posts</tt>
# variable. Example:
#
#   <%= will_paginate :id => true %>
#
# ... will result in <tt>@post</tt> collection getting paginated:
#
#   <div class="pagination" id="posts_pagination"> ... </div>
#
# source://will_paginate//lib/will_paginate/view_helpers/action_view.rb#23
module WillPaginate::ActionView
  include ::WillPaginate::I18n
  include ::WillPaginate::ViewHelpers

  # source://will_paginate//lib/will_paginate/view_helpers/action_view.rb#36
  def page_entries_info(collection = T.unsafe(nil), options = T.unsafe(nil)); end

  # Wrapper for rendering pagination links at both top and bottom of a block
  # of content.
  #
  #   <%= paginated_section @posts do %>
  #     <ol id="posts">
  #       <% for post in @posts %>
  #         <li> ... </li>
  #       <% end %>
  #     </ol>
  #   <% end %>
  #
  # will result in:
  #
  #   <div class="pagination"> ... </div>
  #   <ol id="posts">
  #     ...
  #   </ol>
  #   <div class="pagination"> ... </div>
  #
  # Arguments are passed to a <tt>will_paginate</tt> call, so the same options
  # apply. Don't use the <tt>:id</tt> option; otherwise you'll finish with two
  # blocks of pagination links sharing the same ID (which is invalid HTML).
  #
  # source://will_paginate//lib/will_paginate/view_helpers/action_view.rb#65
  def paginated_section(*args, &block); end

  # source://will_paginate//lib/will_paginate/view_helpers/action_view.rb#26
  def will_paginate(collection = T.unsafe(nil), options = T.unsafe(nil)); end

  # source://will_paginate//lib/will_paginate/view_helpers/action_view.rb#74
  def will_paginate_translate(keys, options = T.unsafe(nil)); end

  protected

  # @raise [ArgumentError]
  #
  # source://will_paginate//lib/will_paginate/view_helpers/action_view.rb#91
  def infer_collection_from_controller; end
end

# source://will_paginate//lib/will_paginate/view_helpers/action_view.rb#99
class WillPaginate::ActionView::LinkRenderer < ::WillPaginate::ViewHelpers::LinkRenderer
  protected

  # source://will_paginate//lib/will_paginate/view_helpers/action_view.rb#133
  def add_current_page_param(url_params, page); end

  # source://will_paginate//lib/will_paginate/view_helpers/action_view.rb#104
  def default_url_params; end

  # source://will_paginate//lib/will_paginate/view_helpers/action_view.rb#121
  def merge_get_params(url_params); end

  # source://will_paginate//lib/will_paginate/view_helpers/action_view.rb#128
  def merge_optional_params(url_params); end

  # source://will_paginate//lib/will_paginate/view_helpers/action_view.rb#108
  def url(page); end

  private

  # source://will_paginate//lib/will_paginate/view_helpers/action_view.rb#144
  def parse_query_parameters(params); end
end

# source://will_paginate//lib/will_paginate/view_helpers/action_view.rb#102
WillPaginate::ActionView::LinkRenderer::GET_PARAMS_BLACKLIST = T.let(T.unsafe(nil), Array)

# = The key to pagination
# Arrays returned from paginating finds are, in fact, instances of this little
# class. You may think of WillPaginate::Collection as an ordinary array with
# some extra properties. Those properties are used by view helpers to generate
# correct page links.
#
# WillPaginate::Collection also assists in rolling out your own pagination
# solutions: see +create+.
#
# If you are writing a library that provides a collection which you would like
# to conform to this API, you don't have to copy these methods over; simply
# make your plugin/gem dependant on this library and do:
#
#   require 'will_paginate/collection'
#   # WillPaginate::Collection is now available for use
#
# source://will_paginate//lib/will_paginate/collection.rb#52
class WillPaginate::Collection < ::Array
  include ::WillPaginate::CollectionMethods

  # Arguments to the constructor are the current page number, per-page limit
  # and the total number of entries. The last argument is optional because it
  # is best to do lazy counting; in other words, count *conditionally* after
  # populating the collection using the +replace+ method.
  #
  # @return [Collection] a new instance of Collection
  #
  # source://will_paginate//lib/will_paginate/collection.rb#61
  def initialize(page, per_page = T.unsafe(nil), total = T.unsafe(nil)); end

  # Returns the value of attribute current_page.
  #
  # source://will_paginate//lib/will_paginate/collection.rb#55
  def current_page; end

  # Current offset of the paginated collection. If we're on the first page,
  # it is always 0. If we're on the 2nd page and there are 30 entries per page,
  # the offset is 30. This property is useful if you want to render ordinals
  # side by side with records in the view: simply start with offset + 1.
  #
  # source://will_paginate//lib/will_paginate/collection.rb#104
  def offset; end

  # Returns the value of attribute per_page.
  #
  # source://will_paginate//lib/will_paginate/collection.rb#55
  def per_page; end

  # This is a magic wrapper for the original Array#replace method. It serves
  # for populating the paginated collection after initialization.
  #
  # Why magic? Because it tries to guess the total number of entries judging
  # by the size of given array. If it is shorter than +per_page+ limit, then we
  # know we're on the last page. This trick is very useful for avoiding
  # unnecessary hits to the database to do the counting after we fetched the
  # data for the current page.
  #
  # However, after using +replace+ you should always test the value of
  # +total_entries+ and set it to a proper value if it's +nil+. See the example
  # in +create+.
  #
  # source://will_paginate//lib/will_paginate/collection.rb#124
  def replace(array); end

  # Returns the value of attribute total_entries.
  #
  # source://will_paginate//lib/will_paginate/collection.rb#55
  def total_entries; end

  # source://will_paginate//lib/will_paginate/collection.rb#108
  def total_entries=(number); end

  class << self
    # Just like +new+, but yields the object after instantiation and returns it
    # afterwards. This is very useful for manual pagination:
    #
    #   @entries = WillPaginate::Collection.create(1, 10) do |pager|
    #     result = Post.find(:all, :limit => pager.per_page, :offset => pager.offset)
    #     # inject the result array into the paginated collection:
    #     pager.replace(result)
    #
    #     unless pager.total_entries
    #       # the pager didn't manage to guess the total count, do it manually
    #       pager.total_entries = Post.count
    #     end
    #   end
    #
    # The possibilities with this are endless. For another example, here is how
    # WillPaginate used to define pagination for Array instances:
    #
    #   Array.class_eval do
    #     def paginate(page = 1, per_page = 15)
    #       WillPaginate::Collection.create(page, per_page, size) do |pager|
    #         pager.replace self[pager.offset, pager.per_page].to_a
    #       end
    #     end
    #   end
    #
    # The Array#paginate API has since then changed, but this still serves as a
    # fine example of WillPaginate::Collection usage.
    #
    # @yield [pager]
    #
    # source://will_paginate//lib/will_paginate/collection.rb#94
    def create(page, per_page, total = T.unsafe(nil)); end
  end
end

# Any will_paginate-compatible collection should have these methods:
#
#   current_page, per_page, offset, total_entries, total_pages
#
# It can also define some of these optional methods:
#
#   out_of_bounds?, previous_page, next_page
#
# This module provides few of these methods.
#
# source://will_paginate//lib/will_paginate/collection.rb#14
module WillPaginate::CollectionMethods
  # current_page + 1 or nil if there is no next page
  #
  # source://will_paginate//lib/will_paginate/collection.rb#25
  def next_page; end

  # Helper method that is true when someone tries to fetch a page with a
  # larger number than the last page. Can be used in combination with flashes
  # and redirecting.
  #
  # @return [Boolean]
  #
  # source://will_paginate//lib/will_paginate/collection.rb#32
  def out_of_bounds?; end

  # current_page - 1 or nil if there is no previous page
  #
  # source://will_paginate//lib/will_paginate/collection.rb#20
  def previous_page; end

  # source://will_paginate//lib/will_paginate/collection.rb#15
  def total_pages; end
end

# source://will_paginate//lib/will_paginate/deprecation.rb#1
module WillPaginate::Deprecation
  class << self
    # source://will_paginate//lib/will_paginate/deprecation.rb#3
    def warn(message, stack = T.unsafe(nil)); end

    private

    # source://will_paginate//lib/will_paginate/deprecation.rb#16
    def origin_of_call(stack); end

    # source://will_paginate//lib/will_paginate/deprecation.rb#12
    def rails_logger; end
  end
end

# source://will_paginate//lib/will_paginate/deprecation.rb#22
class WillPaginate::Deprecation::Hash < ::Hash
  # @return [Hash] a new instance of Hash
  #
  # source://will_paginate//lib/will_paginate/deprecation.rb#23
  def initialize(values = T.unsafe(nil)); end

  # source://will_paginate//lib/will_paginate/deprecation.rb#29
  def []=(key, value); end

  # source://will_paginate//lib/will_paginate/deprecation.rb#34
  def deprecate_key(*keys, &block); end

  # source://will_paginate//lib/will_paginate/deprecation.rb#39
  def merge(another); end

  # source://will_paginate//lib/will_paginate/deprecation.rb#43
  def to_hash; end

  private

  # source://will_paginate//lib/will_paginate/deprecation.rb#49
  def check_deprecated(key, value); end
end

# source://will_paginate//lib/will_paginate/i18n.rb#2
module WillPaginate::I18n
  # source://will_paginate//lib/will_paginate/i18n.rb#11
  def will_paginate_translate(keys, options = T.unsafe(nil), &block); end

  class << self
    # source://will_paginate//lib/will_paginate/i18n.rb#7
    def load_path; end

    # source://will_paginate//lib/will_paginate/i18n.rb#3
    def locale_dir; end
  end
end

# a module that page number exceptions are tagged with
#
# source://will_paginate//lib/will_paginate/page_number.rb#5
module WillPaginate::InvalidPage; end

# integer representing a page number
#
# source://will_paginate//lib/will_paginate/page_number.rb#8
class WillPaginate::PageNumber < ::Numeric
  extend ::Forwardable

  # @return [PageNumber] a new instance of PageNumber
  #
  # source://will_paginate//lib/will_paginate/page_number.rb#14
  def initialize(value, name); end

  # source://will_paginate//lib/will_paginate/page_number.rb#30
  def *(*_arg0, **_arg1, &_arg2); end

  # source://will_paginate//lib/will_paginate/page_number.rb#30
  def +(*_arg0, **_arg1, &_arg2); end

  # source://will_paginate//lib/will_paginate/page_number.rb#30
  def -(*_arg0, **_arg1, &_arg2); end

  # source://will_paginate//lib/will_paginate/page_number.rb#30
  def /(*_arg0, **_arg1, &_arg2); end

  # source://will_paginate//lib/will_paginate/page_number.rb#30
  def <=>(*_arg0, **_arg1, &_arg2); end

  # source://will_paginate//lib/will_paginate/page_number.rb#30
  def ==(*_arg0, **_arg1, &_arg2); end

  # source://will_paginate//lib/will_paginate/page_number.rb#30
  def coerce(*_arg0, **_arg1, &_arg2); end

  # source://will_paginate//lib/will_paginate/page_number.rb#32
  def inspect; end

  # @return [Boolean]
  #
  # source://will_paginate//lib/will_paginate/page_number.rb#43
  def is_a?(klass); end

  # @return [Boolean]
  #
  # source://will_paginate//lib/will_paginate/page_number.rb#40
  def kind_of?(klass); end

  # source://will_paginate//lib/will_paginate/page_number.rb#26
  def to_i; end

  # source://will_paginate//lib/will_paginate/page_number.rb#30
  def to_json(*_arg0, **_arg1, &_arg2); end

  # source://will_paginate//lib/will_paginate/page_number.rb#36
  def to_offset(per_page); end

  # source://will_paginate//lib/will_paginate/page_number.rb#30
  def to_s(*_arg0, **_arg1, &_arg2); end
end

# a value larger than this is not supported in SQL queries
#
# source://will_paginate//lib/will_paginate/page_number.rb#10
WillPaginate::PageNumber::BIGINT = T.let(T.unsafe(nil), Integer)

# source://will_paginate//lib/will_paginate/per_page.rb#2
module WillPaginate::PerPage
  # source://will_paginate//lib/will_paginate/per_page.rb#3
  def per_page; end

  # source://will_paginate//lib/will_paginate/per_page.rb#7
  def per_page=(limit); end

  class << self
    # @private
    #
    # source://will_paginate//lib/will_paginate/per_page.rb#11
    def extended(base); end
  end
end

# source://will_paginate//lib/will_paginate/per_page.rb#15
module WillPaginate::PerPage::Inheritance
  # source://will_paginate//lib/will_paginate/per_page.rb#16
  def inherited(subclass); end
end

# source://will_paginate//lib/will_paginate/railtie.rb#6
class WillPaginate::Railtie < ::Rails::Railtie
  class << self
    # source://will_paginate//lib/will_paginate/railtie.rb#24
    def setup_actioncontroller; end
  end
end

# source://will_paginate//lib/will_paginate/railtie.rb#61
module WillPaginate::Railtie::ControllerRescuePatch
  # source://will_paginate//lib/will_paginate/railtie.rb#62
  def rescue_from(*args, **kwargs, &block); end
end

# Extending the exception handler middleware so it properly detects
# WillPaginate::InvalidPage regardless of it being a tag module.
#
# source://will_paginate//lib/will_paginate/railtie.rb#33
module WillPaginate::Railtie::ShowExceptionsPatch
  extend ::ActiveSupport::Concern

  # source://will_paginate//lib/will_paginate/railtie.rb#39
  def status_code_with_paginate(exception = T.unsafe(nil)); end
end

# = Will Paginate view helpers
#
# The main view helper is +will_paginate+. It renders the pagination links
# for the given collection. The helper itself is lightweight and serves only
# as a wrapper around LinkRenderer instantiation; the renderer then does
# all the hard work of generating the HTML.
#
# source://will_paginate//lib/will_paginate/view_helpers.rb#13
module WillPaginate::ViewHelpers
  include ::WillPaginate::I18n

  # Renders a message containing number of displayed vs. total entries.
  #
  #   <%= page_entries_info @posts %>
  #   #-> Displaying posts 6 - 12 of 26 in total
  #
  # The default output contains HTML. Use ":html => false" for plain text.
  #
  # source://will_paginate//lib/will_paginate/view_helpers.rb#105
  def page_entries_info(collection, options = T.unsafe(nil)); end

  # Returns HTML representing page links for a WillPaginate::Collection-like object.
  # In case there is no more than one page in total, nil is returned.
  #
  # ==== Options
  # * <tt>:class</tt> -- CSS class name for the generated DIV (default: "pagination")
  # * <tt>:previous_label</tt> -- default: "« Previous"
  # * <tt>:next_label</tt> -- default: "Next »"
  # * <tt>:inner_window</tt> -- how many links are shown around the current page (default: 4)
  # * <tt>:outer_window</tt> -- how many links are around the first and the last page (default: 1)
  # * <tt>:link_separator</tt> -- string separator for page HTML elements (default: single space)
  # * <tt>:param_name</tt> -- parameter name for page number in URLs (default: <tt>:page</tt>)
  # * <tt>:params</tt> -- additional parameters when generating pagination links
  #   (eg. <tt>:controller => "foo", :action => nil</tt>)
  # * <tt>:renderer</tt> -- class name, class or instance of a link renderer (default in Rails:
  #   <tt>WillPaginate::ActionView::LinkRenderer</tt>)
  # * <tt>:page_links</tt> -- when false, only previous/next links are rendered (default: true)
  # * <tt>:container</tt> -- toggles rendering of the DIV container for pagination links, set to
  #   false only when you are rendering your own pagination markup (default: true)
  #
  # All options not recognized by will_paginate will become HTML attributes on the container
  # element for pagination links (the DIV). For example:
  #
  #   <%= will_paginate @posts, :style => 'color:blue' %>
  #
  # will result in:
  #
  #   <div class="pagination" style="color:blue"> ... </div>
  #
  # source://will_paginate//lib/will_paginate/view_helpers.rb#71
  def will_paginate(collection, options = T.unsafe(nil)); end

  class << self
    # Write to this hash to override default options on the global level:
    #
    #   WillPaginate::ViewHelpers.pagination_options[:page_links] = false
    #
    # source://will_paginate//lib/will_paginate/view_helpers.rb#19
    def pagination_options; end

    # Write to this hash to override default options on the global level:
    #
    #   WillPaginate::ViewHelpers.pagination_options[:page_links] = false
    #
    # source://will_paginate//lib/will_paginate/view_helpers.rb#19
    def pagination_options=(_arg0); end
  end
end

# This class does the heavy lifting of actually building the pagination
# links. It is used by +will_paginate+ helper internally.
#
# source://will_paginate//lib/will_paginate/view_helpers/link_renderer.rb#10
class WillPaginate::ViewHelpers::LinkRenderer < ::WillPaginate::ViewHelpers::LinkRendererBase
  # Returns the subset of +options+ this instance was initialized with that
  # represent HTML attributes for the container element of pagination links.
  #
  # source://will_paginate//lib/will_paginate/view_helpers/link_renderer.rb#37
  def container_attributes; end

  # * +collection+ is a WillPaginate::Collection instance or any other object
  #   that conforms to that API
  # * +options+ are forwarded from +will_paginate+ view helper
  # * +template+ is the reference to the template being rendered
  #
  # source://will_paginate//lib/will_paginate/view_helpers/link_renderer.rb#16
  def prepare(collection, options, template); end

  # Process it! This method returns the complete HTML string which contains
  # pagination links. Feel free to subclass LinkRenderer and change this
  # method as you see fit.
  #
  # source://will_paginate//lib/will_paginate/view_helpers/link_renderer.rb#25
  def to_html; end

  protected

  # source://will_paginate//lib/will_paginate/view_helpers/link_renderer.rb#55
  def gap; end

  # source://will_paginate//lib/will_paginate/view_helpers/link_renderer.rb#78
  def html_container(html); end

  # source://will_paginate//lib/will_paginate/view_helpers/link_renderer.rb#65
  def next_page; end

  # source://will_paginate//lib/will_paginate/view_helpers/link_renderer.rb#46
  def page_number(page); end

  # source://will_paginate//lib/will_paginate/view_helpers/link_renderer.rb#70
  def previous_or_next_page(page, text, classname); end

  # source://will_paginate//lib/will_paginate/view_helpers/link_renderer.rb#60
  def previous_page; end

  # Returns URL params for +page_link_or_span+, taking the current GET params
  # and <tt>:params</tt> option into account.
  #
  # @raise [NotImplementedError]
  #
  # source://will_paginate//lib/will_paginate/view_helpers/link_renderer.rb#84
  def url(page); end

  private

  # source://will_paginate//lib/will_paginate/view_helpers/link_renderer.rb#94
  def link(text, target, attributes = T.unsafe(nil)); end

  # source://will_paginate//lib/will_paginate/view_helpers/link_renderer.rb#90
  def param_name; end

  # source://will_paginate//lib/will_paginate/view_helpers/link_renderer.rb#113
  def rel_value(page); end

  # source://will_paginate//lib/will_paginate/view_helpers/link_renderer.rb#120
  def symbolized_update(target, other, blacklist = T.unsafe(nil)); end

  # source://will_paginate//lib/will_paginate/view_helpers/link_renderer.rb#103
  def tag(name, value, attributes = T.unsafe(nil)); end
end

# This class does the heavy lifting of actually building the pagination
# links. It is used by +will_paginate+ helper internally.
#
# source://will_paginate//lib/will_paginate/view_helpers/link_renderer_base.rb#5
class WillPaginate::ViewHelpers::LinkRendererBase
  # source://will_paginate//lib/will_paginate/view_helpers/link_renderer_base.rb#18
  def pagination; end

  # * +collection+ is a WillPaginate::Collection instance or any other object
  #   that conforms to that API
  # * +options+ are forwarded from +will_paginate+ view helper
  #
  # source://will_paginate//lib/will_paginate/view_helpers/link_renderer_base.rb#10
  def prepare(collection, options); end

  protected

  # Calculates visible page numbers using the <tt>:inner_window</tt> and
  # <tt>:outer_window</tt> options.
  #
  # source://will_paginate//lib/will_paginate/view_helpers/link_renderer_base.rb#28
  def windowed_page_numbers; end

  private

  # source://will_paginate//lib/will_paginate/view_helpers/link_renderer_base.rb#68
  def current_page; end

  # source://will_paginate//lib/will_paginate/view_helpers/link_renderer_base.rb#72
  def total_pages; end
end
