# This file is autogenerated. Do not edit it by hand. Regenerate it with:
#   srb rbi hidden-definitions

# typed: autogenerated

class ActionCable::Channel::Base
  include ::Sentry::Rails::ActionCableExtensions::Channel::Subscriptions
  include ::Sentry::Rails::ActionCableExtensions::Channel::Actions
end

class ActionCable::Connection::Base
  include ::Sentry::Rails::ActionCableExtensions::Connection
end

class ActionController::API
  include ::ActionView::Rendering
  include ::ActionDispatch::Routing::RouteSet::MountedHelpers
  include ::ActiveRecord::Railties::ControllerRuntime
  include ::Draper::Compatibility::ApiOnly
  include ::Draper::ViewContext
  include ::GoogleVisualr::Rails::ViewHelper
  include ::AbstractController::Helpers
  include ::ActionController::Helpers
  include ::ActionController::ImplicitRender
  include ::Sentry::Rails::ControllerMethods
  include ::Sentry::Rails::ControllerTransaction
  def _helper_methods(); end

  def _helper_methods=(_helper_methods); end

  def _helper_methods?(); end

  def helpers_path(); end

  def helpers_path=(helpers_path); end

  def helpers_path?(); end

  def include_all_helpers(); end

  def include_all_helpers=(include_all_helpers); end

  def include_all_helpers?(); end

  def previous_render_to_body(options); end
end

module ActionController::API::HelperMethods
  def current_user(*arg, **arg1, &arg2); end

  def devise_controller?(*arg, **arg1, &arg2); end

  def signed_in?(*arg, **arg1, &arg2); end

  def user_session(*arg, **arg1, &arg2); end

  def user_signed_in?(*arg, **arg1, &arg2); end

  def warden(*arg, **arg1, &arg2); end
end

module ActionController::API::HelperMethods
end

class ActionController::API
  extend ::ActionController::Railties::Helpers
  extend ::Draper::HelperSupport
  extend ::Draper::DecoratesAssigned
  extend ::AbstractController::Helpers::ClassMethods
  extend ::AbstractController::Helpers::Resolution
  extend ::ActionController::Helpers::ClassMethods
  def self._helper_methods(); end

  def self._helper_methods=(value); end

  def self._helper_methods?(); end

  def self.helpers_path(); end

  def self.helpers_path=(value); end

  def self.helpers_path?(); end

  def self.include_all_helpers(); end

  def self.include_all_helpers=(value); end

  def self.include_all_helpers?(); end
end

class ActionController::Base
  include ::ActionDispatch::Routing::RouteSet::MountedHelpers
  include ::ActiveRecord::Railties::ControllerRuntime
  include ::Draper::ViewContext
  include ::GoogleVisualr::Rails::ViewHelper
  include ::Sentry::Rails::ControllerMethods
  include ::Sentry::Rails::ControllerTransaction
  def allow_rescue(); end

  def allow_rescue=(val); end
end

module ActionController::Base::HelperMethods
  def current_user(*arg, **arg1, &arg2); end

  def render_chart(*arg, **arg1, &arg2); end

  def user_session(*arg, **arg1, &arg2); end

  def user_signed_in?(*arg, **arg1, &arg2); end
end

class ActionController::Base
  extend ::ActionController::Railties::Helpers
  extend ::WillPaginate::Railtie::ControllerRescuePatch
  extend ::Draper::HelperSupport
  extend ::Draper::DecoratesAssigned
  def self.allow_rescue(); end

  def self.allow_rescue=(val); end
end

module ActionController::Live
  include ::Sentry::Rails::Overrides::StreamingReporter
end

class ActionDispatch::ExceptionWrapper
  include ::WillPaginate::Railtie::ShowExceptionsPatch
  def status_code_without_paginate(); end
end

class ActionDispatch::ExceptionWrapper::SourceMapLocation
  RUBYGEMS_ACTIVATION_MONITOR = ::T.let(nil, ::T.untyped)
end

class ActionDispatch::IntegrationTest
  include ::ActionMailer::TestHelper
  include ::ActiveJob::TestHelper
  include ::ActionMailer::TestCase::ClearTestDeliveries
end

module ActionDispatch::RequestCookieMethods
  def commit_cookie_jar!(); end
end

module ActionDispatch::Routing::RouteSet::MountedHelpers
  def _main_app(); end

  def main_app(); end
end

class ActionDispatch::Routing::RouteWrapper
  include ::Sprockets::Rails::RouteWrapper
  def assets_prefix(); end

  def assets_prefix=(assets_prefix); end

  def assets_prefix?(); end
  RUBYGEMS_ACTIVATION_MONITOR = ::T.let(nil, ::T.untyped)
end

class ActionDispatch::Routing::RouteWrapper
  def self.assets_prefix(); end

  def self.assets_prefix=(value); end

  def self.assets_prefix?(); end
end

class ActionDispatch::Session::CookieStore::SessionId
  RUBYGEMS_ACTIVATION_MONITOR = ::T.let(nil, ::T.untyped)
end

class ActionDispatch::ShowExceptions
  include ::Cucumber::Rails::ActionDispatch::ShowExceptions
end

class ActionDispatch::SystemTestCase
  include ::Capybara::DSLRSpecProxyInstaller
end

module ActionMailbox
  def incinerate(); end

  def incinerate=(val); end

  def incinerate_after(); end

  def incinerate_after=(val); end

  def ingress(); end

  def ingress=(val); end

  def logger(); end

  def logger=(val); end

  def queues(); end

  def queues=(val); end

  def storage_service(); end

  def storage_service=(val); end
end

class ActionMailbox::Base
  include ::ActiveSupport::Rescuable
  include ::ActionMailbox::Routing
  include ::ActiveSupport::Callbacks
  include ::ActionMailbox::Callbacks
  def __callbacks(); end

  def __callbacks?(); end

  def _process_callbacks(); end

  def _run_process_callbacks(&block); end

  def bounce_now_with(message); end

  def bounce_with(message); end

  def bounced!(*arg, **arg1, &arg2); end

  def delivered!(*arg, **arg1, &arg2); end

  def finished_processing?(); end

  def inbound_email(); end

  def initialize(inbound_email); end

  def logger(&arg); end

  def mail(*arg, **arg1, &arg2); end

  def perform_processing(); end

  def process(); end

  def rescue_handlers(); end

  def rescue_handlers=(rescue_handlers); end

  def rescue_handlers?(); end

  def router(); end

  def router=(val); end
end

class ActionMailbox::Base
  extend ::ActionMailbox::Routing::ClassMethods
  extend ::ActiveSupport::DescendantsTracker
  extend ::ActionMailbox::Callbacks::ClassMethods
  def self.__callbacks(); end

  def self.__callbacks=(value); end

  def self.__callbacks?(); end

  def self._process_callbacks(); end

  def self._process_callbacks=(value); end

  def self.receive(inbound_email); end

  def self.rescue_handlers(); end

  def self.rescue_handlers=(value); end

  def self.rescue_handlers?(); end

  def self.router(); end

  def self.router=(val); end
end

module ActionMailbox::Callbacks
  TERMINATOR = ::T.let(nil, ::T.untyped)
end

module ActionMailbox::Callbacks::ClassMethods
  def after_processing(*methods, &block); end

  def around_processing(*methods, &block); end

  def before_processing(*methods, &block); end
end

module ActionMailbox::Callbacks::ClassMethods
end

module ActionMailbox::Callbacks
  extend ::ActiveSupport::Concern
end

class ActionMailbox::Engine
end

class ActionMailbox::Engine
end

class ActionMailbox::Router
  def add_route(address, to:); end

  def add_routes(routes); end

  def mailbox_for(inbound_email); end

  def route(inbound_email); end
end

class ActionMailbox::Router::Route
  def address(); end

  def initialize(address, to:); end

  def mailbox_class(); end

  def mailbox_name(); end

  def match?(inbound_email); end
end

class ActionMailbox::Router::Route
end

class ActionMailbox::Router::RoutingError
end

class ActionMailbox::Router::RoutingError
end

class ActionMailbox::Router
end

module ActionMailbox::Routing
end

module ActionMailbox::Routing::ClassMethods
  def mailbox_for(inbound_email); end

  def route(inbound_email); end

  def routing(routes); end
end

module ActionMailbox::Routing::ClassMethods
end

module ActionMailbox::Routing
  extend ::ActiveSupport::Concern
end

class ActionMailbox::TestCase
  include ::ActionMailbox::TestHelper
end

class ActionMailbox::TestCase
end

module ActionMailbox::TestHelper
  def create_inbound_email_from_fixture(fixture_name, status: T.unsafe(nil)); end

  def create_inbound_email_from_mail(status: T.unsafe(nil), **mail_options, &block); end

  def create_inbound_email_from_source(source, status: T.unsafe(nil)); end

  def receive_inbound_email_from_fixture(*args); end

  def receive_inbound_email_from_mail(**kwargs, &block); end

  def receive_inbound_email_from_source(*args); end
end

module ActionMailbox::TestHelper
end

module ActionMailbox::VERSION
  MAJOR = ::T.let(nil, ::T.untyped)
  MINOR = ::T.let(nil, ::T.untyped)
  PRE = ::T.let(nil, ::T.untyped)
  STRING = ::T.let(nil, ::T.untyped)
  TINY = ::T.let(nil, ::T.untyped)
end

module ActionMailbox::VERSION
end

module ActionMailbox
  extend ::ActiveSupport::Autoload
  def self.deprecator(); end

  def self.gem_version(); end

  def self.incinerate(); end

  def self.incinerate=(val); end

  def self.incinerate_after(); end

  def self.incinerate_after=(val); end

  def self.ingress(); end

  def self.ingress=(val); end

  def self.logger(); end

  def self.logger=(val); end

  def self.queues(); end

  def self.queues=(val); end

  def self.railtie_helpers_paths(); end

  def self.railtie_namespace(); end

  def self.railtie_routes_url_helpers(include_path_helpers=T.unsafe(nil)); end

  def self.storage_service(); end

  def self.storage_service=(val); end

  def self.table_name_prefix(); end

  def self.use_relative_model_naming?(); end

  def self.version(); end
end

class ActionMailer::Base
  include ::ActionDispatch::Routing::UrlFor
  include ::ActionDispatch::Routing::PolymorphicRoutes
  include ::AbstractController::UrlFor
  include ::ActionDispatch::Routing::RouteSet::MountedHelpers
  include ::Draper::ViewContext
  def default_url_options(); end

  def default_url_options=(default_url_options); end

  def default_url_options?(); end
end

class ActionMailer::Base::LateAttachmentsProxy
  RUBYGEMS_ACTIVATION_MONITOR = ::T.let(nil, ::T.untyped)
end

class ActionMailer::Base
  extend ::AbstractController::UrlFor::ClassMethods
  def self.default_url_options(); end

  def self.default_url_options=(value); end

  def self.default_url_options?(); end
end

class ActionMailer::MessageDelivery
  RUBYGEMS_ACTIVATION_MONITOR = ::T.let(nil, ::T.untyped)
end

class ActionMailer::Parameterized::MessageDelivery
  RUBYGEMS_ACTIVATION_MONITOR = ::T.let(nil, ::T.untyped)
end

class ActionView::Base
  include ::Haml::RailsHelpers
  include ::Haml::Helpers
  include ::Sprockets::Rails::Helper
  include ::Sprockets::Rails::Utils
  def assets_environment(); end

  def assets_environment=(assets_environment); end

  def assets_environment?(); end

  def assets_manifest(); end

  def assets_manifest=(assets_manifest); end

  def assets_manifest?(); end

  def assets_precompile(); end

  def assets_precompile=(assets_precompile); end

  def assets_precompile?(); end

  def assets_prefix(); end

  def assets_prefix=(assets_prefix); end

  def assets_prefix?(); end

  def check_precompiled_asset(); end

  def check_precompiled_asset=(check_precompiled_asset); end

  def check_precompiled_asset?(); end

  def debug_assets(); end

  def debug_assets=(debug_assets); end

  def debug_assets?(); end

  def digest_assets(); end

  def digest_assets=(digest_assets); end

  def digest_assets?(); end

  def precompiled_asset_checker(); end

  def precompiled_asset_checker=(precompiled_asset_checker); end

  def precompiled_asset_checker?(); end

  def resolve_assets_with(); end

  def resolve_assets_with=(resolve_assets_with); end

  def resolve_assets_with?(); end

  def unknown_asset_fallback(); end

  def unknown_asset_fallback=(unknown_asset_fallback); end

  def unknown_asset_fallback?(); end
end

class ActionView::Base
  def self.assets_environment(); end

  def self.assets_environment=(value); end

  def self.assets_environment?(); end

  def self.assets_manifest(); end

  def self.assets_manifest=(value); end

  def self.assets_manifest?(); end

  def self.assets_precompile(); end

  def self.assets_precompile=(value); end

  def self.assets_precompile?(); end

  def self.assets_prefix(); end

  def self.assets_prefix=(value); end

  def self.assets_prefix?(); end

  def self.check_precompiled_asset(); end

  def self.check_precompiled_asset=(value); end

  def self.check_precompiled_asset?(); end

  def self.debug_assets(); end

  def self.debug_assets=(value); end

  def self.debug_assets?(); end

  def self.digest_assets(); end

  def self.digest_assets=(value); end

  def self.digest_assets?(); end

  def self.precompiled_asset_checker(); end

  def self.precompiled_asset_checker=(value); end

  def self.precompiled_asset_checker?(); end

  def self.resolve_assets_with(); end

  def self.resolve_assets_with=(value); end

  def self.resolve_assets_with?(); end

  def self.unknown_asset_fallback(); end

  def self.unknown_asset_fallback=(value); end

  def self.unknown_asset_fallback?(); end
end

class ActionView::FixtureResolver
  def data(); end

  def initialize(hash=T.unsafe(nil)); end
end

class ActionView::FixtureResolver
end

class ActionView::NullResolver
end

class ActionView::NullResolver
end

class ActionView::StreamingTemplateRenderer::Body
  include ::Sentry::Rails::Overrides::StreamingReporter
end

module ActionView::TestCase::TestController::HelperMethods
  include ::ActionController::Base::HelperMethods
  include ::Turbo::DriveHelper
  include ::Turbo::FramesHelper
  include ::Turbo::IncludesHelper
  include ::Turbo::StreamsHelper
  include ::Turbo::Streams::ActionHelper
  include ::ActionView::Helpers::TagHelper
  include ::ActionView::Helpers::CaptureHelper
  include ::ActionView::Helpers::OutputSafetyHelper
  include ::ActionText::ContentHelper
  include ::ActionText::TagHelper
  include ::Importmap::ImportmapTagsHelper
  include ::ApplicationHelper
  include ::LogLineHelper
  include ::RconHelper
  include ::ReservationsHelper
  include ::SessionsHelper
  include ::FontAwesome::Rails::IconHelper
  include ::DeviseHelper
end

module ActionView::TestCase::TestController::HelperMethods
end

class ActiveJob::Base
  include ::ActiveRecord::Railties::JobRuntime
  include ::ActiveJob::EnqueueAfterTransactionCommit
  include ::Sentry::Rails::ActiveJobExtensions
end

module ActiveModel::Serializers
  VERSION = ::T.let(nil, ::T.untyped)
end

module ActiveRecord::Assertions
end

module ActiveRecord::Assertions::QueryAssertions
  def assert_no_queries(include_schema: T.unsafe(nil), &block); end

  def assert_no_queries_match(match, include_schema: T.unsafe(nil), &block); end

  def assert_queries_count(count=T.unsafe(nil), include_schema: T.unsafe(nil), &block); end

  def assert_queries_match(match, count: T.unsafe(nil), include_schema: T.unsafe(nil), &block); end
end

module ActiveRecord::Assertions::QueryAssertions
end

module ActiveRecord::Assertions
end

class ActiveRecord::Base
  include ::Draper::Decoratable
  include ::Draper::Decoratable::Equality
end

class ActiveRecord::Base
  extend ::CarrierWave::ActiveRecord
  extend ::CarrierWave::Mount
  extend ::Geocoder::Model::ActiveRecord
  extend ::Geocoder::Model::Base
  extend ::WillPaginate::PerPage
  extend ::WillPaginate::PerPage::Inheritance
  extend ::WillPaginate::ActiveRecord::Pagination
  extend ::WillPaginate::ActiveRecord::BaseMethods
  extend ::Devise::Models
end

module ActiveRecord::ConnectionAdapters::PostgreSQL
end

class ActiveRecord::ConnectionAdapters::PostgreSQL::AlterTable
  def add_exclusion_constraint(expression, options); end

  def add_unique_constraint(column_name, options); end

  def constraint_validations(); end

  def drop_exclusion_constraint(constraint_name); end

  def drop_unique_constraint(unique_constraint_name); end

  def exclusion_constraint_adds(); end

  def exclusion_constraint_drops(); end

  def unique_constraint_adds(); end

  def unique_constraint_drops(); end

  def validate_constraint(name); end
end

class ActiveRecord::ConnectionAdapters::PostgreSQL::AlterTable
end

class ActiveRecord::ConnectionAdapters::PostgreSQL::Column
  def array(); end

  def array?(); end

  def enum?(); end

  def fmod(*arg, **arg1, &arg2); end

  def identity?(); end

  def initialize(*arg, serial: T.unsafe(nil), identity: T.unsafe(nil), generated: T.unsafe(nil), **arg1); end

  def oid(*arg, **arg1, &arg2); end

  def serial?(); end

  def sql_type(); end
end

class ActiveRecord::ConnectionAdapters::PostgreSQL::Column
end

module ActiveRecord::ConnectionAdapters::PostgreSQL::ColumnMethods
  def primary_key(name, type=T.unsafe(nil), **options); end
end

module ActiveRecord::ConnectionAdapters::PostgreSQL::ColumnMethods
  extend ::ActiveSupport::Concern
end

module ActiveRecord::ConnectionAdapters::PostgreSQL::DatabaseStatements
  def begin_db_transaction(); end

  def begin_isolated_db_transaction(isolation); end

  def build_explain_clause(options=T.unsafe(nil)); end

  def commit_db_transaction(); end

  def exec_delete(sql, name=T.unsafe(nil), binds=T.unsafe(nil)); end

  def exec_insert(sql, name=T.unsafe(nil), binds=T.unsafe(nil), pk=T.unsafe(nil), sequence_name=T.unsafe(nil), returning: T.unsafe(nil)); end

  def exec_restart_db_transaction(); end

  def exec_rollback_db_transaction(); end

  def exec_update(sql, name=T.unsafe(nil), binds=T.unsafe(nil)); end

  def execute(*arg, **arg1, &arg2); end

  def explain(arel, binds=T.unsafe(nil), options=T.unsafe(nil)); end

  def high_precision_current_timestamp(); end

  def internal_exec_query(sql, name=T.unsafe(nil), binds=T.unsafe(nil), prepare: T.unsafe(nil), async: T.unsafe(nil), allow_retry: T.unsafe(nil), materialize_transactions: T.unsafe(nil)); end

  def query(sql, name=T.unsafe(nil)); end

  def raw_execute(sql, name, async: T.unsafe(nil), allow_retry: T.unsafe(nil), materialize_transactions: T.unsafe(nil)); end

  def set_constraints(deferred, *constraints); end

  def write_query?(sql); end
end

module ActiveRecord::ConnectionAdapters::PostgreSQL::DatabaseStatements
end

class ActiveRecord::ConnectionAdapters::PostgreSQL::ExclusionConstraintDefinition
  def deferrable(); end

  def export_name_on_schema_dump?(); end

  def expression(); end

  def expression=(_); end

  def name(); end

  def options(); end

  def options=(_); end

  def table_name(); end

  def table_name=(_); end

  def using(); end

  def where(); end
end

class ActiveRecord::ConnectionAdapters::PostgreSQL::ExclusionConstraintDefinition
  def self.[](*arg); end

  def self.keyword_init?(); end

  def self.members(); end
end

class ActiveRecord::ConnectionAdapters::PostgreSQL::ExplainPrettyPrinter
  def pp(result); end
end

class ActiveRecord::ConnectionAdapters::PostgreSQL::ExplainPrettyPrinter
end

class ActiveRecord::ConnectionAdapters::PostgreSQL::Name
  def ==(o); end

  def eql?(o); end

  def identifier(); end

  def initialize(schema, identifier); end

  def parts(); end

  def quoted(); end

  def schema(); end
  SEPARATOR = ::T.let(nil, ::T.untyped)
end

class ActiveRecord::ConnectionAdapters::PostgreSQL::Name
end

module ActiveRecord::ConnectionAdapters::PostgreSQL::OID
end

class ActiveRecord::ConnectionAdapters::PostgreSQL::OID::Array
  include ::ActiveModel::Type::Helpers::Mutable
  def delimiter(); end

  def force_equality?(value); end

  def initialize(subtype, delimiter=T.unsafe(nil)); end

  def limit(*arg, **arg1, &arg2); end

  def map(value, &block); end

  def precision(*arg, **arg1, &arg2); end

  def scale(*arg, **arg1, &arg2); end

  def subtype(); end

  def type(*arg, **arg1, &arg2); end

  def user_input_in_time_zone(*arg, **arg1, &arg2); end
end

class ActiveRecord::ConnectionAdapters::PostgreSQL::OID::Array::Data
  def encoder(); end

  def encoder=(_); end

  def values=(_); end
end

class ActiveRecord::ConnectionAdapters::PostgreSQL::OID::Array::Data
  def self.[](*arg); end

  def self.keyword_init?(); end

  def self.members(); end
end

class ActiveRecord::ConnectionAdapters::PostgreSQL::OID::Array
end

class ActiveRecord::ConnectionAdapters::PostgreSQL::OID::Bit
end

class ActiveRecord::ConnectionAdapters::PostgreSQL::OID::Bit::Data
  def binary?(); end

  def hex?(); end

  def initialize(value); end
end

class ActiveRecord::ConnectionAdapters::PostgreSQL::OID::Bit::Data
end

class ActiveRecord::ConnectionAdapters::PostgreSQL::OID::Bit
end

class ActiveRecord::ConnectionAdapters::PostgreSQL::OID::BitVarying
end

class ActiveRecord::ConnectionAdapters::PostgreSQL::OID::BitVarying
end

class ActiveRecord::ConnectionAdapters::PostgreSQL::OID::Bytea
end

class ActiveRecord::ConnectionAdapters::PostgreSQL::OID::Bytea
end

class ActiveRecord::ConnectionAdapters::PostgreSQL::OID::Cidr
end

class ActiveRecord::ConnectionAdapters::PostgreSQL::OID::Cidr
end

class ActiveRecord::ConnectionAdapters::PostgreSQL::OID::Date
end

class ActiveRecord::ConnectionAdapters::PostgreSQL::OID::Date
end

class ActiveRecord::ConnectionAdapters::PostgreSQL::OID::DateTime
  def real_type_unless_aliased(real_type); end
end

class ActiveRecord::ConnectionAdapters::PostgreSQL::OID::DateTime
end

class ActiveRecord::ConnectionAdapters::PostgreSQL::OID::Decimal
  def infinity(options=T.unsafe(nil)); end
end

class ActiveRecord::ConnectionAdapters::PostgreSQL::OID::Decimal
end

class ActiveRecord::ConnectionAdapters::PostgreSQL::OID::Enum
end

class ActiveRecord::ConnectionAdapters::PostgreSQL::OID::Enum
end

class ActiveRecord::ConnectionAdapters::PostgreSQL::OID::Hstore
  include ::ActiveModel::Type::Helpers::Mutable
  def accessor(); end
  ERROR = ::T.let(nil, ::T.untyped)
end

class ActiveRecord::ConnectionAdapters::PostgreSQL::OID::Hstore
end

class ActiveRecord::ConnectionAdapters::PostgreSQL::OID::Inet
end

class ActiveRecord::ConnectionAdapters::PostgreSQL::OID::Inet
end

class ActiveRecord::ConnectionAdapters::PostgreSQL::OID::Interval
end

class ActiveRecord::ConnectionAdapters::PostgreSQL::OID::Interval
end

class ActiveRecord::ConnectionAdapters::PostgreSQL::OID::Jsonb
end

class ActiveRecord::ConnectionAdapters::PostgreSQL::OID::Jsonb
end

class ActiveRecord::ConnectionAdapters::PostgreSQL::OID::LegacyPoint
  include ::ActiveModel::Type::Helpers::Mutable
end

class ActiveRecord::ConnectionAdapters::PostgreSQL::OID::LegacyPoint
end

class ActiveRecord::ConnectionAdapters::PostgreSQL::OID::Macaddr
end

class ActiveRecord::ConnectionAdapters::PostgreSQL::OID::Macaddr
end

class ActiveRecord::ConnectionAdapters::PostgreSQL::OID::Money
end

class ActiveRecord::ConnectionAdapters::PostgreSQL::OID::Money
end

class ActiveRecord::ConnectionAdapters::PostgreSQL::OID::Oid
end

class ActiveRecord::ConnectionAdapters::PostgreSQL::OID::Oid
end

class ActiveRecord::ConnectionAdapters::PostgreSQL::OID::Point
  include ::ActiveModel::Type::Helpers::Mutable
end

class ActiveRecord::ConnectionAdapters::PostgreSQL::OID::Point
end

class ActiveRecord::ConnectionAdapters::PostgreSQL::OID::Range
  def force_equality?(value); end

  def initialize(subtype, type=T.unsafe(nil)); end

  def subtype(); end

  def user_input_in_time_zone(*arg, **arg1, &arg2); end
  INFINITE_FLOAT_RANGE = ::T.let(nil, ::T.untyped)
end

class ActiveRecord::ConnectionAdapters::PostgreSQL::OID::Range
end

class ActiveRecord::ConnectionAdapters::PostgreSQL::OID::SpecializedString
  def initialize(type, **options); end
end

class ActiveRecord::ConnectionAdapters::PostgreSQL::OID::SpecializedString
end

class ActiveRecord::ConnectionAdapters::PostgreSQL::OID::Timestamp
end

class ActiveRecord::ConnectionAdapters::PostgreSQL::OID::Timestamp
end

class ActiveRecord::ConnectionAdapters::PostgreSQL::OID::TimestampWithTimeZone
end

class ActiveRecord::ConnectionAdapters::PostgreSQL::OID::TimestampWithTimeZone
end

class ActiveRecord::ConnectionAdapters::PostgreSQL::OID::TypeMapInitializer
  def initialize(store); end

  def query_conditions_for_array_types(); end

  def query_conditions_for_known_type_names(); end

  def query_conditions_for_known_type_types(); end

  def run(records); end
end

class ActiveRecord::ConnectionAdapters::PostgreSQL::OID::TypeMapInitializer
end

class ActiveRecord::ConnectionAdapters::PostgreSQL::OID::Uuid
  ACCEPTABLE_UUID = ::T.let(nil, ::T.untyped)
  CANONICAL_UUID = ::T.let(nil, ::T.untyped)
end

class ActiveRecord::ConnectionAdapters::PostgreSQL::OID::Uuid
end

class ActiveRecord::ConnectionAdapters::PostgreSQL::OID::Vector
  def delim(); end

  def initialize(delim, subtype); end

  def subtype(); end
end

class ActiveRecord::ConnectionAdapters::PostgreSQL::OID::Vector
end

class ActiveRecord::ConnectionAdapters::PostgreSQL::OID::Xml
end

class ActiveRecord::ConnectionAdapters::PostgreSQL::OID::Xml::Data
  def initialize(value); end
end

class ActiveRecord::ConnectionAdapters::PostgreSQL::OID::Xml::Data
end

class ActiveRecord::ConnectionAdapters::PostgreSQL::OID::Xml
end

module ActiveRecord::ConnectionAdapters::PostgreSQL::OID
end

module ActiveRecord::ConnectionAdapters::PostgreSQL::Quoting
  def check_int_in_range(value); end

  def escape_bytea(value); end

  def lookup_cast_type_from_column(column); end

  def quote(value); end

  def quote_default_expression(value, column); end

  def quote_schema_name(schema_name); end

  def quote_string(s); end

  def quote_table_name_for_assignment(table, attr); end

  def quoted_binary(value); end

  def quoted_date(value); end

  def type_cast(value); end

  def unescape_bytea(value); end
  QUOTED_COLUMN_NAMES = ::T.let(nil, ::T.untyped)
  QUOTED_TABLE_NAMES = ::T.let(nil, ::T.untyped)
end

module ActiveRecord::ConnectionAdapters::PostgreSQL::Quoting::ClassMethods
  def column_name_matcher(); end

  def column_name_with_order_matcher(); end

  def quote_column_name(name); end

  def quote_table_name(name); end
end

module ActiveRecord::ConnectionAdapters::PostgreSQL::Quoting::ClassMethods
end

class ActiveRecord::ConnectionAdapters::PostgreSQL::Quoting::IntegerOutOf64BitRange
  def initialize(msg); end
end

class ActiveRecord::ConnectionAdapters::PostgreSQL::Quoting::IntegerOutOf64BitRange
end

module ActiveRecord::ConnectionAdapters::PostgreSQL::Quoting
  extend ::ActiveSupport::Concern
end

module ActiveRecord::ConnectionAdapters::PostgreSQL::ReferentialIntegrity
  def check_all_foreign_keys_valid!(); end

  def disable_referential_integrity(); end
end

module ActiveRecord::ConnectionAdapters::PostgreSQL::ReferentialIntegrity
end

class ActiveRecord::ConnectionAdapters::PostgreSQL::SchemaCreation
  def quoted_include_columns_for_index(*arg, **arg1, &arg2); end
end

class ActiveRecord::ConnectionAdapters::PostgreSQL::SchemaCreation
end

class ActiveRecord::ConnectionAdapters::PostgreSQL::SchemaDumper
end

class ActiveRecord::ConnectionAdapters::PostgreSQL::SchemaDumper
end

module ActiveRecord::ConnectionAdapters::PostgreSQL::SchemaStatements
  def add_column(table_name, column_name, type, **options); end

  def add_exclusion_constraint(table_name, expression, **options); end

  def add_foreign_key(from_table, to_table, **options); end

  def add_index(table_name, column_name, **options); end

  def add_index_options(table_name, column_name, **options); end

  def add_unique_constraint(table_name, column_name=T.unsafe(nil), **options); end

  def build_change_column_default_definition(table_name, column_name, default_or_changes); end

  def build_change_column_definition(table_name, column_name, type, **options); end

  def build_create_index_definition(table_name, column_name, **options); end

  def change_column(table_name, column_name, type, **options); end

  def change_column_comment(table_name, column_name, comment_or_changes); end

  def change_column_default(table_name, column_name, default_or_changes); end

  def change_column_null(table_name, column_name, null, default=T.unsafe(nil)); end

  def change_table_comment(table_name, comment_or_changes); end

  def check_constraints(table_name); end

  def client_min_messages(); end

  def client_min_messages=(level); end

  def collation(); end

  def columns_for_distinct(columns, orders); end

  def create_database(name, options=T.unsafe(nil)); end

  def create_schema(schema_name, force: T.unsafe(nil), if_not_exists: T.unsafe(nil)); end

  def create_schema_dumper(options); end

  def ctype(); end

  def current_database(); end

  def current_schema(); end

  def default_sequence_name(table_name, pk=T.unsafe(nil)); end

  def drop_database(name); end

  def drop_schema(schema_name, **options); end

  def drop_table(table_name, **options); end

  def encoding(); end

  def exclusion_constraint_options(table_name, expression, options); end

  def exclusion_constraints(table_name); end

  def foreign_key_column_for(table_name, column_name); end

  def foreign_keys(table_name); end

  def foreign_table_exists?(table_name); end

  def foreign_tables(); end

  def index_name(table_name, options); end

  def index_name_exists?(table_name, index_name); end

  def indexes(table_name); end

  def pk_and_sequence_for(table); end

  def primary_keys(table_name); end

  def quoted_include_columns_for_index(column_names); end

  def recreate_database(name, options=T.unsafe(nil)); end

  def remove_exclusion_constraint(table_name, expression=T.unsafe(nil), **options); end

  def remove_index(table_name, column_name=T.unsafe(nil), **options); end

  def remove_unique_constraint(table_name, column_name=T.unsafe(nil), **options); end

  def rename_column(table_name, column_name, new_column_name); end

  def rename_index(table_name, old_name, new_name); end

  def rename_table(table_name, new_name, **options); end

  def reset_pk_sequence!(table, pk=T.unsafe(nil), sequence=T.unsafe(nil)); end

  def schema_creation(); end

  def schema_exists?(name); end

  def schema_names(); end

  def schema_search_path(); end

  def schema_search_path=(schema_csv); end

  def serial_sequence(table, column); end

  def set_pk_sequence!(table, value); end

  def table_comment(table_name); end

  def table_options(table_name); end

  def type_to_sql(type, limit: T.unsafe(nil), precision: T.unsafe(nil), scale: T.unsafe(nil), array: T.unsafe(nil), enum_type: T.unsafe(nil), **arg); end

  def unique_constraint_options(table_name, column_name, options); end

  def unique_constraints(table_name); end

  def update_table_definition(table_name, base); end

  def validate_check_constraint(table_name, **options); end

  def validate_constraint(table_name, constraint_name); end

  def validate_foreign_key(from_table, to_table=T.unsafe(nil), **options); end
end

module ActiveRecord::ConnectionAdapters::PostgreSQL::SchemaStatements
end

class ActiveRecord::ConnectionAdapters::PostgreSQL::Table
  include ::ActiveRecord::ConnectionAdapters::PostgreSQL::ColumnMethods
  def bigserial(*names, **options); end

  def bit(*names, **options); end

  def bit_varying(*names, **options); end

  def box(*names, **options); end

  def cidr(*names, **options); end

  def circle(*names, **options); end

  def citext(*names, **options); end

  def daterange(*names, **options); end

  def enum(*names, **options); end

  def exclusion_constraint(*args); end

  def hstore(*names, **options); end

  def inet(*names, **options); end

  def int4range(*names, **options); end

  def int8range(*names, **options); end

  def interval(*names, **options); end

  def jsonb(*names, **options); end

  def line(*names, **options); end

  def lseg(*names, **options); end

  def ltree(*names, **options); end

  def macaddr(*names, **options); end

  def money(*names, **options); end

  def numrange(*names, **options); end

  def oid(*names, **options); end

  def path(*names, **options); end

  def point(*names, **options); end

  def polygon(*names, **options); end

  def remove_exclusion_constraint(*args); end

  def remove_unique_constraint(*args); end

  def serial(*names, **options); end

  def timestamptz(*names, **options); end

  def tsrange(*names, **options); end

  def tstzrange(*names, **options); end

  def tsvector(*names, **options); end

  def unique_constraint(*args); end

  def uuid(*names, **options); end

  def validate_check_constraint(*args); end

  def validate_constraint(*args); end

  def xml(*names, **options); end
end

class ActiveRecord::ConnectionAdapters::PostgreSQL::Table
end

class ActiveRecord::ConnectionAdapters::PostgreSQL::TableDefinition
  include ::ActiveRecord::ConnectionAdapters::PostgreSQL::ColumnMethods
  def bigserial(*names, **options); end

  def bit(*names, **options); end

  def bit_varying(*names, **options); end

  def box(*names, **options); end

  def cidr(*names, **options); end

  def circle(*names, **options); end

  def citext(*names, **options); end

  def daterange(*names, **options); end

  def enum(*names, **options); end

  def exclusion_constraint(expression, **options); end

  def exclusion_constraints(); end

  def hstore(*names, **options); end

  def inet(*names, **options); end

  def initialize(*arg, **arg1); end

  def int4range(*names, **options); end

  def int8range(*names, **options); end

  def interval(*names, **options); end

  def jsonb(*names, **options); end

  def line(*names, **options); end

  def lseg(*names, **options); end

  def ltree(*names, **options); end

  def macaddr(*names, **options); end

  def money(*names, **options); end

  def new_exclusion_constraint_definition(expression, options); end

  def new_unique_constraint_definition(column_name, options); end

  def numrange(*names, **options); end

  def oid(*names, **options); end

  def path(*names, **options); end

  def point(*names, **options); end

  def polygon(*names, **options); end

  def serial(*names, **options); end

  def timestamptz(*names, **options); end

  def tsrange(*names, **options); end

  def tstzrange(*names, **options); end

  def tsvector(*names, **options); end

  def unique_constraint(column_name, **options); end

  def unique_constraints(); end

  def unlogged(); end

  def uuid(*names, **options); end

  def xml(*names, **options); end
end

class ActiveRecord::ConnectionAdapters::PostgreSQL::TableDefinition
end

class ActiveRecord::ConnectionAdapters::PostgreSQL::TypeMetadata
  include ::ActiveRecord::ConnectionAdapters::Deduplicable
  def ==(other); end

  def eql?(other); end

  def fmod(); end

  def hash(); end

  def initialize(type_metadata, oid: T.unsafe(nil), fmod: T.unsafe(nil)); end

  def oid(); end

  RUBYGEMS_ACTIVATION_MONITOR = ::T.let(nil, ::T.untyped)
end

class ActiveRecord::ConnectionAdapters::PostgreSQL::TypeMetadata
  extend ::ActiveRecord::ConnectionAdapters::Deduplicable::ClassMethods
end

class ActiveRecord::ConnectionAdapters::PostgreSQL::UniqueConstraintDefinition
  def column(); end

  def column=(_); end

  def deferrable(); end

  def defined_for?(name: T.unsafe(nil), column: T.unsafe(nil), **options); end

  def export_name_on_schema_dump?(); end

  def name(); end

  def options(); end

  def options=(_); end

  def table_name(); end

  def table_name=(_); end

  def using_index(); end
end

class ActiveRecord::ConnectionAdapters::PostgreSQL::UniqueConstraintDefinition
  def self.[](*arg); end

  def self.keyword_init?(); end

  def self.members(); end
end

module ActiveRecord::ConnectionAdapters::PostgreSQL::Utils
  def extract_schema_qualified_name(string); end

  def unquote_identifier(identifier); end
end

module ActiveRecord::ConnectionAdapters::PostgreSQL::Utils
  extend ::ActiveRecord::ConnectionAdapters::PostgreSQL::Utils
end

module ActiveRecord::ConnectionAdapters::PostgreSQL
end

class ActiveRecord::ConnectionAdapters::PostgreSQLAdapter
  include ::ActiveRecord::ConnectionAdapters::PostgreSQL::Quoting
  include ::ActiveRecord::ConnectionAdapters::PostgreSQL::ReferentialIntegrity
  include ::ActiveRecord::ConnectionAdapters::PostgreSQL::SchemaStatements
  include ::ActiveRecord::ConnectionAdapters::PostgreSQL::DatabaseStatements
  def add_enum_value(type_name, value, options=T.unsafe(nil)); end

  def create_enum(name, values, **options); end

  def create_unlogged_tables(); end

  def create_unlogged_tables=(create_unlogged_tables); end

  def create_unlogged_tables?(); end

  def datetime_type(); end

  def datetime_type=(datetime_type); end

  def datetime_type?(); end

  def decode_dates(); end

  def decode_dates=(decode_dates); end

  def decode_dates?(); end

  def disable_extension(name, force: T.unsafe(nil)); end

  def drop_enum(name, values=T.unsafe(nil), **options); end

  def enum_types(); end

  def extension_available?(name); end

  def extension_enabled?(name); end

  def initialize(*arg, **arg1, &arg2); end

  def postgresql_version(); end

  def reload_type_map(); end

  def rename_enum(name, options=T.unsafe(nil)); end

  def rename_enum_value(type_name, options=T.unsafe(nil)); end

  def session_auth=(user); end

  def set_standard_conforming_strings(); end

  def supports_identity_columns?(); end

  def supports_insert_on_conflict?(); end

  def supports_pgcrypto_uuid?(); end

  def use_insert_returning?(); end
  ADAPTER_NAME = ::T.let(nil, ::T.untyped)
  DEADLOCK_DETECTED = ::T.let(nil, ::T.untyped)
  DUPLICATE_DATABASE = ::T.let(nil, ::T.untyped)
  FEATURE_NOT_SUPPORTED = ::T.let(nil, ::T.untyped)
  FOREIGN_KEY_VIOLATION = ::T.let(nil, ::T.untyped)
  LOCK_NOT_AVAILABLE = ::T.let(nil, ::T.untyped)
  NATIVE_DATABASE_TYPES = ::T.let(nil, ::T.untyped)
  NOT_NULL_VIOLATION = ::T.let(nil, ::T.untyped)
  NUMERIC_VALUE_OUT_OF_RANGE = ::T.let(nil, ::T.untyped)
  QUERY_CANCELED = ::T.let(nil, ::T.untyped)
  SERIALIZATION_FAILURE = ::T.let(nil, ::T.untyped)
  UNIQUE_VIOLATION = ::T.let(nil, ::T.untyped)
  VALUE_LIMIT_VIOLATION = ::T.let(nil, ::T.untyped)
end

class ActiveRecord::ConnectionAdapters::PostgreSQLAdapter::MoneyDecoder
  def decode(value, tuple=T.unsafe(nil), field=T.unsafe(nil)); end
  TYPE = ::T.let(nil, ::T.untyped)
end

class ActiveRecord::ConnectionAdapters::PostgreSQLAdapter::MoneyDecoder
end

ActiveRecord::ConnectionAdapters::PostgreSQLAdapter::OID = ActiveRecord::ConnectionAdapters::PostgreSQL::OID

class ActiveRecord::ConnectionAdapters::PostgreSQLAdapter::StatementPool
  def initialize(connection, max); end

  def next_key(); end
end

class ActiveRecord::ConnectionAdapters::PostgreSQLAdapter::StatementPool
end

class ActiveRecord::ConnectionAdapters::PostgreSQLAdapter
  extend ::ActiveRecord::ConnectionAdapters::PostgreSQL::Quoting::ClassMethods
  def self.create_unlogged_tables(); end

  def self.create_unlogged_tables=(value); end

  def self.create_unlogged_tables?(); end

  def self.datetime_type(); end

  def self.datetime_type=(value); end

  def self.datetime_type?(); end

  def self.decode_dates(); end

  def self.decode_dates=(value); end

  def self.decode_dates?(); end

  def self.native_database_types(); end

  def self.new_client(conn_params); end
end

ActiveRecord::ConnectionAdapters::PostgreSQLColumn = ActiveRecord::ConnectionAdapters::PostgreSQL::Column

ActiveRecord::ConnectionAdapters::PostgreSQLTypeMetadata = ActiveRecord::ConnectionAdapters::PostgreSQL::TypeMetadata

class ActiveRecord::ConnectionAdapters::StatementPool
  include ::Enumerable
  def [](key); end

  def []=(sql, stmt); end

  def clear(); end

  def delete(key); end

  def each(&block); end

  def initialize(statement_limit=T.unsafe(nil)); end

  def key?(key); end

  def length(); end

  def reset(); end
  DEFAULT_STATEMENT_LIMIT = ::T.let(nil, ::T.untyped)
end

class ActiveRecord::ConnectionAdapters::StatementPool
end

class ActiveRecord::FixtureSet
  extend ::GlobalID::FixtureSet
end

class ActiveRecord::Locking::LockingType
  RUBYGEMS_ACTIVATION_MONITOR = ::T.let(nil, ::T.untyped)
end

module ActiveRecord::Marshalling::Methods
  def marshal_dump(); end
end

class ActiveRecord::Point
  def x(); end

  def x=(_); end

  def y(); end

  def y=(_); end
end

class ActiveRecord::Point
  def self.[](*arg); end

  def self.keyword_init?(); end

  def self.members(); end
end

module ActiveRecord::Railties
end

module ActiveRecord::Railties::ControllerRuntime
  def db_runtime(); end

  def db_runtime=(db_runtime); end

  def initialize(*arg, **arg1, &arg2); end
end

module ActiveRecord::Railties::ControllerRuntime
  extend ::ActiveSupport::Concern
end

module ActiveRecord::Railties::JobRuntime
end

module ActiveRecord::Railties::JobRuntime
end

module ActiveRecord::Railties
end

class ActiveRecord::Relation
  include ::WillPaginate::ActiveRecord::Pagination
end

module ActiveRecord::Serialization
  def to_xml(options=T.unsafe(nil), &block); end
end

class ActiveRecord::Type::Serialized
  RUBYGEMS_ACTIVATION_MONITOR = ::T.let(nil, ::T.untyped)
end

class ActiveRecord::Type::Time::Value
  RUBYGEMS_ACTIVATION_MONITOR = ::T.let(nil, ::T.untyped)
end

class ActiveRecord::XmlSerializer
end

class ActiveRecord::XmlSerializer::Attribute
end

class ActiveRecord::XmlSerializer::Attribute
end

class ActiveRecord::XmlSerializer
end

class ActiveReservationCheckerWorker
  def sidekiq_options_hash(); end

  def sidekiq_options_hash=(sidekiq_options_hash); end

  def sidekiq_retries_exhausted_block(); end

  def sidekiq_retries_exhausted_block=(sidekiq_retries_exhausted_block); end

  def sidekiq_retry_in_block(); end

  def sidekiq_retry_in_block=(sidekiq_retry_in_block); end
end

class ActiveReservationCheckerWorker
  def self.__synchronized_sidekiq_options_hash(); end

  def self.sidekiq_options_hash(); end

  def self.sidekiq_options_hash=(val); end

  def self.sidekiq_retries_exhausted_block(); end

  def self.sidekiq_retries_exhausted_block=(val); end

  def self.sidekiq_retry_in_block(); end

  def self.sidekiq_retry_in_block=(val); end
end

class ActiveReservationsCheckerWorker
  def sidekiq_options_hash(); end

  def sidekiq_options_hash=(sidekiq_options_hash); end

  def sidekiq_retries_exhausted_block(); end

  def sidekiq_retries_exhausted_block=(sidekiq_retries_exhausted_block); end

  def sidekiq_retry_in_block(); end

  def sidekiq_retry_in_block=(sidekiq_retry_in_block); end
end

class ActiveReservationsCheckerWorker
  def self.sidekiq_options_hash(); end

  def self.sidekiq_options_hash=(val); end

  def self.sidekiq_retries_exhausted_block(); end

  def self.sidekiq_retries_exhausted_block=(val); end

  def self.sidekiq_retry_in_block(); end

  def self.sidekiq_retry_in_block=(val); end
end

class ActiveStorage::Blobs::ProxyController
  include ::Sentry::Rails::Overrides::StreamingReporter
end

class ActiveStorage::Representations::ProxyController
  include ::Sentry::Rails::Overrides::StreamingReporter
end

class ActiveStorage::Service::S3Service
  def bucket(); end

  def client(); end

  def download(key, &block); end

  def headers_for_direct_upload(key, content_type:, checksum:, filename: T.unsafe(nil), disposition: T.unsafe(nil), custom_metadata: T.unsafe(nil), **arg); end

  def initialize(bucket:, upload: T.unsafe(nil), public: T.unsafe(nil), **options); end

  def multipart_upload_threshold(); end

  def upload(key, io, checksum: T.unsafe(nil), filename: T.unsafe(nil), content_type: T.unsafe(nil), disposition: T.unsafe(nil), custom_metadata: T.unsafe(nil), **arg); end

  def upload_options(); end
  MAXIMUM_UPLOAD_PARTS_COUNT = ::T.let(nil, ::T.untyped)
  MINIMUM_UPLOAD_PART_SIZE = ::T.let(nil, ::T.untyped)
end

class ActiveStorage::Service::S3Service
end

module ActiveSupport::CurrentAttributes::TestHelper
  def after_teardown(); end

  def before_setup(); end
end

module ActiveSupport::CurrentAttributes::TestHelper
end

module ActiveSupport::ExecutionContext::TestHelper
  def after_teardown(); end

  def before_setup(); end
end

module ActiveSupport::ExecutionContext::TestHelper
end

module ActiveSupport::Executor::TestHelper
  def run(*arg, **arg1, &arg2); end
end

module ActiveSupport::Executor::TestHelper
end

class ActiveSupport::SyntaxErrorProxy
  RUBYGEMS_ACTIVATION_MONITOR = ::T.let(nil, ::T.untyped)
end

class ActiveSupport::SyntaxErrorProxy::BacktraceLocationProxy
  RUBYGEMS_ACTIVATION_MONITOR = ::T.let(nil, ::T.untyped)
end

class ActiveSupport::TestCase
  include ::ActiveSupport::Executor::TestHelper
  include ::ActiveRecord::TestDatabases
  include ::ActiveRecord::TestFixtures
  include ::ActiveRecord::Assertions::QueryAssertions
  def fixture_class_names(); end

  def fixture_class_names=(fixture_class_names); end

  def fixture_class_names?(); end

  def fixture_paths(); end

  def fixture_paths?(); end

  def fixture_sets(); end

  def fixture_sets=(fixture_sets); end

  def fixture_sets?(); end

  def fixture_table_names(); end

  def fixture_table_names=(fixture_table_names); end

  def fixture_table_names?(); end

  def lock_threads(); end

  def lock_threads=(lock_threads); end

  def lock_threads?(); end

  def pre_loaded_fixtures(); end

  def pre_loaded_fixtures=(pre_loaded_fixtures); end

  def pre_loaded_fixtures?(); end

  def use_instantiated_fixtures(); end

  def use_instantiated_fixtures=(use_instantiated_fixtures); end

  def use_instantiated_fixtures?(); end

  def use_transactional_tests(); end

  def use_transactional_tests=(use_transactional_tests); end

  def use_transactional_tests?(); end
end

class ActiveSupport::TestCase
  extend ::Rails::LineFiltering
  def self.fixture_class_names(); end

  def self.fixture_class_names=(value); end

  def self.fixture_class_names?(); end

  def self.fixture_paths(); end

  def self.fixture_paths=(value); end

  def self.fixture_paths?(); end

  def self.fixture_sets(); end

  def self.fixture_sets=(value); end

  def self.fixture_sets?(); end

  def self.fixture_table_names(); end

  def self.fixture_table_names=(value); end

  def self.fixture_table_names?(); end

  def self.lock_threads(); end

  def self.lock_threads=(value); end

  def self.lock_threads?(); end

  def self.pre_loaded_fixtures(); end

  def self.pre_loaded_fixtures=(value); end

  def self.pre_loaded_fixtures?(); end

  def self.use_instantiated_fixtures(); end

  def self.use_instantiated_fixtures=(value); end

  def self.use_instantiated_fixtures?(); end

  def self.use_transactional_tests(); end

  def self.use_transactional_tests=(value); end

  def self.use_transactional_tests?(); end
end

class AddTvPortToServers::Server
  include ::AddTvPortToServers::Server::GeneratedAttributeMethods
  include ::AddTvPortToServers::Server::GeneratedAssociationMethods
end

module AddTvPortToServers::Server::GeneratedAssociationMethods
end

module AddTvPortToServers::Server::GeneratedAssociationMethods
end

module AddTvPortToServers::Server::GeneratedAttributeMethods
end

module AddTvPortToServers::Server::GeneratedAttributeMethods
end

class Addrinfo
  def connect_internal(local_addrinfo, timeout=T.unsafe(nil)); end
end

class AllowReservationPlayerWorker
  def sidekiq_options_hash(); end

  def sidekiq_options_hash=(sidekiq_options_hash); end

  def sidekiq_retries_exhausted_block(); end

  def sidekiq_retries_exhausted_block=(sidekiq_retries_exhausted_block); end

  def sidekiq_retry_in_block(); end

  def sidekiq_retry_in_block=(sidekiq_retry_in_block); end
end

class AllowReservationPlayerWorker
  def self.__synchronized_sidekiq_options_hash(); end

  def self.sidekiq_options_hash(); end

  def self.sidekiq_options_hash=(val); end

  def self.sidekiq_retries_exhausted_block(); end

  def self.sidekiq_retries_exhausted_block=(val); end

  def self.sidekiq_retry_in_block(); end

  def self.sidekiq_retry_in_block=(val); end
end

class AnnounceDonatorWorker
  def sidekiq_options_hash(); end

  def sidekiq_options_hash=(sidekiq_options_hash); end

  def sidekiq_retries_exhausted_block(); end

  def sidekiq_retries_exhausted_block=(sidekiq_retries_exhausted_block); end

  def sidekiq_retry_in_block(); end

  def sidekiq_retry_in_block=(sidekiq_retry_in_block); end
end

class AnnounceDonatorWorker
  def self.sidekiq_options_hash(); end

  def self.sidekiq_options_hash=(val); end

  def self.sidekiq_retries_exhausted_block(); end

  def self.sidekiq_retries_exhausted_block=(val); end

  def self.sidekiq_retry_in_block(); end

  def self.sidekiq_retry_in_block=(val); end
end

module ApplicationHelper
  def au_system?(); end

  def na_system?(); end

  def sa_system?(); end

  def sea_system?(); end
end

class ArgumentError
  include ::ErrorHighlight::CoreExt
end

class Array
  def deconstruct(); end

  def to_h(); end
end

class Array
  def self.new(*arg); end

  def self.try_convert(arg); end
end

class AvailableMapsWorker
  def sidekiq_options_hash(); end

  def sidekiq_options_hash=(sidekiq_options_hash); end

  def sidekiq_retries_exhausted_block(); end

  def sidekiq_retries_exhausted_block=(sidekiq_retries_exhausted_block); end

  def sidekiq_retry_in_block(); end

  def sidekiq_retry_in_block=(sidekiq_retry_in_block); end
end

class AvailableMapsWorker
  def self.sidekiq_options_hash(); end

  def self.sidekiq_options_hash=(val); end

  def self.sidekiq_retries_exhausted_block(); end

  def self.sidekiq_retries_exhausted_block=(val); end

  def self.sidekiq_retry_in_block(); end

  def self.sidekiq_retry_in_block=(val); end
end

class BasicObject
  def as_null_object(); end

  def null_object?(); end

  def received_message?(message, *args, &block); end

  def should(matcher=T.unsafe(nil), message=T.unsafe(nil), &block); end

  def should_not(matcher=T.unsafe(nil), message=T.unsafe(nil), &block); end

  def should_not_receive(message, &block); end

  def should_receive(message, opts=T.unsafe(nil), &block); end

  def stub(message_or_hash, opts=T.unsafe(nil), &block); end

  def stub_chain(*chain, &blk); end

  def unstub(message); end
end

BasicObject::BasicObject = BasicObject

class BasicSocket
  def read_nonblock(len, str=T.unsafe(nil), exception: T.unsafe(nil)); end
end

module Benchmark
  def self.ms(&block); end
end

class BigDecimal
  def clone(); end

  def n_significant_digits(); end

  def precision(); end

  def precision_scale(); end

  def scale(); end
end

class BigDecimal
  def self.interpret_loosely(arg); end
end

class Binding
  def clone(); end
end

class Bundler::APIResponseInvalidDependenciesError
  def status_code(); end
end

class Bundler::APIResponseInvalidDependenciesError
end

module Bundler::CIDetector
  ENV_DESCRIPTORS = ::T.let(nil, ::T.untyped)
  ENV_INDICATORS = ::T.let(nil, ::T.untyped)
end

module Bundler::CIDetector
  def self.ci?(); end

  def self.ci_strings(); end
end

class Bundler::CLI
  def add(*gems); end

  def binstubs(*gems); end

  def cache(); end

  def check(); end

  def clean(); end

  def cli_help(); end

  def config(*args); end

  def console(group=T.unsafe(nil)); end

  def doctor(); end

  def env(); end

  def exec(*args); end

  def fund(); end

  def help(cli=T.unsafe(nil)); end

  def info(gem_name); end

  def init(); end

  def initialize(*args); end

  def inject(name, version); end

  def install(); end

  def issue(); end

  def licenses(); end

  def list(); end

  def lock(); end

  def open(name); end

  def outdated(*gems); end

  def platform(); end

  def plugin(*args); end

  def pristine(*gems); end

  def remove(*gems); end

  def show(gem_name=T.unsafe(nil)); end

  def update(*gems); end

  def version(); end

  def viz(); end
  AUTO_INSTALL_CMDS = ::T.let(nil, ::T.untyped)
  COMMAND_ALIASES = ::T.let(nil, ::T.untyped)
  EXTENSIONS = ::T.let(nil, ::T.untyped)
  PARSEABLE_COMMANDS = ::T.let(nil, ::T.untyped)
end

module Bundler::CLI::Common
end

module Bundler::CLI::Common
  def self.ask_for_spec_from(specs); end

  def self.clean_after_install?(); end

  def self.configure_gem_version_promoter(definition, options); end

  def self.default_gem_spec(name); end

  def self.ensure_all_gems_in_lockfile!(names, locked_gems=T.unsafe(nil)); end

  def self.gem_not_found_message(missing_gem_name, alternatives); end

  def self.output_fund_metadata_summary(); end

  def self.output_post_install_messages(messages); end

  def self.output_without_groups_message(command); end

  def self.patch_level_options(options); end

  def self.print_post_install_message(name, msg); end

  def self.select_spec(name, regex_match=T.unsafe(nil)); end

  def self.verbalize_groups(groups); end

  def self.without_groups_message(command); end
end

class Bundler::CLI::Config
  def base(name=T.unsafe(nil), *value); end

  def get(name); end

  def list(); end

  def set(name, value, *value_); end

  def unset(name); end
end

class Bundler::CLI::Config::Base
  def confirm(name); end

  def confirm_all(); end

  def explicit_scope?(); end

  def initialize(options, name, value, thor); end

  def message(); end

  def name(); end

  def new_value(); end

  def options(); end

  def run(); end

  def scope(); end

  def show_pretty_values_for(setting); end

  def thor(); end

  def validate_scope!(); end

  def value(); end

  def warn_unused_scope(msg); end
end

class Bundler::CLI::Config::Base
end

class Bundler::CLI::Config
end

class Bundler::CLI::Install
  def initialize(options); end

  def options(); end

  def run(); end
end

class Bundler::CLI::Install
end

class Bundler::CLI::Plugin
  def install(*plugins); end

  def list(); end

  def uninstall(*plugins); end
end

class Bundler::CLI::Plugin
end

class Bundler::CLI
  def self.aliases_for(command_name); end

  def self.all_aliases(); end

  def self.check_deprecated_ext_option(arguments); end

  def self.deprecated_ext_value?(arguments); end

  def self.dispatch(*arg); end

  def self.reformatted_help_args(args); end

  def self.source_root(); end

  def self.start(*arg); end
end

class Bundler::Checksum
  def ==(other); end

  def algo(); end

  def digest(); end

  def eql?(other); end

  def formatted_sources(); end

  def initialize(algo, digest, source); end

  def match?(other); end

  def merge!(other); end

  def removable?(); end

  def removal_instructions(); end

  def same_source?(other); end

  def sources(); end

  def to_lock(); end
  ALGO_SEPARATOR = ::T.let(nil, ::T.untyped)
end

class Bundler::Checksum::Source
  def ==(other); end

  def initialize(type, location); end

  def location(); end

  def removable?(); end

  def removal(); end

  def type(); end
end

class Bundler::Checksum::Source
end

class Bundler::Checksum::Store
  def merge!(other); end

  def register(spec, checksum); end

  def replace(spec, checksum); end

  def store(); end

  def to_lock(spec); end
end

class Bundler::Checksum::Store
end

class Bundler::Checksum
  def self.from_api(digest, source_uri, algo=T.unsafe(nil)); end

  def self.from_gem(io, pathname, algo=T.unsafe(nil)); end

  def self.from_gem_package(gem_package, algo=T.unsafe(nil)); end

  def self.from_lock(lock_checksum, lockfile_location); end

  def self.to_hexdigest(digest, algo=T.unsafe(nil)); end
end

class Bundler::ChecksumMismatchError
  def initialize(lock_name, existing, checksum); end

  def mismatch_resolution_instructions(); end
end

class Bundler::ChecksumMismatchError
end

class Bundler::ConnectionPool
  def auto_reload_after_fork(); end

  def available(); end

  def checkin(force: T.unsafe(nil)); end

  def checkout(options=T.unsafe(nil)); end

  def initialize(options=T.unsafe(nil), &block); end

  def reload(&block); end

  def shutdown(&block); end

  def size(); end

  def then(options=T.unsafe(nil)); end

  def with(options=T.unsafe(nil)); end
  DEFAULTS = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

class Bundler::ConnectionPool::TimedStack
  def <<(obj, options=T.unsafe(nil)); end

  def empty?(); end

  def initialize(size=T.unsafe(nil), &block); end

  def length(); end

  def max(); end

  def pop(timeout=T.unsafe(nil), options=T.unsafe(nil)); end

  def push(obj, options=T.unsafe(nil)); end

  def shutdown(reload: T.unsafe(nil), &block); end
end

class Bundler::ConnectionPool::TimedStack
end

class Bundler::ConnectionPool
  def self.after_fork(); end

  def self.wrap(options, &block); end
end

class Bundler::CorruptBundlerInstallError
  def initialize(loaded_spec); end

  def status_code(); end
end

class Bundler::CorruptBundlerInstallError
end

class Bundler::CurrentRuby
  def jruby_30?(); end

  def jruby_31?(); end

  def jruby_32?(); end

  def jruby_33?(); end

  def jruby_3?(); end

  def maglev_30?(); end

  def maglev_31?(); end

  def maglev_32?(); end

  def maglev_33?(); end

  def maglev_3?(); end

  def mingw_30?(); end

  def mingw_31?(); end

  def mingw_32?(); end

  def mingw_33?(); end

  def mingw_3?(); end

  def mri_30?(); end

  def mri_31?(); end

  def mri_32?(); end

  def mri_33?(); end

  def mri_3?(); end

  def mswin64_30?(); end

  def mswin64_31?(); end

  def mswin64_32?(); end

  def mswin64_33?(); end

  def mswin64_3?(); end

  def mswin_30?(); end

  def mswin_31?(); end

  def mswin_32?(); end

  def mswin_33?(); end

  def mswin_3?(); end

  def on_30?(); end

  def on_31?(); end

  def on_32?(); end

  def on_33?(); end

  def on_3?(); end

  def rbx_30?(); end

  def rbx_31?(); end

  def rbx_32?(); end

  def rbx_33?(); end

  def rbx_3?(); end

  def ruby_30?(); end

  def ruby_31?(); end

  def ruby_32?(); end

  def ruby_33?(); end

  def ruby_3?(); end

  def truffleruby_30?(); end

  def truffleruby_31?(); end

  def truffleruby_32?(); end

  def truffleruby_33?(); end

  def truffleruby_3?(); end

  def windows?(); end

  def windows_18?(); end

  def windows_19?(); end

  def windows_1?(); end

  def windows_20?(); end

  def windows_21?(); end

  def windows_22?(); end

  def windows_23?(); end

  def windows_24?(); end

  def windows_25?(); end

  def windows_26?(); end

  def windows_27?(); end

  def windows_2?(); end

  def windows_30?(); end

  def windows_31?(); end

  def windows_32?(); end

  def windows_33?(); end

  def windows_3?(); end

  def x64_mingw_30?(); end

  def x64_mingw_31?(); end

  def x64_mingw_32?(); end

  def x64_mingw_33?(); end

  def x64_mingw_3?(); end
end

class Bundler::Definition
  def bundler_version_to_lock(); end

  def current_locked_dependencies(); end

  def deleted_deps(); end

  def dependencies_for(groups); end

  def filter_relevant(dependencies); end

  def locked_checksums(); end

  def locked_dependencies(); end

  def most_specific_locked_platform(); end

  def new_deps(); end

  def no_resolve_needed?(); end

  def prefer_local!(); end

  def requested_dependencies(); end

  def resolve_only_locally!(); end
end

class Bundler::Definition
  def self.no_lock(); end

  def self.no_lock=(no_lock); end
end

class Bundler::Dependency
  def branch(); end

  def expanded_platforms(); end

  def gemspec_dev_dep?(); end

  def git(); end

  def github(); end

  def glob(); end

  def path(); end

  def ref(); end
  ALL_RUBY_VERSIONS = ::T.let(nil, ::T.untyped)
end

Bundler::Deprecate = Gem::Deprecate

module Bundler::Digest
  SHA1_MASK = ::T.let(nil, ::T.untyped)
  SHA1_WORDS = ::T.let(nil, ::T.untyped)
end

module Bundler::Digest
  def self.sha1(string); end
end

class Bundler::DirectoryRemovalError
  def initialize(orig_exception, msg); end

  def status_code(); end
end

class Bundler::DirectoryRemovalError
end

class Bundler::Dsl
  def check_primary_source_safety(); end

  def gemfile(); end
  GITHUB_PULL_REQUEST_URL = ::T.let(nil, ::T.untyped)
  GITLAB_MERGE_REQUEST_URL = ::T.let(nil, ::T.untyped)
end

class Bundler::EndpointSpecification
  include ::Bundler::MatchRemoteMetadata
  include ::Bundler::FetchMetadata
end

class Bundler::Env
end

class Bundler::Env
  def self.environment(); end

  def self.report(options=T.unsafe(nil)); end

  def self.write(io); end
end

class Bundler::EnvironmentPreserver
  def replace_with_backup(); end
end

class Bundler::EnvironmentPreserver
  def self.from_env(); end
end

module Bundler::FetchMetadata
  def matches_current_ruby?(); end

  def matches_current_rubygems?(); end
end

module Bundler::FetchMetadata
end

class Bundler::Fetcher
  def api_fetcher?(); end

  def fetch_spec(spec); end

  def gem_remote_fetcher(); end

  def http_proxy(); end

  def initialize(remote); end

  def specs(gem_names, source); end

  def specs_with_retry(gem_names, source); end

  def uri(); end

  def user_agent(); end
  FAIL_ERRORS = ::T.let(nil, ::T.untyped)
  HTTP_ERRORS = ::T.let(nil, ::T.untyped)
  NET_ERRORS = ::T.let(nil, ::T.untyped)
end

class Bundler::Fetcher::AuthenticationForbiddenError
  def initialize(remote_uri); end
end

class Bundler::Fetcher::AuthenticationForbiddenError
end

class Bundler::Fetcher::AuthenticationRequiredError
  def initialize(remote_uri); end
end

class Bundler::Fetcher::BadAuthenticationError
  def initialize(remote_uri); end
end

class Bundler::Fetcher::Base
  def api_fetcher?(); end

  def available?(); end

  def display_uri(); end

  def downloader(); end

  def fetch_uri(); end

  def gem_remote_fetcher(); end

  def initialize(downloader, remote, display_uri, gem_remote_fetcher); end

  def remote(); end

  def remote_uri(); end
end

class Bundler::Fetcher::Base
end

class Bundler::Fetcher::CertificateFailureError
  def initialize(remote_uri); end
end

class Bundler::Fetcher::CompactIndex
  def available?(*args, &blk); end

  def specs(*args, &blk); end

  def specs_for_names(gem_names); end
end

class Bundler::Fetcher::CompactIndex::ClientFetcher
  def call(path, headers); end

  def fetcher(); end

  def fetcher=(_); end

  def ui(); end

  def ui=(_); end
end

class Bundler::Fetcher::CompactIndex::ClientFetcher
  def self.[](*arg); end

  def self.keyword_init?(); end

  def self.members(); end
end

class Bundler::Fetcher::CompactIndex
  def self.compact_index_request(method_name); end
end

class Bundler::Fetcher::Dependency
  def dependency_api_uri(gem_names=T.unsafe(nil)); end

  def dependency_specs(gem_names); end

  def get_formatted_specs_and_deps(gem_list); end

  def specs(gem_names, full_dependency_list=T.unsafe(nil), last_spec_list=T.unsafe(nil)); end

  def unmarshalled_dep_gems(gem_names); end
end

class Bundler::Fetcher::Dependency
end

class Bundler::Fetcher::Downloader
  def connection(); end

  def fetch(uri, headers=T.unsafe(nil), counter=T.unsafe(nil)); end

  def initialize(connection, redirect_limit); end

  def redirect_limit(); end

  def request(uri, headers); end
end

class Bundler::Fetcher::Downloader
end

class Bundler::Fetcher::Index
  def specs(_gem_names); end
end

class Bundler::Fetcher::Index
end

class Bundler::Fetcher::SSLError
  def initialize(msg=T.unsafe(nil)); end
end

class Bundler::Fetcher::TooManyRequestsError
end

class Bundler::Fetcher::TooManyRequestsError
end

class Bundler::Fetcher
  def self.api_timeout(); end

  def self.api_timeout=(api_timeout); end

  def self.disable_endpoint(); end

  def self.disable_endpoint=(disable_endpoint); end

  def self.max_retries(); end

  def self.max_retries=(max_retries); end

  def self.redirect_limit(); end

  def self.redirect_limit=(redirect_limit); end
end

module Bundler::FileUtils
  VERSION = ::T.let(nil, ::T.untyped)
end

class Bundler::FileUtils::Entry_
  def link(dest); end
end

module Bundler::FileUtils
  def self.cp_lr(src, dest, noop: T.unsafe(nil), verbose: T.unsafe(nil), dereference_root: T.unsafe(nil), remove_destination: T.unsafe(nil)); end

  def self.link_entry(src, dest, dereference_root=T.unsafe(nil), remove_destination=T.unsafe(nil)); end

  def self.ln_sr(src, dest, target_directory: T.unsafe(nil), force: T.unsafe(nil), noop: T.unsafe(nil), verbose: T.unsafe(nil)); end
end

module Bundler::ForcePlatform
end

module Bundler::ForcePlatform
end

class Bundler::GemHelper
  include ::Rake::DSL
  include ::Rake::FileUtilsExt
  include ::FileUtils
  include ::FileUtils::StreamUtils_
end

class Bundler::GemHelpers::PlatformMatch
  def self.specificity_score(spec_platform, user_platform); end
end

module Bundler::GemHelpers
  def self.force_ruby_platform(specs); end

  def self.generic_local_platform_is_ruby?(); end

  def self.local_platform(); end

  def self.same_deps(spec, exemplary_spec); end

  def self.same_specificity(platform, spec, exemplary_spec); end

  def self.sort_best_platform_match(matching, platform); end
end

class Bundler::GemVersionPromoter
  def filter_versions(package, specs); end

  def level(); end

  def level=(value); end

  def major?(); end

  def minor?(); end

  def pre(); end

  def pre=(pre); end

  def pre?(); end

  def sort_versions(package, specs); end

  def strict(); end

  def strict=(strict); end
end

class Bundler::GemVersionPromoter
end

class Bundler::Graph
  def edge_options(); end

  def groups(); end

  def initialize(env, output_file, show_version=T.unsafe(nil), show_requirements=T.unsafe(nil), output_format=T.unsafe(nil), without=T.unsafe(nil)); end

  def node_options(); end

  def output_file(); end

  def output_format(); end

  def relations(); end

  def viz(); end
  GRAPH_NAME = ::T.let(nil, ::T.untyped)
end

class Bundler::Graph::GraphVizClient
  def g(); end

  def initialize(graph_instance); end

  def run(); end
end

class Bundler::Graph::GraphVizClient
end

class Bundler::Graph
end

class Bundler::Index
  include ::Enumerable
  def add(spec); end

  def duplicates(); end

  def merge!(other); end

  def subset?(other); end
end

class Bundler::Injector
  def initialize(deps, options=T.unsafe(nil)); end

  def inject(gemfile_path, lockfile_path); end

  def remove(gemfile_path, lockfile_path); end
  INJECTED_GEMS = ::T.let(nil, ::T.untyped)
end

class Bundler::Injector
  def self.inject(new_deps, options=T.unsafe(nil)); end

  def self.remove(gems, options=T.unsafe(nil)); end
end

class Bundler::InsecureInstallPathError
  def initialize(path); end

  def status_code(); end
end

class Bundler::InsecureInstallPathError
end

class Bundler::Installer
  def definition(); end
end

class Bundler::LazySpecification
  include ::Bundler::ForcePlatform
  def dependencies=(dependencies); end

  def eql?(other); end

  def force_ruby_platform(); end

  def force_ruby_platform!(); end

  def force_ruby_platform=(force_ruby_platform); end

  def lock_name(); end

  def materialize_for_installation(); end

  def name_tuple(); end

  def required_ruby_version(); end

  def required_ruby_version=(required_ruby_version); end

  def required_rubygems_version(); end

  def required_rubygems_version=(required_rubygems_version); end

  def runtime_dependencies(); end
end

class Bundler::LazySpecification
  def self.from_spec(s); end
end

class Bundler::LockfileParser
  def checksums(); end

  def may_include_redundant_platform_specific_gems?(); end
  CHECKSUMS = ::T.let(nil, ::T.untyped)
end

class Bundler::LockfileParser::Position
  def advance!(string); end

  def column(); end

  def initialize(line, column); end

  def line(); end
end

class Bundler::LockfileParser::Position
end

class Bundler::LockfileParser
  def self.bundled_with(); end
end

module Bundler::MatchMetadata
  def matches_current_metadata?(); end

  def matches_current_ruby?(); end

  def matches_current_rubygems?(); end
end

module Bundler::MatchMetadata
end

module Bundler::MatchRemoteMetadata
  include ::Bundler::MatchMetadata
  include ::Bundler::FetchMetadata
end

module Bundler::MatchRemoteMetadata
end

class Bundler::PermissionError
  def parent_folder(); end

  def permission_type(); end
end

module Bundler::Plugin::API::Source
  def ==(other); end

  def add_dependency_names(names); end

  def app_cache_dirname(); end

  def app_cache_path(custom_path=T.unsafe(nil)); end

  def cache(spec, custom_path=T.unsafe(nil)); end

  def cached!(); end

  def can_lock?(spec); end

  def checksum_store(); end

  def dependency_names(); end

  def dependency_names=(dependency_names); end

  def double_check_for(*arg); end

  def eql?(other); end

  def fetch_gemspec_files(); end

  def gem_install_dir(); end

  def hash(); end

  def identifier(); end

  def include?(other); end

  def initialize(opts); end

  def install(spec, opts); end

  def install_path(); end

  def installed?(); end

  def local!(); end

  def name(); end

  def options(); end

  def options_to_lock(); end

  def post_install(spec, disable_exts=T.unsafe(nil)); end

  def remote!(); end

  def root(); end

  def spec_names(); end

  def specs(); end

  def to_lock(); end

  def to_s(); end

  def unlock!(); end

  def unmet_deps(); end

  def uri(); end

  def uri_hash(); end
end

module Bundler::Plugin::API::Source
end

module Bundler::Plugin::Events
  GEM_AFTER_INSTALL = ::T.let(nil, ::T.untyped)
  GEM_AFTER_INSTALL_ALL = ::T.let(nil, ::T.untyped)
  GEM_BEFORE_INSTALL = ::T.let(nil, ::T.untyped)
  GEM_BEFORE_INSTALL_ALL = ::T.let(nil, ::T.untyped)
end

class Bundler::Plugin::Index
  def installed_in_plugin_root?(name); end

  def installed_plugins(); end

  def plugin_commands(plugin); end

  def unregister_plugin(name); end
end

class Bundler::Plugin::Index::CommandConflict
  def initialize(plugin, commands); end
end

class Bundler::Plugin::Index::CommandConflict
end

class Bundler::Plugin::Index::SourceConflict
  def initialize(plugin, sources); end
end

class Bundler::Plugin::Index::SourceConflict
end

class Bundler::Plugin::Installer
  def install(names, options); end

  def install_definition(definition); end
end

class Bundler::Plugin::Installer::Git
  def generate_bin(spec, disable_extensions=T.unsafe(nil)); end
end

class Bundler::Plugin::Installer::Git
end

class Bundler::Plugin::Installer::Path
  def generate_bin(spec, disable_extensions=T.unsafe(nil)); end
end

class Bundler::Plugin::Installer::Path
end

class Bundler::Plugin::Installer::Rubygems
end

class Bundler::Plugin::Installer::Rubygems
end

class Bundler::Plugin::Installer
end

class Bundler::Plugin::PluginInstallError
end

class Bundler::Plugin::PluginInstallError
end

class Bundler::Plugin::SourceList
end

class Bundler::Plugin::SourceList
end

module Bundler::Plugin
  def self.from_lock(locked_opts); end

  def self.list(); end

  def self.loaded?(plugin); end

  def self.save_plugin(name, spec, optional_plugin=T.unsafe(nil)); end

  def self.uninstall(names, options); end
end

class Bundler::ProcessLock
end

class Bundler::ProcessLock
  def self.lock(bundle_path=T.unsafe(nil)); end
end

class Bundler::PubGrub::Incompatibility
  def cause(); end

  def conflict?(); end

  def eql?(other); end

  def external_incompatibilities(); end

  def failure?(); end

  def initialize(terms, cause:, custom_explanation: T.unsafe(nil)); end

  def terms(); end
end

class Bundler::PubGrub::Incompatibility
end

class Bundler::RemoteSpecification
  include ::Bundler::MatchRemoteMetadata
  include ::Bundler::MatchMetadata
  include ::Bundler::FetchMetadata
  def runtime_dependencies(); end
end

class Bundler::Resolver
  include ::Bundler::GemHelpers
  def all_versions_for(package); end

  def bundler_pinned_to_current_version?(); end

  def default_bundler_source(); end

  def find_names_to_relax(incompatibility); end

  def incompatibilities_for(package, version); end

  def no_versions_incompatibility_for(package, unsatisfied_term); end

  def parse_dependency(package, dependency); end

  def raise_not_found!(package); end

  def setup_solver(); end

  def solve_versions(root:, logger:); end

  def source_for(name); end

  def versions_for(package, range=T.unsafe(nil)); end
end

class Bundler::Resolver::Base
  def [](name); end

  def base_requirements(); end

  def delete(specs); end

  def get_package(name); end

  def include_prereleases(names); end

  def initialize(source_requirements, dependencies, base, platforms, options); end

  def packages(); end

  def requirements(); end

  def source_requirements(); end

  def unlock_names(names); end
end

class Bundler::Resolver::Base
end

class Bundler::Resolver::Candidate
  include ::Comparable
  def ==(other); end

  def dependencies(); end

  def eql?(other); end

  def generic!(); end

  def initialize(version, specs: T.unsafe(nil)); end

  def platform_specific!(); end

  def prerelease?(); end

  def segments(); end

  def sort_obj(); end

  def to_specs(package); end

  def version(); end
end

class Bundler::Resolver::Candidate
end

class Bundler::Resolver::Incompatibility
  def extended_explanation(); end

  def initialize(terms, cause:, custom_explanation: T.unsafe(nil), extended_explanation: T.unsafe(nil)); end
end

class Bundler::Resolver::Incompatibility
end

class Bundler::Resolver::Package
  def ==(other); end

  def consider_prereleases!(); end

  def current_platform?(); end

  def dependency(); end

  def force_ruby_platform?(); end

  def ignores_prereleases?(); end

  def initialize(name, platforms, locked_specs:, unlock:, prerelease: T.unsafe(nil), dependency: T.unsafe(nil)); end

  def locked_version(); end

  def meta?(); end

  def name(); end

  def platforms(); end

  def prerelease_specified?(); end

  def root?(); end

  def top_level?(); end

  def unlock?(); end
end

class Bundler::Resolver::Package
end

class Bundler::Resolver::Root
  def initialize(name); end
end

class Bundler::Resolver::Root
end

class Bundler::Resolver::SpecGroup
  def dependencies(); end

  def empty?(); end

  def sorted_spec_names(); end
end

class Bundler::Retry
  def attempt(&block); end

  def attempts(&block); end

  def current_run(); end

  def current_run=(current_run); end

  def initialize(name, exceptions=T.unsafe(nil), retries=T.unsafe(nil)); end

  def name(); end

  def name=(name); end

  def total_runs(); end

  def total_runs=(total_runs); end
end

class Bundler::Retry
  def self.attempts(); end

  def self.default_attempts(); end

  def self.default_retries(); end
end

module Bundler::RubyDsl
  def normalize_ruby_file(filename); end
end

class Bundler::RubygemsIntegration
  def add_default_gems_to(specs); end

  def all_specs(); end

  def default_stubs(); end

  def find_bundler(version); end

  def find_name(name); end

  def plain_specs(); end

  def plain_specs=(specs); end

  def stub_rubygems(specs); end

  def supports_bundler_trampolining?(); end
end

module Bundler::SafeMarshal
  ALLOWED_CLASSES = ::T.let(nil, ::T.untyped)
  ERROR = ::T.let(nil, ::T.untyped)
  PROC = ::T.let(nil, ::T.untyped)
end

module Bundler::SafeMarshal
end

class Bundler::SelfManager
  def install_locked_bundler_and_restart_with_it_if_needed(); end

  def restart_with_locked_bundler_if_needed(); end

  def update_bundler_and_restart_with_it_if_needed(target); end
end

class Bundler::SelfManager
end

class Bundler::Settings
  def processor_count(); end
  REMEMBERED_KEYS = ::T.let(nil, ::T.untyped)
  STRING_KEYS = ::T.let(nil, ::T.untyped)
end

class Bundler::Settings::Mirror
  def ==(other); end

  def fallback_timeout(); end

  def fallback_timeout=(timeout); end

  def initialize(uri=T.unsafe(nil), fallback_timeout=T.unsafe(nil)); end

  def uri(); end

  def uri=(uri); end

  def valid?(); end

  def validate!(probe=T.unsafe(nil)); end
  DEFAULT_FALLBACK_TIMEOUT = ::T.let(nil, ::T.untyped)
end

class Bundler::Settings::Mirror
end

class Bundler::Settings::Mirrors
  def each(&blk); end

  def for(uri); end

  def initialize(prober=T.unsafe(nil)); end

  def parse(key, value); end
end

class Bundler::Settings::Mirrors
end

class Bundler::Settings::Path
  def self.keyword_init?(); end
end

class Bundler::Settings::Validator
end

class Bundler::Settings::Validator::Rule
  def description(); end

  def fail!(key, value, *reasons); end

  def initialize(keys, description, &validate); end

  def k(key); end

  def set(settings, key, value, *reasons); end

  def validate!(key, value, settings); end
end

class Bundler::Settings::Validator::Rule
end

class Bundler::Settings::Validator
  def self.validate!(key, value, settings); end
end

class Bundler::Settings
  def self.key_for(key); end

  def self.key_to_s(key); end
end

module Bundler::SharedHelpers
  def bundle_bin_path(); end

  def checksum_for_file(path, digest); end

  def relative_gemfile_path(); end

  def relative_lockfile_path(); end

  def relative_path_to(destination, from: T.unsafe(nil)); end
end

class Bundler::SolveFailure
  def status_code(); end
end

class Bundler::SolveFailure
end

class Bundler::Source
  def add_dependency_names(names); end

  def cached!(); end

  def checksum_store(); end

  def identifier(); end

  def local!(); end

  def local_only!(); end

  def remote!(); end

  def spec_names(); end
end

class Bundler::Source::Git
  def current_branch(); end

  def glob(); end

  def local?(); end

  def to_gemfile(); end

  def uri_with_specifiers(specifiers); end
end

class Bundler::Source::Rubygems
  def default_cache_path_for(dir); end

  def dependency_api_available?(); end

  def fetch_gem_if_possible(spec, previous_spec=T.unsafe(nil)); end

  def multiple_remotes?(); end

  def no_remotes?(); end

  def package_path(cache_path, spec); end

  def remote_fetchers(); end

  def remote_names(); end

  def remotes=(remotes); end

  def to_gemfile(); end
end

class Bundler::Source::RubygemsAggregate
  def identifier(); end

  def initialize(sources, source_map); end

  def source_map(); end

  def sources(); end

  def specs(); end
end

class Bundler::Source::RubygemsAggregate
end

class Bundler::SourceList
  def add_global_rubygems_remote(uri); end

  def aggregate_global_source?(); end

  def expired_sources?(replacement_sources); end

  def global_path_source(); end

  def implicit_global_source?(); end

  def local!(); end

  def local_mode?(); end

  def local_only!(); end

  def lock_other_sources(); end

  def lock_rubygems_sources(); end

  def merged_gem_lockfile_sections!(replacement_source); end

  def merged_gem_lockfile_sections?(); end

  def non_default_explicit_sources(); end

  def non_global_rubygems_sources(); end
end

class Bundler::SourceMap
  def all_requirements(); end

  def dependencies(); end

  def direct_requirements(); end

  def initialize(sources, dependencies, locked_specs); end

  def locked_requirements(); end

  def locked_specs(); end

  def pinned_spec_names(skip=T.unsafe(nil)); end

  def sources(); end
end

class Bundler::SourceMap
end

class Bundler::SpecSet
  include ::Enumerable
  include ::Bundler::TSort
  def -(other); end

  def add_extra_platforms!(platforms); end

  def complete_platforms!(platforms); end

  def delete(specs); end

  def delete_by_name(name); end

  def incomplete_for_platform?(deps, platform); end

  def incomplete_specs(); end

  def missing_specs(); end

  def names(); end

  def validate_deps(s); end
end

class Bundler::StubSpecification
  def checksum(); end

  def extensions(); end

  def full_gem_path=(path); end

  def gem_build_complete_path(); end

  def manually_installed?(); end
end

module Bundler::TSort
  def each_strongly_connected_component(&block); end

  def each_strongly_connected_component_from(node, id_map=T.unsafe(nil), stack=T.unsafe(nil), &block); end

  def strongly_connected_components(); end

  def tsort(); end

  def tsort_each(&block); end

  def tsort_each_child(node); end

  def tsort_each_node(); end
  VERSION = ::T.let(nil, ::T.untyped)
end

class Bundler::TSort::Cyclic
end

class Bundler::TSort::Cyclic
end

module Bundler::TSort
  def self.each_strongly_connected_component(each_node, each_child); end

  def self.each_strongly_connected_component_from(node, each_child, id_map=T.unsafe(nil), stack=T.unsafe(nil)); end

  def self.strongly_connected_components(each_node, each_child); end

  def self.tsort(each_node, each_child); end

  def self.tsort_each(each_node, each_child); end
end

class Bundler::Thor
  include ::Bundler::Thor::Base
  include ::Bundler::Thor::Invocation
  include ::Bundler::Thor::Shell
  def help(command=T.unsafe(nil), subcommand=T.unsafe(nil)); end
  Correctable = ::T.let(nil, ::T.untyped)
  HELP_MAPPINGS = ::T.let(nil, ::T.untyped)
  TEMPLATE_EXTNAME = ::T.let(nil, ::T.untyped)
  THOR_RESERVED_WORDS = ::T.let(nil, ::T.untyped)
end

module Bundler::Thor::Actions
  def _cleanup_options_and_set(options, key); end

  def _shared_configuration(); end

  def action(instance); end

  def add_file(destination, *args, &block); end

  def add_link(destination, *args); end

  def append_file(path, *args, &block); end

  def append_to_file(path, *args, &block); end

  def apply(path, config=T.unsafe(nil)); end

  def behavior(); end

  def behavior=(behavior); end

  def chmod(path, mode, config=T.unsafe(nil)); end

  def comment_lines(path, flag, *args); end

  def copy_file(source, *args, &block); end

  def create_file(destination, *args, &block); end

  def create_link(destination, *args); end

  def destination_root(); end

  def destination_root=(root); end

  def directory(source, *args, &block); end

  def empty_directory(destination, config=T.unsafe(nil)); end

  def find_in_source_paths(file); end

  def get(source, *args, &block); end

  def gsub_file(path, flag, *args, &block); end

  def in_root(); end

  def initialize(args=T.unsafe(nil), options=T.unsafe(nil), config=T.unsafe(nil)); end

  def inject_into_class(path, klass, *args, &block); end

  def inject_into_file(destination, *args, &block); end

  def inject_into_module(path, module_name, *args, &block); end

  def insert_into_file(destination, *args, &block); end

  def inside(dir=T.unsafe(nil), config=T.unsafe(nil), &block); end

  def link_file(source, *args); end

  def prepend_file(path, *args, &block); end

  def prepend_to_file(path, *args, &block); end

  def relative_to_original_destination_root(path, remove_dot=T.unsafe(nil)); end

  def remove_dir(path, config=T.unsafe(nil)); end

  def remove_file(path, config=T.unsafe(nil)); end

  def run(command, config=T.unsafe(nil)); end

  def run_ruby_script(command, config=T.unsafe(nil)); end

  def source_paths(); end

  def template(source, *args, &block); end

  def thor(command, *args); end

  def uncomment_lines(path, flag, *args); end
  WARNINGS = ::T.let(nil, ::T.untyped)
end

class Bundler::Thor::Actions::CapturableERB
end

class Bundler::Thor::Actions::CapturableERB
end

module Bundler::Thor::Actions::ClassMethods
  def add_runtime_options!(); end

  def source_paths(); end

  def source_paths_for_search(); end

  def source_root(path=T.unsafe(nil)); end
end

module Bundler::Thor::Actions::ClassMethods
end

class Bundler::Thor::Actions::CreateFile
  def data(); end

  def force_on_collision?(); end

  def force_or_skip_or_conflict(force, skip, &block); end

  def identical?(); end

  def initialize(base, destination, data, config=T.unsafe(nil)); end

  def on_conflict_behavior(&block); end

  def render(); end
end

class Bundler::Thor::Actions::CreateFile
end

class Bundler::Thor::Actions::CreateLink
end

class Bundler::Thor::Actions::CreateLink
end

class Bundler::Thor::Actions::Directory
  def execute!(); end

  def file_level_lookup(previous_lookup); end

  def files(lookup); end

  def initialize(base, source, destination=T.unsafe(nil), config=T.unsafe(nil), &block); end

  def source(); end
end

class Bundler::Thor::Actions::Directory
end

class Bundler::Thor::Actions::EmptyDirectory
  def base(); end

  def config(); end

  def convert_encoded_instructions(filename); end

  def destination(); end

  def destination=(destination); end

  def exists?(); end

  def given_destination(); end

  def initialize(base, destination, config=T.unsafe(nil)); end

  def invoke!(); end

  def invoke_with_conflict_check(&block); end

  def on_conflict_behavior(); end

  def on_file_clash_behavior(); end

  def pretend?(); end

  def relative_destination(); end

  def revoke!(); end

  def say_status(status, color); end
end

class Bundler::Thor::Actions::EmptyDirectory
end

class Bundler::Thor::Actions::InjectIntoFile
  def behavior(); end

  def content(); end

  def flag(); end

  def initialize(base, destination, data, config); end

  def replace!(regexp, string, force); end

  def replacement(); end

  def replacement_present?(); end

  def say_status(behavior, warning: T.unsafe(nil), color: T.unsafe(nil)); end
end

class Bundler::Thor::Actions::InjectIntoFile
end

module Bundler::Thor::Actions
  def self.included(base); end
end

class Bundler::Thor::AmbiguousCommandError
end

class Bundler::Thor::AmbiguousCommandError
end

Bundler::Thor::AmbiguousTaskError = Bundler::Thor::AmbiguousCommandError

class Bundler::Thor::Argument
  def banner(); end

  def default(); end

  def default_banner(); end

  def description(); end

  def enum(); end

  def enum_to_s(); end

  def human_name(); end

  def initialize(name, options=T.unsafe(nil)); end

  def name(); end

  def print_default(); end

  def required(); end

  def required?(); end

  def show_default?(); end

  def type(); end

  def usage(); end

  def valid_type?(type); end

  def validate!(); end
  VALID_TYPES = ::T.let(nil, ::T.untyped)
end

class Bundler::Thor::Argument
end

class Bundler::Thor::Arguments
  def initialize(arguments=T.unsafe(nil)); end

  def parse(args); end

  def remaining(); end
  NUMERIC = ::T.let(nil, ::T.untyped)
end

class Bundler::Thor::Arguments
  def self.parse(*args); end

  def self.split(args); end
end

class Bundler::Thor::AtLeastOneRequiredArgumentError
end

class Bundler::Thor::AtLeastOneRequiredArgumentError
end

module Bundler::Thor::Base
  def args(); end

  def args=(args); end

  def initialize(args=T.unsafe(nil), local_options=T.unsafe(nil), config=T.unsafe(nil)); end

  def options(); end

  def options=(options); end

  def parent_options(); end

  def parent_options=(parent_options); end
end

module Bundler::Thor::Base
  def self.included(base); end

  def self.register_klass_file(klass); end

  def self.shell(); end

  def self.shell=(shell); end

  def self.subclass_files(); end

  def self.subclasses(); end
end

class Bundler::Thor::Command
  def formatted_usage(klass, namespace=T.unsafe(nil), subcommand=T.unsafe(nil)); end

  def handle_argument_error?(instance, error, caller); end

  def handle_no_method_error?(instance, error, caller); end

  def hidden?(); end

  def initialize(name, description, long_description, wrap_long_description, usage, options=T.unsafe(nil), options_relation=T.unsafe(nil)); end

  def local_method?(instance, name); end

  def method_at_least_one_option_names(); end

  def method_exclusive_option_names(); end

  def not_debugging?(instance); end

  def private_method?(instance); end

  def public_method?(instance); end

  def required_arguments_for(klass, usage); end

  def required_options(); end

  def run(instance, args=T.unsafe(nil)); end

  def sans_backtrace(backtrace, caller); end
  FILE_REGEXP = ::T.let(nil, ::T.untyped)
end

class Bundler::Thor::Command
end

module Bundler::Thor::CoreExt
end

class Bundler::Thor::CoreExt::HashWithIndifferentAccess
  def [](key); end

  def []=(key, value); end

  def convert_key(key); end

  def delete(key); end

  def except(*keys); end

  def fetch(key, *args); end

  def initialize(hash=T.unsafe(nil)); end

  def key?(key); end

  def merge(other); end

  def merge!(other); end

  def method_missing(method, *args); end

  def replace(other_hash); end

  def reverse_merge(other); end

  def slice(*keys); end

  def values_at(*indices); end
end

class Bundler::Thor::CoreExt::HashWithIndifferentAccess
end

module Bundler::Thor::CoreExt
end

class Bundler::Thor::DynamicCommand
  def initialize(name, options=T.unsafe(nil)); end
end

class Bundler::Thor::DynamicCommand
end

Bundler::Thor::DynamicTask = Bundler::Thor::DynamicCommand

class Bundler::Thor::Error
end

class Bundler::Thor::Error
end

class Bundler::Thor::ExclusiveArgumentError
end

class Bundler::Thor::ExclusiveArgumentError
end

class Bundler::Thor::Group
  include ::Bundler::Thor::Base
  include ::Bundler::Thor::Invocation
  include ::Bundler::Thor::Shell
  def _invoke_for_class_method(klass, command=T.unsafe(nil), *args, &block); end
end

class Bundler::Thor::Group
  def self.banner(); end

  def self.desc(description=T.unsafe(nil)); end

  def self.get_options_from_invocations(group_options, base_options); end

  def self.handle_argument_error(command, error, _args, arity); end

  def self.help(shell); end

  def self.invocation_blocks(); end

  def self.invocations(); end

  def self.invoke(*names, &block); end

  def self.invoke_from_option(*names, &block); end

  def self.printable_commands(*arg); end

  def self.printable_tasks(*arg); end

  def self.remove_invocation(*names); end

  def self.self_command(); end

  def self.self_task(); end
end

class Bundler::Thor::HiddenCommand
end

class Bundler::Thor::HiddenCommand
end

Bundler::Thor::HiddenTask = Bundler::Thor::HiddenCommand

module Bundler::Thor::Invocation
  def _parse_initialization_options(args, opts, config); end

  def _retrieve_class_and_command(name, sent_command=T.unsafe(nil)); end

  def _retrieve_class_and_task(name, sent_command=T.unsafe(nil)); end

  def _shared_configuration(); end

  def current_command_chain(); end

  def initialize(args=T.unsafe(nil), options=T.unsafe(nil), config=T.unsafe(nil), &block); end

  def invoke(name=T.unsafe(nil), *args); end

  def invoke_all(); end

  def invoke_command(command, *args); end

  def invoke_task(command, *args); end

  def invoke_with_padding(*args); end
end

module Bundler::Thor::Invocation
  def self.included(base); end
end

class Bundler::Thor::InvocationError
end

class Bundler::Thor::InvocationError
end

module Bundler::Thor::LineEditor
end

class Bundler::Thor::LineEditor::Basic
  def initialize(prompt, options); end

  def options(); end

  def prompt(); end

  def readline(); end
end

class Bundler::Thor::LineEditor::Basic
  def self.available?(); end
end

class Bundler::Thor::LineEditor::Readline
end

class Bundler::Thor::LineEditor::Readline::PathCompletion
  def initialize(text); end

  def matches(); end
end

class Bundler::Thor::LineEditor::Readline::PathCompletion
end

class Bundler::Thor::LineEditor::Readline
end

module Bundler::Thor::LineEditor
  def self.best_available(); end

  def self.readline(prompt, options=T.unsafe(nil)); end
end

class Bundler::Thor::MalformattedArgumentError
end

class Bundler::Thor::MalformattedArgumentError
end

class Bundler::Thor::NestedContext
  def enter(); end

  def entered?(); end
end

class Bundler::Thor::NestedContext
end

class Bundler::Thor::Option
  def aliases(); end

  def aliases_for_usage(); end

  def array?(); end

  def boolean?(); end

  def dasherize(str); end

  def dasherized?(); end

  def group(); end

  def hash?(); end

  def hide(); end

  def lazy_default(); end

  def numeric?(); end

  def repeatable(); end

  def string?(); end

  def switch_name(); end

  def undasherize(str); end

  def usage(padding=T.unsafe(nil)); end

  def validate_default_type!(); end
  VALID_TYPES = ::T.let(nil, ::T.untyped)
end

class Bundler::Thor::Option
  def self.parse(key, value); end
end

class Bundler::Thor::Options
  def assign_result!(option, result); end

  def check_at_least_one!(); end

  def check_exclusive!(); end

  def check_unknown!(); end

  def current_is_switch?(); end

  def current_is_switch_formatted?(); end

  def initialize(hash_options=T.unsafe(nil), defaults=T.unsafe(nil), stop_on_unknown=T.unsafe(nil), disable_required_check=T.unsafe(nil), relations=T.unsafe(nil)); end

  def names_to_switch_names(names=T.unsafe(nil)); end

  def normalize_switch(arg); end

  def parse_boolean(switch); end

  def parse_peek(switch, option); end

  def parsing_options?(); end

  def switch?(arg); end

  def switch_option(arg); end

  def unshift(arg, is_value: T.unsafe(nil)); end
  EQ_RE = ::T.let(nil, ::T.untyped)
  LONG_RE = ::T.let(nil, ::T.untyped)
  OPTS_END = ::T.let(nil, ::T.untyped)
  SHORT_NUM = ::T.let(nil, ::T.untyped)
  SHORT_RE = ::T.let(nil, ::T.untyped)
  SHORT_SQ_RE = ::T.let(nil, ::T.untyped)
end

class Bundler::Thor::Options
  def self.to_switches(options); end
end

module Bundler::Thor::RakeCompat
  include ::Rake::DSL
  include ::Rake::FileUtilsExt
  include ::FileUtils
  include ::FileUtils::StreamUtils_
end

module Bundler::Thor::RakeCompat
  def self.included(base); end

  def self.rake_classes(); end
end

class Bundler::Thor::RequiredArgumentMissingError
end

class Bundler::Thor::RequiredArgumentMissingError
end

module Bundler::Thor::Sandbox
end

module Bundler::Thor::Sandbox
end

module Bundler::Thor::Shell
  def _shared_configuration(); end

  def ask(*args, &block); end

  def error(*args, &block); end

  def file_collision(*args, &block); end

  def initialize(args=T.unsafe(nil), options=T.unsafe(nil), config=T.unsafe(nil)); end

  def no?(*args, &block); end

  def print_in_columns(*args, &block); end

  def print_table(*args, &block); end

  def print_wrapped(*args, &block); end

  def say(*args, &block); end

  def say_error(*args, &block); end

  def say_status(*args, &block); end

  def set_color(*args, &block); end

  def shell(); end

  def shell=(shell); end

  def terminal_width(*args, &block); end

  def with_padding(); end

  def yes?(*args, &block); end
  SHELL_DELEGATED_METHODS = ::T.let(nil, ::T.untyped)
end

module Bundler::Thor::Shell
end

Bundler::Thor::Task = Bundler::Thor::Command

class Bundler::Thor::UndefinedCommandError
  def all_commands(); end

  def command(); end

  def initialize(command, all_commands, namespace); end
end

class Bundler::Thor::UndefinedCommandError::SpellChecker
  def corrections(); end

  def error(); end

  def initialize(error); end

  def spell_checker(); end
end

class Bundler::Thor::UndefinedCommandError::SpellChecker
end

class Bundler::Thor::UndefinedCommandError
end

Bundler::Thor::UndefinedTaskError = Bundler::Thor::UndefinedCommandError

class Bundler::Thor::UnknownArgumentError
  def initialize(switches, unknown); end

  def switches(); end

  def unknown(); end
end

class Bundler::Thor::UnknownArgumentError::SpellChecker
  def corrections(); end

  def error(); end

  def initialize(error); end

  def spell_checker(); end
end

class Bundler::Thor::UnknownArgumentError::SpellChecker
end

class Bundler::Thor::UnknownArgumentError
end

module Bundler::Thor::Util
end

module Bundler::Thor::Util
  def self.camel_case(str); end

  def self.escape_globs(path); end

  def self.escape_html(string); end

  def self.find_by_namespace(namespace); end

  def self.find_class_and_command_by_namespace(namespace, fallback=T.unsafe(nil)); end

  def self.find_class_and_task_by_namespace(namespace, fallback=T.unsafe(nil)); end

  def self.globs_for(path); end

  def self.load_thorfile(path, content=T.unsafe(nil), debug=T.unsafe(nil)); end

  def self.namespace_from_thor_class(constant); end

  def self.namespaces_in_content(contents, file=T.unsafe(nil)); end

  def self.ruby_command(); end

  def self.snake_case(str); end

  def self.thor_classes_in(klass); end

  def self.thor_root(); end

  def self.thor_root_glob(); end

  def self.user_home(); end
end

class Bundler::Thor
  def self.at_least_one(*args, &block); end

  def self.banner(command, namespace=T.unsafe(nil), subcommand=T.unsafe(nil)); end

  def self.check_unknown_options!(options=T.unsafe(nil)); end

  def self.command_help(shell, command_name); end

  def self.default_command(meth=T.unsafe(nil)); end

  def self.default_task(meth=T.unsafe(nil)); end

  def self.deprecation_warning(message); end

  def self.desc(usage, description, options=T.unsafe(nil)); end

  def self.disable_required_check(); end

  def self.disable_required_check!(*command_names); end

  def self.disable_required_check?(command); end

  def self.dispatch(meth, given_args, given_opts, config); end

  def self.dynamic_command_class(); end

  def self.exclusive(*args, &block); end

  def self.find_command_possibilities(meth); end

  def self.find_task_possibilities(meth); end

  def self.help(shell, subcommand=T.unsafe(nil)); end

  def self.long_desc(long_description, options=T.unsafe(nil)); end

  def self.map(mappings=T.unsafe(nil), **kw); end

  def self.method_at_least_one(*args, &block); end

  def self.method_at_least_one_option_names(); end

  def self.method_exclusive(*args, &block); end

  def self.method_exclusive_option_names(); end

  def self.method_option(name, options=T.unsafe(nil)); end

  def self.method_options(options=T.unsafe(nil)); end

  def self.normalize_command_name(meth); end

  def self.normalize_task_name(meth); end

  def self.option(name, options=T.unsafe(nil)); end

  def self.options(options=T.unsafe(nil)); end

  def self.package_name(name, _=T.unsafe(nil)); end

  def self.print_at_least_one_required_options(shell, command=T.unsafe(nil)); end

  def self.print_exclusive_options(shell, command=T.unsafe(nil)); end

  def self.printable_commands(all=T.unsafe(nil), subcommand=T.unsafe(nil)); end

  def self.printable_tasks(all=T.unsafe(nil), subcommand=T.unsafe(nil)); end

  def self.register(klass, subcommand_name, usage, description, options=T.unsafe(nil)); end

  def self.retrieve_command_name(args); end

  def self.retrieve_task_name(args); end

  def self.sort_commands!(list); end

  def self.stop_on_unknown_option(); end

  def self.stop_on_unknown_option!(*command_names); end

  def self.stop_on_unknown_option?(command); end

  def self.subcommand(subcommand, subcommand_class); end

  def self.subcommand_classes(); end

  def self.subcommand_help(cmd); end

  def self.subcommands(); end

  def self.subtask(subcommand, subcommand_class); end

  def self.subtask_help(cmd); end

  def self.subtasks(); end

  def self.task_help(shell, command_name); end
end

class Bundler::UI::Shell
  def add_color(string, *color); end

  def ask(msg); end

  def confirm(msg=T.unsafe(nil), newline=T.unsafe(nil)); end

  def confirm?(); end

  def debug(msg=T.unsafe(nil), newline=T.unsafe(nil)); end

  def debug?(); end

  def error(msg=T.unsafe(nil), newline=T.unsafe(nil), color=T.unsafe(nil)); end

  def error?(); end

  def info(msg=T.unsafe(nil), newline=T.unsafe(nil)); end

  def info?(); end

  def initialize(options=T.unsafe(nil)); end

  def level(name=T.unsafe(nil)); end

  def level=(level); end

  def no?(); end

  def quiet?(); end

  def shell=(shell); end

  def silence(&blk); end

  def trace(e, newline=T.unsafe(nil), force=T.unsafe(nil)); end

  def unprinted_warnings(); end

  def warn(msg=T.unsafe(nil), newline=T.unsafe(nil), color=T.unsafe(nil)); end

  def warn?(); end

  def yes?(msg); end
  LEVELS = ::T.let(nil, ::T.untyped)
end

class Bundler::UI::Shell
end

class Bundler::UI::Silent
  def confirm?(); end

  def error?(); end

  def info?(); end

  def warn?(); end
end

module Bundler::URINormalizer
end

module Bundler::URINormalizer
  def self.normalize_suffix(uri, trailing_slash: T.unsafe(nil)); end
end

module Bundler
  def self.auto_install(); end

  def self.configure_gem_home_and_path(path=T.unsafe(nil)); end

  def self.create_bundle_path(); end

  def self.gem_version(); end

  def self.most_specific_locked_platform?(platform); end

  def self.original_exec(*args); end

  def self.original_system(*args); end

  def self.preferred_gemfile_name(); end

  def self.reset_settings_and_root!(); end

  def self.safe_load_marshal(data); end

  def self.self_manager(); end

  def self.unbundled_env(); end

  def self.unbundled_exec(*args); end

  def self.unbundled_system(*args); end
end

class CGI
  VERSION = ::T.let(nil, ::T.untyped)
end

class CGI::Cookie
  DOMAIN_VALUE_RE = ::T.let(nil, ::T.untyped)
  PATH_VALUE_RE = ::T.let(nil, ::T.untyped)
  TOKEN_RE = ::T.let(nil, ::T.untyped)
end

module CGI::Escape
  def escapeURIComponent(arg); end

  def escape_uri_component(arg); end

  def unescape_uri_component(*arg); end
end

module CGI::HtmlExtension
  def a(href=T.unsafe(nil)); end

  def base(href=T.unsafe(nil)); end

  def blockquote(cite=T.unsafe(nil)); end

  def caption(align=T.unsafe(nil)); end

  def checkbox(name=T.unsafe(nil), value=T.unsafe(nil), checked=T.unsafe(nil)); end

  def checkbox_group(name=T.unsafe(nil), *values); end

  def file_field(name=T.unsafe(nil), size=T.unsafe(nil), maxlength=T.unsafe(nil)); end

  def form(method=T.unsafe(nil), action=T.unsafe(nil), enctype=T.unsafe(nil)); end

  def hidden(name=T.unsafe(nil), value=T.unsafe(nil)); end

  def html(attributes=T.unsafe(nil)); end

  def image_button(src=T.unsafe(nil), name=T.unsafe(nil), alt=T.unsafe(nil)); end

  def img(src=T.unsafe(nil), alt=T.unsafe(nil), width=T.unsafe(nil), height=T.unsafe(nil)); end

  def multipart_form(action=T.unsafe(nil), enctype=T.unsafe(nil)); end

  def password_field(name=T.unsafe(nil), value=T.unsafe(nil), size=T.unsafe(nil), maxlength=T.unsafe(nil)); end

  def popup_menu(name=T.unsafe(nil), *values); end

  def radio_button(name=T.unsafe(nil), value=T.unsafe(nil), checked=T.unsafe(nil)); end

  def radio_group(name=T.unsafe(nil), *values); end

  def reset(value=T.unsafe(nil), name=T.unsafe(nil)); end

  def scrolling_list(name=T.unsafe(nil), *values); end

  def submit(value=T.unsafe(nil), name=T.unsafe(nil)); end

  def text_field(name=T.unsafe(nil), value=T.unsafe(nil), size=T.unsafe(nil), maxlength=T.unsafe(nil)); end

  def textarea(name=T.unsafe(nil), cols=T.unsafe(nil), rows=T.unsafe(nil)); end
end

module CGI::HtmlExtension
end

module CGI::Util
  def escapeURIComponent(arg); end

  def escape_uri_component(arg); end

  def unescape_uri_component(*arg); end
end

class CSV
  def close(*args, **arg, &block); end

  def close_read(*args, **arg, &block); end

  def close_write(*args, **arg, &block); end

  def closed?(*args, **arg, &block); end

  def external_encoding(*args, **arg, &block); end

  def fcntl(*args, **arg, &block); end

  def fileno(*args, **arg, &block); end

  def flush(*args, **arg, &block); end

  def fsync(*args, **arg, &block); end

  def internal_encoding(*args, **arg, &block); end

  def isatty(*args, **arg, &block); end

  def pid(*args, **arg, &block); end

  def pos(*args, **arg, &block); end

  def pos=(*args, **arg, &block); end

  def reopen(*args, **arg, &block); end

  def seek(*args, **arg, &block); end

  def string(*args, **arg, &block); end

  def sync(*args, **arg, &block); end

  def sync=(*args, **arg, &block); end

  def tell(*args, **arg, &block); end

  def truncate(*args, **arg, &block); end

  def tty?(*args, **arg, &block); end
end

class CSV::FieldInfo
  def header(); end

  def header=(_); end

  def index(); end

  def index=(_); end

  def line(); end

  def line=(_); end

  def quoted?(); end
end

class CSV::FieldInfo
  def self.[](*arg); end

  def self.keyword_init?(); end

  def self.members(); end
end

class CSV::Row
  def empty?(*args, **arg, &block); end

  def length(*args, **arg, &block); end

  def size(*args, **arg, &block); end

  def to_ary(*arg); end
end

module Capybara::DSL
  include ::Capybara::DSLRSpecProxyInstaller
end

module Capybara::DSLRSpecProxyInstaller
end

module Capybara::DSLRSpecProxyInstaller
  def self.prepended(base); end
end

module Capybara::RSpecMatcherProxies
  def all(*args, **kwargs, &block); end

  def within(*args, **kwargs, &block); end
end

module Capybara::RSpecMatcherProxies
end

module Capybara::RSpecMatcherProxyInstaller
end

module Capybara::RSpecMatcherProxyInstaller::ClassMethods
  def included(base); end
end

module Capybara::RSpecMatcherProxyInstaller::ClassMethods
end

module Capybara::RSpecMatcherProxyInstaller
  def self.prepended(base); end
end

module Capybara::RSpecMatchers
  def become_closed(**options); end

  def have_all_of_selectors(*arg, **arg1, &arg2); end

  def have_ancestor(*arg, **arg1, &arg2); end

  def have_any_of_selectors(*arg, **arg1, &arg2); end

  def have_button(locator=T.unsafe(nil), **options, &optional_filter_block); end

  def have_checked_field(locator=T.unsafe(nil), **options, &optional_filter_block); end

  def have_content(text_or_type, *args, **options); end

  def have_css(expr, **options, &optional_filter_block); end

  def have_current_path(path, **options, &optional_filter_block); end

  def have_element(locator=T.unsafe(nil), **options, &optional_filter_block); end

  def have_field(locator=T.unsafe(nil), **options, &optional_filter_block); end

  def have_link(locator=T.unsafe(nil), **options, &optional_filter_block); end

  def have_no_ancestor(*args, **kw_args, &optional_filter_block); end

  def have_no_button(*args, **kw_args, &optional_filter_block); end

  def have_no_checked_field(*args, **kw_args, &optional_filter_block); end

  def have_no_content(*args, **kw_args, &optional_filter_block); end

  def have_no_css(*args, **kw_args, &optional_filter_block); end

  def have_no_current_path(*args, **kw_args, &optional_filter_block); end

  def have_no_element(*args, **kw_args, &optional_filter_block); end

  def have_no_field(*args, **kw_args, &optional_filter_block); end

  def have_no_link(*args, **kw_args, &optional_filter_block); end

  def have_no_select(*args, **kw_args, &optional_filter_block); end

  def have_no_selector(*args, **kw_args, &optional_filter_block); end

  def have_no_sibling(*args, **kw_args, &optional_filter_block); end

  def have_no_table(*args, **kw_args, &optional_filter_block); end

  def have_no_text(*args, **kw_args, &optional_filter_block); end

  def have_no_title(*args, **kw_args, &optional_filter_block); end

  def have_no_unchecked_field(*args, **kw_args, &optional_filter_block); end

  def have_no_xpath(*args, **kw_args, &optional_filter_block); end

  def have_none_of_selectors(*arg, **arg1, &arg2); end

  def have_select(locator=T.unsafe(nil), **options, &optional_filter_block); end

  def have_selector(*arg, **arg1, &arg2); end

  def have_sibling(*arg, **arg1, &arg2); end

  def have_style(styles=T.unsafe(nil), **options); end

  def have_table(locator=T.unsafe(nil), **options, &optional_filter_block); end

  def have_text(text_or_type, *args, **options); end

  def have_title(title, **options); end

  def have_unchecked_field(locator=T.unsafe(nil), **options, &optional_filter_block); end

  def have_xpath(expr, **options, &optional_filter_block); end

  def match_css(expr, **options, &optional_filter_block); end

  def match_selector(*arg, **arg1, &arg2); end

  def match_style(styles=T.unsafe(nil), **options); end

  def match_xpath(expr, **options, &optional_filter_block); end

  def not_match_css(*args, **kw_args, &optional_filter_block); end

  def not_match_selector(*args, **kw_args, &optional_filter_block); end

  def not_match_xpath(*args, **kw_args, &optional_filter_block); end
end

module Capybara::RSpecMatchers::CountSugar
  def at_least(number); end

  def at_most(number); end

  def exactly(number); end

  def once(); end

  def thrice(); end

  def times(); end

  def twice(); end
end

module Capybara::RSpecMatchers::CountSugar
end

module Capybara::RSpecMatchers::Matchers
end

class Capybara::RSpecMatchers::Matchers::Base
  include ::Capybara::RSpecMatchers::Matchers::Compound
  include ::RSpec::Matchers::Composable
  def failure_message(); end

  def failure_message_when_negated(); end

  def initialize(*args, **kw_args, &filter_block); end
end

class Capybara::RSpecMatchers::Matchers::Base
end

class Capybara::RSpecMatchers::Matchers::BecomeClosed
  def failure_message(); end

  def failure_message_when_negated(); end

  def initialize(options); end

  def matches?(window); end
end

class Capybara::RSpecMatchers::Matchers::BecomeClosed
end

module Capybara::RSpecMatchers::Matchers::Compound
  include ::RSpec::Matchers::Composable
  def and(matcher); end

  def and_then(matcher); end

  def or(matcher); end
end

class Capybara::RSpecMatchers::Matchers::Compound::And
  include ::Capybara::RSpecMatchers::Matchers::Compound::Synchronizer
end

class Capybara::RSpecMatchers::Matchers::Compound::And
end

class Capybara::RSpecMatchers::Matchers::Compound::CapybaraEvaluator
  def initialize(actual); end

  def matcher_matches?(matcher); end

  def reset(); end
end

class Capybara::RSpecMatchers::Matchers::Compound::CapybaraEvaluator
end

class Capybara::RSpecMatchers::Matchers::Compound::Or
  include ::Capybara::RSpecMatchers::Matchers::Compound::Synchronizer
end

class Capybara::RSpecMatchers::Matchers::Compound::Or
end

module Capybara::RSpecMatchers::Matchers::Compound::Synchronizer
  def match(_expected, actual); end

  def sync_element(el); end
end

module Capybara::RSpecMatchers::Matchers::Compound::Synchronizer
end

module Capybara::RSpecMatchers::Matchers::Compound
end

class Capybara::RSpecMatchers::Matchers::CountableWrappedElementMatcher
  include ::Capybara::RSpecMatchers::CountSugar
  include ::Capybara::RSpecMatchers::SpatialSugar
end

class Capybara::RSpecMatchers::Matchers::CountableWrappedElementMatcher
end

class Capybara::RSpecMatchers::Matchers::HaveAllSelectors
  def description(); end

  def does_not_match?(_actual); end

  def element_matches?(el); end
end

class Capybara::RSpecMatchers::Matchers::HaveAllSelectors
end

class Capybara::RSpecMatchers::Matchers::HaveAncestor
  def description(); end

  def element_does_not_match?(el); end

  def element_matches?(el); end

  def query(); end
end

class Capybara::RSpecMatchers::Matchers::HaveAncestor
end

class Capybara::RSpecMatchers::Matchers::HaveAnySelectors
  def description(); end

  def does_not_match?(el); end

  def element_matches?(el); end
end

class Capybara::RSpecMatchers::Matchers::HaveAnySelectors
end

class Capybara::RSpecMatchers::Matchers::HaveCurrentPath
  def description(); end

  def element_does_not_match?(el); end

  def element_matches?(el); end
end

class Capybara::RSpecMatchers::Matchers::HaveCurrentPath
end

class Capybara::RSpecMatchers::Matchers::HaveNoSelectors
  def description(); end

  def does_not_match?(_actual); end

  def element_matches?(el); end
end

class Capybara::RSpecMatchers::Matchers::HaveNoSelectors
end

class Capybara::RSpecMatchers::Matchers::HaveSelector
  def description(); end

  def element_does_not_match?(el); end

  def element_matches?(el); end

  def query(); end
end

class Capybara::RSpecMatchers::Matchers::HaveSelector
end

class Capybara::RSpecMatchers::Matchers::HaveSibling
  def description(); end

  def element_does_not_match?(el); end

  def element_matches?(el); end

  def query(); end
end

class Capybara::RSpecMatchers::Matchers::HaveSibling
end

class Capybara::RSpecMatchers::Matchers::HaveStyle
  def initialize(*args, **kw_args, &filter_block); end
end

class Capybara::RSpecMatchers::Matchers::HaveStyle
end

class Capybara::RSpecMatchers::Matchers::HaveText
  def description(); end

  def element_does_not_match?(el); end

  def element_matches?(el); end

  def format(content); end
end

class Capybara::RSpecMatchers::Matchers::HaveText
end

class Capybara::RSpecMatchers::Matchers::HaveTitle
  def description(); end

  def element_does_not_match?(el); end

  def element_matches?(el); end
end

class Capybara::RSpecMatchers::Matchers::HaveTitle
end

class Capybara::RSpecMatchers::Matchers::MatchSelector
end

class Capybara::RSpecMatchers::Matchers::MatchSelector
end

class Capybara::RSpecMatchers::Matchers::MatchStyle
  def description(); end

  def does_not_match?(_actual); end

  def element_matches?(el); end

  def initialize(styles=T.unsafe(nil), **kw_args, &filter_block); end
end

class Capybara::RSpecMatchers::Matchers::MatchStyle
end

class Capybara::RSpecMatchers::Matchers::NegatedMatcher
  include ::Capybara::RSpecMatchers::Matchers::Compound
  include ::RSpec::Matchers::Composable
  def description(); end

  def does_not_match?(actual, &filter_block); end

  def failure_message(); end

  def failure_message_when_negated(); end

  def initialize(matcher); end

  def matches?(actual, &filter_block); end
end

class Capybara::RSpecMatchers::Matchers::NegatedMatcher
end

class Capybara::RSpecMatchers::Matchers::WrappedElementMatcher
  def does_not_match?(actual, &filter_block); end

  def matches?(actual, &filter_block); end
end

class Capybara::RSpecMatchers::Matchers::WrappedElementMatcher
end

module Capybara::RSpecMatchers::Matchers
end

module Capybara::RSpecMatchers::SpatialSugar
  def above(el); end

  def below(el); end

  def left_of(el); end

  def near(el); end

  def right_of(el); end
end

module Capybara::RSpecMatchers::SpatialSugar
end

module Capybara::RSpecMatchers
end

class Capybara::ReadOnlySessionConfig
  RUBYGEMS_ACTIVATION_MONITOR = ::T.let(nil, ::T.untyped)
end

class Capybara::Selector
  RUBYGEMS_ACTIVATION_MONITOR = ::T.let(nil, ::T.untyped)
end

module Capybara
  extend ::Capybara::DSLRSpecProxyInstaller
end

module CarrierWave::ActiveRecord
  include ::CarrierWave::Mount
end

module CarrierWave::ActiveRecord
end

module CarrierWave::Validations
end

module CarrierWave::Validations::ActiveModel
end

class CarrierWave::Validations::ActiveModel::DownloadValidator
end

class CarrierWave::Validations::ActiveModel::DownloadValidator
end

module CarrierWave::Validations::ActiveModel::HelperMethods
  def validates_download_of(*attr_names); end

  def validates_integrity_of(*attr_names); end

  def validates_processing_of(*attr_names); end
end

module CarrierWave::Validations::ActiveModel::HelperMethods
end

class CarrierWave::Validations::ActiveModel::IntegrityValidator
end

class CarrierWave::Validations::ActiveModel::IntegrityValidator
end

class CarrierWave::Validations::ActiveModel::ProcessingValidator
end

class CarrierWave::Validations::ActiveModel::ProcessingValidator
end

module CarrierWave::Validations::ActiveModel
  extend ::ActiveSupport::Concern
end

module CarrierWave::Validations
end

class Class
  def any_instance(); end
end

class CleanupWorker
  def sidekiq_options_hash(); end

  def sidekiq_options_hash=(sidekiq_options_hash); end

  def sidekiq_retries_exhausted_block(); end

  def sidekiq_retries_exhausted_block=(sidekiq_retries_exhausted_block); end

  def sidekiq_retry_in_block(); end

  def sidekiq_retry_in_block=(sidekiq_retry_in_block); end
end

class CleanupWorker
  def self.sidekiq_options_hash(); end

  def self.sidekiq_options_hash=(val); end

  def self.sidekiq_retries_exhausted_block(); end

  def self.sidekiq_retries_exhausted_block=(val); end

  def self.sidekiq_retry_in_block(); end

  def self.sidekiq_retry_in_block=(val); end
end

class Concurrent::SerializedExecutionDelegator
  RUBYGEMS_ACTIVATION_MONITOR = ::T.let(nil, ::T.untyped)
end

class Concurrent::SynchronizedDelegator
  RUBYGEMS_ACTIVATION_MONITOR = ::T.let(nil, ::T.untyped)
end

module Coverage
  def self.resume(); end

  def self.setup(*arg); end

  def self.state(); end

  def self.supported?(arg); end

  def self.suspend(); end
end

module Crack
  VERSION = ::T.let(nil, ::T.untyped)
end

class Crack::JSON
  DATE_REGEX = ::T.let(nil, ::T.untyped)
end

class Crack::JSON
  def self.convert_json_to_yaml(json); end

  def self.format_dates(output, date_starts, date_ends); end

  def self.parse(json); end

  def self.parser_exceptions(); end

  def self.unescape(str); end
end

class Crack::ParseError
end

class Crack::ParseError
end

module Crack::Util
  def snake_case(str); end

  def to_xml_attributes(hash); end
end

module Crack::Util
  extend ::Crack::Util
end

class CronWorker
  def sidekiq_options_hash(); end

  def sidekiq_options_hash=(sidekiq_options_hash); end

  def sidekiq_retries_exhausted_block(); end

  def sidekiq_retries_exhausted_block=(sidekiq_retries_exhausted_block); end

  def sidekiq_retry_in_block(); end

  def sidekiq_retry_in_block=(sidekiq_retry_in_block); end
end

class CronWorker
  def self.__synchronized_sidekiq_options_hash(); end

  def self.sidekiq_options_hash(); end

  def self.sidekiq_options_hash=(val); end

  def self.sidekiq_retries_exhausted_block(); end

  def self.sidekiq_retries_exhausted_block=(val); end

  def self.sidekiq_retry_in_block(); end

  def self.sidekiq_retry_in_block=(val); end
end

class Cucumber::Core::Test::DocString
  RUBYGEMS_ACTIVATION_MONITOR = ::T.let(nil, ::T.untyped)
end

class Cucumber::MultilineArgument::DocString
  RUBYGEMS_ACTIVATION_MONITOR = ::T.let(nil, ::T.untyped)
end

module Cucumber::Rails
end

module Cucumber::Rails::ActionDispatch
end

module Cucumber::Rails::ActionDispatch::ShowExceptions
  def call(env); end
end

module Cucumber::Rails::ActionDispatch::ShowExceptions
end

module Cucumber::Rails::ActionDispatch
end

module Cucumber::Rails::Application
  def initialize!(); end
end

module Cucumber::Rails::Application
end

class Cucumber::Rails::World
  include ::Rack::Test::Methods
  def initialize(); end
end

class Cucumber::Rails::World
end

module Cucumber::Rails
  def self.include_rack_test_helpers?(); end
end

class Cucumber::RunningTestCase::TestCase
  RUBYGEMS_ACTIVATION_MONITOR = ::T.let(nil, ::T.untyped)
end

class Cucumber::StepMatchSearch::CachesStepMatch
  RUBYGEMS_ACTIVATION_MONITOR = ::T.let(nil, ::T.untyped)
end

class Date
  def compare_without_coercion(arg); end

  def deconstruct_keys(arg); end

  def default_inspect(); end

  def minus_without_duration(arg); end

  def plus_without_duration(arg); end
end

class Date
  def self._parse_without_american_date(*arg); end

  def self.parse_without_american_date(*arg); end

  def self.today_without_delorean(*arg); end
end

class DateTime
  def self.new(*arg); end

  def self.now_without_delorean(*arg); end
end

class Delegator
  RUBYGEMS_ACTIVATION_MONITOR = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

class Devise::ConfirmationsController
  def after_confirmation_path_for(resource_name, resource); end

  def after_resending_confirmation_instructions_path_for(resource_name); end
end

module Devise::Controllers::Helpers
  def authenticate_user!(opts=T.unsafe(nil)); end

  def current_user(); end

  def user_session(); end

  def user_signed_in?(); end
end

class Devise::PasswordsController
  def after_resetting_password_path_for(resource); end

  def after_sending_reset_password_instructions_path_for(resource_name); end

  def assert_reset_token_passed(); end

  def unlockable?(resource); end
end

class Devise::RegistrationsController
  def account_update_params(); end

  def after_inactive_sign_up_path_for(resource); end

  def after_sign_up_path_for(resource); end

  def after_update_path_for(resource); end

  def authenticate_scope!(); end

  def build_resource(hash=T.unsafe(nil)); end

  def sign_up(resource_name, resource); end

  def sign_up_params(); end

  def update_needs_confirmation?(resource, previous); end

  def update_resource(resource, params); end
end

class Devise::SessionsController
  def auth_options(); end

  def serialize_options(resource); end
end

class DeviseController
  include ::Devise::Controllers::ScopedViews
  def assert_is_devise_resource!(); end

  def clean_up_passwords(object); end

  def devise_i18n_options(options); end

  def find_message(kind, options=T.unsafe(nil)); end

  def require_no_authentication(); end

  def resource=(new_resource); end

  def respond_with_navigational(*args, &block); end

  def set_flash_message(key, kind, options=T.unsafe(nil)); end

  def set_flash_message!(key, kind, options=T.unsafe(nil)); end

  def set_minimum_password_length(); end

  def successfully_sent?(resource); end

  def unknown_action!(msg); end
end

class DidYouMean::ClassNameChecker
  def class_name(); end

  def class_names(); end

  def corrections(); end

  def initialize(exception); end

  def scopes(); end
end

module DidYouMean::Correctable
  def corrections(); end

  def detailed_message(highlight: T.unsafe(nil), did_you_mean: T.unsafe(nil), **arg); end

  def original_message(); end

  def spell_checker(); end
end

class DidYouMean::Formatter
  def message_for(corrections); end
end

class DidYouMean::Formatter
  def self.message_for(corrections); end
end

module DidYouMean::Jaro
  def self.distance(str1, str2); end
end

module DidYouMean::JaroWinkler
  def self.distance(str1, str2); end
end

class DidYouMean::KeyErrorChecker
  def corrections(); end

  def initialize(key_error); end
end

class DidYouMean::KeyErrorChecker
end

module DidYouMean::Levenshtein
  def self.distance(str1, str2); end

  def self.min3(a, b, c); end
end

class DidYouMean::MethodNameChecker
  def corrections(); end

  def initialize(exception); end

  def method_name(); end

  def method_names(); end

  def names_to_exclude(); end

  def receiver(); end
  RB_RESERVED_WORDS = ::T.let(nil, ::T.untyped)
end

class DidYouMean::NullChecker
  def corrections(); end

  def initialize(*arg); end
end

class DidYouMean::PatternKeyNameChecker
  def corrections(); end

  def initialize(no_matching_pattern_key_error); end
end

class DidYouMean::PatternKeyNameChecker
end

DidYouMean::PlainFormatter = DidYouMean::Formatter

class DidYouMean::RequirePathChecker
  def corrections(); end

  def initialize(exception); end

  def path(); end
end

class DidYouMean::RequirePathChecker
  def self.requireables(); end
end

class DidYouMean::TreeSpellChecker
  def augment(); end

  def correct(input); end

  def dictionary(); end

  def dictionary_without_leaves(); end

  def dimensions(); end

  def find_leaves(path); end

  def initialize(dictionary:, separator: T.unsafe(nil), augment: T.unsafe(nil)); end

  def plausible_dimensions(input); end

  def possible_paths(states); end

  def separator(); end

  def tree_depth(); end
end

class DidYouMean::TreeSpellChecker
end

class DidYouMean::VariableNameChecker
  def corrections(); end

  def cvar_names(); end

  def initialize(exception); end

  def ivar_names(); end

  def lvar_names(); end

  def method_names(); end

  def name(); end
  RB_RESERVED_WORDS = ::T.let(nil, ::T.untyped)
end

module DidYouMean
  def self.correct_error(error_class, spell_checker); end

  def self.formatter(); end

  def self.formatter=(formatter); end

  def self.spell_checkers(); end
end

module Digest
  VERSION = ::T.let(nil, ::T.untyped)
end

class Dir
  def chdir(); end

  def children(); end

  def each_child(); end
end

module Dir::Tmpname
  UNUSABLE_CHARS = ::T.let(nil, ::T.untyped)
end

class Dir
  def self.fchdir(arg); end

  def self.for_fd(arg); end
end

class DisableMitigationsWorker
  def sidekiq_options_hash(); end

  def sidekiq_options_hash=(sidekiq_options_hash); end

  def sidekiq_retries_exhausted_block(); end

  def sidekiq_retries_exhausted_block=(sidekiq_retries_exhausted_block); end

  def sidekiq_retry_in_block(); end

  def sidekiq_retry_in_block=(sidekiq_retry_in_block); end
end

class DisableMitigationsWorker
  def self.__synchronized_sidekiq_options_hash(); end

  def self.sidekiq_options_hash(); end

  def self.sidekiq_options_hash=(val); end

  def self.sidekiq_retries_exhausted_block(); end

  def self.sidekiq_retries_exhausted_block=(val); end

  def self.sidekiq_retry_in_block(); end

  def self.sidekiq_retry_in_block=(val); end
end

module Docile
  VERSION = ::T.let(nil, ::T.untyped)
end

module Docile::BacktraceFilter
  def backtrace(); end

  def backtrace_locations(); end
  FILTER_PATTERN = ::T.let(nil, ::T.untyped)
end

module Docile::BacktraceFilter
end

class Docile::ChainingFallbackContextProxy
end

class Docile::ChainingFallbackContextProxy
end

module Docile::Execution
end

module Docile::Execution
  def self.exec_in_proxy_context(dsl, proxy_type, *args, **arg, &block); end
end

class Docile::FallbackContextProxy
  def initialize(receiver, fallback); end

  def method_missing(method, *args, **arg, &block); end
  NON_FALLBACK_METHODS = ::T.let(nil, ::T.untyped)
  NON_PROXIED_INSTANCE_VARIABLES = ::T.let(nil, ::T.untyped)
  NON_PROXIED_METHODS = ::T.let(nil, ::T.untyped)
end

class Docile::FallbackContextProxy
end

module Docile
  extend ::Docile::Execution
  def self.dsl_eval(dsl, *args, **arg, &block); end

  def self.dsl_eval_immutable(dsl, *args, **arg, &block); end

  def self.dsl_eval_with_block_return(dsl, *args, **arg, &block); end
end

class ERB
  def def_method(mod, methodname, fname=T.unsafe(nil)); end

  def def_module(methodname=T.unsafe(nil)); end
end

class ERB::Compiler::Scanner
  DEFAULT_ETAGS = ::T.let(nil, ::T.untyped)
  DEFAULT_STAGS = ::T.let(nil, ::T.untyped)
end

module ERB::Util
  include ::ERB::Escape
end

class Encoding
  def _dump(*arg); end
end

class Encoding::Converter
  def initialize(*arg); end
  LF_NEWLINE_DECORATOR = ::T.let(nil, ::T.untyped)
end

class Encoding
  def self._load(arg); end
end

module Enumerable
  def compact(); end
end

class Enumerator
  def +(arg); end

  def each_with_index(); end
end

class Enumerator::ArithmeticSequence
  def begin(); end

  def each(&blk); end

  def end(); end

  def exclude_end?(); end

  def last(*arg); end

  def step(); end
end

class Enumerator::ArithmeticSequence
end

class Enumerator::Generator
  def each(*arg, &blk); end

  def initialize(*arg); end
end

class Enumerator::Producer
  def each(&blk); end
end

class Enumerator::Producer
end

class Enumerator::Product
  def each(&blk); end
end

class Enumerator::Product
end

class Enumerator
  def self.product(*arg); end
end

Errno::EAUTH = Errno::NOERROR

Errno::EBADARCH = Errno::NOERROR

Errno::EBADEXEC = Errno::NOERROR

Errno::EBADMACHO = Errno::NOERROR

Errno::EBADRPC = Errno::NOERROR

Errno::ECAPMODE = Errno::NOERROR

Errno::EDEADLOCK = Errno::EDEADLK

Errno::EDEVERR = Errno::NOERROR

Errno::EDOOFUS = Errno::NOERROR

Errno::EFTYPE = Errno::NOERROR

Errno::EIPSEC = Errno::NOERROR

Errno::ELAST = Errno::NOERROR

Errno::ENEEDAUTH = Errno::NOERROR

Errno::ENOATTR = Errno::NOERROR

Errno::ENOPOLICY = Errno::NOERROR

Errno::ENOTCAPABLE = Errno::NOERROR

class Errno::ENOTSUP
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::ENOTSUP
end

Errno::EPROCLIM = Errno::NOERROR

Errno::EPROCUNAVAIL = Errno::NOERROR

Errno::EPROGMISMATCH = Errno::NOERROR

Errno::EPROGUNAVAIL = Errno::NOERROR

Errno::EPWROFF = Errno::NOERROR

Errno::EQFULL = Errno::NOERROR

Errno::ERPCMISMATCH = Errno::NOERROR

Errno::ESHLIBVERS = Errno::NOERROR

module ErrorHighlight::CoreExt
  def detailed_message(highlight: T.unsafe(nil), error_highlight: T.unsafe(nil), **arg); end
end

module Etc
  VERSION = ::T.let(nil, ::T.untyped)
end

class Etc::Group
  def gid=(_); end

  def mem=(_); end

  def name=(_); end

  def passwd=(_); end
end

class Etc::Group
  extend ::Enumerable
  def self.[](*arg); end

  def self.each(&blk); end

  def self.keyword_init?(); end

  def self.members(); end
end

class Etc::Passwd
  def dir=(_); end

  def gecos(); end

  def gecos=(_); end

  def gid=(_); end

  def name=(_); end

  def passwd=(_); end

  def shell=(_); end

  def uid=(_); end
end

class Etc::Passwd
  extend ::Enumerable
  def self.[](*arg); end

  def self.each(&blk); end

  def self.keyword_init?(); end

  def self.members(); end
end

class Etf2lProfile
  extend ::T::Private::Methods::MethodHooks
  extend ::T::Private::Methods::SingletonMethodHooks
end

module Exception2MessageMapper
  def bind(cl); end
end

Exception2MessageMapper::E2MM = Exception2MessageMapper

class Exception2MessageMapper::ErrNotRegisteredException
end

class Exception2MessageMapper::ErrNotRegisteredException
end

module Exception2MessageMapper
  def self.Fail(klass=T.unsafe(nil), err=T.unsafe(nil), *rest); end

  def self.Raise(klass=T.unsafe(nil), err=T.unsafe(nil), *rest); end

  def self.def_e2message(k, c, m); end

  def self.def_exception(k, n, m, s=T.unsafe(nil)); end

  def self.e2mm_message(klass, exp); end

  def self.extend_object(cl); end

  def self.message(klass, exp); end
end

class ExitCalledError
end

class Faraday::RackBuilder
  extend ::VCR::LibraryHooks::Faraday::BuilderClassExtension
end

module Fcntl
  F_GETPIPE_SZ = ::T.let(nil, ::T.untyped)
  F_SETPIPE_SZ = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

class Fiber
  def active_support_execution_state(); end

  def active_support_execution_state=(active_support_execution_state); end

  def backtrace(*arg); end

  def backtrace_locations(*arg); end

  def blocking?(); end

  def kill(); end

  def storage(); end

  def storage=(storage); end

  def transfer(*arg); end
end

class Fiber
  def self.blocking(); end

  def self.blocking?(); end

  def self.current(); end

  def self.current_scheduler(); end

  def self.schedule(*arg); end

  def self.scheduler(); end

  def self.set_scheduler(arg); end
end

module Fiddle
  ALIGN_BOOL = ::T.let(nil, ::T.untyped)
  ALIGN_INT16_T = ::T.let(nil, ::T.untyped)
  ALIGN_INT32_T = ::T.let(nil, ::T.untyped)
  ALIGN_INT64_T = ::T.let(nil, ::T.untyped)
  ALIGN_INT8_T = ::T.let(nil, ::T.untyped)
  NULL = ::T.let(nil, ::T.untyped)
  Qfalse = ::T.let(nil, ::T.untyped)
  Qnil = ::T.let(nil, ::T.untyped)
  Qtrue = ::T.let(nil, ::T.untyped)
  Qundef = ::T.let(nil, ::T.untyped)
  RTLD_GLOBAL = ::T.let(nil, ::T.untyped)
  RTLD_LAZY = ::T.let(nil, ::T.untyped)
  RTLD_NOW = ::T.let(nil, ::T.untyped)
  SIZEOF_BOOL = ::T.let(nil, ::T.untyped)
  SIZEOF_CONST_STRING = ::T.let(nil, ::T.untyped)
  SIZEOF_INT16_T = ::T.let(nil, ::T.untyped)
  SIZEOF_INT32_T = ::T.let(nil, ::T.untyped)
  SIZEOF_INT64_T = ::T.let(nil, ::T.untyped)
  SIZEOF_INT8_T = ::T.let(nil, ::T.untyped)
  SIZEOF_UCHAR = ::T.let(nil, ::T.untyped)
  SIZEOF_UINT = ::T.let(nil, ::T.untyped)
  SIZEOF_UINT16_T = ::T.let(nil, ::T.untyped)
  SIZEOF_UINT32_T = ::T.let(nil, ::T.untyped)
  SIZEOF_UINT64_T = ::T.let(nil, ::T.untyped)
  SIZEOF_UINT8_T = ::T.let(nil, ::T.untyped)
  SIZEOF_ULONG = ::T.let(nil, ::T.untyped)
  SIZEOF_ULONG_LONG = ::T.let(nil, ::T.untyped)
  SIZEOF_USHORT = ::T.let(nil, ::T.untyped)
  TYPE_BOOL = ::T.let(nil, ::T.untyped)
  TYPE_CONST_STRING = ::T.let(nil, ::T.untyped)
  TYPE_INT16_T = ::T.let(nil, ::T.untyped)
  TYPE_INT32_T = ::T.let(nil, ::T.untyped)
  TYPE_INT64_T = ::T.let(nil, ::T.untyped)
  TYPE_INT8_T = ::T.let(nil, ::T.untyped)
  TYPE_UCHAR = ::T.let(nil, ::T.untyped)
  TYPE_UINT = ::T.let(nil, ::T.untyped)
  TYPE_UINT16_T = ::T.let(nil, ::T.untyped)
  TYPE_UINT32_T = ::T.let(nil, ::T.untyped)
  TYPE_UINT64_T = ::T.let(nil, ::T.untyped)
  TYPE_UINT8_T = ::T.let(nil, ::T.untyped)
  TYPE_ULONG = ::T.let(nil, ::T.untyped)
  TYPE_ULONG_LONG = ::T.let(nil, ::T.untyped)
  TYPE_USHORT = ::T.let(nil, ::T.untyped)
  TYPE_VARIADIC = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
  WINDOWS = ::T.let(nil, ::T.untyped)
end

class Fiddle::CStruct
  include ::Enumerable
  def each(&blk); end

  def each_pair(); end

  def replace(another); end

  def to_h(); end
end

class Fiddle::CStruct
  def self.entity_class(); end

  def self.offsetof(name, members, types); end
end

module Fiddle::CStructBuilder
end

module Fiddle::CStructBuilder
  def self.create(klass, types, members); end
end

class Fiddle::CStructEntity
  include ::Fiddle::PackInfo
  include ::Fiddle::ValueUtil
  def [](*args); end

  def []=(*args); end

  def assign_names(members); end

  def initialize(addr, types, func=T.unsafe(nil)); end

  def set_ctypes(types); end

  def to_s(); end
end

class Fiddle::CStructEntity
  def self.alignment(types); end

  def self.malloc(types, func=T.unsafe(nil), size=T.unsafe(nil), &block); end

  def self.size(types); end
end

class Fiddle::CUnion
end

class Fiddle::CUnion
  def self.entity_class(); end

  def self.offsetof(name, members, types); end
end

class Fiddle::CUnionEntity
end

class Fiddle::CUnionEntity
end

class Fiddle::ClearedReferenceError
end

class Fiddle::ClearedReferenceError
end

class Fiddle::Closure
  def free(); end

  def freed?(); end
end

class Fiddle::Closure
  def self.create(*args); end
end

class Fiddle::CompositeHandler
  def [](symbol); end

  def handlers(); end

  def initialize(handlers); end

  def sym(symbol); end
end

class Fiddle::CompositeHandler
end

class Fiddle::Error
end

class Fiddle::Error
end

class Fiddle::Function
  def need_gvl?(); end

  def to_proc(); end
end

class Fiddle::Handle
  def file_name(); end

  def sym_defined?(arg); end

  def to_ptr(); end
end

class Fiddle::Handle
  def self.sym_defined?(arg); end
end

module Fiddle::Importer
  include ::Fiddle
  include ::Fiddle::CParser
end

module Fiddle::Importer
  extend ::Fiddle::Importer
  extend ::Fiddle
  extend ::Fiddle::CParser
end

class Fiddle::MemoryView
  def [](*arg); end

  def byte_size(); end

  def format(); end

  def initialize(arg); end

  def item_size(); end

  def ndim(); end

  def obj(); end

  def readonly?(); end

  def release(); end

  def shape(); end

  def strides(); end

  def sub_offsets(); end
end

class Fiddle::MemoryView
  def self.export(arg); end
end

module Fiddle::PackInfo
  ALIGN_MAP = ::T.let(nil, ::T.untyped)
  PACK_MAP = ::T.let(nil, ::T.untyped)
  SIZE_MAP = ::T.let(nil, ::T.untyped)
end

module Fiddle::PackInfo
  def self.align(addr, align); end
end

class Fiddle::Packer
  include ::Fiddle::PackInfo
  def initialize(types); end

  def pack(ary); end

  def size(); end

  def unpack(ary); end
end

class Fiddle::Packer
  def self.[](*types); end
end

class Fiddle::Pinned
  def clear(); end

  def cleared?(); end

  def initialize(arg); end

  def ref(); end
end

class Fiddle::Pinned
end

class Fiddle::Pointer
  def call_free(); end

  def freed?(); end
end

class Fiddle::Pointer
  def self.read(arg, arg1); end

  def self.write(arg, arg1); end
end

class Fiddle::StructArray
  include ::Fiddle::ValueUtil
  def []=(index, value); end

  def initialize(ptr, type, initial_values); end

  def to_ptr(); end
end

class Fiddle::StructArray
end

module Fiddle::Types
  BOOL = ::T.let(nil, ::T.untyped)
  CHAR = ::T.let(nil, ::T.untyped)
  CONST_STRING = ::T.let(nil, ::T.untyped)
  DOUBLE = ::T.let(nil, ::T.untyped)
  FLOAT = ::T.let(nil, ::T.untyped)
  INT = ::T.let(nil, ::T.untyped)
  INT16_T = ::T.let(nil, ::T.untyped)
  INT32_T = ::T.let(nil, ::T.untyped)
  INT64_T = ::T.let(nil, ::T.untyped)
  INT8_T = ::T.let(nil, ::T.untyped)
  INTPTR_T = ::T.let(nil, ::T.untyped)
  LONG = ::T.let(nil, ::T.untyped)
  LONG_LONG = ::T.let(nil, ::T.untyped)
  PTRDIFF_T = ::T.let(nil, ::T.untyped)
  SHORT = ::T.let(nil, ::T.untyped)
  SIZE_T = ::T.let(nil, ::T.untyped)
  SSIZE_T = ::T.let(nil, ::T.untyped)
  UCHAR = ::T.let(nil, ::T.untyped)
  UINT = ::T.let(nil, ::T.untyped)
  UINT16_T = ::T.let(nil, ::T.untyped)
  UINT32_T = ::T.let(nil, ::T.untyped)
  UINT64_T = ::T.let(nil, ::T.untyped)
  UINT8_T = ::T.let(nil, ::T.untyped)
  UINTPTR_T = ::T.let(nil, ::T.untyped)
  ULONG = ::T.let(nil, ::T.untyped)
  ULONG_LONG = ::T.let(nil, ::T.untyped)
  USHORT = ::T.let(nil, ::T.untyped)
  VARIADIC = ::T.let(nil, ::T.untyped)
  VOID = ::T.let(nil, ::T.untyped)
  VOIDP = ::T.let(nil, ::T.untyped)
end

module Fiddle::Types
end

module Fiddle::ValueUtil
  def signed_value(val, ty); end

  def unsigned_value(val, ty); end

  def wrap_arg(arg, ty, funcs=T.unsafe(nil), &block); end

  def wrap_args(args, tys, funcs, &block); end
end

module Fiddle::ValueUtil
end

class File
  def self.absolute_path?(arg); end
end

class FileUpload
  include ::CarrierWave::Mount::Extension
  include ::CarrierWave::Validations::ActiveModel
  include ::CarrierWave::Validations::ActiveModel::HelperMethods
  def autosave_associated_records_for_server_uploads(*args); end

  def autosave_associated_records_for_servers(*args); end

  def autosave_associated_records_for_user(*args); end

  def read_uploader(attr_name, &block); end

  def validate_associated_records_for_server_uploads(*args); end

  def validate_associated_records_for_servers(*args); end

  def write_uploader(attr_name, value); end
end

class FileUpload
  extend ::CarrierWave::Validations::ActiveModel::HelperMethods
end

module FileUtils
  include ::FileUtils::StreamUtils_
end

module FileUtils::DryRun
  include ::FileUtils
  include ::FileUtils::StreamUtils_
  include ::FileUtils::LowMethods
end

module FileUtils::DryRun
  extend ::FileUtils::DryRun
  extend ::FileUtils
  extend ::FileUtils::StreamUtils_
  extend ::FileUtils::LowMethods
end

module FileUtils::NoWrite
  include ::FileUtils
  include ::FileUtils::StreamUtils_
  include ::FileUtils::LowMethods
end

module FileUtils::NoWrite
  extend ::FileUtils::NoWrite
  extend ::FileUtils
  extend ::FileUtils::StreamUtils_
  extend ::FileUtils::LowMethods
end

module FileUtils::Verbose
  include ::FileUtils
  include ::FileUtils::StreamUtils_
end

module FileUtils::Verbose
  extend ::FileUtils::Verbose
  extend ::FileUtils
  extend ::FileUtils::StreamUtils_
end

module FileUtils
  extend ::FileUtils::StreamUtils_
  def self.ln_sr(src, dest, target_directory: T.unsafe(nil), force: T.unsafe(nil), noop: T.unsafe(nil), verbose: T.unsafe(nil)); end
end

module Find
  VERSION = ::T.let(nil, ::T.untyped)
end

module Forwardable
  VERSION = ::T.let(nil, ::T.untyped)
end

module Forwardable
  def self._compile_method(src, file, line); end

  def self._delegator_method(obj, accessor, method, ali); end

  def self._valid_method?(method); end

  def self.debug(); end

  def self.debug=(debug); end
end

module GC
  def garbage_collect(full_mark: T.unsafe(nil), immediate_mark: T.unsafe(nil), immediate_sweep: T.unsafe(nil)); end
end

module GC
  def self.latest_compact_info(); end
end

module Gem
  ConfigMap = ::T.let(nil, ::T.untyped)
  HAVE_OPENSSL = ::T.let(nil, ::T.untyped)
  RbConfigPriorities = ::T.let(nil, ::T.untyped)
  RubyGemsVersion = ::T.let(nil, ::T.untyped)
end

module Gem::BUNDLED_GEMS
  def self.build_message(gem); end

  def self.find_gem(path); end

  def self.replace_require(specs); end

  def self.warning?(name, specs: T.unsafe(nil)); end
end

class Gem::BasicSpecification
  def plugins(); end
end

module Gem::BetterPermissionError
  def data(); end
end

module Gem::BetterPermissionError
end

module Gem::CIDetector
  ENV_DESCRIPTORS = ::T.let(nil, ::T.untyped)
  ENV_INDICATORS = ::T.let(nil, ::T.untyped)
end

module Gem::CIDetector
  def self.ci?(); end

  def self.ci_strings(); end
end

class Gem::ConfigFile
  def ipv4_fallback_enabled(); end

  def ipv4_fallback_enabled=(ipv4_fallback_enabled); end

  def last_update_check(); end

  def last_update_check=(timestamp); end

  def state_file_name(); end

  def state_file_writable?(); end
  DEFAULT_IPV4_FALLBACK_ENABLED = ::T.let(nil, ::T.untyped)
end

class Gem::ConfigFile
  def self.dump_with_rubygems_yaml(content); end

  def self.load_with_rubygems_config_hash(yaml); end
end

class Gem::Dependency
  include ::Bundler::ForcePlatform
  def force_ruby_platform(); end
end

class Gem::DependencyList
  include ::Gem::TSort
end

module Gem::Deprecate
  def deprecate(name, repl, year, month); end
end

module Gem::Deprecate
  def self.next_rubygems_major_version(); end

  def self.rubygems_deprecate(name, replacement=T.unsafe(nil)); end

  def self.rubygems_deprecate_command(version=T.unsafe(nil)); end
end

class Gem::Installer
  include ::Gem::InstallerUninstallerUtils
  def ensure_writable_dir(dir); end

  def explicit_version_requirement(name); end

  def gemdeps_load(name); end

  def generate_plugins(); end
end

class Gem::Installer::ExtensionBuildError
end

class Gem::Installer::ExtensionBuildError
end

class Gem::Installer::FakePackage
  def copy_to(path); end

  def data_mode(); end

  def data_mode=(data_mode); end

  def dir_mode(); end

  def dir_mode=(dir_mode); end

  def extract_files(destination_dir, pattern=T.unsafe(nil)); end

  def initialize(spec); end

  def prog_mode(); end

  def prog_mode=(prog_mode); end

  def spec(); end

  def spec=(spec); end
end

class Gem::Installer::FakePackage
end

class Gem::Installer
  def self.inherited(klass); end
end

module Gem::InstallerUninstallerUtils
  def regenerate_plugins_for(spec, plugins_dir); end

  def remove_plugins_for(spec, plugins_dir); end
end

module Gem::InstallerUninstallerUtils
end

class Gem::Licenses
  DEPRECATED_EXCEPTION_IDENTIFIERS = ::T.let(nil, ::T.untyped)
  DEPRECATED_EXCEPTION_REGEXP = ::T.let(nil, ::T.untyped)
  DEPRECATED_LICENSE_IDENTIFIERS = ::T.let(nil, ::T.untyped)
  DEPRECATED_LICENSE_REGEXP = ::T.let(nil, ::T.untyped)
  LICENSE_REF = ::T.let(nil, ::T.untyped)
  VALID_REGEXP = ::T.let(nil, ::T.untyped)
end

class Gem::Licenses
  def self.deprecated_exception_id?(license); end

  def self.deprecated_license_id?(license); end
end

module Gem::Molinillo::SpecificationProvider
  def allow_missing?(dependency); end

  def dependencies_equal?(dependencies, other_dependencies); end

  def dependencies_for(specification); end

  def name_for(dependency); end

  def name_for_explicit_dependency_source(); end

  def name_for_locking_dependency_source(); end

  def requirement_satisfied_by?(requirement, activated, spec); end

  def search_for(dependency); end

  def sort_dependencies(dependencies, activated, conflicts); end
end

module Gem::Molinillo::SpecificationProvider
end

module Gem::Molinillo::UI
  def after_resolution(); end

  def before_resolution(); end

  def debug(depth=T.unsafe(nil)); end

  def debug?(); end

  def indicate_progress(); end

  def output(); end

  def progress_rate(); end
end

module Gem::Molinillo::UI
end

class Gem::NameTuple
  def lock_name(); end
end

module Gem::Net
end

class Gem::Net::BufferedIO
  def <<(*strs); end

  def close(); end

  def closed?(); end

  def continue_timeout(); end

  def continue_timeout=(continue_timeout); end

  def debug_output(); end

  def debug_output=(debug_output); end

  def eof?(); end

  def initialize(io, read_timeout: T.unsafe(nil), write_timeout: T.unsafe(nil), continue_timeout: T.unsafe(nil), debug_output: T.unsafe(nil)); end

  def io(); end

  def read(len, dest=T.unsafe(nil), ignore_eof=T.unsafe(nil)); end

  def read_all(dest=T.unsafe(nil)); end

  def read_timeout(); end

  def read_timeout=(read_timeout); end

  def readline(); end

  def readuntil(terminator, ignore_eof=T.unsafe(nil)); end

  def write(*strs); end

  def write_timeout(); end

  def write_timeout=(write_timeout); end

  def writeline(str); end
  BUFSIZE = ::T.let(nil, ::T.untyped)
end

class Gem::Net::BufferedIO
end

class Gem::Net::HTTP
  def active?(); end

  def address(); end

  def ca_file(); end

  def ca_file=(ca_file); end

  def ca_path(); end

  def ca_path=(ca_path); end

  def cert(); end

  def cert=(cert); end

  def cert_store(); end

  def cert_store=(cert_store); end

  def ciphers(); end

  def ciphers=(ciphers); end

  def close_on_empty_response(); end

  def close_on_empty_response=(close_on_empty_response); end

  def continue_timeout(); end

  def continue_timeout=(sec); end

  def copy(path, initheader=T.unsafe(nil)); end

  def delete(path, initheader=T.unsafe(nil)); end

  def extra_chain_cert(); end

  def extra_chain_cert=(extra_chain_cert); end

  def finish(); end

  def get(path, initheader=T.unsafe(nil), dest=T.unsafe(nil), &block); end

  def get2(path, initheader=T.unsafe(nil), &block); end

  def head(path, initheader=T.unsafe(nil)); end

  def head2(path, initheader=T.unsafe(nil), &block); end

  def ignore_eof(); end

  def ignore_eof=(ignore_eof); end

  def initialize(address, port=T.unsafe(nil)); end

  def ipaddr(); end

  def ipaddr=(addr); end

  def keep_alive_timeout(); end

  def keep_alive_timeout=(keep_alive_timeout); end

  def key(); end

  def key=(key); end

  def local_host(); end

  def local_host=(local_host); end

  def local_port(); end

  def local_port=(local_port); end

  def lock(path, body, initheader=T.unsafe(nil)); end

  def max_retries(); end

  def max_retries=(retries); end

  def max_version(); end

  def max_version=(max_version); end

  def min_version(); end

  def min_version=(min_version); end

  def mkcol(path, body=T.unsafe(nil), initheader=T.unsafe(nil)); end

  def move(path, initheader=T.unsafe(nil)); end

  def open_timeout(); end

  def open_timeout=(open_timeout); end

  def options(path, initheader=T.unsafe(nil)); end

  def patch(path, data, initheader=T.unsafe(nil), dest=T.unsafe(nil), &block); end

  def peer_cert(); end

  def port(); end

  def post(path, data, initheader=T.unsafe(nil), dest=T.unsafe(nil), &block); end

  def post2(path, data, initheader=T.unsafe(nil), &block); end

  def propfind(path, body=T.unsafe(nil), initheader=T.unsafe(nil)); end

  def proppatch(path, body, initheader=T.unsafe(nil)); end

  def proxy?(); end

  def proxy_address(); end

  def proxy_address=(proxy_address); end

  def proxy_from_env=(proxy_from_env); end

  def proxy_from_env?(); end

  def proxy_pass(); end

  def proxy_pass=(proxy_pass); end

  def proxy_port(); end

  def proxy_port=(proxy_port); end

  def proxy_uri(); end

  def proxy_user(); end

  def proxy_user=(proxy_user); end

  def proxyaddr(); end

  def proxyport(); end

  def put(path, data, initheader=T.unsafe(nil)); end

  def put2(path, data, initheader=T.unsafe(nil), &block); end

  def read_timeout(); end

  def read_timeout=(sec); end

  def request(req, body=T.unsafe(nil), &block); end

  def request_get(path, initheader=T.unsafe(nil), &block); end

  def request_head(path, initheader=T.unsafe(nil), &block); end

  def request_post(path, data, initheader=T.unsafe(nil), &block); end

  def request_put(path, data, initheader=T.unsafe(nil), &block); end

  def response_body_encoding(); end

  def response_body_encoding=(value); end

  def send_request(name, path, data=T.unsafe(nil), header=T.unsafe(nil)); end

  def set_debug_output(output); end

  def ssl_timeout(); end

  def ssl_timeout=(ssl_timeout); end

  def ssl_version(); end

  def ssl_version=(ssl_version); end

  def start(); end

  def started?(); end

  def trace(path, initheader=T.unsafe(nil)); end

  def unlock(path, body, initheader=T.unsafe(nil)); end

  def use_ssl=(flag); end

  def use_ssl?(); end

  def verify_callback(); end

  def verify_callback=(verify_callback); end

  def verify_depth(); end

  def verify_depth=(verify_depth); end

  def verify_hostname(); end

  def verify_hostname=(verify_hostname); end

  def verify_mode(); end

  def verify_mode=(verify_mode); end

  def write_timeout(); end

  def write_timeout=(sec); end
  HAVE_ZLIB = ::T.let(nil, ::T.untyped)
  HTTPVersion = ::T.let(nil, ::T.untyped)
  IDEMPOTENT_METHODS_ = ::T.let(nil, ::T.untyped)
  SSL_ATTRIBUTES = ::T.let(nil, ::T.untyped)
  SSL_IVNAMES = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTP::Copy
  METHOD = ::T.let(nil, ::T.untyped)
  REQUEST_HAS_BODY = ::T.let(nil, ::T.untyped)
  RESPONSE_HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTP::Copy
end

class Gem::Net::HTTP::Delete
  METHOD = ::T.let(nil, ::T.untyped)
  REQUEST_HAS_BODY = ::T.let(nil, ::T.untyped)
  RESPONSE_HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTP::Delete
end

class Gem::Net::HTTP::Get
  METHOD = ::T.let(nil, ::T.untyped)
  REQUEST_HAS_BODY = ::T.let(nil, ::T.untyped)
  RESPONSE_HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTP::Get
end

class Gem::Net::HTTP::Head
  METHOD = ::T.let(nil, ::T.untyped)
  REQUEST_HAS_BODY = ::T.let(nil, ::T.untyped)
  RESPONSE_HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTP::Head
end

class Gem::Net::HTTP::Lock
  METHOD = ::T.let(nil, ::T.untyped)
  REQUEST_HAS_BODY = ::T.let(nil, ::T.untyped)
  RESPONSE_HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTP::Lock
end

class Gem::Net::HTTP::Mkcol
  METHOD = ::T.let(nil, ::T.untyped)
  REQUEST_HAS_BODY = ::T.let(nil, ::T.untyped)
  RESPONSE_HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTP::Mkcol
end

class Gem::Net::HTTP::Move
  METHOD = ::T.let(nil, ::T.untyped)
  REQUEST_HAS_BODY = ::T.let(nil, ::T.untyped)
  RESPONSE_HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTP::Move
end

class Gem::Net::HTTP::Options
  METHOD = ::T.let(nil, ::T.untyped)
  REQUEST_HAS_BODY = ::T.let(nil, ::T.untyped)
  RESPONSE_HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTP::Options
end

class Gem::Net::HTTP::Patch
  METHOD = ::T.let(nil, ::T.untyped)
  REQUEST_HAS_BODY = ::T.let(nil, ::T.untyped)
  RESPONSE_HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTP::Patch
end

class Gem::Net::HTTP::Persistent
  def ca_file(); end

  def ca_file=(file); end

  def ca_path(); end

  def ca_path=(path); end

  def cert(); end

  def cert=(certificate); end

  def cert_store(); end

  def cert_store=(store); end

  def certificate(); end

  def certificate=(certificate); end

  def ciphers(); end

  def ciphers=(ciphers); end

  def connection_for(uri); end

  def debug_output(); end

  def debug_output=(debug_output); end

  def escape(str); end

  def expired?(connection); end

  def finish(connection); end

  def generation(); end

  def headers(); end

  def http_version(uri); end

  def http_versions(); end

  def idle_timeout(); end

  def idle_timeout=(idle_timeout); end

  def initialize(name: T.unsafe(nil), proxy: T.unsafe(nil), pool_size: T.unsafe(nil)); end

  def keep_alive(); end

  def keep_alive=(keep_alive); end

  def key(); end

  def key=(key); end

  def max_requests(); end

  def max_requests=(max_requests); end

  def max_retries(); end

  def max_retries=(retries); end

  def max_version(); end

  def max_version=(max_version); end

  def min_version(); end

  def min_version=(min_version); end

  def name(); end

  def no_proxy(); end

  def normalize_uri(uri); end

  def open_timeout(); end

  def open_timeout=(open_timeout); end

  def override_headers(); end

  def pool(); end

  def private_key(); end

  def private_key=(key); end

  def proxy=(proxy); end

  def proxy_bypass?(host, port); end

  def proxy_from_env(); end

  def proxy_uri(); end

  def read_timeout(); end

  def read_timeout=(read_timeout); end

  def reconnect(); end

  def reconnect_ssl(); end

  def request(uri, req=T.unsafe(nil), &block); end

  def request_setup(req_or_uri); end

  def reset(connection); end

  def reuse_ssl_sessions(); end

  def reuse_ssl_sessions=(reuse_ssl_sessions); end

  def shutdown(); end

  def socket_options(); end

  def ssl(connection); end

  def ssl_generation(); end

  def ssl_timeout(); end

  def ssl_timeout=(ssl_timeout); end

  def ssl_version(); end

  def ssl_version=(ssl_version); end

  def start(http); end

  def timeout_key(); end

  def unescape(str); end

  def verify_callback(); end

  def verify_callback=(callback); end

  def verify_depth(); end

  def verify_depth=(verify_depth); end

  def verify_mode(); end

  def verify_mode=(verify_mode); end

  def write_timeout(); end

  def write_timeout=(write_timeout); end
  DEFAULT_POOL_SIZE = ::T.let(nil, ::T.untyped)
  EPOCH = ::T.let(nil, ::T.untyped)
  HAVE_OPENSSL = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTP::Persistent::Connection
  def close(); end

  def finish(); end

  def http(); end

  def http=(http); end

  def initialize(http_class, http_args, ssl_generation); end

  def last_use(); end

  def last_use=(last_use); end

  def requests(); end

  def requests=(requests); end

  def reset(); end

  def ressl(ssl_generation); end

  def ssl_generation(); end

  def ssl_generation=(ssl_generation); end
end

class Gem::Net::HTTP::Persistent::Connection
end

class Gem::Net::HTTP::Persistent::Error
end

class Gem::Net::HTTP::Persistent::Error
end

class Gem::Net::HTTP::Persistent::Pool
  def checkin(net_http_args); end

  def checkout(net_http_args); end

  def key(); end

  def shutdown(); end
end

class Gem::Net::HTTP::Persistent::Pool
end

class Gem::Net::HTTP::Persistent::TimedStackMulti
end

class Gem::Net::HTTP::Persistent::TimedStackMulti
  def self.hash_of_arrays(); end
end

class Gem::Net::HTTP::Persistent
  def self.detect_idle_timeout(uri, max=T.unsafe(nil)); end
end

class Gem::Net::HTTP::Post
  METHOD = ::T.let(nil, ::T.untyped)
  REQUEST_HAS_BODY = ::T.let(nil, ::T.untyped)
  RESPONSE_HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTP::Post
end

class Gem::Net::HTTP::Propfind
  METHOD = ::T.let(nil, ::T.untyped)
  REQUEST_HAS_BODY = ::T.let(nil, ::T.untyped)
  RESPONSE_HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTP::Propfind
end

class Gem::Net::HTTP::Proppatch
  METHOD = ::T.let(nil, ::T.untyped)
  REQUEST_HAS_BODY = ::T.let(nil, ::T.untyped)
  RESPONSE_HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTP::Proppatch
end

module Gem::Net::HTTP::ProxyDelta
end

module Gem::Net::HTTP::ProxyDelta
end

class Gem::Net::HTTP::Put
  METHOD = ::T.let(nil, ::T.untyped)
  REQUEST_HAS_BODY = ::T.let(nil, ::T.untyped)
  RESPONSE_HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTP::Put
end

class Gem::Net::HTTP::Trace
  METHOD = ::T.let(nil, ::T.untyped)
  REQUEST_HAS_BODY = ::T.let(nil, ::T.untyped)
  RESPONSE_HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTP::Trace
end

class Gem::Net::HTTP::Unlock
  METHOD = ::T.let(nil, ::T.untyped)
  REQUEST_HAS_BODY = ::T.let(nil, ::T.untyped)
  RESPONSE_HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTP::Unlock
end

class Gem::Net::HTTP
  def self.Proxy(p_addr=T.unsafe(nil), p_port=T.unsafe(nil), p_user=T.unsafe(nil), p_pass=T.unsafe(nil)); end

  def self.default_port(); end

  def self.get(uri_or_host, path_or_headers=T.unsafe(nil), port=T.unsafe(nil)); end

  def self.get_print(uri_or_host, path_or_headers=T.unsafe(nil), port=T.unsafe(nil)); end

  def self.get_response(uri_or_host, path_or_headers=T.unsafe(nil), port=T.unsafe(nil), &block); end

  def self.http_default_port(); end

  def self.https_default_port(); end

  def self.is_version_1_1?(); end

  def self.is_version_1_2?(); end

  def self.new(address, port=T.unsafe(nil), p_addr=T.unsafe(nil), p_port=T.unsafe(nil), p_user=T.unsafe(nil), p_pass=T.unsafe(nil), p_no_proxy=T.unsafe(nil)); end

  def self.newobj(*arg, **arg1); end

  def self.post(url, data, header=T.unsafe(nil)); end

  def self.post_form(url, params); end

  def self.proxy_address(); end

  def self.proxy_class?(); end

  def self.proxy_pass(); end

  def self.proxy_port(); end

  def self.proxy_user(); end

  def self.socket_type(); end

  def self.start(address, *arg, &block); end

  def self.version_1_1?(); end

  def self.version_1_2(); end

  def self.version_1_2?(); end
end

class Gem::Net::HTTPAccepted
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTPAccepted
end

class Gem::Net::HTTPAlreadyReported
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTPAlreadyReported
end

class Gem::Net::HTTPBadGateway
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTPBadGateway
end

class Gem::Net::HTTPBadRequest
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTPBadRequest
end

class Gem::Net::HTTPBadResponse
end

class Gem::Net::HTTPBadResponse
end

class Gem::Net::HTTPClientError
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTPClientError
end

Gem::Net::HTTPClientErrorCode = Gem::Net::HTTPClientError

class Gem::Net::HTTPClientException
  include ::Gem::Net::HTTPExceptions
end

class Gem::Net::HTTPClientException
end

class Gem::Net::HTTPConflict
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTPConflict
end

class Gem::Net::HTTPContinue
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTPContinue
end

class Gem::Net::HTTPCreated
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTPCreated
end

class Gem::Net::HTTPEarlyHints
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTPEarlyHints
end

class Gem::Net::HTTPError
  include ::Gem::Net::HTTPExceptions
end

class Gem::Net::HTTPError
end

module Gem::Net::HTTPExceptions
  def data(); end

  def initialize(msg, res); end

  def response(); end
end

module Gem::Net::HTTPExceptions
end

class Gem::Net::HTTPExpectationFailed
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTPExpectationFailed
end

class Gem::Net::HTTPFailedDependency
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTPFailedDependency
end

class Gem::Net::HTTPFatalError
  include ::Gem::Net::HTTPExceptions
end

class Gem::Net::HTTPFatalError
end

Gem::Net::HTTPFatalErrorCode = Gem::Net::HTTPClientError

class Gem::Net::HTTPForbidden
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTPForbidden
end

class Gem::Net::HTTPFound
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTPFound
end

Gem::Net::HTTPGatewayTimeOut = Gem::Net::HTTPGatewayTimeout

class Gem::Net::HTTPGatewayTimeout
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTPGatewayTimeout
end

class Gem::Net::HTTPGenericRequest
  include ::Gem::Net::HTTPHeader
  def body(); end

  def body=(str); end

  def body_exist?(); end

  def body_stream(); end

  def body_stream=(input); end

  def decode_content(); end

  def exec(sock, ver, path); end

  def initialize(m, reqbody, resbody, uri_or_path, initheader=T.unsafe(nil)); end

  def method(); end

  def path(); end

  def request_body_permitted?(); end

  def response_body_permitted?(); end

  def set_body_internal(str); end

  def update_uri(addr, port, ssl); end

  def uri(); end
end

class Gem::Net::HTTPGenericRequest::Chunker
  def finish(); end

  def initialize(sock); end

  def write(buf); end
end

class Gem::Net::HTTPGenericRequest::Chunker
end

class Gem::Net::HTTPGenericRequest
end

class Gem::Net::HTTPGone
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTPGone
end

module Gem::Net::HTTPHeader
  def [](key); end

  def []=(key, val); end

  def add_field(key, val); end

  def basic_auth(account, password); end

  def canonical_each(); end

  def chunked?(); end

  def connection_close?(); end

  def connection_keep_alive?(); end

  def content_length(); end

  def content_length=(len); end

  def content_range(); end

  def content_type(); end

  def content_type=(type, params=T.unsafe(nil)); end

  def delete(key); end

  def each(&blk); end

  def each_capitalized(); end

  def each_capitalized_name(); end

  def each_header(); end

  def each_key(&block); end

  def each_name(&block); end

  def each_value(); end

  def fetch(key, *args, &block); end

  def form_data=(params, sep=T.unsafe(nil)); end

  def get_fields(key); end

  def initialize_http_header(initheader); end

  def key?(key); end

  def length(); end

  def main_type(); end

  def proxy_basic_auth(account, password); end

  def range(); end

  def range=(r, e=T.unsafe(nil)); end

  def range_length(); end

  def set_content_type(type, params=T.unsafe(nil)); end

  def set_form(params, enctype=T.unsafe(nil), formopt=T.unsafe(nil)); end

  def set_form_data(params, sep=T.unsafe(nil)); end

  def set_range(r, e=T.unsafe(nil)); end

  def size(); end

  def sub_type(); end

  def to_hash(); end

  def type_params(); end
  MAX_FIELD_LENGTH = ::T.let(nil, ::T.untyped)
  MAX_KEY_LENGTH = ::T.let(nil, ::T.untyped)
end

module Gem::Net::HTTPHeader
end

class Gem::Net::HTTPHeaderSyntaxError
end

class Gem::Net::HTTPHeaderSyntaxError
end

class Gem::Net::HTTPIMUsed
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTPIMUsed
end

class Gem::Net::HTTPInformation
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

Gem::Net::HTTPInformation::EXCEPTION_TYPE = Gem::Net::HTTPError

class Gem::Net::HTTPInformation
end

Gem::Net::HTTPInformationCode = Gem::Net::HTTPInformation

class Gem::Net::HTTPInsufficientStorage
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTPInsufficientStorage
end

class Gem::Net::HTTPInternalServerError
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTPInternalServerError
end

class Gem::Net::HTTPLengthRequired
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTPLengthRequired
end

class Gem::Net::HTTPLocked
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTPLocked
end

class Gem::Net::HTTPLoopDetected
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTPLoopDetected
end

class Gem::Net::HTTPMethodNotAllowed
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTPMethodNotAllowed
end

class Gem::Net::HTTPMisdirectedRequest
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTPMisdirectedRequest
end

class Gem::Net::HTTPMovedPermanently
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTPMovedPermanently
end

Gem::Net::HTTPMovedTemporarily = Gem::Net::HTTPFound

class Gem::Net::HTTPMultiStatus
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTPMultiStatus
end

Gem::Net::HTTPMultipleChoice = Gem::Net::HTTPMultipleChoices

class Gem::Net::HTTPMultipleChoices
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTPMultipleChoices
end

class Gem::Net::HTTPNetworkAuthenticationRequired
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTPNetworkAuthenticationRequired
end

class Gem::Net::HTTPNoContent
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTPNoContent
end

class Gem::Net::HTTPNonAuthoritativeInformation
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTPNonAuthoritativeInformation
end

class Gem::Net::HTTPNotAcceptable
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTPNotAcceptable
end

class Gem::Net::HTTPNotExtended
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTPNotExtended
end

class Gem::Net::HTTPNotFound
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTPNotFound
end

class Gem::Net::HTTPNotImplemented
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTPNotImplemented
end

class Gem::Net::HTTPNotModified
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTPNotModified
end

class Gem::Net::HTTPOK
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTPOK
end

class Gem::Net::HTTPPartialContent
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTPPartialContent
end

class Gem::Net::HTTPPayloadTooLarge
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTPPayloadTooLarge
end

class Gem::Net::HTTPPaymentRequired
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTPPaymentRequired
end

class Gem::Net::HTTPPermanentRedirect
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTPPermanentRedirect
end

class Gem::Net::HTTPPreconditionFailed
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTPPreconditionFailed
end

class Gem::Net::HTTPPreconditionRequired
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTPPreconditionRequired
end

class Gem::Net::HTTPProcessing
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTPProcessing
end

class Gem::Net::HTTPProxyAuthenticationRequired
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTPProxyAuthenticationRequired
end

class Gem::Net::HTTPRangeNotSatisfiable
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTPRangeNotSatisfiable
end

class Gem::Net::HTTPRedirection
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTPRedirection
end

Gem::Net::HTTPRedirectionCode = Gem::Net::HTTPRedirection

class Gem::Net::HTTPRequest
  def initialize(path, initheader=T.unsafe(nil)); end
end

class Gem::Net::HTTPRequest
end

Gem::Net::HTTPRequestEntityTooLarge = Gem::Net::HTTPPayloadTooLarge

class Gem::Net::HTTPRequestHeaderFieldsTooLarge
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTPRequestHeaderFieldsTooLarge
end

Gem::Net::HTTPRequestTimeOut = Gem::Net::HTTPRequestTimeout

class Gem::Net::HTTPRequestTimeout
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTPRequestTimeout
end

Gem::Net::HTTPRequestURITooLarge = Gem::Net::HTTPURITooLong

Gem::Net::HTTPRequestURITooLong = Gem::Net::HTTPURITooLong

Gem::Net::HTTPRequestedRangeNotSatisfiable = Gem::Net::HTTPRangeNotSatisfiable

class Gem::Net::HTTPResetContent
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTPResetContent
end

Gem::Net::HTTPResponceReceiver = Gem::Net::HTTPResponse

class Gem::Net::HTTPResponse
  include ::Gem::Net::HTTPHeader
  def body(); end

  def body=(value); end

  def body_encoding(); end

  def body_encoding=(value); end

  def code(); end

  def code_type(); end

  def decode_content(); end

  def decode_content=(decode_content); end

  def entity(); end

  def error!(); end

  def error_type(); end

  def header(); end

  def http_version(); end

  def ignore_eof(); end

  def ignore_eof=(ignore_eof); end

  def initialize(httpv, code, msg); end

  def message(); end

  def msg(); end

  def read_body(dest=T.unsafe(nil), &block); end

  def read_header(); end

  def reading_body(sock, reqmethodallowbody); end

  def response(); end

  def uri(); end

  def uri=(uri); end

  def value(); end
  CODE_CLASS_TO_OBJ = ::T.let(nil, ::T.untyped)
  CODE_TO_OBJ = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTPResponse::Inflater
  def bytes_inflated(); end

  def finish(); end

  def inflate_adapter(dest); end

  def initialize(socket); end

  def read(clen, dest, ignore_eof=T.unsafe(nil)); end

  def read_all(dest); end
end

class Gem::Net::HTTPResponse::Inflater
end

class Gem::Net::HTTPResponse
  def self.body_permitted?(); end

  def self.exception_type(); end

  def self.read_new(sock); end
end

Gem::Net::HTTPResponseReceiver = Gem::Net::HTTPResponse

Gem::Net::HTTPRetriableCode = Gem::Net::HTTPRedirection

class Gem::Net::HTTPRetriableError
  include ::Gem::Net::HTTPExceptions
end

class Gem::Net::HTTPRetriableError
end

class Gem::Net::HTTPSeeOther
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTPSeeOther
end

class Gem::Net::HTTPServerError
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTPServerError
end

Gem::Net::HTTPServerErrorCode = Gem::Net::HTTPServerError

Gem::Net::HTTPServerException = Gem::Net::HTTPClientException

class Gem::Net::HTTPServiceUnavailable
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTPServiceUnavailable
end

Gem::Net::HTTPSession = Gem::Net::HTTP

class Gem::Net::HTTPSuccess
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

Gem::Net::HTTPSuccess::EXCEPTION_TYPE = Gem::Net::HTTPError

class Gem::Net::HTTPSuccess
end

Gem::Net::HTTPSuccessCode = Gem::Net::HTTPSuccess

class Gem::Net::HTTPSwitchProtocol
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTPSwitchProtocol
end

class Gem::Net::HTTPTemporaryRedirect
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTPTemporaryRedirect
end

class Gem::Net::HTTPTooManyRequests
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTPTooManyRequests
end

class Gem::Net::HTTPURITooLong
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTPURITooLong
end

class Gem::Net::HTTPUnauthorized
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTPUnauthorized
end

class Gem::Net::HTTPUnavailableForLegalReasons
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTPUnavailableForLegalReasons
end

class Gem::Net::HTTPUnknownResponse
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

Gem::Net::HTTPUnknownResponse::EXCEPTION_TYPE = Gem::Net::HTTPError

class Gem::Net::HTTPUnknownResponse
end

class Gem::Net::HTTPUnprocessableEntity
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTPUnprocessableEntity
end

class Gem::Net::HTTPUnsupportedMediaType
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTPUnsupportedMediaType
end

class Gem::Net::HTTPUpgradeRequired
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTPUpgradeRequired
end

class Gem::Net::HTTPUseProxy
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTPUseProxy
end

class Gem::Net::HTTPVariantAlsoNegotiates
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTPVariantAlsoNegotiates
end

class Gem::Net::HTTPVersionNotSupported
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTPVersionNotSupported
end

class Gem::Net::InternetMessageIO
  def each_list_item(); end

  def each_message_chunk(); end

  def initialize(*arg, **arg1); end

  def write_message(src); end

  def write_message_0(src); end

  def write_message_by_block(&block); end
end

class Gem::Net::InternetMessageIO
end

module Gem::Net::NetPrivate
end

Gem::Net::NetPrivate::HTTPRequest = Gem::Net::HTTPRequest

Gem::Net::NetPrivate::Socket = Gem::Net::InternetMessageIO

module Gem::Net::NetPrivate
end

class Gem::Net::OpenTimeout
end

class Gem::Net::OpenTimeout
end

class Gem::Net::ProtoAuthError
end

class Gem::Net::ProtoAuthError
end

class Gem::Net::ProtoCommandError
end

class Gem::Net::ProtoCommandError
end

class Gem::Net::ProtoFatalError
end

class Gem::Net::ProtoFatalError
end

class Gem::Net::ProtoRetriableError
end

class Gem::Net::ProtoRetriableError
end

class Gem::Net::ProtoServerError
end

class Gem::Net::ProtoServerError
end

class Gem::Net::ProtoSyntaxError
end

class Gem::Net::ProtoSyntaxError
end

class Gem::Net::ProtoUnknownError
end

class Gem::Net::ProtoUnknownError
end

Gem::Net::ProtocRetryError = Gem::Net::ProtoRetriableError

class Gem::Net::Protocol
  VERSION = ::T.let(nil, ::T.untyped)
end

class Gem::Net::Protocol
  def self.protocol_param(name, val); end
end

class Gem::Net::ProtocolError
end

class Gem::Net::ProtocolError
end

class Gem::Net::ReadAdapter
  def <<(str); end

  def initialize(block); end
end

class Gem::Net::ReadAdapter
end

class Gem::Net::ReadTimeout
  def initialize(io=T.unsafe(nil)); end

  def io(); end
end

class Gem::Net::ReadTimeout
end

class Gem::Net::WriteAdapter
  def <<(str); end

  def initialize(writer); end

  def print(str); end

  def printf(*args); end

  def puts(str=T.unsafe(nil)); end

  def write(str); end
end

class Gem::Net::WriteAdapter
end

class Gem::Net::WriteTimeout
  def initialize(io=T.unsafe(nil)); end

  def io(); end
end

class Gem::Net::WriteTimeout
end

module Gem::Net
end

class Gem::PathSupport
  def home(); end

  def initialize(env); end

  def path(); end

  def spec_cache_dir(); end
end

class Gem::Platform
  def normalized_linux_version(); end

  def normalized_linux_version_ext(); end
  WINDOWS = ::T.let(nil, ::T.untyped)
  X64_LINUX = ::T.let(nil, ::T.untyped)
  X64_LINUX_MUSL = ::T.let(nil, ::T.untyped)
end

class Gem::Platform
  def self._deprecated_match(platform); end

  def self.match_gem?(platform, gem_name); end

  def self.match_spec?(spec); end

  def self.sort_priority(platform); end
end

class Gem::RequestSet
  include ::Gem::TSort
end

class Gem::RequestSet::Lockfile::Tokenizer::Token
  def self.keyword_init?(); end
end

class Gem::Requirement
  def _sorted_requirements(); end
end

class Gem::Resolv
  def each_address(name); end

  def each_name(address); end

  def getaddress(name); end

  def getaddresses(name); end

  def getname(address); end

  def getnames(address); end

  def initialize(resolvers=T.unsafe(nil), use_ipv6: T.unsafe(nil)); end
  AddressRegex = ::T.let(nil, ::T.untyped)
  DefaultResolver = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

class Gem::Resolv::DNS
  def close(); end

  def each_address(name); end

  def each_name(address); end

  def each_resource(name, typeclass, &proc); end

  def extract_resources(msg, name, typeclass); end

  def fetch_resource(name, typeclass); end

  def getaddress(name); end

  def getaddresses(name); end

  def getname(address); end

  def getnames(address); end

  def getresource(name, typeclass); end

  def getresources(name, typeclass); end

  def initialize(config_info=T.unsafe(nil)); end

  def lazy_initialize(); end

  def make_tcp_requester(host, port); end

  def make_udp_requester(); end

  def timeouts=(values); end
  Port = ::T.let(nil, ::T.untyped)
  RequestID = ::T.let(nil, ::T.untyped)
  RequestIDMutex = ::T.let(nil, ::T.untyped)
  UDPSize = ::T.let(nil, ::T.untyped)
end

class Gem::Resolv::DNS::Config
  def generate_candidates(name); end

  def generate_timeouts(); end

  def initialize(config_info=T.unsafe(nil)); end

  def lazy_initialize(); end

  def nameserver_port(); end

  def resolv(name); end

  def single?(); end

  def timeouts=(values); end

  def use_ipv6?(); end
  InitialTimeout = ::T.let(nil, ::T.untyped)
end

class Gem::Resolv::DNS::Config::NXDomain
end

class Gem::Resolv::DNS::Config::NXDomain
end

class Gem::Resolv::DNS::Config::OtherResolvError
end

class Gem::Resolv::DNS::Config::OtherResolvError
end

class Gem::Resolv::DNS::Config
  def self.default_config_hash(filename=T.unsafe(nil)); end

  def self.parse_resolv_conf(filename); end
end

class Gem::Resolv::DNS::DecodeError
end

class Gem::Resolv::DNS::DecodeError
end

class Gem::Resolv::DNS::EncodeError
end

class Gem::Resolv::DNS::EncodeError
end

module Gem::Resolv::DNS::Label
end

class Gem::Resolv::DNS::Label::Str
  def ==(other); end

  def downcase(); end

  def eql?(other); end

  def initialize(string); end

  def string(); end
end

class Gem::Resolv::DNS::Label::Str
end

module Gem::Resolv::DNS::Label
  def self.split(arg); end
end

class Gem::Resolv::DNS::Message
  def ==(other); end

  def aa(); end

  def aa=(aa); end

  def add_additional(name, ttl, data); end

  def add_answer(name, ttl, data); end

  def add_authority(name, ttl, data); end

  def add_question(name, typeclass); end

  def additional(); end

  def answer(); end

  def authority(); end

  def each_additional(); end

  def each_answer(); end

  def each_authority(); end

  def each_question(); end

  def each_resource(); end

  def encode(); end

  def id(); end

  def id=(id); end

  def initialize(id=T.unsafe(nil)); end

  def opcode(); end

  def opcode=(opcode); end

  def qr(); end

  def qr=(qr); end

  def question(); end

  def ra(); end

  def ra=(ra); end

  def rcode(); end

  def rcode=(rcode); end

  def rd(); end

  def rd=(rd); end

  def tc(); end

  def tc=(tc); end
end

class Gem::Resolv::DNS::Message::MessageDecoder
  def get_bytes(len=T.unsafe(nil)); end

  def get_label(); end

  def get_labels(); end

  def get_length16(); end

  def get_list(); end

  def get_name(); end

  def get_question(); end

  def get_rr(); end

  def get_string(); end

  def get_string_list(); end

  def get_unpack(template); end

  def initialize(data); end
end

class Gem::Resolv::DNS::Message::MessageDecoder
end

class Gem::Resolv::DNS::Message::MessageEncoder
  def put_bytes(d); end

  def put_label(d); end

  def put_labels(d, compress: T.unsafe(nil)); end

  def put_length16(); end

  def put_name(d, compress: T.unsafe(nil)); end

  def put_pack(template, *d); end

  def put_string(d); end

  def put_string_list(ds); end
end

class Gem::Resolv::DNS::Message::MessageEncoder
end

class Gem::Resolv::DNS::Message
  def self.decode(m); end
end

class Gem::Resolv::DNS::Name
  def ==(other); end

  def [](i); end

  def absolute?(); end

  def eql?(other); end

  def initialize(labels, absolute=T.unsafe(nil)); end

  def length(); end

  def subdomain_of?(other); end

  def to_a(); end
end

class Gem::Resolv::DNS::Name
  def self.create(arg); end
end

module Gem::Resolv::DNS::OpCode
  IQuery = ::T.let(nil, ::T.untyped)
  Notify = ::T.let(nil, ::T.untyped)
  Query = ::T.let(nil, ::T.untyped)
  Status = ::T.let(nil, ::T.untyped)
  Update = ::T.let(nil, ::T.untyped)
end

module Gem::Resolv::DNS::OpCode
end

class Gem::Resolv::DNS::Query
  def encode_rdata(msg); end
end

class Gem::Resolv::DNS::Query
  def self.decode_rdata(msg); end
end

module Gem::Resolv::DNS::RCode
  BADALG = ::T.let(nil, ::T.untyped)
  BADKEY = ::T.let(nil, ::T.untyped)
  BADMODE = ::T.let(nil, ::T.untyped)
  BADNAME = ::T.let(nil, ::T.untyped)
  BADSIG = ::T.let(nil, ::T.untyped)
  BADTIME = ::T.let(nil, ::T.untyped)
  BADVERS = ::T.let(nil, ::T.untyped)
  FormErr = ::T.let(nil, ::T.untyped)
  NXDomain = ::T.let(nil, ::T.untyped)
  NXRRSet = ::T.let(nil, ::T.untyped)
  NoError = ::T.let(nil, ::T.untyped)
  NotAuth = ::T.let(nil, ::T.untyped)
  NotImp = ::T.let(nil, ::T.untyped)
  NotZone = ::T.let(nil, ::T.untyped)
  Refused = ::T.let(nil, ::T.untyped)
  ServFail = ::T.let(nil, ::T.untyped)
  YXDomain = ::T.let(nil, ::T.untyped)
  YXRRSet = ::T.let(nil, ::T.untyped)
end

module Gem::Resolv::DNS::RCode
end

class Gem::Resolv::DNS::Requester
  def close(); end

  def request(sender, tout); end

  def sender_for(addr, msg); end
end

class Gem::Resolv::DNS::Requester::ConnectedUDP
  def initialize(host, port=T.unsafe(nil)); end

  def lazy_initialize(); end

  def recv_reply(readable_socks); end

  def sender(msg, data, host=T.unsafe(nil), port=T.unsafe(nil)); end
end

class Gem::Resolv::DNS::Requester::ConnectedUDP::Sender
  def data(); end

  def send(); end
end

class Gem::Resolv::DNS::Requester::ConnectedUDP::Sender
end

class Gem::Resolv::DNS::Requester::ConnectedUDP
end

class Gem::Resolv::DNS::Requester::MDNSOneShot
end

class Gem::Resolv::DNS::Requester::MDNSOneShot
end

class Gem::Resolv::DNS::Requester::RequestError
end

class Gem::Resolv::DNS::Requester::RequestError
end

class Gem::Resolv::DNS::Requester::Sender
  def initialize(msg, data, sock); end
end

class Gem::Resolv::DNS::Requester::Sender
end

class Gem::Resolv::DNS::Requester::TCP
  def initialize(host, port=T.unsafe(nil)); end

  def recv_reply(readable_socks); end

  def sender(msg, data, host=T.unsafe(nil), port=T.unsafe(nil)); end
end

class Gem::Resolv::DNS::Requester::TCP::Sender
  def data(); end

  def send(); end
end

class Gem::Resolv::DNS::Requester::TCP::Sender
end

class Gem::Resolv::DNS::Requester::TCP
end

class Gem::Resolv::DNS::Requester::UnconnectedUDP
  def initialize(*nameserver_port); end

  def lazy_initialize(); end

  def recv_reply(readable_socks); end

  def sender(msg, data, host, port=T.unsafe(nil)); end
end

class Gem::Resolv::DNS::Requester::UnconnectedUDP::Sender
  def data(); end

  def initialize(msg, data, sock, host, port); end

  def send(); end
end

class Gem::Resolv::DNS::Requester::UnconnectedUDP::Sender
end

class Gem::Resolv::DNS::Requester::UnconnectedUDP
end

class Gem::Resolv::DNS::Requester
end

class Gem::Resolv::DNS::Resource
  def ==(other); end

  def eql?(other); end

  def ttl(); end
  ClassHash = ::T.let(nil, ::T.untyped)
  ClassInsensitiveTypes = ::T.let(nil, ::T.untyped)
  ClassValue = ::T.let(nil, ::T.untyped)
end

class Gem::Resolv::DNS::Resource::ANY
  TypeValue = ::T.let(nil, ::T.untyped)
end

class Gem::Resolv::DNS::Resource::ANY
end

class Gem::Resolv::DNS::Resource::CNAME
  TypeValue = ::T.let(nil, ::T.untyped)
end

class Gem::Resolv::DNS::Resource::CNAME
end

class Gem::Resolv::DNS::Resource::DomainName
  def initialize(name); end

  def name(); end
end

class Gem::Resolv::DNS::Resource::DomainName
end

class Gem::Resolv::DNS::Resource::Generic
  def data(); end

  def initialize(data); end
end

class Gem::Resolv::DNS::Resource::Generic
  def self.create(type_value, class_value); end
end

class Gem::Resolv::DNS::Resource::HINFO
  def cpu(); end

  def initialize(cpu, os); end

  def os(); end
  TypeValue = ::T.let(nil, ::T.untyped)
end

class Gem::Resolv::DNS::Resource::HINFO
end

module Gem::Resolv::DNS::Resource::IN
  ClassValue = ::T.let(nil, ::T.untyped)
end

class Gem::Resolv::DNS::Resource::IN::A
  def address(); end

  def initialize(address); end
  ClassValue = ::T.let(nil, ::T.untyped)
  TypeValue = ::T.let(nil, ::T.untyped)
end

class Gem::Resolv::DNS::Resource::IN::A
end

class Gem::Resolv::DNS::Resource::IN::AAAA
  def address(); end

  def initialize(address); end
  ClassValue = ::T.let(nil, ::T.untyped)
  TypeValue = ::T.let(nil, ::T.untyped)
end

class Gem::Resolv::DNS::Resource::IN::AAAA
end

class Gem::Resolv::DNS::Resource::IN::ANY
  ClassValue = ::T.let(nil, ::T.untyped)
  TypeValue = ::T.let(nil, ::T.untyped)
end

class Gem::Resolv::DNS::Resource::IN::ANY
end

class Gem::Resolv::DNS::Resource::IN::CNAME
  ClassValue = ::T.let(nil, ::T.untyped)
  TypeValue = ::T.let(nil, ::T.untyped)
end

class Gem::Resolv::DNS::Resource::IN::CNAME
end

class Gem::Resolv::DNS::Resource::IN::HINFO
  ClassValue = ::T.let(nil, ::T.untyped)
  TypeValue = ::T.let(nil, ::T.untyped)
end

class Gem::Resolv::DNS::Resource::IN::HINFO
end

class Gem::Resolv::DNS::Resource::IN::HTTPS
  ClassValue = ::T.let(nil, ::T.untyped)
  TypeValue = ::T.let(nil, ::T.untyped)
end

class Gem::Resolv::DNS::Resource::IN::HTTPS
end

class Gem::Resolv::DNS::Resource::IN::LOC
  ClassValue = ::T.let(nil, ::T.untyped)
  TypeValue = ::T.let(nil, ::T.untyped)
end

class Gem::Resolv::DNS::Resource::IN::LOC
end

class Gem::Resolv::DNS::Resource::IN::MINFO
  ClassValue = ::T.let(nil, ::T.untyped)
  TypeValue = ::T.let(nil, ::T.untyped)
end

class Gem::Resolv::DNS::Resource::IN::MINFO
end

class Gem::Resolv::DNS::Resource::IN::MX
  ClassValue = ::T.let(nil, ::T.untyped)
  TypeValue = ::T.let(nil, ::T.untyped)
end

class Gem::Resolv::DNS::Resource::IN::MX
end

class Gem::Resolv::DNS::Resource::IN::NS
  ClassValue = ::T.let(nil, ::T.untyped)
  TypeValue = ::T.let(nil, ::T.untyped)
end

class Gem::Resolv::DNS::Resource::IN::NS
end

class Gem::Resolv::DNS::Resource::IN::PTR
  ClassValue = ::T.let(nil, ::T.untyped)
  TypeValue = ::T.let(nil, ::T.untyped)
end

class Gem::Resolv::DNS::Resource::IN::PTR
end

class Gem::Resolv::DNS::Resource::IN::SOA
  ClassValue = ::T.let(nil, ::T.untyped)
  TypeValue = ::T.let(nil, ::T.untyped)
end

class Gem::Resolv::DNS::Resource::IN::SOA
end

class Gem::Resolv::DNS::Resource::IN::SRV
  def initialize(priority, weight, port, target); end

  def port(); end

  def priority(); end

  def target(); end

  def weight(); end
  ClassValue = ::T.let(nil, ::T.untyped)
  TypeValue = ::T.let(nil, ::T.untyped)
end

class Gem::Resolv::DNS::Resource::IN::SRV
end

class Gem::Resolv::DNS::Resource::IN::SVCB
  ClassValue = ::T.let(nil, ::T.untyped)
  TypeValue = ::T.let(nil, ::T.untyped)
end

class Gem::Resolv::DNS::Resource::IN::SVCB
end

class Gem::Resolv::DNS::Resource::IN::ServiceBinding
  def alias_mode?(); end

  def encode_rdata(msg); end

  def initialize(priority, target, params=T.unsafe(nil)); end

  def params(); end

  def priority(); end

  def service_mode?(); end

  def target(); end
end

class Gem::Resolv::DNS::Resource::IN::ServiceBinding
  def self.decode_rdata(msg); end
end

class Gem::Resolv::DNS::Resource::IN::TXT
  ClassValue = ::T.let(nil, ::T.untyped)
  TypeValue = ::T.let(nil, ::T.untyped)
end

class Gem::Resolv::DNS::Resource::IN::TXT
end

class Gem::Resolv::DNS::Resource::IN::WKS
  def address(); end

  def bitmap(); end

  def initialize(address, protocol, bitmap); end

  def protocol(); end
  ClassValue = ::T.let(nil, ::T.untyped)
  TypeValue = ::T.let(nil, ::T.untyped)
end

class Gem::Resolv::DNS::Resource::IN::WKS
end

module Gem::Resolv::DNS::Resource::IN
end

class Gem::Resolv::DNS::Resource::LOC
  def altitude(); end

  def hprecision(); end

  def initialize(version, ssize, hprecision, vprecision, latitude, longitude, altitude); end

  def latitude(); end

  def longitude(); end

  def ssize(); end

  def version(); end

  def vprecision(); end
  TypeValue = ::T.let(nil, ::T.untyped)
end

class Gem::Resolv::DNS::Resource::LOC
end

class Gem::Resolv::DNS::Resource::MINFO
  def emailbx(); end

  def initialize(rmailbx, emailbx); end

  def rmailbx(); end
  TypeValue = ::T.let(nil, ::T.untyped)
end

class Gem::Resolv::DNS::Resource::MINFO
end

class Gem::Resolv::DNS::Resource::MX
  def exchange(); end

  def initialize(preference, exchange); end

  def preference(); end
  TypeValue = ::T.let(nil, ::T.untyped)
end

class Gem::Resolv::DNS::Resource::MX
end

class Gem::Resolv::DNS::Resource::NS
  TypeValue = ::T.let(nil, ::T.untyped)
end

class Gem::Resolv::DNS::Resource::NS
end

class Gem::Resolv::DNS::Resource::PTR
  TypeValue = ::T.let(nil, ::T.untyped)
end

class Gem::Resolv::DNS::Resource::PTR
end

class Gem::Resolv::DNS::Resource::SOA
  def expire(); end

  def initialize(mname, rname, serial, refresh, retry_, expire, minimum); end

  def minimum(); end

  def mname(); end

  def refresh(); end

  def retry(); end

  def rname(); end

  def serial(); end
  TypeValue = ::T.let(nil, ::T.untyped)
end

class Gem::Resolv::DNS::Resource::SOA
end

class Gem::Resolv::DNS::Resource::TXT
  def data(); end

  def initialize(first_string, *rest_strings); end

  def strings(); end
  TypeValue = ::T.let(nil, ::T.untyped)
end

class Gem::Resolv::DNS::Resource::TXT
end

class Gem::Resolv::DNS::Resource
  def self.get_class(type_value, class_value); end
end

class Gem::Resolv::DNS::SvcParam
  ClassHash = ::T.let(nil, ::T.untyped)
end

class Gem::Resolv::DNS::SvcParam::ALPN
  def encode(msg); end

  def initialize(protocol_ids); end

  def protocol_ids(); end
  KeyName = ::T.let(nil, ::T.untyped)
  KeyNumber = ::T.let(nil, ::T.untyped)
end

class Gem::Resolv::DNS::SvcParam::ALPN
  def self.decode(msg); end
end

class Gem::Resolv::DNS::SvcParam::DoHPath
  def encode(msg); end

  def initialize(template); end

  def template(); end
  KeyName = ::T.let(nil, ::T.untyped)
  KeyNumber = ::T.let(nil, ::T.untyped)
end

class Gem::Resolv::DNS::SvcParam::DoHPath
  def self.decode(msg); end
end

class Gem::Resolv::DNS::SvcParam::Generic
  def encode(msg); end

  def initialize(value); end

  def value(); end
end

class Gem::Resolv::DNS::SvcParam::Generic
  def self.create(key_number); end

  def self.decode(msg); end
end

class Gem::Resolv::DNS::SvcParam::IPv4Hint
  def addresses(); end

  def encode(msg); end

  def initialize(addresses); end
  KeyName = ::T.let(nil, ::T.untyped)
  KeyNumber = ::T.let(nil, ::T.untyped)
end

class Gem::Resolv::DNS::SvcParam::IPv4Hint
  def self.decode(msg); end
end

class Gem::Resolv::DNS::SvcParam::IPv6Hint
  def addresses(); end

  def encode(msg); end

  def initialize(addresses); end
  KeyName = ::T.let(nil, ::T.untyped)
  KeyNumber = ::T.let(nil, ::T.untyped)
end

class Gem::Resolv::DNS::SvcParam::IPv6Hint
  def self.decode(msg); end
end

class Gem::Resolv::DNS::SvcParam::Mandatory
  def encode(msg); end

  def initialize(keys); end

  def keys(); end
  KeyName = ::T.let(nil, ::T.untyped)
  KeyNumber = ::T.let(nil, ::T.untyped)
end

class Gem::Resolv::DNS::SvcParam::Mandatory
  def self.decode(msg); end
end

class Gem::Resolv::DNS::SvcParam::NoDefaultALPN
  def encode(msg); end
  KeyName = ::T.let(nil, ::T.untyped)
  KeyNumber = ::T.let(nil, ::T.untyped)
end

class Gem::Resolv::DNS::SvcParam::NoDefaultALPN
  def self.decode(msg); end
end

class Gem::Resolv::DNS::SvcParam::Port
  def encode(msg); end

  def initialize(port); end

  def port(); end
  KeyName = ::T.let(nil, ::T.untyped)
  KeyNumber = ::T.let(nil, ::T.untyped)
end

class Gem::Resolv::DNS::SvcParam::Port
  def self.decode(msg); end
end

class Gem::Resolv::DNS::SvcParam
  def self.key_name(); end

  def self.key_number(); end
end

class Gem::Resolv::DNS::SvcParams
  include ::Enumerable
  def [](key); end

  def add(param); end

  def count(); end

  def delete(key); end

  def each(&block); end

  def empty?(); end

  def encode(msg); end

  def initialize(params=T.unsafe(nil)); end
end

class Gem::Resolv::DNS::SvcParams
  def self.decode(msg); end
end

class Gem::Resolv::DNS
  def self.allocate_request_id(host, port); end

  def self.bind_random_port(udpsock, bind_host=T.unsafe(nil)); end

  def self.free_request_id(host, port, id); end

  def self.open(*args); end

  def self.random(arg); end
end

class Gem::Resolv::Hosts
  def each_address(name, &proc); end

  def each_name(address, &proc); end

  def getaddress(name); end

  def getaddresses(name); end

  def getname(address); end

  def getnames(address); end

  def initialize(filename=T.unsafe(nil)); end

  def lazy_initialize(); end
  DefaultFileName = ::T.let(nil, ::T.untyped)
end

class Gem::Resolv::Hosts
end

class Gem::Resolv::IPv4
  def ==(other); end

  def address(); end

  def eql?(other); end

  def initialize(address); end

  def to_name(); end
  Regex = ::T.let(nil, ::T.untyped)
  Regex256 = ::T.let(nil, ::T.untyped)
end

class Gem::Resolv::IPv4
  def self.create(arg); end
end

class Gem::Resolv::IPv6
  def ==(other); end

  def address(); end

  def eql?(other); end

  def initialize(address); end

  def to_name(); end
  Regex = ::T.let(nil, ::T.untyped)
  Regex_6Hex4Dec = ::T.let(nil, ::T.untyped)
  Regex_8Hex = ::T.let(nil, ::T.untyped)
  Regex_8HexLinkLocal = ::T.let(nil, ::T.untyped)
  Regex_CompressedHex = ::T.let(nil, ::T.untyped)
  Regex_CompressedHex4Dec = ::T.let(nil, ::T.untyped)
  Regex_CompressedHexLinkLocal = ::T.let(nil, ::T.untyped)
end

class Gem::Resolv::IPv6
  def self.create(arg); end
end

module Gem::Resolv::LOC
end

class Gem::Resolv::LOC::Alt
  def ==(other); end

  def altitude(); end

  def eql?(other); end

  def initialize(altitude); end
  Regex = ::T.let(nil, ::T.untyped)
end

class Gem::Resolv::LOC::Alt
  def self.create(arg); end
end

class Gem::Resolv::LOC::Coord
  def ==(other); end

  def coordinates(); end

  def eql?(other); end

  def initialize(coordinates, orientation); end

  def orientation(); end
  Regex = ::T.let(nil, ::T.untyped)
end

class Gem::Resolv::LOC::Coord
  def self.create(arg); end
end

class Gem::Resolv::LOC::Size
  def ==(other); end

  def eql?(other); end

  def initialize(scalar); end

  def scalar(); end
  Regex = ::T.let(nil, ::T.untyped)
end

class Gem::Resolv::LOC::Size
  def self.create(arg); end
end

module Gem::Resolv::LOC
end

class Gem::Resolv::MDNS
  AddressV4 = ::T.let(nil, ::T.untyped)
  AddressV6 = ::T.let(nil, ::T.untyped)
  Addresses = ::T.let(nil, ::T.untyped)
  Port = ::T.let(nil, ::T.untyped)
end

class Gem::Resolv::MDNS
end

class Gem::Resolv::ResolvError
end

class Gem::Resolv::ResolvError
end

class Gem::Resolv::ResolvTimeout
end

class Gem::Resolv::ResolvTimeout
end

class Gem::Resolv
  def self.each_address(name, &block); end

  def self.each_name(address, &proc); end

  def self.getaddress(name); end

  def self.getaddresses(name); end

  def self.getname(address); end

  def self.getnames(address); end
end

class Gem::Resolver
  include ::Gem::Molinillo::UI
  include ::Gem::Molinillo::SpecificationProvider
end

class Gem::Resolver::APISet::GemParser
  def parse(line); end
end

class Gem::Resolver::APISet::GemParser
end

class Gem::Resolver::APISpecification
  def self.new(set, api_data); end
end

class Gem::Resolver::ActivationRequest
  def eql?(other); end
end

class Gem::Resolver::CurrentSet
end

class Gem::Resolver::CurrentSet
end

class Gem::Resolver::IndexSpecification
  def ==(other); end
end

class Gem::Resolver::InstallerSet
  def force(); end

  def force=(force); end
end

class Gem::Resolver::LocalSpecification
end

class Gem::Resolver::LocalSpecification
end

class Gem::Resolver::Specification
  def required_ruby_version(); end

  def required_rubygems_version(); end
end

class Gem::RuntimeRequirementNotMetError
  def suggestion(); end

  def suggestion=(suggestion); end
end

class Gem::RuntimeRequirementNotMetError
end

class Gem::SpecFetcher
  include ::Gem::UserInteraction
  include ::Gem::DefaultUserInteraction
  include ::Gem::Text
  def available_specs(type); end

  def detect(type=T.unsafe(nil)); end

  def initialize(sources=T.unsafe(nil)); end

  def latest_specs(); end

  def prerelease_specs(); end

  def search_for_dependency(dependency, matching_platform=T.unsafe(nil)); end

  def sources(); end

  def spec_for_dependency(dependency, matching_platform=T.unsafe(nil)); end

  def specs(); end

  def suggest_gems_from_name(gem_name, type=T.unsafe(nil), num_results=T.unsafe(nil)); end

  def tuples_for(source, type, gracefully_ignore=T.unsafe(nil)); end
end

class Gem::SpecFetcher
  def self.fetcher(); end

  def self.fetcher=(fetcher); end
end

class Gem::Specification
  include ::Bundler::MatchMetadata
  include ::Bundler::MatchPlatform
  include ::Bundler::GemHelpers
  def _deprecated_validate_dependencies(); end

  def _deprecated_validate_metadata(); end

  def _deprecated_validate_permissions(); end

  def deleted_gem?(); end

  def flatten_require_paths(); end

  def removed_method_calls(); end

  def to_ruby(); end
  LATEST_RUBY_WITHOUT_PATCH_VERSIONS = ::T.let(nil, ::T.untyped)
  REMOVED_METHODS = ::T.let(nil, ::T.untyped)
end

class Gem::Specification
  extend ::Gem::Deprecate
  extend ::Enumerable
  def self.add_spec(spec); end

  def self.find_by_full_name(full_name); end

  def self.gemspec_stubs_in(dir, pattern); end

  def self.latest_spec_for(name); end

  def self.remove_spec(spec); end

  def self.specification_record(); end

  def self.stubs_for_pattern(pattern, match_platform=T.unsafe(nil)); end
end

class Gem::SpecificationPolicy
  include ::Gem::UserInteraction
  include ::Gem::DefaultUserInteraction
  include ::Gem::Text
  def initialize(specification); end

  def packaging(); end

  def packaging=(packaging); end

  def validate(strict=T.unsafe(nil)); end

  def validate_dependencies(); end

  def validate_duplicate_dependencies(); end

  def validate_metadata(); end

  def validate_optional(strict); end

  def validate_permissions(); end

  def validate_required!(); end

  def validate_required_ruby_version(); end
  HOMEPAGE_URI_PATTERN = ::T.let(nil, ::T.untyped)
  LAZY = ::T.let(nil, ::T.untyped)
  LAZY_PATTERN = ::T.let(nil, ::T.untyped)
  METADATA_LINK_KEYS = ::T.let(nil, ::T.untyped)
  SPECIAL_CHARACTERS = ::T.let(nil, ::T.untyped)
  VALID_NAME_PATTERN = ::T.let(nil, ::T.untyped)
  VALID_URI_PATTERN = ::T.let(nil, ::T.untyped)
end

class Gem::SpecificationPolicy
end

class Gem::SpecificationRecord
  include ::Enumerable
  def add_spec(spec); end

  def all(); end

  def all=(specs); end

  def all_names(); end

  def each(&blk); end

  def find_active_stub_by_path(path); end

  def find_all_by_name(name, *requirements); end

  def find_by_path(path); end

  def find_inactive_by_path(path); end

  def initialize(dirs); end

  def latest_spec_for(name); end

  def latest_specs(prerelease); end

  def remove_spec(spec); end

  def stubs(); end

  def stubs_for(name); end

  def stubs_for_pattern(pattern, match_platform=T.unsafe(nil)); end
end

class Gem::SpecificationRecord
  def self.dirs_from(paths); end

  def self.from_path(path); end
end

class Gem::StubSpecification
  include ::Gem::BetterPermissionError
  def build_extensions(); end

  def extensions(); end

  def initialize(filename, base_dir, gems_dir, default_gem); end

  def missing_extensions?(); end

  def spec(); end

  def valid?(); end
end

class Gem::StubSpecification::StubLine
  def extensions(); end

  def full_name(); end

  def initialize(data, extensions); end

  def name(); end

  def platform(); end

  def require_paths(); end

  def version(); end
end

class Gem::StubSpecification
  def self.default_gemspec_stub(filename, base_dir, gems_dir); end

  def self.gemspec_stub(filename, base_dir, gems_dir); end
end

module Gem::TSort
  def each_strongly_connected_component(&block); end

  def each_strongly_connected_component_from(node, id_map=T.unsafe(nil), stack=T.unsafe(nil), &block); end

  def strongly_connected_components(); end

  def tsort(); end

  def tsort_each(&block); end

  def tsort_each_child(node); end

  def tsort_each_node(); end
  VERSION = ::T.let(nil, ::T.untyped)
end

module Gem::TSort
  def self.each_strongly_connected_component(each_node, each_child); end

  def self.each_strongly_connected_component_from(node, each_child, id_map=T.unsafe(nil), stack=T.unsafe(nil)); end

  def self.strongly_connected_components(each_node, each_child); end

  def self.tsort(each_node, each_child); end

  def self.tsort_each(each_node, each_child); end
end

module Gem::Timeout
  VERSION = ::T.let(nil, ::T.untyped)
end

class Gem::Timeout::Error
end

class Gem::Timeout::Error
  def self.handle_timeout(message); end
end

class Gem::Timeout::ExitException
  def exception(*arg); end
end

class Gem::Timeout::ExitException
end

module Gem::Timeout
  def self.ensure_timeout_thread_created(); end

  def self.timeout(sec, klass=T.unsafe(nil), message=T.unsafe(nil), &block); end
end

module Gem::URI
  include ::Gem::URI::RFC2396_REGEXP
  ABS_PATH = ::T.let(nil, ::T.untyped)
  ABS_URI = ::T.let(nil, ::T.untyped)
  ABS_URI_REF = ::T.let(nil, ::T.untyped)
  DEFAULT_PARSER = ::T.let(nil, ::T.untyped)
  ESCAPED = ::T.let(nil, ::T.untyped)
  FRAGMENT = ::T.let(nil, ::T.untyped)
  HOST = ::T.let(nil, ::T.untyped)
  OPAQUE = ::T.let(nil, ::T.untyped)
  PORT = ::T.let(nil, ::T.untyped)
  QUERY = ::T.let(nil, ::T.untyped)
  REGISTRY = ::T.let(nil, ::T.untyped)
  REL_PATH = ::T.let(nil, ::T.untyped)
  REL_URI = ::T.let(nil, ::T.untyped)
  REL_URI_REF = ::T.let(nil, ::T.untyped)
  RFC3986_PARSER = ::T.let(nil, ::T.untyped)
  SCHEME = ::T.let(nil, ::T.untyped)
  TBLDECWWWCOMP_ = ::T.let(nil, ::T.untyped)
  TBLENCURICOMP_ = ::T.let(nil, ::T.untyped)
  TBLENCWWWCOMP_ = ::T.let(nil, ::T.untyped)
  UNSAFE = ::T.let(nil, ::T.untyped)
  URI_REF = ::T.let(nil, ::T.untyped)
  USERINFO = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
  VERSION_CODE = ::T.let(nil, ::T.untyped)
  WEB_ENCODINGS_ = ::T.let(nil, ::T.untyped)
end

class Gem::URI::BadURIError
end

class Gem::URI::BadURIError
end

class Gem::URI::Error
end

class Gem::URI::Error
end

class Gem::URI::FTP
  def set_typecode(v); end

  def typecode(); end

  def typecode=(typecode); end
  COMPONENT = ::T.let(nil, ::T.untyped)
  DEFAULT_PORT = ::T.let(nil, ::T.untyped)
  TYPECODE = ::T.let(nil, ::T.untyped)
  TYPECODE_PREFIX = ::T.let(nil, ::T.untyped)
end

class Gem::URI::FTP
  def self.new2(user, password, host, port, path, typecode=T.unsafe(nil), arg_check=T.unsafe(nil)); end
end

class Gem::URI::File
  def check_password(user); end

  def check_user(user); end

  def check_userinfo(user); end

  def set_userinfo(v); end
  COMPONENT = ::T.let(nil, ::T.untyped)
  DEFAULT_PORT = ::T.let(nil, ::T.untyped)
end

class Gem::URI::File
end

class Gem::URI::Generic
  include ::Gem::URI
  include ::Gem::URI::RFC2396_REGEXP
  def +(oth); end

  def -(oth); end

  def ==(oth); end

  def absolute(); end

  def absolute?(); end

  def coerce(oth); end

  def component(); end

  def component_ary(); end

  def decoded_password(); end

  def decoded_user(); end

  def default_port(); end

  def eql?(oth); end

  def find_proxy(env=T.unsafe(nil)); end

  def fragment(); end

  def fragment=(v); end

  def hierarchical?(); end

  def host(); end

  def host=(v); end

  def hostname(); end

  def hostname=(v); end

  def initialize(scheme, userinfo, host, port, registry, path, opaque, query, fragment, parser=T.unsafe(nil), arg_check=T.unsafe(nil)); end

  def merge(oth); end

  def merge!(oth); end

  def normalize(); end

  def normalize!(); end

  def opaque(); end

  def opaque=(v); end

  def parser(); end

  def password(); end

  def password=(password); end

  def path(); end

  def path=(v); end

  def port(); end

  def port=(v); end

  def query(); end

  def query=(v); end

  def registry(); end

  def registry=(v); end

  def relative?(); end

  def route_from(oth); end

  def route_to(oth); end

  def scheme(); end

  def scheme=(v); end

  def select(*components); end

  def set_host(v); end

  def set_opaque(v); end

  def set_password(v); end

  def set_path(v); end

  def set_port(v); end

  def set_registry(v); end

  def set_scheme(v); end

  def set_user(v); end

  def set_userinfo(user, password=T.unsafe(nil)); end

  def to_str(); end

  def user(); end

  def user=(user); end

  def userinfo(); end

  def userinfo=(userinfo); end
  COMPONENT = ::T.let(nil, ::T.untyped)
  DEFAULT_PORT = ::T.let(nil, ::T.untyped)
  USE_REGISTRY = ::T.let(nil, ::T.untyped)
end

class Gem::URI::Generic
  def self.build(args); end

  def self.build2(args); end

  def self.component(); end

  def self.default_port(); end

  def self.use_proxy?(hostname, addr, port, no_proxy); end

  def self.use_registry(); end
end

class Gem::URI::HTTP
  def authority(); end

  def origin(); end

  def request_uri(); end
  COMPONENT = ::T.let(nil, ::T.untyped)
  DEFAULT_PORT = ::T.let(nil, ::T.untyped)
end

class Gem::URI::HTTP
end

class Gem::URI::HTTPS
  DEFAULT_PORT = ::T.let(nil, ::T.untyped)
end

class Gem::URI::HTTPS
end

class Gem::URI::InvalidComponentError
end

class Gem::URI::InvalidComponentError
end

class Gem::URI::InvalidURIError
end

class Gem::URI::InvalidURIError
end

class Gem::URI::LDAP
  def attributes(); end

  def attributes=(val); end

  def dn(); end

  def dn=(val); end

  def extensions(); end

  def extensions=(val); end

  def filter(); end

  def filter=(val); end

  def initialize(*arg); end

  def scope(); end

  def scope=(val); end

  def set_attributes(val); end

  def set_dn(val); end

  def set_extensions(val); end

  def set_filter(val); end

  def set_scope(val); end
  COMPONENT = ::T.let(nil, ::T.untyped)
  DEFAULT_PORT = ::T.let(nil, ::T.untyped)
  SCOPE = ::T.let(nil, ::T.untyped)
  SCOPE_BASE = ::T.let(nil, ::T.untyped)
  SCOPE_ONE = ::T.let(nil, ::T.untyped)
  SCOPE_SUB = ::T.let(nil, ::T.untyped)
end

class Gem::URI::LDAP
end

class Gem::URI::LDAPS
  DEFAULT_PORT = ::T.let(nil, ::T.untyped)
end

class Gem::URI::LDAPS
end

class Gem::URI::MailTo
  def headers(); end

  def headers=(v); end

  def initialize(*arg); end

  def set_headers(v); end

  def set_to(v); end

  def to(); end

  def to=(v); end

  def to_mailtext(); end

  def to_rfc822text(); end
  COMPONENT = ::T.let(nil, ::T.untyped)
  DEFAULT_PORT = ::T.let(nil, ::T.untyped)
  EMAIL_REGEXP = ::T.let(nil, ::T.untyped)
  HEADER_REGEXP = ::T.let(nil, ::T.untyped)
end

class Gem::URI::MailTo
end

Gem::URI::Parser = Gem::URI::RFC2396_Parser

Gem::URI::REGEXP = Gem::URI::RFC2396_REGEXP

class Gem::URI::RFC2396_Parser
  include ::Gem::URI::RFC2396_REGEXP
  def escape(str, unsafe=T.unsafe(nil)); end

  def extract(str, schemes=T.unsafe(nil)); end

  def initialize(opts=T.unsafe(nil)); end

  def join(*uris); end

  def make_regexp(schemes=T.unsafe(nil)); end

  def parse(uri); end

  def pattern(); end

  def regexp(); end

  def split(uri); end

  def unescape(str, escaped=T.unsafe(nil)); end
end

class Gem::URI::RFC2396_Parser
end

module Gem::URI::RFC2396_REGEXP
end

module Gem::URI::RFC2396_REGEXP::PATTERN
  ABS_PATH = ::T.let(nil, ::T.untyped)
  ABS_URI = ::T.let(nil, ::T.untyped)
  ALNUM = ::T.let(nil, ::T.untyped)
  ALPHA = ::T.let(nil, ::T.untyped)
  DOMLABEL = ::T.let(nil, ::T.untyped)
  ESCAPED = ::T.let(nil, ::T.untyped)
  FRAGMENT = ::T.let(nil, ::T.untyped)
  HEX = ::T.let(nil, ::T.untyped)
  HIER_PART = ::T.let(nil, ::T.untyped)
  HOST = ::T.let(nil, ::T.untyped)
  HOSTNAME = ::T.let(nil, ::T.untyped)
  HOSTPORT = ::T.let(nil, ::T.untyped)
  IPV4ADDR = ::T.let(nil, ::T.untyped)
  IPV6ADDR = ::T.let(nil, ::T.untyped)
  IPV6REF = ::T.let(nil, ::T.untyped)
  NET_PATH = ::T.let(nil, ::T.untyped)
  OPAQUE_PART = ::T.let(nil, ::T.untyped)
  PATH_SEGMENTS = ::T.let(nil, ::T.untyped)
  PORT = ::T.let(nil, ::T.untyped)
  QUERY = ::T.let(nil, ::T.untyped)
  REG_NAME = ::T.let(nil, ::T.untyped)
  REL_PATH = ::T.let(nil, ::T.untyped)
  REL_SEGMENT = ::T.let(nil, ::T.untyped)
  REL_URI = ::T.let(nil, ::T.untyped)
  RESERVED = ::T.let(nil, ::T.untyped)
  SCHEME = ::T.let(nil, ::T.untyped)
  TOPLABEL = ::T.let(nil, ::T.untyped)
  UNRESERVED = ::T.let(nil, ::T.untyped)
  URIC = ::T.let(nil, ::T.untyped)
  URIC_NO_SLASH = ::T.let(nil, ::T.untyped)
  URI_REF = ::T.let(nil, ::T.untyped)
  USERINFO = ::T.let(nil, ::T.untyped)
  X_ABS_URI = ::T.let(nil, ::T.untyped)
  X_REL_URI = ::T.let(nil, ::T.untyped)
end

module Gem::URI::RFC2396_REGEXP::PATTERN
end

module Gem::URI::RFC2396_REGEXP
end

class Gem::URI::RFC3986_Parser
  def join(*uris); end

  def parse(uri); end

  def regexp(); end

  def split(uri); end
  FRAGMENT = ::T.let(nil, ::T.untyped)
  HOST = ::T.let(nil, ::T.untyped)
  RFC3986_URI = ::T.let(nil, ::T.untyped)
  RFC3986_relative_ref = ::T.let(nil, ::T.untyped)
  SCHEME = ::T.let(nil, ::T.untyped)
  SEG = ::T.let(nil, ::T.untyped)
  SEG_NC = ::T.let(nil, ::T.untyped)
  USERINFO = ::T.let(nil, ::T.untyped)
end

class Gem::URI::RFC3986_Parser
end

module Gem::URI::Util
end

module Gem::URI::Util
  def self.make_components_hash(klass, array_hash); end
end

class Gem::URI::WS
  def request_uri(); end
  COMPONENT = ::T.let(nil, ::T.untyped)
  DEFAULT_PORT = ::T.let(nil, ::T.untyped)
end

class Gem::URI::WS
end

class Gem::URI::WSS
  DEFAULT_PORT = ::T.let(nil, ::T.untyped)
end

class Gem::URI::WSS
end

module Gem::URI
  def self.decode_uri_component(str, enc=T.unsafe(nil)); end

  def self.decode_www_form(str, enc=T.unsafe(nil), separator: T.unsafe(nil), use__charset_: T.unsafe(nil), isindex: T.unsafe(nil)); end

  def self.decode_www_form_component(str, enc=T.unsafe(nil)); end

  def self.encode_uri_component(str, enc=T.unsafe(nil)); end

  def self.encode_www_form(enum, enc=T.unsafe(nil)); end

  def self.encode_www_form_component(str, enc=T.unsafe(nil)); end

  def self.extract(str, schemes=T.unsafe(nil), &block); end

  def self.for(scheme, *arguments, default: T.unsafe(nil)); end

  def self.get_encoding(label); end

  def self.join(*str); end

  def self.parse(uri); end

  def self.regexp(schemes=T.unsafe(nil)); end

  def self.register_scheme(scheme, klass); end

  def self.scheme_list(); end

  def self.split(uri); end
end

class Gem::UninstallError
  def spec(); end

  def spec=(spec); end
end

class Gem::UninstallError
end

class Gem::UnknownCommandError
  def initialize(unknown_command); end

  def unknown_command(); end
end

class Gem::UnknownCommandError
  def self.attach_correctable(); end
end

class Gem::UnknownCommandSpellChecker
  def corrections(); end

  def error(); end

  def initialize(error); end
end

class Gem::UnknownCommandSpellChecker
end

Gem::UnsatisfiableDepedencyError = Gem::UnsatisfiableDependencyError

module Gem::Util
  def self._deprecated_silent_system(*command); end
end

class Gem::Version
  def partition_segments(ver); end
end

Gem::Version::Requirement = Gem::Requirement

class Gem::WebauthnVerificationError
  def initialize(message); end
end

class Gem::WebauthnVerificationError
end

module Gem::YAMLSerializer
  ARRAY_REGEX = ::T.let(nil, ::T.untyped)
  HASH_REGEX = ::T.let(nil, ::T.untyped)
end

module Gem::YAMLSerializer
  def self.dump(hash); end

  def self.load(str); end

  def self.strip_comment(val); end
end

module Gem
  def self.activated_gem_paths(); end

  def self.cache_home(); end

  def self.config_home(); end

  def self.data_home(); end

  def self.default_user_install(); end

  def self.disable_system_update_message(); end

  def self.disable_system_update_message=(disable_system_update_message); end

  def self.discover_gems_on_require(); end

  def self.discover_gems_on_require=(discover_gems_on_require); end

  def self.dynamic_library_suffixes(); end

  def self.find_config_file(); end

  def self.find_default_spec(path); end

  def self.freebsd_platform?(); end

  def self.load_safe_marshal(); end

  def self.open_file(path, flags, &block); end

  def self.plugin_suffix_pattern(); end

  def self.plugin_suffix_regexp(); end

  def self.plugindir(install_dir=T.unsafe(nil)); end

  def self.solaris_platform?(); end

  def self.state_file(); end

  def self.state_home(); end
end

class Geocoder::Configuration
  def self.initialize(); end
end

class Geocoder::Lookup::MaxmindLocal
  extend ::T::Private::Methods::MethodHooks
  extend ::T::Private::Methods::SingletonMethodHooks
end

class Geocoder::Result::MaxmindLocal
  def city(); end

  def ip(); end

  def postal_code(); end
end

class Geocoder::Result::MaxmindLocal
  def self.response_attributes(); end
end

module Geocoder::Sql
  def approx_bearing(latitude, longitude, lat_attr, lon_attr, options=T.unsafe(nil)); end

  def approx_distance(latitude, longitude, lat_attr, lon_attr, options=T.unsafe(nil)); end

  def full_bearing(latitude, longitude, lat_attr, lon_attr, options=T.unsafe(nil)); end

  def full_distance(latitude, longitude, lat_attr, lon_attr, options=T.unsafe(nil)); end

  def within_bounding_box(sw_lat, sw_lng, ne_lat, ne_lng, lat_attr, lon_attr); end
end

module Geocoder::Sql
  extend ::Geocoder::Sql
end

module Geocoder::Store
end

module Geocoder::Store::ActiveRecord
  include ::Geocoder::Store::Base
  def fetch_address(); end

  def fetch_coordinates(); end

  def geocode(); end

  def nearbys(radius=T.unsafe(nil), options=T.unsafe(nil)); end

  def reverse_geocode(); end
end

module Geocoder::Store::ActiveRecord::ClassMethods
  def add_exclude_condition(conditions, exclude); end

  def bearing_sql(latitude, longitude, options=T.unsafe(nil)); end

  def distance_from_sql(location, *args); end

  def distance_sql(latitude, longitude, options=T.unsafe(nil)); end

  def false_condition(); end

  def full_column_name(column); end

  def near_scope_options(latitude, longitude, radius=T.unsafe(nil), options=T.unsafe(nil)); end

  def null_value(); end

  def select_clause(columns, distance=T.unsafe(nil), bearing=T.unsafe(nil), distance_column=T.unsafe(nil), bearing_column=T.unsafe(nil)); end

  def using_postgres?(); end

  def using_sqlite?(); end

  def using_sqlite_with_extensions?(); end

  def using_unextended_sqlite?(); end
end

module Geocoder::Store::ActiveRecord::ClassMethods
end

module Geocoder::Store::ActiveRecord
  def self.included(base); end
end

module Geocoder::Store::Base
  def bearing_from(point, options=T.unsafe(nil)); end

  def bearing_to(point, options=T.unsafe(nil)); end

  def distance_from(point, units=T.unsafe(nil)); end

  def distance_to(point, units=T.unsafe(nil)); end

  def geocode(); end

  def geocoded?(); end

  def reverse_geocode(); end

  def to_coordinates(); end
end

module Geocoder::Store::Base
end

module Geocoder::Store
end

module GlobalID::FixtureSet
  def global_id(fixture_set_name, label, column_type: T.unsafe(nil), **options); end

  def signed_global_id(fixture_set_name, label, column_type: T.unsafe(nil), **options); end
end

module GlobalID::FixtureSet
end

class Group
  def autosave_associated_records_for_group_servers(*args); end

  def autosave_associated_records_for_group_users(*args); end

  def autosave_associated_records_for_servers(*args); end

  def autosave_associated_records_for_users(*args); end

  def validate_associated_records_for_group_servers(*args); end

  def validate_associated_records_for_group_users(*args); end

  def validate_associated_records_for_servers(*args); end

  def validate_associated_records_for_users(*args); end
end

module Group::GeneratedAttributeMethods
  def clear_created_at_change(); end

  def clear_id_change(); end

  def clear_id_value_change(); end

  def clear_name_change(); end

  def clear_updated_at_change(); end

  def created_at_for_database(); end

  def id_value_for_database(); end

  def name_for_database(); end

  def updated_at_for_database(); end
end

class Group
  extend ::T::Private::Methods::MethodHooks
  extend ::T::Private::Methods::SingletonMethodHooks
end

class GroupServer
  def autosave_associated_records_for_group(*args); end

  def autosave_associated_records_for_server(*args); end
end

class GroupUser
  def autosave_associated_records_for_group(*args); end

  def autosave_associated_records_for_user(*args); end
end

class HTTP::Response::Status
  RUBYGEMS_ACTIVATION_MONITOR = ::T.let(nil, ::T.untyped)
end

module Haml::RailsHelpers
  include ::Haml::Helpers
  def capture_haml(*args, &block); end

  def find_and_preserve(input=T.unsafe(nil), tags=T.unsafe(nil), &block); end

  def precede(str, &block); end

  def preserve(input=T.unsafe(nil), &block); end

  def succeed(str, &block); end

  def surround(front, back=T.unsafe(nil), &block); end
  DEFAULT_PRESERVE_TAGS = ::T.let(nil, ::T.untyped)
end

module Haml::RailsHelpers
  extend ::Haml::RailsHelpers
  extend ::Haml::Helpers
end

class Haml::RailsTemplate
  def call(template, source=T.unsafe(nil)); end

  def supports_streaming?(); end
end

class Haml::RailsTemplate
  def self.options(); end

  def self.set_options(opts); end
end

class Hash
  def deconstruct_keys(arg); end
end

class Hash
  def self.ruby2_keywords_hash(arg); end

  def self.ruby2_keywords_hash?(arg); end
end

module Hashie::Extensions::ActiveSupport
end

module Hashie::Extensions::ActiveSupport::CoreExt
end

module Hashie::Extensions::ActiveSupport::CoreExt::Hash
  def except(*keys); end
end

module Hashie::Extensions::ActiveSupport::CoreExt::Hash
end

module Hashie::Extensions::ActiveSupport::CoreExt
end

module Hashie::Extensions::ActiveSupport
end

class Hashie::Mash
  include ::Hashie::Extensions::ActiveSupport::CoreExt::Hash
end

module Hive
end

class Hive::GeoIP2
  def close(); end

  def closed?(); end

  def initialize(arg); end

  def lookup(arg); end
end

class Hive::GeoIP2
  def self.lookup(arg, arg1); end
end

module Hive
end

class I18n::Backend::Simple
  include ::I18n::Backend::Fallbacks
end

class IO
  def beep(); end

  def check_winsize_changed(); end

  def clear_screen(); end

  def console_mode(); end

  def console_mode=(console_mode); end

  def cooked(); end

  def cooked!(); end

  def cursor(); end

  def cursor=(cursor); end

  def cursor_down(arg); end

  def cursor_left(arg); end

  def cursor_right(arg); end

  def cursor_up(arg); end

  def echo=(echo); end

  def echo?(); end

  def erase_line(arg); end

  def erase_screen(arg); end

  def getch(*arg); end

  def getpass(*arg); end

  def goto(arg, arg1); end

  def goto_column(arg); end

  def iflush(); end

  def ioflush(); end

  def noecho(); end

  def nonblock(*arg); end

  def nonblock=(nonblock); end

  def nonblock?(); end

  def nread(); end

  def oflush(); end

  def path(); end

  def pathconf(arg); end

  def pressed?(); end

  def raw(*arg); end

  def raw!(*arg); end

  def ready?(); end

  def scroll_backward(arg); end

  def scroll_forward(arg); end

  def timeout(); end

  def timeout=(timeout); end

  def to_path(); end

  def wait(*arg); end

  def wait_priority(*arg); end

  def wait_readable(*arg); end

  def wait_writable(*arg); end

  def winsize(); end

  def winsize=(winsize); end
end

class IO::ConsoleMode
  VERSION = ::T.let(nil, ::T.untyped)
end

class IO
  def self.console(*arg); end

  def self.console_size(); end

  def self.default_console_size(); end

  def self.new(*arg); end
end

class IPAddr
  def ==(other); end

  def begin_addr(); end

  def end_addr(); end

  def initialize(addr=T.unsafe(nil), family=T.unsafe(nil)); end

  def netmask(); end

  def zone_id(); end

  def zone_id=(zid); end
  VERSION = ::T.let(nil, ::T.untyped)
end

module IRB
  IRBRC_EXT = ::T.let(nil, ::T.untyped)
  TOPLEVEL_BINDING = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

class IRB::BaseCompletor
  def command_candidates(target); end

  def completion_candidates(preposing, target, postposing, bind:); end

  def doc_namespace(preposing, matched, postposing, bind:); end

  def retrieve_files_to_require_from_load_path(); end

  def retrieve_files_to_require_relative_from_current_dir(); end

  def retrieve_gem_and_system_load_path(); end
  GEM_PATHS = ::T.let(nil, ::T.untyped)
  HELP_COMMAND_PREPOSING = ::T.let(nil, ::T.untyped)
  ReservedWords = ::T.let(nil, ::T.untyped)
end

class IRB::BaseCompletor
end

module IRB::Color
  BLACK = ::T.let(nil, ::T.untyped)
  BLUE = ::T.let(nil, ::T.untyped)
  BOLD = ::T.let(nil, ::T.untyped)
  CLEAR = ::T.let(nil, ::T.untyped)
  CYAN = ::T.let(nil, ::T.untyped)
  GREEN = ::T.let(nil, ::T.untyped)
  MAGENTA = ::T.let(nil, ::T.untyped)
  RED = ::T.let(nil, ::T.untyped)
  REVERSE = ::T.let(nil, ::T.untyped)
  UNDERLINE = ::T.let(nil, ::T.untyped)
  WHITE = ::T.let(nil, ::T.untyped)
  YELLOW = ::T.let(nil, ::T.untyped)
end

module IRB::Color
  def self.clear(colorable: T.unsafe(nil)); end

  def self.colorable?(); end

  def self.colorize(text, seq, colorable: T.unsafe(nil)); end

  def self.colorize_code(code, complete: T.unsafe(nil), ignore_error: T.unsafe(nil), colorable: T.unsafe(nil), local_variables: T.unsafe(nil)); end

  def self.inspect_colorable?(obj, seen: T.unsafe(nil)); end
end

module IRB::Command
  NO_OVERRIDE = ::T.let(nil, ::T.untyped)
  OVERRIDE_ALL = ::T.let(nil, ::T.untyped)
  OVERRIDE_PRIVATE_ONLY = ::T.let(nil, ::T.untyped)
end

class IRB::Command::Backtrace
  def execute(arg); end
end

class IRB::Command::Backtrace
end

class IRB::Command::Base
  def execute(arg); end

  def initialize(irb_context); end

  def irb_context(); end
end

class IRB::Command::Base
  def self.execute(irb_context, arg); end
end

class IRB::Command::Break
  def execute(arg); end
end

class IRB::Command::Break
end

class IRB::Command::CD
end

class IRB::Command::CD
end

class IRB::Command::Catch
  def execute(arg); end
end

class IRB::Command::Catch
end

class IRB::Command::ChangeWorkspace
end

class IRB::Command::ChangeWorkspace
end

class IRB::Command::CommandArgumentError
end

class IRB::Command::CommandArgumentError
end

class IRB::Command::Context
  def execute(_arg); end
end

class IRB::Command::Context
end

class IRB::Command::Continue
  def execute(arg); end
end

class IRB::Command::Continue
end

class IRB::Command::CurrentWorkingWorkspace
  def execute(_arg); end
end

class IRB::Command::CurrentWorkingWorkspace
end

class IRB::Command::Debug
  def execute(_arg); end

  def execute_debug_command(pre_cmds: T.unsafe(nil), do_cmds: T.unsafe(nil)); end
end

class IRB::Command::Debug
end

class IRB::Command::DebugCommand
end

class IRB::Command::DebugCommand
  def self.category(); end

  def self.description(); end
end

class IRB::Command::Delete
  def execute(arg); end
end

class IRB::Command::Delete
end

class IRB::Command::DisableIrb
  def execute(*arg); end
end

class IRB::Command::DisableIrb
end

class IRB::Command::Edit
  include ::IRB::Command::RubyArgsExtractor
end

class IRB::Command::Edit
end

class IRB::Command::Exit
  def execute(_arg); end
end

class IRB::Command::Exit
end

class IRB::Command::Finish
  def execute(arg); end
end

class IRB::Command::Finish
end

class IRB::Command::ForceExit
  def execute(_arg); end
end

class IRB::Command::ForceExit
end

class IRB::Command::Foreground
  def execute_internal(key=T.unsafe(nil)); end
end

class IRB::Command::Foreground
end

class IRB::Command::Help
  def execute(command_name); end
end

class IRB::Command::Help
end

class IRB::Command::History
end

class IRB::Command::History
end

class IRB::Command::Info
  def execute(arg); end
end

class IRB::Command::Info
end

class IRB::Command::IrbCommand
  def execute_internal(*obj); end
end

class IRB::Command::IrbCommand
end

class IRB::Command::IrbInfo
  def execute(_arg); end
end

class IRB::Command::IrbInfo
end

class IRB::Command::Jobs
  def execute(_arg); end
end

class IRB::Command::Jobs
end

class IRB::Command::Kill
  def execute_internal(*keys); end
end

class IRB::Command::Kill
end

class IRB::Command::Load
  def execute_internal(file_name=T.unsafe(nil), priv=T.unsafe(nil)); end
end

class IRB::Command::Load
end

class IRB::Command::LoaderCommand
  include ::IRB::Command::RubyArgsExtractor
  include ::IRB::IrbLoader
  def raise_cmd_argument_error(); end
end

class IRB::Command::LoaderCommand
end

class IRB::Command::Ls
  include ::IRB::Command::RubyArgsExtractor
  def class_method_map(classes, dumped_mods); end

  def dump_methods(o, klass, obj); end
end

class IRB::Command::Ls
end

class IRB::Command::Measure
  include ::IRB::Command::RubyArgsExtractor
  def execute_internal(type=T.unsafe(nil), arg=T.unsafe(nil)); end

  def initialize(*args); end
end

class IRB::Command::Measure
end

class IRB::Command::MultiIRBCommand
  include ::IRB::Command::RubyArgsExtractor
end

class IRB::Command::MultiIRBCommand
end

class IRB::Command::Next
  def execute(arg); end
end

class IRB::Command::Next
end

IRB::Command::Nop = IRB::Command::Base

class IRB::Command::PopWorkspace
end

class IRB::Command::PopWorkspace
end

class IRB::Command::PushWorkspace
  def execute(arg); end
end

class IRB::Command::PushWorkspace
end

class IRB::Command::Require
  def execute_internal(file_name=T.unsafe(nil)); end
end

class IRB::Command::Require
end

module IRB::Command::RubyArgsExtractor
  def ruby_args(arg); end

  def unwrap_string_literal(str); end
end

module IRB::Command::RubyArgsExtractor
end

class IRB::Command::ShowDoc
  include ::IRB::Command::RubyArgsExtractor
end

class IRB::Command::ShowDoc
end

class IRB::Command::ShowSource
  include ::IRB::Command::RubyArgsExtractor
end

class IRB::Command::ShowSource
end

class IRB::Command::Source
  def execute_internal(file_name=T.unsafe(nil)); end
end

class IRB::Command::Source
end

class IRB::Command::Step
  def execute(arg); end
end

class IRB::Command::Step
end

class IRB::Command::Whereami
  def execute(_arg); end
end

class IRB::Command::Whereami
end

class IRB::Command::Workspaces
  def execute(_arg); end
end

class IRB::Command::Workspaces
end

module IRB::Command
  def self._register_with_aliases(name, command_class, *aliases); end

  def self.all_commands_info(); end

  def self.command_names(); end

  def self.command_override_policies(); end

  def self.execute_as_command?(name, public_method:, private_method:); end

  def self.extract_ruby_args(*args, **kwargs); end

  def self.load_command(command); end
end

class IRB::Context
  def __inspect__(); end

  def __to_s__(); end

  def change_workspace(*_main); end

  def command_aliases(); end

  def command_aliases=(command_aliases); end

  def echo_on_assignment(); end

  def echo_on_assignment=(echo_on_assignment); end

  def echo_on_assignment?(); end

  def evaluate(statement, line_no); end

  def evaluate_expression(code, line_no); end

  def extra_doc_dirs(); end

  def extra_doc_dirs=(extra_doc_dirs); end

  def from_binding?(); end

  def history_file(); end

  def history_file=(hist); end

  def home_workspace(); end

  def initialize(irb, workspace=T.unsafe(nil), input_method=T.unsafe(nil)); end

  def inspect_last_value(); end

  def newline_before_multiline_output(); end

  def newline_before_multiline_output=(newline_before_multiline_output); end

  def newline_before_multiline_output?(); end

  def pop_workspace(); end

  def push_workspace(*_main); end

  def replace_workspace(workspace); end

  def save_history(); end

  def use_autocomplete(); end

  def use_autocomplete?(); end

  def use_multiline(); end

  def use_multiline?(); end

  def use_reline(); end

  def use_reline?(); end

  def use_singleline(); end

  def use_singleline?(); end

  def with_debugger(); end

  def with_debugger=(with_debugger); end
  IDNAME_IVARS = ::T.let(nil, ::T.untyped)
  NOPRINTING_IVARS = ::T.let(nil, ::T.untyped)
  NO_INSPECTING_IVARS = ::T.let(nil, ::T.untyped)
end

module IRB::Debug
  IRB_DIR = ::T.let(nil, ::T.untyped)
end

module IRB::Debug
  def self.insert_debug_break(pre_cmds: T.unsafe(nil), do_cmds: T.unsafe(nil)); end

  def self.setup(irb); end
end

IRB::ExtendCommand = IRB::Command

class IRB::FileInputMethod
  def close(); end

  def initialize(file); end
end

class IRB::FileInputMethod
  def self.open(file, &block); end
end

class IRB::HelperMethod::Base
  include ::Singleton
end

class IRB::HelperMethod::Base
  extend ::Singleton::SingletonClassMethods
end

class IRB::HelperMethod::Conf
  def execute(); end
end

class IRB::HelperMethod::Conf
end

module IRB::HelpersContainer
  def conf(*args, **opts, &block); end
end

module IRB::HelpersContainer
  def self.install_helper_methods(); end
end

module IRB::HistorySavingAbility
  def load_history(); end

  def reset_history_counter(); end

  def save_history(); end

  def support_history_saving?(); end
end

module IRB::HistorySavingAbility
end

module IRB::InputCompletor
  CompletionProc = ::T.let(nil, ::T.untyped)
end

module IRB::InputCompletor
  def self.retrieve_completion_data(input, bind: T.unsafe(nil), doc_namespace: T.unsafe(nil)); end
end

class IRB::InputMethod
  def prompting?(); end

  def support_history_saving?(); end

  def winsize(); end
  BASIC_WORD_BREAK_CHARACTERS = ::T.let(nil, ::T.untyped)
end

class IRB::Inspector
  def initialize(inspect_proc, init_proc=T.unsafe(nil)); end
  KERNEL_INSPECT = ::T.let(nil, ::T.untyped)
end

class IRB::Irb
  def build_statement(code); end

  def command?(code); end

  def configure_io(); end

  def convert_invalid_byte_sequence(str, enc); end

  def debug_break(); end

  def debug_readline(binding); end

  def each_top_level_statement(); end

  def encode_with_invalid_byte_sequence(str, enc); end

  def from_binding(); end

  def handle_exception(exc); end

  def initialize(workspace=T.unsafe(nil), input_method=T.unsafe(nil), from_binding: T.unsafe(nil)); end

  def output_value(omit=T.unsafe(nil)); end

  def parse_command(code); end

  def read_input(prompt); end

  def readmultiline(); end
  ASSIGN_OPERATORS_REGEXP = ::T.let(nil, ::T.untyped)
  CONTROL_CHARACTERS_PATTERN = ::T.let(nil, ::T.untyped)
  PROMPT_MAIN_TRUNCATE_LENGTH = ::T.let(nil, ::T.untyped)
  PROMPT_MAIN_TRUNCATE_OMISSION = ::T.let(nil, ::T.untyped)
end

module IRB::IrbLoader
  def irb_load(fn, priv=T.unsafe(nil)); end

  def load_file(path, priv=T.unsafe(nil)); end

  def old(); end

  def search_file_from_ruby_path(fn); end

  def source_file(path); end
end

module IRB::IrbLoader
end

class IRB::LoadAbort
end

class IRB::LoadAbort
end

class IRB::Locale
  def String(mes); end

  def each_localized_path(dir, file); end

  def each_sublocale(); end

  def encoding(); end

  def find(file, paths=T.unsafe(nil)); end

  def format(*opts); end

  def gets(*rs); end

  def initialize(locale=T.unsafe(nil)); end

  def lang(); end

  def load(file); end

  def modifier(); end

  def print(*opts); end

  def printf(*opts); end

  def puts(*opts); end

  def readline(*rs); end

  def search_file(lib_paths, dir, file); end

  def territory(); end
  LEGACY_ENCODING_ALIAS_MAP = ::T.let(nil, ::T.untyped)
  LOCALE_DIR = ::T.let(nil, ::T.untyped)
  LOCALE_NAME_RE = ::T.let(nil, ::T.untyped)
end

class IRB::Locale
end

module IRB::NestingParser
  IGNORE_TOKENS = ::T.let(nil, ::T.untyped)
end

module IRB::NestingParser
  def self.open_tokens(tokens); end

  def self.parse_by_line(tokens); end

  def self.scan_opens(tokens); end
end

class IRB::Pager
  PAGE_COMMANDS = ::T.let(nil, ::T.untyped)
end

class IRB::Pager
  def self.page(retain_content: T.unsafe(nil)); end

  def self.page_content(content, **options); end
end

class IRB::ReadlineInputMethod
  include ::IRB::HistorySavingAbility
  def completion_info(); end
end

class IRB::ReadlineInputMethod
  def self.initialize_readline(); end
end

class IRB::RegexpCompletor
  def complete_require_path(target, preposing, postposing); end

  def doc_namespace(_preposing, matched, _postposing, bind:); end

  def retrieve_completion_data(input, bind:, doc_namespace:); end

  def select_message(receiver, message, candidates, sep=T.unsafe(nil)); end
  Operators = ::T.let(nil, ::T.untyped)
end

class IRB::RegexpCompletor
end

class IRB::ReidlineInputMethod
  def initialize(); end
end

class IRB::RelineInputMethod
  include ::IRB::HistorySavingAbility
  def auto_indent(&block); end

  def check_termination(&block); end

  def completion_info(); end

  def display_document(matched); end

  def dynamic_prompt(&block); end

  def initialize(completor); end

  def rdoc_ri_driver(); end

  def retrieve_doc_namespace(matched); end

  def show_doc_dialog_proc(); end
  HISTORY = ::T.let(nil, ::T.untyped)
end

class IRB::RubyLex
  def assignment_expression?(code, local_variables:); end

  def calc_indent_level(opens); end

  def check_code_state(code, local_variables:); end

  def check_code_syntax(code, local_variables:); end

  def check_termination_in_prev_line(code, local_variables:); end

  def code_terminated?(code, tokens, opens, local_variables:); end

  def free_indent_token?(token); end

  def indent_difference(lines, line_results, line_index); end

  def ltype_from_open_tokens(opens); end

  def process_indent_level(tokens, lines, line_index, is_newline); end

  def should_continue?(tokens); end
  ASSIGNMENT_NODE_TYPES = ::T.let(nil, ::T.untyped)
  ERROR_TOKENS = ::T.let(nil, ::T.untyped)
  FREE_INDENT_TOKENS = ::T.let(nil, ::T.untyped)
  LTYPE_TOKENS = ::T.let(nil, ::T.untyped)
end

class IRB::RubyLex::TerminateLineInput
  def initialize(); end
end

class IRB::RubyLex::TerminateLineInput
end

class IRB::RubyLex
  def self.compile_with_errors_suppressed(code, line_no: T.unsafe(nil)); end

  def self.generate_local_variables_assign_code(local_variables); end

  def self.interpolate_ripper_ignored_tokens(code, tokens); end

  def self.ripper_lex_without_warning(code, local_variables: T.unsafe(nil)); end
end

class IRB::SourceFinder
  def find_source(signature, super_level=T.unsafe(nil)); end

  def initialize(irb_context); end
end

class IRB::SourceFinder::EvaluationError
end

class IRB::SourceFinder::EvaluationError
end

class IRB::SourceFinder
end

class IRB::Statement
  def code(); end

  def is_assignment?(); end

  def should_be_handled_by_debugger?(); end

  def suppresses_echo?(); end
end

class IRB::Statement::Command
  def arg(); end

  def command_class(); end

  def initialize(original_code, command_class, arg); end
end

class IRB::Statement::Command
end

class IRB::Statement::EmptyInput
end

class IRB::Statement::EmptyInput
end

class IRB::Statement::Expression
  def initialize(code, is_assignment); end
end

class IRB::Statement::Expression
end

class IRB::Statement
end

class IRB::TypeCompletor
  def completion_candidates(preposing, target, _postposing, bind:); end

  def doc_namespace(preposing, matched, _postposing, bind:); end

  def initialize(context); end
end

class IRB::TypeCompletor
end

class IRB::WorkSpace
  def initialize(*main); end

  def load_helper_methods_to_main(); end

  def local_variable_get(name); end

  def local_variable_set(name, value); end
end

module IRB
  def self.Inspector(inspect, init=T.unsafe(nil)); end

  def self.init_config(ap_path); end

  def self.init_error(); end

  def self.initialized?(); end

  def self.irbrc_files(); end

  def self.load_modules(); end

  def self.parse_opts(argv: T.unsafe(nil)); end

  def self.raise_validation_error(msg); end

  def self.rc_file(ext); end

  def self.run_config(); end

  def self.set_measure_callback(type=T.unsafe(nil), arg=T.unsafe(nil), &block); end

  def self.unset_measure_callback(type=T.unsafe(nil)); end

  def self.validate_config(); end
end

class InactiveServerCheckerWorker
  def sidekiq_options_hash(); end

  def sidekiq_options_hash=(sidekiq_options_hash); end

  def sidekiq_retries_exhausted_block(); end

  def sidekiq_retries_exhausted_block=(sidekiq_retries_exhausted_block); end

  def sidekiq_retry_in_block(); end

  def sidekiq_retry_in_block=(sidekiq_retry_in_block); end
end

class InactiveServerCheckerWorker
  def self.__synchronized_sidekiq_options_hash(); end

  def self.sidekiq_options_hash(); end

  def self.sidekiq_options_hash=(val); end

  def self.sidekiq_retries_exhausted_block(); end

  def self.sidekiq_retries_exhausted_block=(val); end

  def self.sidekiq_retry_in_block(); end

  def self.sidekiq_retry_in_block=(val); end
end

class InactiveServersCheckerWorker
  def sidekiq_options_hash(); end

  def sidekiq_options_hash=(sidekiq_options_hash); end

  def sidekiq_retries_exhausted_block(); end

  def sidekiq_retries_exhausted_block=(sidekiq_retries_exhausted_block); end

  def sidekiq_retry_in_block(); end

  def sidekiq_retry_in_block=(sidekiq_retry_in_block); end
end

class InactiveServersCheckerWorker
  def self.sidekiq_options_hash(); end

  def self.sidekiq_options_hash=(val); end

  def self.sidekiq_retries_exhausted_block(); end

  def self.sidekiq_retries_exhausted_block=(val); end

  def self.sidekiq_retry_in_block(); end

  def self.sidekiq_retry_in_block=(val); end
end

class Integer
  def ceildiv(other); end

  def multiple_of?(number); end

  def ordinal(); end

  def ordinalize(); end

  def to_bn(); end
end

class Integer
  def self.try_convert(arg); end
end

class JSON::Ext::Generator::State
  def escape_slash(); end

  def escape_slash=(escape_slash); end

  def escape_slash?(); end

  def script_safe(); end

  def script_safe=(script_safe); end

  def script_safe?(); end

  def strict(); end

  def strict=(strict); end

  def strict?(); end
end

class JSON::Ext::Generator::State
  def self.from_state(arg); end
end

class JSON::Ext::Parser
  def initialize(source, opts = T.unsafe(nil)); end
end

class Jbuilder::DependencyTracker
  def dependencies(); end

  def initialize(name, template, view_paths=T.unsafe(nil)); end
  DIRECT_RENDERS = ::T.let(nil, ::T.untyped)
  EXPLICIT_DEPENDENCY = ::T.let(nil, ::T.untyped)
  INDIRECT_RENDERS = ::T.let(nil, ::T.untyped)
end

class Jbuilder::DependencyTracker
  def self.call(name, template, view_paths=T.unsafe(nil)); end
end

class Jbuilder::EnumerableCompat
  RUBYGEMS_ACTIVATION_MONITOR = ::T.let(nil, ::T.untyped)
end

module JsonExpressions::RSpec
end

module JsonExpressions::RSpec::Matchers
  def match_json_expression(expected); end
end

class JsonExpressions::RSpec::Matchers::MatchJsonExpression
  def ===(target); end

  def description(); end

  def failure_message(); end

  def failure_message_for_should(); end

  def failure_message_for_should_not(); end

  def failure_message_when_negated(); end

  def initialize(expected); end

  def matches?(target); end
end

class JsonExpressions::RSpec::Matchers::MatchJsonExpression
end

module JsonExpressions::RSpec::Matchers
end

module JsonExpressions::RSpec
end

module Kernel
  def class_eval(*args, &block); end

  def pretty_inspect(); end
end

module Kernel
  def self.at_exit(); end

  def self.exit(*arg); end

  def self.no_warning_require(arg); end

  def self.zeitwerk_original_require(name); end
end

class KeyError
  include ::DidYouMean::Correctable
end

class LeagueRequest
  def __callbacks(); end

  def __callbacks?(); end

  def _run_validate_callbacks(&block); end

  def _validate_callbacks(); end

  def _validators(); end

  def _validators?(); end

  def model_name(&arg); end

  def param_delimiter=(param_delimiter); end

  def validation_context(); end
end

class LeagueRequest
  def self.__callbacks(); end

  def self.__callbacks=(value); end

  def self.__callbacks?(); end

  def self._validate_callbacks(); end

  def self._validate_callbacks=(value); end

  def self._validators(); end

  def self._validators=(value); end

  def self._validators?(); end

  def self.param_delimiter(); end

  def self.param_delimiter=(value); end

  def self.param_delimiter?(); end
end

module Libv8
end

module Libv8::Node
  LIBV8_VERSION = ::T.let(nil, ::T.untyped)
  NODE_VERSION = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

class Libv8::Node::Location
  def install!(); end
end

class Libv8::Node::Location::MkmfContext
  def incflags(); end

  def ldflags(); end
end

class Libv8::Node::Location::MkmfContext
end

class Libv8::Node::Location::Vendor
  def configure(context=T.unsafe(nil)); end

  def verify_installation!(); end
end

class Libv8::Node::Location::Vendor::ArchiveNotFound
  def initialize(filename); end
end

class Libv8::Node::Location::Vendor::ArchiveNotFound
end

class Libv8::Node::Location::Vendor::HeaderNotFound
end

class Libv8::Node::Location::Vendor::HeaderNotFound
end

class Libv8::Node::Location::Vendor
end

class Libv8::Node::Location
  def self.load!(); end
end

module Libv8::Node::Paths
end

module Libv8::Node::Paths
  def self.config(); end

  def self.include_paths(); end

  def self.object_paths(); end

  def self.platform(); end

  def self.vendored_source_path(); end
end

module Libv8::Node
  def self.configure_makefile(); end
end

module Libv8
end

class LoadError
  include ::DidYouMean::Correctable
  def is_missing?(location); end
end

class LocalServerDecorator
  def local_server(); end
end

class Location
  def autosave_associated_records_for_servers(*args); end

  def validate_associated_records_for_servers(*args); end
end

class LogScanWorker
  def sidekiq_options_hash(); end

  def sidekiq_options_hash=(sidekiq_options_hash); end

  def sidekiq_retries_exhausted_block(); end

  def sidekiq_retries_exhausted_block=(sidekiq_retries_exhausted_block); end

  def sidekiq_retry_in_block(); end

  def sidekiq_retry_in_block=(sidekiq_retry_in_block); end
end

class LogScanWorker
  def self.__synchronized_sidekiq_options_hash(); end

  def self.sidekiq_options_hash(); end

  def self.sidekiq_options_hash=(val); end

  def self.sidekiq_retries_exhausted_block(); end

  def self.sidekiq_retries_exhausted_block=(val); end

  def self.sidekiq_retry_in_block(); end

  def self.sidekiq_retry_in_block=(val); end
end

class LogUpload
  def autosave_associated_records_for_reservation(*args); end
end

class LogWorker
  def sidekiq_options_hash(); end

  def sidekiq_options_hash=(sidekiq_options_hash); end

  def sidekiq_retries_exhausted_block(); end

  def sidekiq_retries_exhausted_block=(sidekiq_retries_exhausted_block); end

  def sidekiq_retry_in_block(); end

  def sidekiq_retry_in_block=(sidekiq_retry_in_block); end
end

class LogWorker
  def self.__synchronized_sidekiq_options_hash(); end

  def self.sidekiq_options_hash(); end

  def self.sidekiq_options_hash=(val); end

  def self.sidekiq_retries_exhausted_block(); end

  def self.sidekiq_retries_exhausted_block=(val); end

  def self.sidekiq_retry_in_block(); end

  def self.sidekiq_retry_in_block=(val); end
end

class Lograge::SilentLogger
  RUBYGEMS_ACTIVATION_MONITOR = ::T.let(nil, ::T.untyped)
end

class Mail::Address
  def ==(other_address); end
end

class Mail::Address
  def self.wrap(address); end
end

class Mail::Message
  def bcc_addresses(); end

  def cc_addresses(); end

  def from_address(); end

  def recipients(); end

  def recipients_addresses(); end

  def to_addresses(); end

  def x_forwarded_to_addresses(); end

  def x_original_to_addresses(); end
end

class Mail::PartsList
  RUBYGEMS_ACTIVATION_MONITOR = ::T.let(nil, ::T.untyped)
end

module Mail
  def self.from_source(source); end
end

class MapUpload
  def autosave_associated_records_for_file_attachment(*args); end

  def autosave_associated_records_for_file_blob(*args); end

  def autosave_associated_records_for_user(*args); end
end

module MapUpload::GeneratedAssociationMethods
  def file(); end

  def file=(attachable); end
end

class MapUpload
  def self.with_attached_file(*args, **arg); end
end

class MapUploadsController
  include ::ActionView::Layouts::ClassMethods::LayoutConditions
end

class MatchData
  def deconstruct(); end

  def deconstruct_keys(arg); end

  def match(arg); end

  def match_length(arg); end
end

class MessagePack::ExtensionValue
  def self.keyword_init?(); end
end

class MessagePack::Packer
  def register_type_internal(arg, arg1, arg2); end

  def reset(); end

  def write_bin(arg); end

  def write_bin_header(arg); end
end

class MessagePack::Unpacker
  def feed_reference(arg); end

  def freeze?(); end
end

module Minitest::Assertions
  def assert_mock(mock); end
end

class Minitest::Expectation
  def ctx(); end

  def ctx=(_); end

  def target(); end

  def target=(_); end
end

class Minitest::Expectation
  def self.[](*arg); end

  def self.keyword_init?(); end

  def self.members(); end
end

module Minitest::Expectations
  def must_be(*args, **arg); end

  def must_be_close_to(*args, **arg); end

  def must_be_empty(*args, **arg); end

  def must_be_instance_of(*args, **arg); end

  def must_be_kind_of(*args, **arg); end

  def must_be_nil(*args, **arg); end

  def must_be_same_as(*args, **arg); end

  def must_be_silent(*args, **arg); end

  def must_be_within_delta(*args, **arg); end

  def must_be_within_epsilon(*args, **arg); end

  def must_equal(*args, **arg); end

  def must_include(*args, **arg); end

  def must_match(*args, **arg); end

  def must_output(*args, **arg); end

  def must_pattern_match(*args, **arg); end

  def must_raise(*args, **arg); end

  def must_respond_to(*args, **arg); end

  def must_throw(*args, **arg); end

  def path_must_exist(*args, **arg); end

  def path_wont_exist(*args, **arg); end

  def wont_be(*args, **arg); end

  def wont_be_close_to(*args, **arg); end

  def wont_be_empty(*args, **arg); end

  def wont_be_instance_of(*args, **arg); end

  def wont_be_kind_of(*args, **arg); end

  def wont_be_nil(*args, **arg); end

  def wont_be_same_as(*args, **arg); end

  def wont_be_within_delta(*args, **arg); end

  def wont_be_within_epsilon(*args, **arg); end

  def wont_equal(*args, **arg); end

  def wont_include(*args, **arg); end

  def wont_match(*args, **arg); end

  def wont_pattern_match(*args, **arg); end

  def wont_respond_to(*args, **arg); end
end

module Minitest::Expectations
end

class Minitest::Mock
  def ===(*args, **kwargs, &b); end

  def __call(name, data); end

  def __respond_to?(*arg); end

  def class(*args, **kwargs, &b); end

  def expect(name, retval, args=T.unsafe(nil), **kwargs, &blk); end

  def initialize(delegator=T.unsafe(nil)); end

  def inspect(*args, **kwargs, &b); end

  def instance_eval(*args, **kwargs, &b); end

  def instance_variables(*args, **kwargs, &b); end

  def method_missing(sym, *args, **kwargs, &block); end

  def object_id(*args, **kwargs, &b); end

  def public_send(*args, **kwargs, &b); end

  def respond_to?(sym, include_private=T.unsafe(nil)); end

  def send(*args, **kwargs, &b); end

  def to_s(*args, **kwargs, &b); end

  def verify(); end
end

class Minitest::Mock
end

class Minitest::Spec
  include ::Minitest::Spec::DSL::InstanceMethods
  TYPES = ::T.let(nil, ::T.untyped)
end

module Minitest::Spec::DSL
  def after(_type=T.unsafe(nil), &block); end

  def before(_type=T.unsafe(nil), &block); end

  def children(); end

  def create(name, desc); end

  def desc(); end

  def describe_stack(); end

  def it(desc=T.unsafe(nil), &block); end

  def let(name, &block); end

  def name(); end

  def nuke_test_methods!(); end

  def register_spec_type(*args, &block); end

  def spec_type(desc, *additional); end

  def specify(desc=T.unsafe(nil), &block); end

  def subject(&block); end

  def to_s(); end
  TYPES = ::T.let(nil, ::T.untyped)
end

module Minitest::Spec::DSL::InstanceMethods
  def _(value=T.unsafe(nil), &block); end

  def before_setup(); end

  def expect(value=T.unsafe(nil), &block); end

  def value(value=T.unsafe(nil), &block); end
end

module Minitest::Spec::DSL::InstanceMethods
end

module Minitest::Spec::DSL
  def self.extended(obj); end
end

class Minitest::Spec
  extend ::Minitest::Spec::DSL
  def self.current(); end
end

class MockExpectationError
end

class MockExpectationError
end

class Module
  def context(*a, &b); end

  def describe(*a, &b); end

  def example_group(*a, &b); end

  def fcontext(*a, &b); end

  def fdescribe(*a, &b); end

  def feature(*a, &b); end

  def ffeature(*a, &b); end

  def infect_an_assertion(meth, new_name, dont_flip=T.unsafe(nil)); end

  def set_temporary_name(arg); end

  def shared_context(name, *args, &block); end

  def shared_examples(name, *args, &block); end

  def shared_examples_for(name, *args, &block); end

  def undefined_instance_methods(); end

  def xcontext(*a, &b); end

  def xdescribe(*a, &b); end

  def xfeature(*a, &b); end
end

class Monitor
  def enter(); end

  def exit(); end

  def mon_check_owner(); end

  def mon_enter(); end

  def mon_exit(); end

  def mon_locked?(); end

  def mon_owned?(); end

  def mon_synchronize(); end

  def mon_try_enter(); end

  def new_cond(); end

  def synchronize(); end

  def try_enter(); end

  def try_mon_enter(); end

  def wait_for_cond(arg, arg1); end
end

module MonitorMixin
  def initialize(*arg, **arg1, &arg2); end
end

class MonitorMixin::ConditionVariable
  def initialize(monitor); end
end

class MonthlyDonationProgressAnnouncerWorker
  def sidekiq_options_hash(); end

  def sidekiq_options_hash=(sidekiq_options_hash); end

  def sidekiq_retries_exhausted_block(); end

  def sidekiq_retries_exhausted_block=(sidekiq_retries_exhausted_block); end

  def sidekiq_retry_in_block(); end

  def sidekiq_retry_in_block=(sidekiq_retry_in_block); end
end

class MonthlyDonationProgressAnnouncerWorker
  def self.sidekiq_options_hash(); end

  def self.sidekiq_options_hash=(val); end

  def self.sidekiq_retries_exhausted_block(); end

  def self.sidekiq_retries_exhausted_block=(val); end

  def self.sidekiq_retry_in_block(); end

  def self.sidekiq_retry_in_block=(val); end
end

class Net::HTTP
  include ::Sentry::Net::HTTP
  include ::Sentry::Utils::HttpTracing
  def extra_chain_cert(); end

  def extra_chain_cert=(extra_chain_cert); end

  def ignore_eof(); end

  def ignore_eof=(ignore_eof); end

  def ipaddr(); end

  def ipaddr=(addr); end

  def max_version(); end

  def max_version=(max_version); end

  def min_version(); end

  def min_version=(min_version); end

  def response_body_encoding(); end

  def response_body_encoding=(value); end

  def verify_hostname(); end

  def verify_hostname=(verify_hostname); end

  def write_timeout(); end

  def write_timeout=(sec); end
  VERSION = ::T.let(nil, ::T.untyped)
end

class Net::HTTP::Post::Multipart
  include ::Multipart::Post::Multipartable
end

class Net::HTTP::Post::Multipart
end

class Net::HTTP::Put::Multipart
  include ::Multipart::Post::Multipartable
end

class Net::HTTP::Put::Multipart
end

class Net::HTTPAlreadyReported
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Net::HTTPAlreadyReported
end

Net::HTTPClientErrorCode = Net::HTTPClientError

class Net::HTTPEarlyHints
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Net::HTTPEarlyHints
end

Net::HTTPFatalErrorCode = Net::HTTPClientError

module Net::HTTPHeader
  MAX_FIELD_LENGTH = ::T.let(nil, ::T.untyped)
  MAX_KEY_LENGTH = ::T.let(nil, ::T.untyped)
end

Net::HTTPInformation::EXCEPTION_TYPE = Net::HTTPError

Net::HTTPInformationCode = Net::HTTPInformation

class Net::HTTPLoopDetected
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Net::HTTPLoopDetected
end

class Net::HTTPMisdirectedRequest
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Net::HTTPMisdirectedRequest
end

Net::HTTPMovedTemporarily = Net::HTTPFound

Net::HTTPMultipleChoice = Net::HTTPMultipleChoices

class Net::HTTPNotExtended
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Net::HTTPNotExtended
end

class Net::HTTPPayloadTooLarge
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Net::HTTPPayloadTooLarge
end

class Net::HTTPProcessing
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Net::HTTPProcessing
end

class Net::HTTPRangeNotSatisfiable
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Net::HTTPRangeNotSatisfiable
end

Net::HTTPRedirectionCode = Net::HTTPRedirection

Net::HTTPRequestURITooLarge = Net::HTTPURITooLong

Net::HTTPResponceReceiver = Net::HTTPResponse

class Net::HTTPResponse
  def body_encoding(); end

  def body_encoding=(value); end

  def ignore_eof(); end

  def ignore_eof=(ignore_eof); end
end

class Net::HTTPResponse::Inflater
  def bytes_inflated(); end
end

Net::HTTPResponseReceiver = Net::HTTPResponse

Net::HTTPRetriableCode = Net::HTTPRedirection

Net::HTTPServerErrorCode = Net::HTTPServerError

Net::HTTPSession = Net::HTTP

Net::HTTPSuccess::EXCEPTION_TYPE = Net::HTTPError

Net::HTTPSuccessCode = Net::HTTPSuccess

class Net::HTTPURITooLong
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Net::HTTPURITooLong
end

Net::HTTPUnknownResponse::EXCEPTION_TYPE = Net::HTTPError

class Net::HTTPVariantAlsoNegotiates
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Net::HTTPVariantAlsoNegotiates
end

class Net::IMAP::ResponseParser::Token
  def self.keyword_init?(); end
end

Net::NetPrivate::HTTPRequest = Net::HTTPRequest

class Net::SSH::Authentication::ED25519::SigningKeyFromFile
  RUBYGEMS_ACTIVATION_MONITOR = ::T.let(nil, ::T.untyped)
end

class Net::SSH::HostKeyEntries::PubKey
  RUBYGEMS_ACTIVATION_MONITOR = ::T.let(nil, ::T.untyped)
end

class Net::SSH::Transport::OpenSSLAESCTR
  RUBYGEMS_ACTIVATION_MONITOR = ::T.let(nil, ::T.untyped)
end

class NilClass
  def =~(arg); end
end

class NoMatchingPatternKeyError
  include ::DidYouMean::Correctable
  def key(); end

  def matchee(); end
end

class NoMatchingPatternKeyError
end

class Object
  include ::Minitest::Expectations
  def stub(name, val_or_callable, *block_args, **block_kwargs, &block); end
  ARGF = ::T.let(nil, ::T.untyped)
  ARGV = ::T.let(nil, ::T.untyped)
  CROSS_COMPILING = ::T.let(nil, ::T.untyped)
  ENV = ::T.let(nil, ::T.untyped)
  MAPS_DIR = ::T.let(nil, ::T.untyped)
  MAX_RESPONSE_KB = ::T.let(nil, ::T.untyped)
  NFO_COOKIETOKEN = ::T.let(nil, ::T.untyped)
  NFO_DOMAIN = ::T.let(nil, ::T.untyped)
  NFO_EMAIL = ::T.let(nil, ::T.untyped)
  NFO_PASSWORD = ::T.let(nil, ::T.untyped)
  RUBY18 = ::T.let(nil, ::T.untyped)
  RUBY19 = ::T.let(nil, ::T.untyped)
  RUBY_COPYRIGHT = ::T.let(nil, ::T.untyped)
  RUBY_DESCRIPTION = ::T.let(nil, ::T.untyped)
  RUBY_ENGINE = ::T.let(nil, ::T.untyped)
  RUBY_ENGINE_VERSION = ::T.let(nil, ::T.untyped)
  RUBY_PATCHLEVEL = ::T.let(nil, ::T.untyped)
  RUBY_PLATFORM = ::T.let(nil, ::T.untyped)
  RUBY_RELEASE_DATE = ::T.let(nil, ::T.untyped)
  RUBY_REVISION = ::T.let(nil, ::T.untyped)
  RUBY_VERSION = ::T.let(nil, ::T.untyped)
  SITE_HOST = ::T.let(nil, ::T.untyped)
  SITE_URL = ::T.let(nil, ::T.untyped)
  STDERR = ::T.let(nil, ::T.untyped)
  STDIN = ::T.let(nil, ::T.untyped)
  STDOUT = ::T.let(nil, ::T.untyped)
  STRIPE_PUBLISHABLE_KEY = ::T.let(nil, ::T.untyped)
  TOPLEVEL_BINDING = ::T.let(nil, ::T.untyped)
end

class ObjectSpace::InternalObjectWrapper
  def internal_object_id(); end

  def type(); end
end

class ObjectSpace::InternalObjectWrapper
end

class ObjectSpace::WeakMap
  def delete(arg); end
end

module ObjectSpace
  def self.allocation_class_path(arg); end

  def self.allocation_generation(arg); end

  def self.allocation_method_id(arg); end

  def self.allocation_sourcefile(arg); end

  def self.allocation_sourceline(arg); end

  def self.count_nodes(*arg); end

  def self.count_symbols(*arg); end

  def self.dump(obj, output: T.unsafe(nil)); end

  def self.dump_all(output: T.unsafe(nil), full: T.unsafe(nil), since: T.unsafe(nil), shapes: T.unsafe(nil)); end

  def self.dump_shapes(output: T.unsafe(nil), since: T.unsafe(nil)); end

  def self.internal_class_of(arg); end

  def self.internal_super_of(arg); end

  def self.reachable_objects_from(arg); end

  def self.reachable_objects_from_root(); end

  def self.trace_object_allocations(); end

  def self.trace_object_allocations_debug_start(); end
end

module Observable
  VERSION = ::T.let(nil, ::T.untyped)
end

module Open3
  VERSION = ::T.let(nil, ::T.untyped)
end

class OpenSSL::ASN1::ASN1Data
  def indefinite_length(); end

  def indefinite_length=(indefinite_length); end
end

class OpenSSL::BN
  def +@(); end

  def -@(); end

  def /(arg); end

  def abs(); end

  def get_flags(arg); end

  def mod_sqrt(arg); end

  def negative?(); end

  def set_flags(arg); end
  CONSTTIME = ::T.let(nil, ::T.untyped)
end

module OpenSSL::Buffering
  def getbyte(); end
end

class OpenSSL::Buffering::Buffer
  def <<(string); end

  def concat(string); end

  def initialize(); end
  BINARY = ::T.let(nil, ::T.untyped)
end

class OpenSSL::Buffering::Buffer
end

class OpenSSL::Cipher
  def ccm_data_len=(ccm_data_len); end
end

class OpenSSL::HMAC
  def ==(other); end
end

module OpenSSL::Marshal
  def _dump(_level); end
end

module OpenSSL::Marshal::ClassMethods
  def _load(string); end
end

module OpenSSL::Marshal::ClassMethods
end

module OpenSSL::Marshal
  def self.included(base); end
end

class OpenSSL::OCSP::Request
  def signed?(); end
end

OpenSSL::PKCS7::Signer = OpenSSL::PKCS7::SignerInfo

class OpenSSL::PKey::DH
  include ::OpenSSL::Marshal
end

class OpenSSL::PKey::DH
  extend ::OpenSSL::Marshal::ClassMethods
  def self.new(*args, &blk); end
end

class OpenSSL::PKey::DSA
  include ::OpenSSL::Marshal
end

class OpenSSL::PKey::DSA
  extend ::OpenSSL::Marshal::ClassMethods
  def self.new(*args, &blk); end
end

class OpenSSL::PKey::EC
  include ::OpenSSL::Marshal
  EXPLICIT_CURVE = ::T.let(nil, ::T.untyped)
end

class OpenSSL::PKey::EC::Point
  def add(arg); end

  def to_octet_string(arg); end
end

class OpenSSL::PKey::EC
  extend ::OpenSSL::Marshal::ClassMethods
end

class OpenSSL::PKey::PKey
  def compare?(arg); end

  def decrypt(*arg); end

  def derive(*arg); end

  def encrypt(*arg); end

  def oid(); end

  def private_to_der(*arg); end

  def private_to_pem(*arg); end

  def public_to_der(); end

  def public_to_pem(); end

  def raw_private_key(); end

  def raw_public_key(); end

  def sign_raw(*arg); end

  def to_text(); end

  def verify_raw(*arg); end

  def verify_recover(*arg); end
end

class OpenSSL::PKey::RSA
  include ::OpenSSL::Marshal
end

class OpenSSL::PKey::RSA
  extend ::OpenSSL::Marshal::ClassMethods
  def self.new(*args, &blk); end
end

module OpenSSL::PKey
  def self.generate_key(*arg); end

  def self.generate_parameters(*arg); end

  def self.new_raw_private_key(arg, arg1); end

  def self.new_raw_public_key(arg, arg1); end
end

class OpenSSL::Provider
  def name(); end

  def unload(); end
end

class OpenSSL::Provider::ProviderError
end

class OpenSSL::Provider::ProviderError
end

class OpenSSL::Provider
  def self.load(arg); end

  def self.provider_names(); end
end

module OpenSSL::SSL
  OP_ALLOW_CLIENT_RENEGOTIATION = ::T.let(nil, ::T.untyped)
  OP_ALLOW_NO_DHE_KEX = ::T.let(nil, ::T.untyped)
  OP_ALLOW_UNSAFE_LEGACY_RENEGOTIATION = ::T.let(nil, ::T.untyped)
  OP_CLEANSE_PLAINTEXT = ::T.let(nil, ::T.untyped)
  OP_CRYPTOPRO_TLSEXT_BUG = ::T.let(nil, ::T.untyped)
  OP_DISABLE_TLSEXT_CA_NAMES = ::T.let(nil, ::T.untyped)
  OP_ENABLE_KTLS = ::T.let(nil, ::T.untyped)
  OP_ENABLE_MIDDLEBOX_COMPAT = ::T.let(nil, ::T.untyped)
  OP_IGNORE_UNEXPECTED_EOF = ::T.let(nil, ::T.untyped)
  OP_LEGACY_SERVER_CONNECT = ::T.let(nil, ::T.untyped)
  OP_NO_ANTI_REPLAY = ::T.let(nil, ::T.untyped)
  OP_NO_ENCRYPT_THEN_MAC = ::T.let(nil, ::T.untyped)
  OP_NO_RENEGOTIATION = ::T.let(nil, ::T.untyped)
  OP_NO_TLSv1_3 = ::T.let(nil, ::T.untyped)
  OP_PRIORITIZE_CHACHA = ::T.let(nil, ::T.untyped)
  OP_SAFARI_ECDHE_ECDSA_BUG = ::T.let(nil, ::T.untyped)
  OP_TLSEXT_PADDING = ::T.let(nil, ::T.untyped)
  SSL2_VERSION = ::T.let(nil, ::T.untyped)
  SSL3_VERSION = ::T.let(nil, ::T.untyped)
  TLS1_VERSION = ::T.let(nil, ::T.untyped)
end

module OpenSSL::Timestamp
end

class OpenSSL::Timestamp::Factory
  def additional_certs(); end

  def additional_certs=(additional_certs); end

  def allowed_digests(); end

  def allowed_digests=(allowed_digests); end

  def create_timestamp(arg, arg1, arg2); end

  def default_policy_id(); end

  def default_policy_id=(default_policy_id); end

  def gen_time(); end

  def gen_time=(gen_time); end

  def serial_number(); end

  def serial_number=(serial_number); end
end

class OpenSSL::Timestamp::Factory
end

class OpenSSL::Timestamp::Request
  def algorithm(); end

  def algorithm=(algorithm); end

  def cert_requested=(cert_requested); end

  def cert_requested?(); end

  def initialize(*arg); end

  def message_imprint(); end

  def message_imprint=(message_imprint); end

  def nonce(); end

  def nonce=(nonce); end

  def policy_id(); end

  def policy_id=(policy_id); end

  def to_der(); end

  def version(); end

  def version=(version); end
end

class OpenSSL::Timestamp::Request
end

class OpenSSL::Timestamp::Response
  def failure_info(); end

  def initialize(arg); end

  def status(); end

  def status_text(); end

  def to_der(); end

  def token(); end

  def token_info(); end

  def tsa_certificate(); end

  def verify(*arg); end
  GRANTED = ::T.let(nil, ::T.untyped)
  GRANTED_WITH_MODS = ::T.let(nil, ::T.untyped)
  REJECTION = ::T.let(nil, ::T.untyped)
  REVOCATION_NOTIFICATION = ::T.let(nil, ::T.untyped)
  REVOCATION_WARNING = ::T.let(nil, ::T.untyped)
  WAITING = ::T.let(nil, ::T.untyped)
end

class OpenSSL::Timestamp::Response
end

class OpenSSL::Timestamp::TimestampError
end

class OpenSSL::Timestamp::TimestampError
end

class OpenSSL::Timestamp::TokenInfo
  def algorithm(); end

  def gen_time(); end

  def initialize(arg); end

  def message_imprint(); end

  def nonce(); end

  def ordering(); end

  def policy_id(); end

  def serial_number(); end

  def to_der(); end

  def version(); end
end

class OpenSSL::Timestamp::TokenInfo
end

module OpenSSL::Timestamp
end

module OpenSSL::X509
  V_ERR_CA_KEY_TOO_SMALL = ::T.let(nil, ::T.untyped)
  V_ERR_CA_MD_TOO_WEAK = ::T.let(nil, ::T.untyped)
  V_ERR_CRL_PATH_VALIDATION_ERROR = ::T.let(nil, ::T.untyped)
  V_ERR_DANE_NO_MATCH = ::T.let(nil, ::T.untyped)
  V_ERR_DIFFERENT_CRL_SCOPE = ::T.let(nil, ::T.untyped)
  V_ERR_EE_KEY_TOO_SMALL = ::T.let(nil, ::T.untyped)
  V_ERR_EMAIL_MISMATCH = ::T.let(nil, ::T.untyped)
  V_ERR_EXCLUDED_VIOLATION = ::T.let(nil, ::T.untyped)
  V_ERR_HOSTNAME_MISMATCH = ::T.let(nil, ::T.untyped)
  V_ERR_INVALID_CALL = ::T.let(nil, ::T.untyped)
  V_ERR_INVALID_EXTENSION = ::T.let(nil, ::T.untyped)
  V_ERR_INVALID_NON_CA = ::T.let(nil, ::T.untyped)
  V_ERR_INVALID_POLICY_EXTENSION = ::T.let(nil, ::T.untyped)
  V_ERR_IP_ADDRESS_MISMATCH = ::T.let(nil, ::T.untyped)
  V_ERR_KEYUSAGE_NO_CRL_SIGN = ::T.let(nil, ::T.untyped)
  V_ERR_KEYUSAGE_NO_DIGITAL_SIGNATURE = ::T.let(nil, ::T.untyped)
  V_ERR_NO_EXPLICIT_POLICY = ::T.let(nil, ::T.untyped)
  V_ERR_NO_VALID_SCTS = ::T.let(nil, ::T.untyped)
  V_ERR_OCSP_CERT_UNKNOWN = ::T.let(nil, ::T.untyped)
  V_ERR_OCSP_VERIFY_FAILED = ::T.let(nil, ::T.untyped)
  V_ERR_OCSP_VERIFY_NEEDED = ::T.let(nil, ::T.untyped)
  V_ERR_PATH_LOOP = ::T.let(nil, ::T.untyped)
  V_ERR_PERMITTED_VIOLATION = ::T.let(nil, ::T.untyped)
  V_ERR_PROXY_CERTIFICATES_NOT_ALLOWED = ::T.let(nil, ::T.untyped)
  V_ERR_PROXY_PATH_LENGTH_EXCEEDED = ::T.let(nil, ::T.untyped)
  V_ERR_PROXY_SUBJECT_NAME_VIOLATION = ::T.let(nil, ::T.untyped)
  V_ERR_STORE_LOOKUP = ::T.let(nil, ::T.untyped)
  V_ERR_SUBTREE_MINMAX = ::T.let(nil, ::T.untyped)
  V_ERR_SUITE_B_CANNOT_SIGN_P_384_WITH_P_256 = ::T.let(nil, ::T.untyped)
  V_ERR_SUITE_B_INVALID_ALGORITHM = ::T.let(nil, ::T.untyped)
  V_ERR_SUITE_B_INVALID_CURVE = ::T.let(nil, ::T.untyped)
  V_ERR_SUITE_B_INVALID_SIGNATURE_ALGORITHM = ::T.let(nil, ::T.untyped)
  V_ERR_SUITE_B_INVALID_VERSION = ::T.let(nil, ::T.untyped)
  V_ERR_SUITE_B_LOS_NOT_ALLOWED = ::T.let(nil, ::T.untyped)
  V_ERR_UNABLE_TO_GET_CRL_ISSUER = ::T.let(nil, ::T.untyped)
  V_ERR_UNHANDLED_CRITICAL_CRL_EXTENSION = ::T.let(nil, ::T.untyped)
  V_ERR_UNHANDLED_CRITICAL_EXTENSION = ::T.let(nil, ::T.untyped)
  V_ERR_UNNESTED_RESOURCE = ::T.let(nil, ::T.untyped)
  V_ERR_UNSPECIFIED = ::T.let(nil, ::T.untyped)
  V_ERR_UNSUPPORTED_CONSTRAINT_SYNTAX = ::T.let(nil, ::T.untyped)
  V_ERR_UNSUPPORTED_CONSTRAINT_TYPE = ::T.let(nil, ::T.untyped)
  V_ERR_UNSUPPORTED_EXTENSION_FEATURE = ::T.let(nil, ::T.untyped)
  V_ERR_UNSUPPORTED_NAME_SYNTAX = ::T.let(nil, ::T.untyped)
  V_FLAG_NO_CHECK_TIME = ::T.let(nil, ::T.untyped)
  V_FLAG_PARTIAL_CHAIN = ::T.let(nil, ::T.untyped)
  V_FLAG_SUITEB_128_LOS = ::T.let(nil, ::T.untyped)
  V_FLAG_SUITEB_128_LOS_ONLY = ::T.let(nil, ::T.untyped)
  V_FLAG_SUITEB_192_LOS = ::T.let(nil, ::T.untyped)
  V_FLAG_TRUSTED_FIRST = ::T.let(nil, ::T.untyped)
  V_FLAG_USE_CHECK_TIME = ::T.let(nil, ::T.untyped)
end

class OpenSSL::X509::Attribute
  include ::OpenSSL::Marshal
  def ==(other); end
end

class OpenSSL::X509::Attribute
  extend ::OpenSSL::Marshal::ClassMethods
end

class OpenSSL::X509::CRL
  include ::OpenSSL::Marshal
  include ::OpenSSL::X509::Extension::AuthorityKeyIdentifier
  include ::OpenSSL::X509::Extension::Helpers
  def ==(other); end
end

class OpenSSL::X509::CRL
  extend ::OpenSSL::Marshal::ClassMethods
end

class OpenSSL::X509::Certificate
  include ::OpenSSL::Marshal
  include ::OpenSSL::X509::Extension::SubjectKeyIdentifier
  include ::OpenSSL::X509::Extension::AuthorityKeyIdentifier
  include ::OpenSSL::X509::Extension::CRLDistributionPoints
  include ::OpenSSL::X509::Extension::AuthorityInfoAccess
  include ::OpenSSL::X509::Extension::Helpers
end

class OpenSSL::X509::Certificate
  extend ::OpenSSL::Marshal::ClassMethods
  def self.load(arg); end

  def self.load_file(path); end
end

class OpenSSL::X509::Extension
  include ::OpenSSL::Marshal
  def ==(other); end

  def value_der(); end
end

module OpenSSL::X509::Extension::AuthorityInfoAccess
  include ::OpenSSL::X509::Extension::Helpers
  def ca_issuer_uris(); end

  def ocsp_uris(); end
end

module OpenSSL::X509::Extension::AuthorityInfoAccess
end

module OpenSSL::X509::Extension::AuthorityKeyIdentifier
  include ::OpenSSL::X509::Extension::Helpers
  def authority_key_identifier(); end
end

module OpenSSL::X509::Extension::AuthorityKeyIdentifier
end

module OpenSSL::X509::Extension::CRLDistributionPoints
  include ::OpenSSL::X509::Extension::Helpers
  def crl_uris(); end
end

module OpenSSL::X509::Extension::CRLDistributionPoints
end

module OpenSSL::X509::Extension::Helpers
  def find_extension(oid); end
end

module OpenSSL::X509::Extension::Helpers
end

module OpenSSL::X509::Extension::SubjectKeyIdentifier
  include ::OpenSSL::X509::Extension::Helpers
  def subject_key_identifier(); end
end

module OpenSSL::X509::Extension::SubjectKeyIdentifier
end

class OpenSSL::X509::Extension
  extend ::OpenSSL::Marshal::ClassMethods
end

class OpenSSL::X509::Name
  include ::OpenSSL::Marshal
  def to_utf8(); end
end

class OpenSSL::X509::Name
  extend ::OpenSSL::Marshal::ClassMethods
end

class OpenSSL::X509::Request
  include ::OpenSSL::Marshal
  def ==(other); end
end

class OpenSSL::X509::Request
  extend ::OpenSSL::Marshal::ClassMethods
end

class OpenSSL::X509::Revoked
  def ==(other); end

  def to_der(); end
end

module OpenSSL
  def self.fips_mode(); end
end

class OpenStruct
  def __id__!(); end

  def __send__!(*arg); end

  def as_json!(options=T.unsafe(nil)); end

  def at_exit!(&block); end

  def class!(); end

  def clone!(freeze: T.unsafe(nil)); end

  def deep_dup!(); end

  def define_singleton_method!(*arg); end

  def delete_field!(name, &block); end

  def dig!(name, *names); end

  def display!(*arg); end

  def dup!(); end

  def each_pair!(); end

  def encode_with(coder); end

  def encode_with!(coder); end

  def enum_for!(*arg); end

  def freeze!(); end

  def gem!(dep, *reqs); end

  def hash!(); end

  def init_with(coder); end

  def init_with!(coder); end

  def inspect!(); end

  def instance_eval!(*arg); end

  def instance_exec!(*arg); end

  def instance_values!(); end

  def instance_variable_get!(arg); end

  def instance_variable_names!(); end

  def instance_variable_set!(arg, arg1); end

  def instance_variables!(); end

  def itself!(); end

  def marshal_dump!(); end

  def method!(arg); end

  def methods!(*arg); end

  def object_id!(); end

  def presence!(); end

  def presence_in!(another_object); end

  def private_methods!(*arg); end

  def protected_methods!(*arg); end

  def public_method!(arg); end

  def public_methods!(*arg); end

  def public_send!(*arg); end

  def remove_instance_variable!(arg); end

  def require_dependency!(filename); end

  def send!(*arg); end

  def singleton_class!(); end

  def singleton_method!(arg); end

  def singleton_methods!(*arg); end

  def tap!(); end

  def then!(); end

  def to_enum!(*arg); end

  def to_h!(&block); end

  def to_param!(); end

  def to_query!(key); end

  def to_s!(); end

  def to_yaml!(options=T.unsafe(nil)); end

  def with!(**attributes); end

  def with_options!(options, &block); end

  def yield_self!(); end
  VERSION = ::T.let(nil, ::T.untyped)
end

module OpenURI
  RE_LWS = ::T.let(nil, ::T.untyped)
  RE_PARAMETERS = ::T.let(nil, ::T.untyped)
  RE_QUOTED_STRING = ::T.let(nil, ::T.untyped)
  RE_TOKEN = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

class OpenURI::Buffer
  def <<(str); end

  def io(); end

  def size(); end
  StringMax = ::T.let(nil, ::T.untyped)
end

class OpenURI::Buffer
end

class OpenURI::HTTPError
  def initialize(message, io); end
end

class OpenURI::HTTPRedirect
  def initialize(message, io, uri); end
end

module OpenURI::Meta
  def content_type_parse(); end

  def meta_add_field(name, value); end

  def meta_add_field2(name, values); end

  def meta_setup_encoding(); end
end

module OpenURI::Meta
  def self.init(obj, src=T.unsafe(nil)); end
end

class OpenURI::TooManyRedirects
end

class OpenURI::TooManyRedirects
end

module OpenURI
  def self.check_options(options); end

  def self.open_http(buf, target, proxy, options); end

  def self.open_loop(uri, options); end

  def self.open_uri(name, *rest); end

  def self.redirectable?(uri1, uri2); end

  def self.scan_open_optional_arguments(*rest); end
end

class OptionParser
  def additional_message(typ, opt); end

  def raise_unknown(); end

  def raise_unknown=(raise_unknown); end

  def require_exact(); end

  def require_exact=(require_exact); end
  Version = ::T.let(nil, ::T.untyped)
end

class OptionParser::List
  def get_candidates(id); end
end

class OptionParser::ParseError
  def additional(); end

  def additional=(additional); end
end

class OptionParser::Switch
  def pretty_print_contents(q); end
end

class OptionParser::Switch::NoArgument
  def pretty_head(); end
end

class OptionParser::Switch::OptionalArgument
  def pretty_head(); end
end

class OptionParser::Switch::PlacedArgument
  def pretty_head(); end
end

class OptionParser::Switch::RequiredArgument
  def pretty_head(); end
end

class Order
  def autosave_associated_records_for_product(*args); end

  def autosave_associated_records_for_user(*args); end

  def autosave_associated_records_for_voucher(*args); end
end

class PP
  VERSION = ::T.let(nil, ::T.untyped)
end

class PP
  def self.width_for(out); end
end

class Parser::Ruby24
  def _reduce_10(val, _values, result); end

  def _reduce_100(val, _values, result); end

  def _reduce_101(val, _values, result); end

  def _reduce_102(val, _values, result); end

  def _reduce_103(val, _values, result); end

  def _reduce_104(val, _values, result); end

  def _reduce_105(val, _values, result); end

  def _reduce_106(val, _values, result); end

  def _reduce_107(val, _values, result); end

  def _reduce_108(val, _values, result); end

  def _reduce_11(val, _values, result); end

  def _reduce_110(val, _values, result); end

  def _reduce_111(val, _values, result); end

  def _reduce_112(val, _values, result); end

  def _reduce_118(val, _values, result); end

  def _reduce_12(val, _values, result); end

  def _reduce_122(val, _values, result); end

  def _reduce_123(val, _values, result); end

  def _reduce_124(val, _values, result); end

  def _reduce_13(val, _values, result); end

  def _reduce_14(val, _values, result); end

  def _reduce_16(val, _values, result); end

  def _reduce_17(val, _values, result); end

  def _reduce_18(val, _values, result); end

  def _reduce_19(val, _values, result); end

  def _reduce_196(val, _values, result); end

  def _reduce_197(val, _values, result); end

  def _reduce_198(val, _values, result); end

  def _reduce_199(val, _values, result); end

  def _reduce_2(val, _values, result); end

  def _reduce_20(val, _values, result); end

  def _reduce_200(val, _values, result); end

  def _reduce_201(val, _values, result); end

  def _reduce_202(val, _values, result); end

  def _reduce_203(val, _values, result); end

  def _reduce_204(val, _values, result); end

  def _reduce_205(val, _values, result); end

  def _reduce_206(val, _values, result); end

  def _reduce_207(val, _values, result); end

  def _reduce_208(val, _values, result); end

  def _reduce_209(val, _values, result); end

  def _reduce_21(val, _values, result); end

  def _reduce_210(val, _values, result); end

  def _reduce_211(val, _values, result); end

  def _reduce_212(val, _values, result); end

  def _reduce_213(val, _values, result); end

  def _reduce_214(val, _values, result); end

  def _reduce_215(val, _values, result); end

  def _reduce_216(val, _values, result); end

  def _reduce_217(val, _values, result); end

  def _reduce_218(val, _values, result); end

  def _reduce_219(val, _values, result); end

  def _reduce_22(val, _values, result); end

  def _reduce_220(val, _values, result); end

  def _reduce_221(val, _values, result); end

  def _reduce_222(val, _values, result); end

  def _reduce_223(val, _values, result); end

  def _reduce_224(val, _values, result); end

  def _reduce_225(val, _values, result); end

  def _reduce_226(val, _values, result); end

  def _reduce_227(val, _values, result); end

  def _reduce_228(val, _values, result); end

  def _reduce_229(val, _values, result); end

  def _reduce_23(val, _values, result); end

  def _reduce_230(val, _values, result); end

  def _reduce_231(val, _values, result); end

  def _reduce_232(val, _values, result); end

  def _reduce_233(val, _values, result); end

  def _reduce_234(val, _values, result); end

  def _reduce_235(val, _values, result); end

  def _reduce_236(val, _values, result); end

  def _reduce_24(val, _values, result); end

  def _reduce_241(val, _values, result); end

  def _reduce_242(val, _values, result); end

  def _reduce_244(val, _values, result); end

  def _reduce_245(val, _values, result); end

  def _reduce_246(val, _values, result); end

  def _reduce_248(val, _values, result); end

  def _reduce_25(val, _values, result); end

  def _reduce_251(val, _values, result); end

  def _reduce_252(val, _values, result); end

  def _reduce_253(val, _values, result); end

  def _reduce_254(val, _values, result); end

  def _reduce_255(val, _values, result); end

  def _reduce_256(val, _values, result); end

  def _reduce_257(val, _values, result); end

  def _reduce_258(val, _values, result); end

  def _reduce_259(val, _values, result); end

  def _reduce_26(val, _values, result); end

  def _reduce_260(val, _values, result); end

  def _reduce_261(val, _values, result); end

  def _reduce_262(val, _values, result); end

  def _reduce_263(val, _values, result); end

  def _reduce_264(val, _values, result); end

  def _reduce_265(val, _values, result); end

  def _reduce_266(val, _values, result); end

  def _reduce_267(val, _values, result); end

  def _reduce_269(val, _values, result); end

  def _reduce_27(val, _values, result); end

  def _reduce_270(val, _values, result); end

  def _reduce_271(val, _values, result); end

  def _reduce_28(val, _values, result); end

  def _reduce_282(val, _values, result); end

  def _reduce_283(val, _values, result); end

  def _reduce_284(val, _values, result); end

  def _reduce_285(val, _values, result); end

  def _reduce_286(val, _values, result); end

  def _reduce_287(val, _values, result); end

  def _reduce_288(val, _values, result); end

  def _reduce_289(val, _values, result); end

  def _reduce_290(val, _values, result); end

  def _reduce_291(val, _values, result); end

  def _reduce_292(val, _values, result); end

  def _reduce_293(val, _values, result); end

  def _reduce_294(val, _values, result); end

  def _reduce_295(val, _values, result); end

  def _reduce_296(val, _values, result); end

  def _reduce_297(val, _values, result); end

  def _reduce_298(val, _values, result); end

  def _reduce_299(val, _values, result); end

  def _reduce_3(val, _values, result); end

  def _reduce_30(val, _values, result); end

  def _reduce_300(val, _values, result); end

  def _reduce_301(val, _values, result); end

  def _reduce_303(val, _values, result); end

  def _reduce_304(val, _values, result); end

  def _reduce_305(val, _values, result); end

  def _reduce_306(val, _values, result); end

  def _reduce_307(val, _values, result); end

  def _reduce_308(val, _values, result); end

  def _reduce_309(val, _values, result); end

  def _reduce_31(val, _values, result); end

  def _reduce_310(val, _values, result); end

  def _reduce_311(val, _values, result); end

  def _reduce_312(val, _values, result); end

  def _reduce_313(val, _values, result); end

  def _reduce_314(val, _values, result); end

  def _reduce_315(val, _values, result); end

  def _reduce_316(val, _values, result); end

  def _reduce_317(val, _values, result); end

  def _reduce_318(val, _values, result); end

  def _reduce_319(val, _values, result); end

  def _reduce_32(val, _values, result); end

  def _reduce_320(val, _values, result); end

  def _reduce_321(val, _values, result); end

  def _reduce_322(val, _values, result); end

  def _reduce_323(val, _values, result); end

  def _reduce_324(val, _values, result); end

  def _reduce_325(val, _values, result); end

  def _reduce_326(val, _values, result); end

  def _reduce_327(val, _values, result); end

  def _reduce_328(val, _values, result); end

  def _reduce_329(val, _values, result); end

  def _reduce_330(val, _values, result); end

  def _reduce_331(val, _values, result); end

  def _reduce_332(val, _values, result); end

  def _reduce_333(val, _values, result); end

  def _reduce_335(val, _values, result); end

  def _reduce_336(val, _values, result); end

  def _reduce_339(val, _values, result); end

  def _reduce_34(val, _values, result); end

  def _reduce_343(val, _values, result); end

  def _reduce_345(val, _values, result); end

  def _reduce_348(val, _values, result); end

  def _reduce_349(val, _values, result); end

  def _reduce_35(val, _values, result); end

  def _reduce_350(val, _values, result); end

  def _reduce_351(val, _values, result); end

  def _reduce_353(val, _values, result); end

  def _reduce_354(val, _values, result); end

  def _reduce_355(val, _values, result); end

  def _reduce_356(val, _values, result); end

  def _reduce_357(val, _values, result); end

  def _reduce_358(val, _values, result); end

  def _reduce_359(val, _values, result); end

  def _reduce_36(val, _values, result); end

  def _reduce_360(val, _values, result); end

  def _reduce_361(val, _values, result); end

  def _reduce_362(val, _values, result); end

  def _reduce_363(val, _values, result); end

  def _reduce_364(val, _values, result); end

  def _reduce_365(val, _values, result); end

  def _reduce_366(val, _values, result); end

  def _reduce_367(val, _values, result); end

  def _reduce_368(val, _values, result); end

  def _reduce_369(val, _values, result); end

  def _reduce_37(val, _values, result); end

  def _reduce_370(val, _values, result); end

  def _reduce_371(val, _values, result); end

  def _reduce_373(val, _values, result); end

  def _reduce_374(val, _values, result); end

  def _reduce_375(val, _values, result); end

  def _reduce_376(val, _values, result); end

  def _reduce_377(val, _values, result); end

  def _reduce_378(val, _values, result); end

  def _reduce_379(val, _values, result); end

  def _reduce_38(val, _values, result); end

  def _reduce_380(val, _values, result); end

  def _reduce_382(val, _values, result); end

  def _reduce_383(val, _values, result); end

  def _reduce_384(val, _values, result); end

  def _reduce_385(val, _values, result); end

  def _reduce_386(val, _values, result); end

  def _reduce_387(val, _values, result); end

  def _reduce_388(val, _values, result); end

  def _reduce_389(val, _values, result); end

  def _reduce_39(val, _values, result); end

  def _reduce_390(val, _values, result); end

  def _reduce_391(val, _values, result); end

  def _reduce_393(val, _values, result); end

  def _reduce_394(val, _values, result); end

  def _reduce_395(val, _values, result); end

  def _reduce_396(val, _values, result); end

  def _reduce_397(val, _values, result); end

  def _reduce_398(val, _values, result); end

  def _reduce_399(val, _values, result); end

  def _reduce_4(val, _values, result); end

  def _reduce_40(val, _values, result); end

  def _reduce_400(val, _values, result); end

  def _reduce_401(val, _values, result); end

  def _reduce_402(val, _values, result); end

  def _reduce_403(val, _values, result); end

  def _reduce_404(val, _values, result); end

  def _reduce_405(val, _values, result); end

  def _reduce_406(val, _values, result); end

  def _reduce_407(val, _values, result); end

  def _reduce_408(val, _values, result); end

  def _reduce_409(val, _values, result); end

  def _reduce_41(val, _values, result); end

  def _reduce_410(val, _values, result); end

  def _reduce_411(val, _values, result); end

  def _reduce_412(val, _values, result); end

  def _reduce_413(val, _values, result); end

  def _reduce_414(val, _values, result); end

  def _reduce_415(val, _values, result); end

  def _reduce_416(val, _values, result); end

  def _reduce_417(val, _values, result); end

  def _reduce_418(val, _values, result); end

  def _reduce_419(val, _values, result); end

  def _reduce_420(val, _values, result); end

  def _reduce_421(val, _values, result); end

  def _reduce_422(val, _values, result); end

  def _reduce_423(val, _values, result); end

  def _reduce_424(val, _values, result); end

  def _reduce_425(val, _values, result); end

  def _reduce_426(val, _values, result); end

  def _reduce_427(val, _values, result); end

  def _reduce_429(val, _values, result); end

  def _reduce_43(val, _values, result); end

  def _reduce_430(val, _values, result); end

  def _reduce_431(val, _values, result); end

  def _reduce_434(val, _values, result); end

  def _reduce_436(val, _values, result); end

  def _reduce_441(val, _values, result); end

  def _reduce_442(val, _values, result); end

  def _reduce_443(val, _values, result); end

  def _reduce_444(val, _values, result); end

  def _reduce_445(val, _values, result); end

  def _reduce_446(val, _values, result); end

  def _reduce_447(val, _values, result); end

  def _reduce_448(val, _values, result); end

  def _reduce_449(val, _values, result); end

  def _reduce_450(val, _values, result); end

  def _reduce_451(val, _values, result); end

  def _reduce_452(val, _values, result); end

  def _reduce_453(val, _values, result); end

  def _reduce_454(val, _values, result); end

  def _reduce_455(val, _values, result); end

  def _reduce_456(val, _values, result); end

  def _reduce_457(val, _values, result); end

  def _reduce_458(val, _values, result); end

  def _reduce_459(val, _values, result); end

  def _reduce_46(val, _values, result); end

  def _reduce_460(val, _values, result); end

  def _reduce_461(val, _values, result); end

  def _reduce_462(val, _values, result); end

  def _reduce_463(val, _values, result); end

  def _reduce_464(val, _values, result); end

  def _reduce_465(val, _values, result); end

  def _reduce_466(val, _values, result); end

  def _reduce_467(val, _values, result); end

  def _reduce_468(val, _values, result); end

  def _reduce_469(val, _values, result); end

  def _reduce_47(val, _values, result); end

  def _reduce_470(val, _values, result); end

  def _reduce_471(val, _values, result); end

  def _reduce_472(val, _values, result); end

  def _reduce_473(val, _values, result); end

  def _reduce_474(val, _values, result); end

  def _reduce_475(val, _values, result); end

  def _reduce_477(val, _values, result); end

  def _reduce_478(val, _values, result); end

  def _reduce_479(val, _values, result); end

  def _reduce_48(val, _values, result); end

  def _reduce_480(val, _values, result); end

  def _reduce_481(val, _values, result); end

  def _reduce_482(val, _values, result); end

  def _reduce_483(val, _values, result); end

  def _reduce_484(val, _values, result); end

  def _reduce_485(val, _values, result); end

  def _reduce_486(val, _values, result); end

  def _reduce_487(val, _values, result); end

  def _reduce_488(val, _values, result); end

  def _reduce_489(val, _values, result); end

  def _reduce_49(val, _values, result); end

  def _reduce_490(val, _values, result); end

  def _reduce_491(val, _values, result); end

  def _reduce_492(val, _values, result); end

  def _reduce_493(val, _values, result); end

  def _reduce_494(val, _values, result); end

  def _reduce_495(val, _values, result); end

  def _reduce_496(val, _values, result); end

  def _reduce_497(val, _values, result); end

  def _reduce_498(val, _values, result); end

  def _reduce_499(val, _values, result); end

  def _reduce_5(val, _values, result); end

  def _reduce_500(val, _values, result); end

  def _reduce_501(val, _values, result); end

  def _reduce_502(val, _values, result); end

  def _reduce_503(val, _values, result); end

  def _reduce_504(val, _values, result); end

  def _reduce_505(val, _values, result); end

  def _reduce_506(val, _values, result); end

  def _reduce_507(val, _values, result); end

  def _reduce_508(val, _values, result); end

  def _reduce_509(val, _values, result); end

  def _reduce_510(val, _values, result); end

  def _reduce_511(val, _values, result); end

  def _reduce_512(val, _values, result); end

  def _reduce_513(val, _values, result); end

  def _reduce_514(val, _values, result); end

  def _reduce_515(val, _values, result); end

  def _reduce_516(val, _values, result); end

  def _reduce_517(val, _values, result); end

  def _reduce_518(val, _values, result); end

  def _reduce_519(val, _values, result); end

  def _reduce_520(val, _values, result); end

  def _reduce_521(val, _values, result); end

  def _reduce_522(val, _values, result); end

  def _reduce_523(val, _values, result); end

  def _reduce_524(val, _values, result); end

  def _reduce_525(val, _values, result); end

  def _reduce_526(val, _values, result); end

  def _reduce_527(val, _values, result); end

  def _reduce_528(val, _values, result); end

  def _reduce_529(val, _values, result); end

  def _reduce_530(val, _values, result); end

  def _reduce_531(val, _values, result); end

  def _reduce_532(val, _values, result); end

  def _reduce_533(val, _values, result); end

  def _reduce_535(val, _values, result); end

  def _reduce_536(val, _values, result); end

  def _reduce_537(val, _values, result); end

  def _reduce_538(val, _values, result); end

  def _reduce_539(val, _values, result); end

  def _reduce_540(val, _values, result); end

  def _reduce_541(val, _values, result); end

  def _reduce_542(val, _values, result); end

  def _reduce_543(val, _values, result); end

  def _reduce_544(val, _values, result); end

  def _reduce_545(val, _values, result); end

  def _reduce_546(val, _values, result); end

  def _reduce_547(val, _values, result); end

  def _reduce_548(val, _values, result); end

  def _reduce_549(val, _values, result); end

  def _reduce_55(val, _values, result); end

  def _reduce_552(val, _values, result); end

  def _reduce_553(val, _values, result); end

  def _reduce_554(val, _values, result); end

  def _reduce_555(val, _values, result); end

  def _reduce_556(val, _values, result); end

  def _reduce_557(val, _values, result); end

  def _reduce_558(val, _values, result); end

  def _reduce_559(val, _values, result); end

  def _reduce_56(val, _values, result); end

  def _reduce_562(val, _values, result); end

  def _reduce_563(val, _values, result); end

  def _reduce_566(val, _values, result); end

  def _reduce_567(val, _values, result); end

  def _reduce_568(val, _values, result); end

  def _reduce_57(val, _values, result); end

  def _reduce_570(val, _values, result); end

  def _reduce_571(val, _values, result); end

  def _reduce_573(val, _values, result); end

  def _reduce_574(val, _values, result); end

  def _reduce_575(val, _values, result); end

  def _reduce_576(val, _values, result); end

  def _reduce_577(val, _values, result); end

  def _reduce_578(val, _values, result); end

  def _reduce_59(val, _values, result); end

  def _reduce_591(val, _values, result); end

  def _reduce_592(val, _values, result); end

  def _reduce_597(val, _values, result); end

  def _reduce_598(val, _values, result); end

  def _reduce_6(val, _values, result); end

  def _reduce_60(val, _values, result); end

  def _reduce_602(val, _values, result); end

  def _reduce_606(val, _values, result); end

  def _reduce_61(val, _values, result); end

  def _reduce_62(val, _values, result); end

  def _reduce_63(val, _values, result); end

  def _reduce_64(val, _values, result); end

  def _reduce_65(val, _values, result); end

  def _reduce_66(val, _values, result); end

  def _reduce_67(val, _values, result); end

  def _reduce_68(val, _values, result); end

  def _reduce_69(val, _values, result); end

  def _reduce_70(val, _values, result); end

  def _reduce_71(val, _values, result); end

  def _reduce_72(val, _values, result); end

  def _reduce_73(val, _values, result); end

  def _reduce_75(val, _values, result); end

  def _reduce_76(val, _values, result); end

  def _reduce_77(val, _values, result); end

  def _reduce_78(val, _values, result); end

  def _reduce_79(val, _values, result); end

  def _reduce_8(val, _values, result); end

  def _reduce_80(val, _values, result); end

  def _reduce_81(val, _values, result); end

  def _reduce_82(val, _values, result); end

  def _reduce_83(val, _values, result); end

  def _reduce_85(val, _values, result); end

  def _reduce_86(val, _values, result); end

  def _reduce_87(val, _values, result); end

  def _reduce_88(val, _values, result); end

  def _reduce_89(val, _values, result); end

  def _reduce_9(val, _values, result); end

  def _reduce_90(val, _values, result); end

  def _reduce_91(val, _values, result); end

  def _reduce_92(val, _values, result); end

  def _reduce_93(val, _values, result); end

  def _reduce_94(val, _values, result); end

  def _reduce_95(val, _values, result); end

  def _reduce_96(val, _values, result); end

  def _reduce_97(val, _values, result); end

  def _reduce_98(val, _values, result); end

  def _reduce_99(val, _values, result); end

  def _reduce_none(val, _values, result); end

  def default_encoding(); end

  def local_pop(); end

  def local_push(); end

  def version(); end
  Racc_arg = ::T.let(nil, ::T.untyped)
  Racc_debug_parser = ::T.let(nil, ::T.untyped)
  Racc_token_to_s_table = ::T.let(nil, ::T.untyped)
end

class Parser::Ruby24
end

class Pathname
  def existence(); end

  def lutime(arg, arg1); end
  VERSION = ::T.let(nil, ::T.untyped)
end

class PlayerStatistic
  def autosave_associated_records_for_reservation(*args); end

  def autosave_associated_records_for_reservation_player(*args); end

  def autosave_associated_records_for_server(*args); end

  def autosave_associated_records_for_user(*args); end
end

class PlayerStatisticDecorator
  include ::Draper::AutomaticDelegation
  def player_statistic(); end
end

class PlayerStatisticDecorator
  extend ::Draper::AutomaticDelegation::ClassMethods
end

class PrettyPrint
  VERSION = ::T.let(nil, ::T.untyped)
end

class PrivateServer
  def __callbacks(); end

  def __callbacks?(); end

  def _run_validate_callbacks(&block); end

  def _validate_callbacks(); end

  def _validators(); end

  def _validators?(); end

  def model_name(&arg); end

  def param_delimiter=(param_delimiter); end

  def validation_context(); end
end

class PrivateServer
  def self.__callbacks(); end

  def self.__callbacks=(value); end

  def self.__callbacks?(); end

  def self._validate_callbacks(); end

  def self._validate_callbacks=(value); end

  def self._validators(); end

  def self._validators=(value); end

  def self._validators?(); end

  def self.param_delimiter(); end

  def self.param_delimiter=(value); end

  def self.param_delimiter?(); end
end

class PrivateServerCleanupWorker
  def sidekiq_options_hash(); end

  def sidekiq_options_hash=(sidekiq_options_hash); end

  def sidekiq_retries_exhausted_block(); end

  def sidekiq_retries_exhausted_block=(sidekiq_retries_exhausted_block); end

  def sidekiq_retry_in_block(); end

  def sidekiq_retry_in_block=(sidekiq_retry_in_block); end
end

class PrivateServerCleanupWorker
  def self.sidekiq_options_hash(); end

  def self.sidekiq_options_hash=(val); end

  def self.sidekiq_retries_exhausted_block(); end

  def self.sidekiq_retries_exhausted_block=(val); end

  def self.sidekiq_retry_in_block(); end

  def self.sidekiq_retry_in_block=(val); end
end

class Proc
  def <<(arg); end

  def >>(arg); end

  def clone(); end
end

module Process
  CLOCK_TAI = ::T.let(nil, ::T.untyped)
end

class Process::Status
  def self.wait(*arg); end
end

class Process::Tms
  def self.keyword_init?(); end
end

module Process
  def self.exit(*arg); end

  def self.warmup(); end
end

class Product
  def autosave_associated_records_for_orders(*args); end

  def validate_associated_records_for_orders(*args); end
end

module Psych
  LOADER_VERSION = ::T.let(nil, ::T.untyped)
end

module Psych
  def self.libyaml_version(); end

  def self.unsafe_load_file(filename, **kwargs); end
end

class Puma::Server
  include ::Sentry::Puma::Server
end

class RDoc::Markup::AttrChanger
  def self.keyword_init?(); end
end

class RDoc::Markup::Formatter::InlineTag
  def self.keyword_init?(); end
end

class RDoc::Markup::Heading
  def self.keyword_init?(); end
end

module RSpec::Core::Configuration::Readers
  def file_fixture_path(); end

  def fixture_paths(); end

  def global_fixtures(); end

  def infer_base_class_for_anonymous_controllers(); end

  def rendering_views(); end

  def use_active_record(); end

  def use_instantiated_fixtures(); end

  def use_transactional_fixtures(); end
end

class RSpec::Core::ExampleGroup
  def wildcard_matcher(); end
end

class RSpec::Core::ExampleGroup
  def self.feature(*args, &example_group_block); end

  def self.ffeature(*args, &example_group_block); end

  def self.fscenario(*all_args, &block); end

  def self.scenario(*all_args, &block); end

  def self.xfeature(*args, &example_group_block); end

  def self.xscenario(*all_args, &block); end
end

module RSpec::Core::MockingAdapters
end

module RSpec::Core::MockingAdapters::RSpec
  include ::RSpec::Mocks::ExampleMethods
  include ::RSpec::Mocks::ArgumentMatchers
  include ::RSpec::Mocks::ExampleMethods::ExpectHost
  def setup_mocks_for_rspec(); end

  def teardown_mocks_for_rspec(); end

  def verify_mocks_for_rspec(); end
end

module RSpec::Core::MockingAdapters::RSpec
  def self.configuration(); end

  def self.framework_name(); end
end

module RSpec::Core::MockingAdapters
end

class RSpec::Expectations::MultipleExpectationsNotMetError
  include ::RSpec::Core::MultipleExceptionError::InterfaceTag
end

module RSpec::Matchers
  include ::Capybara::RSpecMatcherProxyInstaller
end

class RSpec::Matchers::DSL::Matcher
  include ::Capybara::RSpecMatcherProxyInstaller
end

module RSpec::Matchers
  extend ::Capybara::RSpecMatcherProxyInstaller::ClassMethods
end

module RSpec::Rails
  DIRECTORY_MAPPINGS = ::T.let(nil, ::T.untyped)
end

class RSpec::Rails::ActiveRecordConfiguration
end

class RSpec::Rails::ActiveRecordConfiguration
  def self.initialize_activerecord_configuration(config); end
end

class RSpec::Rails::AssertionDelegator
  def initialize(*assertion_modules); end
end

class RSpec::Rails::AssertionDelegator
end

RSpec::Rails::Assertions = Minitest::Assertions

module RSpec::Rails::ChannelExampleGroup
  def have_rejected_connection(); end

  def have_stream_for(object); end

  def have_stream_from(stream); end

  def have_streams(); end
end

module RSpec::Rails::ChannelExampleGroup::ClassMethods
  def channel_class(); end

  def connection_class(); end
end

module RSpec::Rails::ChannelExampleGroup::ClassMethods
end

module RSpec::Rails::ChannelExampleGroup
  extend ::ActiveSupport::Concern
end

class RSpec::Rails::Configuration
end

class RSpec::Rails::Configuration
end

module RSpec::Rails::ControllerAssertionDelegator
  def assert_generates(*args, &block); end

  def assert_recognizes(*args, &block); end

  def assert_routing(*args, &block); end

  def assertion_instance(); end

  def build_assertion_instance(); end

  def setup(*args, &block); end

  def with_routing(*args, &block); end
end

module RSpec::Rails::ControllerAssertionDelegator
end

module RSpec::Rails::ControllerExampleGroup
  include ::RSpec::Rails::Matchers::RedirectTo
  include ::RSpec::Rails::Matchers::RenderTemplate
  include ::RSpec::Rails::Matchers::RoutingMatchers
  include ::RSpec::Rails::ControllerAssertionDelegator
  def bypass_rescue(); end

  def controller(); end

  def method_missing(method, *args, **arg, &block); end

  def routes(); end

  def routes=(routes); end
end

module RSpec::Rails::ControllerExampleGroup::BypassRescue
  def rescue_with_handler(exception); end
end

module RSpec::Rails::ControllerExampleGroup::BypassRescue
end

module RSpec::Rails::ControllerExampleGroup::ClassMethods
  def controller(base_class=T.unsafe(nil), &body); end

  def controller_class(); end

  def routes(); end
end

module RSpec::Rails::ControllerExampleGroup::ClassMethods
end

module RSpec::Rails::ControllerExampleGroup
  extend ::ActiveSupport::Concern
end

module RSpec::Rails::FeatureExampleGroup
  def visit(*arg); end
  DEFAULT_HOST = ::T.let(nil, ::T.untyped)
end

module RSpec::Rails::FeatureExampleGroup
  extend ::ActiveSupport::Concern
end

module RSpec::Rails::FileFixtureSupport
end

module RSpec::Rails::FileFixtureSupport
  extend ::ActiveSupport::Concern
end

module RSpec::Rails::FixtureFileUploadSupport
  def fixture_file_upload(*arg, **arg1, &arg2); end
end

class RSpec::Rails::FixtureFileUploadSupport::RailsFixtureFileWrapper
  include ::ActionDispatch::TestProcess
  include ::ActionDispatch::TestProcess::FixtureFile
  include ::ActiveSupport::Testing::FileFixtures
  def file_fixture_path(); end

  def file_fixture_path?(); end
end

class RSpec::Rails::FixtureFileUploadSupport::RailsFixtureFileWrapper
  def self.file_fixture_path(); end

  def self.file_fixture_path=(value); end

  def self.file_fixture_path?(); end

  def self.fixture_paths(); end

  def self.fixture_paths=(fixture_paths); end

  def self.instance(); end
end

module RSpec::Rails::FixtureFileUploadSupport
end

module RSpec::Rails::FixtureSupport
  def run_in_transaction?(); end
end

module RSpec::Rails::FixtureSupport::Fixtures
end

module RSpec::Rails::FixtureSupport::Fixtures::ClassMethods
  def fixtures(*args); end

  def proxy_method_warning_if_called_in_before_context_scope(method_name, fixture_name); end
end

module RSpec::Rails::FixtureSupport::Fixtures::ClassMethods
end

module RSpec::Rails::FixtureSupport::Fixtures
  extend ::ActiveSupport::Concern
end

module RSpec::Rails::FixtureSupport
  extend ::ActiveSupport::Concern
end

module RSpec::Rails::HelperExampleGroup
  include ::RSpec::Rails::ViewAssigns
  def helper(); end
end

module RSpec::Rails::HelperExampleGroup::ClassMethods
  def determine_constant_from_test_name(_ignore); end
end

module RSpec::Rails::HelperExampleGroup::ClassMethods
end

module RSpec::Rails::HelperExampleGroup
  extend ::ActiveSupport::Concern
end

module RSpec::Rails::JobExampleGroup
end

module RSpec::Rails::JobExampleGroup
  extend ::ActiveSupport::Concern
end

module RSpec::Rails::MailboxExampleGroup
  def have_been_delivered(); end

  def have_bounced(); end

  def have_failed(); end

  def process(message); end
end

module RSpec::Rails::MailboxExampleGroup::ClassMethods
  def mailbox_class(); end
end

module RSpec::Rails::MailboxExampleGroup::ClassMethods
end

module RSpec::Rails::MailboxExampleGroup
  extend ::ActiveSupport::Concern
  extend ::ActionMailbox::TestHelper
  def self.create_inbound_email(arg); end
end

module RSpec::Rails::MailerExampleGroup
end

module RSpec::Rails::MailerExampleGroup::ClassMethods
  def mailer_class(); end
end

module RSpec::Rails::MailerExampleGroup::ClassMethods
end

module RSpec::Rails::MailerExampleGroup
  extend ::ActiveSupport::Concern
end

module RSpec::Rails::Matchers
  def be_a_new(model_class); end

  def be_new_record(); end

  def be_valid(*args); end

  def broadcast_to(target=T.unsafe(nil)); end

  def enqueue_email(mailer_class=T.unsafe(nil), mail_method_name=T.unsafe(nil)); end

  def enqueue_job(job=T.unsafe(nil)); end

  def enqueue_mail(mailer_class=T.unsafe(nil), mail_method_name=T.unsafe(nil)); end

  def have_been_enqueued(); end

  def have_been_performed(); end

  def have_broadcasted_to(target=T.unsafe(nil)); end

  def have_enqueued_email(mailer_class=T.unsafe(nil), mail_method_name=T.unsafe(nil)); end

  def have_enqueued_job(job=T.unsafe(nil)); end

  def have_enqueued_mail(mailer_class=T.unsafe(nil), mail_method_name=T.unsafe(nil)); end

  def have_http_status(target); end

  def have_performed_job(job=T.unsafe(nil)); end

  def perform_job(job=T.unsafe(nil)); end

  def receive_inbound_email(message); end

  def send_email(criteria=T.unsafe(nil)); end
end

module RSpec::Rails::Matchers::ActionCable
end

class RSpec::Rails::Matchers::ActionCable::HaveBroadcastedTo
  def at_least(count); end

  def at_most(count); end

  def exactly(count); end

  def from_channel(channel); end

  def initialize(target, channel:); end

  def matches?(proc); end

  def message_expectation_modifier(); end

  def once(); end

  def thrice(); end

  def times(); end

  def twice(); end

  def with(data=T.unsafe(nil), &block); end
end

class RSpec::Rails::Matchers::ActionCable::HaveBroadcastedTo
end

class RSpec::Rails::Matchers::ActionCable::HaveStream
  def does_not_match?(subscription); end

  def matches?(subscription); end
end

class RSpec::Rails::Matchers::ActionCable::HaveStream
end

module RSpec::Rails::Matchers::ActionCable
end

module RSpec::Rails::Matchers::ActionMailbox
end

class RSpec::Rails::Matchers::ActionMailbox::Base
end

class RSpec::Rails::Matchers::ActionMailbox::Base
end

class RSpec::Rails::Matchers::ActionMailbox::ReceiveInboundEmail
  def initialize(message); end

  def matches?(mailbox); end
end

class RSpec::Rails::Matchers::ActionMailbox::ReceiveInboundEmail
end

module RSpec::Rails::Matchers::ActionMailbox
end

module RSpec::Rails::Matchers::ActiveJob
end

class RSpec::Rails::Matchers::ActiveJob::Base
  def at(time_or_date); end

  def at_least(count); end

  def at_most(count); end

  def exactly(count); end

  def initialize(); end

  def message_expectation_modifier(); end

  def on_queue(queue); end

  def once(); end

  def thrice(); end

  def times(); end

  def twice(); end

  def with(*args, &block); end
end

class RSpec::Rails::Matchers::ActiveJob::Base
end

class RSpec::Rails::Matchers::ActiveJob::HaveBeenEnqueued
  def does_not_match?(proc); end

  def matches?(job); end
  FAILURE_MESSAGE_EXPECTATION_ACTION = ::T.let(nil, ::T.untyped)
  MESSAGE_EXPECTATION_ACTION = ::T.let(nil, ::T.untyped)
end

class RSpec::Rails::Matchers::ActiveJob::HaveBeenEnqueued
end

class RSpec::Rails::Matchers::ActiveJob::HaveBeenPerformed
  def matches?(job); end
  FAILURE_MESSAGE_EXPECTATION_ACTION = ::T.let(nil, ::T.untyped)
  MESSAGE_EXPECTATION_ACTION = ::T.let(nil, ::T.untyped)
end

class RSpec::Rails::Matchers::ActiveJob::HaveBeenPerformed
end

class RSpec::Rails::Matchers::ActiveJob::HaveEnqueuedJob
  def does_not_match?(proc); end

  def initialize(job); end

  def matches?(proc); end
  FAILURE_MESSAGE_EXPECTATION_ACTION = ::T.let(nil, ::T.untyped)
  MESSAGE_EXPECTATION_ACTION = ::T.let(nil, ::T.untyped)
end

class RSpec::Rails::Matchers::ActiveJob::HaveEnqueuedJob
end

class RSpec::Rails::Matchers::ActiveJob::HavePerformedJob
  def initialize(job); end

  def matches?(proc); end
  FAILURE_MESSAGE_EXPECTATION_ACTION = ::T.let(nil, ::T.untyped)
  MESSAGE_EXPECTATION_ACTION = ::T.let(nil, ::T.untyped)
end

class RSpec::Rails::Matchers::ActiveJob::HavePerformedJob
end

module RSpec::Rails::Matchers::ActiveJob
end

class RSpec::Rails::Matchers::BaseMatcher
  include ::RSpec::Matchers::Composable
  include ::RSpec::Rails::Matchers::BaseMatcher::HashFormatting
  include ::RSpec::Rails::Matchers::BaseMatcher::DefaultFailureMessages
  def actual(); end

  def actual_formatted(); end

  def description(); end

  def diffable?(); end

  def expected(); end

  def expected_formatted(); end

  def expects_call_stack_jump?(); end

  def initialize(expected=T.unsafe(nil)); end

  def match_unless_raises(*exceptions); end

  def matcher_name(); end

  def matcher_name=(matcher_name); end

  def matches?(actual); end

  def present_ivars(); end

  def rescued_exception(); end

  def supports_block_expectations?(); end
  UNDEFINED = ::T.let(nil, ::T.untyped)
end

module RSpec::Rails::Matchers::BaseMatcher::DefaultFailureMessages
  def failure_message(); end

  def failure_message_when_negated(); end
end

module RSpec::Rails::Matchers::BaseMatcher::DefaultFailureMessages
  def self.has_default_failure_messages?(matcher); end
end

module RSpec::Rails::Matchers::BaseMatcher::HashFormatting
end

module RSpec::Rails::Matchers::BaseMatcher::HashFormatting
  def self.improve_hash_formatting(inspect_string); end
end

class RSpec::Rails::Matchers::BaseMatcher
  def self.matcher_name(); end
end

class RSpec::Rails::Matchers::BeANew
  def initialize(expected); end

  def with(expected_attributes); end
end

class RSpec::Rails::Matchers::BeANew
end

class RSpec::Rails::Matchers::BeANewRecord
end

class RSpec::Rails::Matchers::BeANewRecord
end

class RSpec::Rails::Matchers::BeValid
end

class RSpec::Rails::Matchers::BeValid
end

class RSpec::Rails::Matchers::HaveEnqueuedMail
  include ::RSpec::Mocks::ArgumentMatchers
  def initialize(mailer_class, method_name); end

  def matches?(block); end
  MAILER_JOB_METHOD = ::T.let(nil, ::T.untyped)
end

class RSpec::Rails::Matchers::HaveEnqueuedMail
end

module RSpec::Rails::Matchers::HaveHttpStatus
  def invalid_response_type_message(); end
end

class RSpec::Rails::Matchers::HaveHttpStatus::GenericStatus
  include ::RSpec::Rails::Matchers::HaveHttpStatus
  def check_expected_status(test_response, expected); end

  def initialize(type); end

  def matches?(response); end
  RESPONSE_METHODS = ::T.let(nil, ::T.untyped)
end

class RSpec::Rails::Matchers::HaveHttpStatus::GenericStatus
  def self.valid_statuses(); end
end

class RSpec::Rails::Matchers::HaveHttpStatus::NumericCode
  include ::RSpec::Rails::Matchers::HaveHttpStatus
  def initialize(code); end

  def matches?(response); end
end

class RSpec::Rails::Matchers::HaveHttpStatus::NumericCode
end

class RSpec::Rails::Matchers::HaveHttpStatus::SymbolicStatus
  include ::RSpec::Rails::Matchers::HaveHttpStatus
  def initialize(status); end

  def matches?(response); end
end

class RSpec::Rails::Matchers::HaveHttpStatus::SymbolicStatus
end

module RSpec::Rails::Matchers::HaveHttpStatus
  def self.as_test_response(obj); end

  def self.matcher_for_status(target); end
end

module RSpec::Rails::Matchers::RedirectTo
  def redirect_to(target); end
end

module RSpec::Rails::Matchers::RedirectTo
end

module RSpec::Rails::Matchers::RenderTemplate
  def have_rendered(options, message=T.unsafe(nil)); end

  def render_template(options, message=T.unsafe(nil)); end
end

module RSpec::Rails::Matchers::RenderTemplate
end

module RSpec::Rails::Matchers::RoutingMatchers
  def be_routable(); end

  def route_to(*expected); end
end

module RSpec::Rails::Matchers::RoutingMatchers::RouteHelpers
  def delete(path); end

  def get(path); end

  def head(path); end

  def options(path); end

  def patch(path); end

  def post(path); end

  def put(path); end
end

module RSpec::Rails::Matchers::RoutingMatchers::RouteHelpers
end

module RSpec::Rails::Matchers::RoutingMatchers
  extend ::RSpec::Matchers::DSL
end

class RSpec::Rails::Matchers::SendEmail
  def initialize(criteria); end

  def matches?(block); end

  def supports_value_expectations?(); end
  INSPECT_EMAIL_ATTRIBUTES = ::T.let(nil, ::T.untyped)
end

class RSpec::Rails::Matchers::SendEmail
end

module RSpec::Rails::Matchers
end

module RSpec::Rails::MinitestAssertionAdapter
  def assertion_delegator(); end
end

class RSpec::Rails::MinitestAssertionAdapter::AssertionDelegator
  include ::Minitest::Assertions
  include ::RSpec::Rails::MinitestCounters
end

class RSpec::Rails::MinitestAssertionAdapter::AssertionDelegator
end

module RSpec::Rails::MinitestAssertionAdapter::ClassMethods
  def assertion_method_names(); end

  def define_assertion_delegators(); end
end

module RSpec::Rails::MinitestAssertionAdapter::ClassMethods
end

module RSpec::Rails::MinitestAssertionAdapter
  extend ::ActiveSupport::Concern
end

module RSpec::Rails::MinitestCounters
  def assertions(); end

  def assertions=(assertions); end
end

module RSpec::Rails::MinitestCounters
end

module RSpec::Rails::MinitestLifecycleAdapter
  def after_setup(); end

  def after_teardown(); end

  def before_setup(); end

  def before_teardown(); end
end

module RSpec::Rails::MinitestLifecycleAdapter
  extend ::ActiveSupport::Concern
end

module RSpec::Rails::ModelExampleGroup
end

module RSpec::Rails::ModelExampleGroup
  extend ::ActiveSupport::Concern
end

module RSpec::Rails::RailsExampleGroup
  include ::RSpec::Rails::TaggedLoggingAdapter
  include ::ActiveSupport::CurrentAttributes::TestHelper
  include ::ActiveSupport::ExecutionContext::TestHelper
end

module RSpec::Rails::RailsExampleGroup
  extend ::ActiveSupport::Concern
end

module RSpec::Rails::RequestExampleGroup
  include ::ActionDispatch::Integration::Runner
  include ::ActionDispatch::Assertions::RoutingAssertions
  include ::ActionDispatch::Assertions
  include ::ActionDispatch::Assertions::ResponseAssertions
  include ::Rails::Dom::Testing::Assertions
  include ::Rails::Dom::Testing::Assertions::DomAssertions
  include ::Rails::Dom::Testing::Assertions::SelectorAssertions
  include ::RSpec::Rails::Matchers::RedirectTo
  include ::RSpec::Rails::Matchers::RenderTemplate
  include ::ActionController::TemplateAssertions
  def app(); end
end

module RSpec::Rails::RequestExampleGroup
  extend ::ActiveSupport::Concern
end

module RSpec::Rails::RoutingAssertionDelegator
  def assert_generates(*args, &block); end

  def assert_recognizes(*args, &block); end

  def assert_routing(*args, &block); end

  def assertion_instance(); end

  def build_assertion_instance(); end

  def setup(*args, &block); end

  def with_routing(*args, &block); end
end

module RSpec::Rails::RoutingAssertionDelegator
end

module RSpec::Rails::RoutingExampleGroup
  include ::RSpec::Rails::Matchers::RoutingMatchers
  include ::RSpec::Rails::Matchers::RoutingMatchers::RouteHelpers
  include ::RSpec::Rails::RoutingAssertionDelegator
  def routes(); end

  def routes=(routes); end
end

module RSpec::Rails::RoutingExampleGroup::ClassMethods
  def routes(); end
end

module RSpec::Rails::RoutingExampleGroup::ClassMethods
end

module RSpec::Rails::RoutingExampleGroup
  extend ::ActiveSupport::Concern
end

module RSpec::Rails::SetupAndTeardownAdapter
  def initialize(*args); end

  def method_name(); end
end

module RSpec::Rails::SetupAndTeardownAdapter::ClassMethods
  def setup(*methods, &block); end

  def teardown(*methods, &block); end
end

module RSpec::Rails::SetupAndTeardownAdapter::ClassMethods
end

module RSpec::Rails::SetupAndTeardownAdapter
  extend ::ActiveSupport::Concern
end

module RSpec::Rails::SystemExampleGroup
  include ::RSpec::Rails::Matchers::RedirectTo
  include ::RSpec::Rails::Matchers::RenderTemplate
  include ::ActionDispatch::Integration::Runner
  include ::ActionDispatch::Assertions::RoutingAssertions
  include ::ActionDispatch::Assertions
  include ::ActionDispatch::Assertions::ResponseAssertions
  include ::Rails::Dom::Testing::Assertions
  include ::Rails::Dom::Testing::Assertions::DomAssertions
  include ::Rails::Dom::Testing::Assertions::SelectorAssertions
  include ::ActionController::TemplateAssertions
  def app(); end

  def metadata(); end

  def method_name(); end

  def passed?(); end
  CHARS_TO_TRANSLATE = ::T.let(nil, ::T.untyped)
end

module RSpec::Rails::SystemExampleGroup::BlowAwayTeardownHooks
  def after_teardown(); end

  def before_teardown(); end
end

module RSpec::Rails::SystemExampleGroup::BlowAwayTeardownHooks
end

class RSpec::Rails::SystemExampleGroup::SuppressRailsScreenshotMetadata
  def [](key); end

  def []=(key, value); end

  def method_missing(_name, *_args, &_block); end
end

class RSpec::Rails::SystemExampleGroup::SuppressRailsScreenshotMetadata
end

module RSpec::Rails::SystemExampleGroup
  extend ::ActiveSupport::Concern
end

module RSpec::Rails::TaggedLoggingAdapter
end

module RSpec::Rails::TaggedLoggingAdapter
end

RSpec::Rails::TestUnitAssertionAdapter = RSpec::Rails::MinitestAssertionAdapter

module RSpec::Rails::ViewAssigns
  def assign(key, value); end

  def view_assigns(); end
end

module RSpec::Rails::ViewAssigns
end

module RSpec::Rails::ViewExampleGroup
  include ::RSpec::Rails::ViewAssigns
  include ::RSpec::Rails::Matchers::RenderTemplate
end

module RSpec::Rails::ViewExampleGroup::ClassMethods
  def _default_helper(); end

  def _default_helpers(); end
end

module RSpec::Rails::ViewExampleGroup::ClassMethods
end

module RSpec::Rails::ViewExampleGroup::ExampleMethods
  def params(); end

  def render(options=T.unsafe(nil), local_assigns=T.unsafe(nil), &block); end

  def response(); end

  def stub_template(hash); end

  def template(); end

  def view(); end
end

module RSpec::Rails::ViewExampleGroup::ExampleMethods
  extend ::ActiveSupport::Concern
end

module RSpec::Rails::ViewExampleGroup::StubResolverCache
end

module RSpec::Rails::ViewExampleGroup::StubResolverCache
  def self.resolver_for(hash); end
end

module RSpec::Rails::ViewExampleGroup
  extend ::ActiveSupport::Concern
end

class RSpec::Rails::ViewPathBuilder
  def initialize(route_set); end

  def path_for(path_params); end
end

class RSpec::Rails::ViewPathBuilder
end

module RSpec::Rails::ViewRendering
  def controller(); end

  def render_views?(); end
  RESOLVER_CACHE = ::T.let(nil, ::T.untyped)
end

module RSpec::Rails::ViewRendering::ClassMethods
  def render_views(true_or_false=T.unsafe(nil)); end

  def render_views?(); end
end

module RSpec::Rails::ViewRendering::ClassMethods
end

class RSpec::Rails::ViewRendering::EmptyTemplateHandler
end

class RSpec::Rails::ViewRendering::EmptyTemplateHandler
  def self.call(_template, _source=T.unsafe(nil)); end
end

class RSpec::Rails::ViewRendering::EmptyTemplateResolver
end

class RSpec::Rails::ViewRendering::EmptyTemplateResolver::FileSystemResolver
end

class RSpec::Rails::ViewRendering::EmptyTemplateResolver::FileSystemResolver
end

class RSpec::Rails::ViewRendering::EmptyTemplateResolver::ResolverDecorator
  def initialize(resolver); end

  def method_missing(name, *args, &block); end
end

class RSpec::Rails::ViewRendering::EmptyTemplateResolver::ResolverDecorator
end

class RSpec::Rails::ViewRendering::EmptyTemplateResolver
  def self.build(path); end

  def self.nullify_template_rendering(templates); end

  def self.template_format(template); end
end

module RSpec::Rails::ViewRendering::EmptyTemplates
  def append_view_path(new_path); end

  def prepend_view_path(new_path); end
end

module RSpec::Rails::ViewRendering::EmptyTemplates
end

module RSpec::Rails::ViewRendering
  extend ::ActiveSupport::Concern
end

module RSpec::Rails::ViewSpecMethods
end

module RSpec::Rails::ViewSpecMethods
  def self.add_to(klass); end

  def self.remove_from(klass); end
end

module RSpec::Rails
  def self.add_test_type_configurations(config); end

  def self.initialize_configuration(config); end
end

module RSpec::Sorbet::Doubles
  extend ::T::Sig
  extend ::T::Helpers
  extend ::T::Private::Methods::MethodHooks
  extend ::T::Private::Methods::SingletonMethodHooks
end

module RSpec
  def self.feature(*args, &example_group_block); end

  def self.ffeature(*args, &example_group_block); end

  def self.xfeature(*args, &example_group_block); end
end

class Racc::CparseParams
end

class Racc::CparseParams
end

class Rack::Session::Cookie::SessionId
  RUBYGEMS_ACTIVATION_MONITOR = ::T.let(nil, ::T.untyped)
end

class Ractor::ClosedError
end

class Ractor::ClosedError
end

class Ractor::Error
end

class Ractor::Error
end

class Ractor::IsolationError
end

class Ractor::IsolationError
end

class Ractor::MovedError
end

class Ractor::MovedError
end

class Ractor::MovedObject
  def !(*arg); end

  def !=(*arg); end

  def ==(*arg); end

  def __id__(*arg); end

  def equal?(*arg); end
end

class Ractor::MovedObject
end

class Ractor::RemoteError
  def ractor(); end
end

class Ractor::RemoteError
end

class Ractor::UnsafeError
end

class Ractor::UnsafeError
end

class Ractor
  def self.new(*args, name: T.unsafe(nil), &block); end
end

class Rails::Application
  include ::Cucumber::Rails::Application
end

module Rails::ApplicationController::HelperMethods
  include ::ActionController::Base::HelperMethods
  include ::Turbo::DriveHelper
  include ::Turbo::FramesHelper
  include ::Turbo::IncludesHelper
  include ::Turbo::StreamsHelper
  include ::Turbo::Streams::ActionHelper
  include ::ActionView::Helpers::TagHelper
  include ::ActionView::Helpers::CaptureHelper
  include ::ActionView::Helpers::OutputSafetyHelper
  include ::ActionText::ContentHelper
  include ::ActionText::TagHelper
  include ::Importmap::ImportmapTagsHelper
  include ::ApplicationHelper
  include ::LogLineHelper
  include ::RconHelper
  include ::ReservationsHelper
  include ::SessionsHelper
  include ::FontAwesome::Rails::IconHelper
  include ::DeviseHelper
end

module Rails::ApplicationController::HelperMethods
end

class Rails::Generators::NamedBase
  include ::Coffee::Rails::JsHook
end

module Rails::HealthController::HelperMethods
  include ::ActionController::Base::HelperMethods
  include ::Turbo::DriveHelper
  include ::Turbo::FramesHelper
  include ::Turbo::IncludesHelper
  include ::Turbo::StreamsHelper
  include ::Turbo::Streams::ActionHelper
  include ::ActionView::Helpers::TagHelper
  include ::ActionView::Helpers::CaptureHelper
  include ::ActionView::Helpers::OutputSafetyHelper
  include ::ActionText::ContentHelper
  include ::ActionText::TagHelper
  include ::Importmap::ImportmapTagsHelper
  include ::ApplicationHelper
  include ::LogLineHelper
  include ::RconHelper
  include ::ReservationsHelper
  include ::SessionsHelper
  include ::FontAwesome::Rails::IconHelper
  include ::DeviseHelper
end

module Rails::HealthController::HelperMethods
end

module Rails::MailersController::HelperMethods
  include ::Rails::ApplicationController::HelperMethods
  include ::ApplicationHelper
  include ::LogLineHelper
  include ::RconHelper
  include ::ReservationsHelper
  include ::SessionsHelper
  include ::FontAwesome::Rails::IconHelper
  include ::DeviseHelper
end

class Random::Base
  include ::Random::Formatter
  def bytes(arg); end

  def initialize(*arg); end

  def seed(); end
end

class Random::Base
  extend ::Random::Formatter
end

module Random::Formatter
  def uuid_v4(); end

  def uuid_v7(extra_timestamp_bits: T.unsafe(nil)); end
end

class Random
  def self.bytes(arg); end

  def self.seed(); end
end

class Range
  def %(arg); end

  def entries(); end

  def overlaps?(arg); end

  def reverse_each(); end

  def to_a(); end
end

module RbConfig
  def self.expand(val, config=T.unsafe(nil)); end

  def self.fire_update!(key, val, mkconf=T.unsafe(nil), conf=T.unsafe(nil)); end
end

class RconFtpServerDecorator
  def rcon_ftp_server(); end
end

class RedisClient::Middlewares
  include ::Sentry::Redis::GlobalRedisInstrumentation
end

class Refinement
  def target(); end
end

class Regexp
  def timeout(); end
end

class Regexp
  def self.linear_time?(*arg); end
end

class Reline::DialogRenderInfo
  def face(); end

  def face=(_); end
end

class Reservation
  def autosave_associated_records_for_log_uploads(*args); end

  def autosave_associated_records_for_ratings(*args); end

  def autosave_associated_records_for_reservation_players(*args); end

  def autosave_associated_records_for_reservation_statuses(*args); end

  def autosave_associated_records_for_server(*args); end

  def autosave_associated_records_for_server_config(*args); end

  def autosave_associated_records_for_server_statistics(*args); end

  def autosave_associated_records_for_stac_logs(*args); end

  def autosave_associated_records_for_user(*args); end

  def autosave_associated_records_for_whitelist(*args); end

  def check_server_available?(); end

  def donator?(*arg, **arg1, &arg2); end

  def validate_associated_records_for_log_uploads(*args); end

  def validate_associated_records_for_ratings(*args); end

  def validate_associated_records_for_reservation_players(*args); end

  def validate_associated_records_for_reservation_statuses(*args); end

  def validate_associated_records_for_server_statistics(*args); end

  def validate_associated_records_for_stac_logs(*args); end
end

module Reservation::GeneratedAssociationMethods
  def rating_ids(); end

  def rating_ids=(ids); end

  def ratings(); end

  def ratings=(value); end
end

class ReservationDecorator
  include ::Draper::AutomaticDelegation
  def reservation(); end
end

class ReservationDecorator
  extend ::Draper::AutomaticDelegation::ClassMethods
end

class ReservationManager
  def server(*arg, **arg1, &arg2); end
end

class ReservationPlayer
  include ::Geocoder::Store::ActiveRecord
  include ::Geocoder::Store::Base
  def autosave_associated_records_for_reservation(*args); end

  def autosave_associated_records_for_server(*args); end

  def autosave_associated_records_for_user(*args); end
end

class ReservationPlayer
  extend ::Geocoder::Store::ActiveRecord::ClassMethods
  def self.geocoded(*args, **arg); end

  def self.near(*args, **arg); end

  def self.not_geocoded(*args, **arg); end

  def self.not_reverse_geocoded(*args, **arg); end

  def self.within_bounding_box(*args, **arg); end
end

class ReservationStatus
  def autosave_associated_records_for_reservation(*args); end
end

class ReservationWorker
  def sidekiq_options_hash(); end

  def sidekiq_options_hash=(sidekiq_options_hash); end

  def sidekiq_retries_exhausted_block(); end

  def sidekiq_retries_exhausted_block=(sidekiq_retries_exhausted_block); end

  def sidekiq_retry_in_block(); end

  def sidekiq_retry_in_block=(sidekiq_retry_in_block); end
end

class ReservationWorker
  def self.__synchronized_sidekiq_options_hash(); end

  def self.sidekiq_options_hash(); end

  def self.sidekiq_options_hash=(val); end

  def self.sidekiq_retries_exhausted_block(); end

  def self.sidekiq_retries_exhausted_block=(val); end

  def self.sidekiq_retry_in_block(); end

  def self.sidekiq_retry_in_block=(val); end
end

class ReservationsController
  include ::ActionView::Layouts::ClassMethods::LayoutConditions
end

class Resolv
  VERSION = ::T.let(nil, ::T.untyped)
end

class Resolv::DNS
  def extract_resources(msg, name, typeclass); end
  RequestID = ::T.let(nil, ::T.untyped)
  RequestIDMutex = ::T.let(nil, ::T.untyped)
end

class Resolv::DNS::Config
  def initialize(config_info=T.unsafe(nil)); end

  def use_ipv6?(); end
end

class Resolv::DNS::Label::Str
  def initialize(string); end
end

class Resolv::DNS::Message
  def initialize(id=T.unsafe(nil)); end
end

class Resolv::DNS::Message::MessageDecoder
  def get_list(); end

  def initialize(data); end
end

class Resolv::DNS::Requester::ConnectedUDP
  def initialize(host, port=T.unsafe(nil)); end

  def lazy_initialize(); end
end

class Resolv::DNS::Requester::Sender
  def initialize(msg, data, sock); end
end

class Resolv::DNS::Requester::TCP
  def initialize(host, port=T.unsafe(nil)); end
end

class Resolv::DNS::Requester::UnconnectedUDP
  def initialize(*nameserver_port); end

  def lazy_initialize(); end
end

class Resolv::DNS::Requester::UnconnectedUDP::Sender
  def initialize(msg, data, sock, host, port); end
end

class Resolv::DNS::Resource
  ClassValue = ::T.let(nil, ::T.untyped)
end

class Resolv::DNS::Resource::IN::HTTPS
  ClassValue = ::T.let(nil, ::T.untyped)
  TypeValue = ::T.let(nil, ::T.untyped)
end

class Resolv::DNS::Resource::IN::HTTPS
end

class Resolv::DNS::Resource::IN::SVCB
  ClassValue = ::T.let(nil, ::T.untyped)
  TypeValue = ::T.let(nil, ::T.untyped)
end

class Resolv::DNS::Resource::IN::SVCB
end

class Resolv::DNS::Resource::IN::ServiceBinding
  def alias_mode?(); end

  def encode_rdata(msg); end

  def initialize(priority, target, params=T.unsafe(nil)); end

  def params(); end

  def priority(); end

  def service_mode?(); end

  def target(); end
end

class Resolv::DNS::Resource::IN::ServiceBinding
  def self.decode_rdata(msg); end
end

class Resolv::DNS::Resource::LOC
  def initialize(version, ssize, hprecision, vprecision, latitude, longitude, altitude); end
end

class Resolv::DNS::SvcParam
  ClassHash = ::T.let(nil, ::T.untyped)
end

class Resolv::DNS::SvcParam::ALPN
  def encode(msg); end

  def initialize(protocol_ids); end

  def protocol_ids(); end
  KeyName = ::T.let(nil, ::T.untyped)
  KeyNumber = ::T.let(nil, ::T.untyped)
end

class Resolv::DNS::SvcParam::ALPN
  def self.decode(msg); end
end

class Resolv::DNS::SvcParam::DoHPath
  def encode(msg); end

  def initialize(template); end

  def template(); end
  KeyName = ::T.let(nil, ::T.untyped)
  KeyNumber = ::T.let(nil, ::T.untyped)
end

class Resolv::DNS::SvcParam::DoHPath
  def self.decode(msg); end
end

class Resolv::DNS::SvcParam::Generic
  def encode(msg); end

  def initialize(value); end

  def value(); end
end

class Resolv::DNS::SvcParam::Generic
  def self.create(key_number); end

  def self.decode(msg); end
end

class Resolv::DNS::SvcParam::IPv4Hint
  def addresses(); end

  def encode(msg); end

  def initialize(addresses); end
  KeyName = ::T.let(nil, ::T.untyped)
  KeyNumber = ::T.let(nil, ::T.untyped)
end

class Resolv::DNS::SvcParam::IPv4Hint
  def self.decode(msg); end
end

class Resolv::DNS::SvcParam::IPv6Hint
  def addresses(); end

  def encode(msg); end

  def initialize(addresses); end
  KeyName = ::T.let(nil, ::T.untyped)
  KeyNumber = ::T.let(nil, ::T.untyped)
end

class Resolv::DNS::SvcParam::IPv6Hint
  def self.decode(msg); end
end

class Resolv::DNS::SvcParam::Mandatory
  def encode(msg); end

  def initialize(keys); end

  def keys(); end
  KeyName = ::T.let(nil, ::T.untyped)
  KeyNumber = ::T.let(nil, ::T.untyped)
end

class Resolv::DNS::SvcParam::Mandatory
  def self.decode(msg); end
end

class Resolv::DNS::SvcParam::NoDefaultALPN
  def encode(msg); end
  KeyName = ::T.let(nil, ::T.untyped)
  KeyNumber = ::T.let(nil, ::T.untyped)
end

class Resolv::DNS::SvcParam::NoDefaultALPN
  def self.decode(msg); end
end

class Resolv::DNS::SvcParam::Port
  def encode(msg); end

  def initialize(port); end

  def port(); end
  KeyName = ::T.let(nil, ::T.untyped)
  KeyNumber = ::T.let(nil, ::T.untyped)
end

class Resolv::DNS::SvcParam::Port
  def self.decode(msg); end
end

class Resolv::DNS::SvcParam
  def self.key_name(); end

  def self.key_number(); end
end

class Resolv::DNS::SvcParams
  include ::Enumerable
  def [](key); end

  def add(param); end

  def count(); end

  def delete(key); end

  def each(&block); end

  def empty?(); end

  def encode(msg); end

  def initialize(params=T.unsafe(nil)); end
end

class Resolv::DNS::SvcParams
  def self.decode(msg); end
end

class Resolv::DNS
  def self.allocate_request_id(host, port); end

  def self.bind_random_port(udpsock, bind_host=T.unsafe(nil)); end

  def self.free_request_id(host, port, id); end

  def self.random(arg); end
end

class Resolv::IPv6
  Regex_8HexLinkLocal = ::T.let(nil, ::T.untyped)
  Regex_CompressedHexLinkLocal = ::T.let(nil, ::T.untyped)
end

class RglProfile
  extend ::T::Private::Methods::MethodHooks
  extend ::T::Private::Methods::SingletonMethodHooks
end

class Ripper
  def column(); end

  def debug_output(); end

  def debug_output=(debug_output); end

  def encoding(); end

  def end_seen?(); end

  def error?(); end

  def filename(); end

  def initialize(*arg); end

  def lineno(); end

  def parse(); end

  def state(); end

  def token(); end

  def yydebug(); end

  def yydebug=(yydebug); end
  EXPR_ARG = ::T.let(nil, ::T.untyped)
  EXPR_ARG_ANY = ::T.let(nil, ::T.untyped)
  EXPR_BEG = ::T.let(nil, ::T.untyped)
  EXPR_BEG_ANY = ::T.let(nil, ::T.untyped)
  EXPR_CLASS = ::T.let(nil, ::T.untyped)
  EXPR_CMDARG = ::T.let(nil, ::T.untyped)
  EXPR_DOT = ::T.let(nil, ::T.untyped)
  EXPR_END = ::T.let(nil, ::T.untyped)
  EXPR_ENDARG = ::T.let(nil, ::T.untyped)
  EXPR_ENDFN = ::T.let(nil, ::T.untyped)
  EXPR_END_ANY = ::T.let(nil, ::T.untyped)
  EXPR_FITEM = ::T.let(nil, ::T.untyped)
  EXPR_FNAME = ::T.let(nil, ::T.untyped)
  EXPR_LABEL = ::T.let(nil, ::T.untyped)
  EXPR_LABELED = ::T.let(nil, ::T.untyped)
  EXPR_MID = ::T.let(nil, ::T.untyped)
  EXPR_NONE = ::T.let(nil, ::T.untyped)
  EXPR_VALUE = ::T.let(nil, ::T.untyped)
  Version = ::T.let(nil, ::T.untyped)
end

class Ripper::Filter
  def initialize(src, filename=T.unsafe(nil), lineno=T.unsafe(nil)); end
end

class Ripper::Lexer
  def errors(); end

  def lex(**kw); end

  def parse(raise_errors: T.unsafe(nil)); end

  def scan(**kw); end

  def tokenize(**kw); end
end

class Ripper::Lexer::Elem
  def [](index); end

  def event(); end

  def event=(event); end

  def initialize(pos, event, tok, state, message=T.unsafe(nil)); end

  def message(); end

  def message=(message); end

  def pos(); end

  def pos=(pos); end

  def state(); end

  def state=(state); end

  def to_a(); end

  def tok(); end

  def tok=(tok); end
end

class Ripper::Lexer::Elem
end

class Ripper::Lexer::State
  def &(i); end

  def ==(i); end

  def [](index); end

  def allbits?(i); end

  def anybits?(i); end

  def initialize(i); end

  def nobits?(i); end

  def to_i(); end

  def to_int(); end

  def |(i); end
end

class Ripper::Lexer::State
end

class Ripper::Lexer
end

class Ripper::SexpBuilder
  def on_BEGIN(*args); end

  def on_CHAR(tok); end

  def on_END(*args); end

  def on___end__(tok); end

  def on_alias(*args); end

  def on_alias_error(*args); end

  def on_aref(*args); end

  def on_aref_field(*args); end

  def on_arg_ambiguous(*args); end

  def on_arg_paren(*args); end

  def on_args_add(*args); end

  def on_args_add_block(*args); end

  def on_args_add_star(*args); end

  def on_args_forward(*args); end

  def on_args_new(*args); end

  def on_array(*args); end

  def on_aryptn(*args); end

  def on_assign(*args); end

  def on_assign_error(*args); end

  def on_assoc_new(*args); end

  def on_assoc_splat(*args); end

  def on_assoclist_from_args(*args); end

  def on_backref(tok); end

  def on_backtick(tok); end

  def on_bare_assoc_hash(*args); end

  def on_begin(*args); end

  def on_binary(*args); end

  def on_block_var(*args); end

  def on_blockarg(*args); end

  def on_bodystmt(*args); end

  def on_brace_block(*args); end

  def on_break(*args); end

  def on_call(*args); end

  def on_case(*args); end

  def on_class(*args); end

  def on_class_name_error(*args); end

  def on_comma(tok); end

  def on_command(*args); end

  def on_command_call(*args); end

  def on_comment(tok); end

  def on_const(tok); end

  def on_const_path_field(*args); end

  def on_const_path_ref(*args); end

  def on_const_ref(*args); end

  def on_cvar(tok); end

  def on_def(*args); end

  def on_defined(*args); end

  def on_defs(*args); end

  def on_do_block(*args); end

  def on_dot2(*args); end

  def on_dot3(*args); end

  def on_dyna_symbol(*args); end

  def on_else(*args); end

  def on_elsif(*args); end

  def on_embdoc(tok); end

  def on_embdoc_beg(tok); end

  def on_embdoc_end(tok); end

  def on_embexpr_beg(tok); end

  def on_embexpr_end(tok); end

  def on_embvar(tok); end

  def on_ensure(*args); end

  def on_excessed_comma(*args); end

  def on_fcall(*args); end

  def on_field(*args); end

  def on_float(tok); end

  def on_fndptn(*args); end

  def on_for(*args); end

  def on_gvar(tok); end

  def on_hash(*args); end

  def on_heredoc_beg(tok); end

  def on_heredoc_end(tok); end

  def on_hshptn(*args); end

  def on_ident(tok); end

  def on_if(*args); end

  def on_if_mod(*args); end

  def on_ifop(*args); end

  def on_ignored_nl(tok); end

  def on_ignored_sp(tok); end

  def on_imaginary(tok); end

  def on_in(*args); end

  def on_int(tok); end

  def on_ivar(tok); end

  def on_kw(tok); end

  def on_kwrest_param(*args); end

  def on_label(tok); end

  def on_label_end(tok); end

  def on_lambda(*args); end

  def on_lbrace(tok); end

  def on_lbracket(tok); end

  def on_lparen(tok); end

  def on_magic_comment(*args); end

  def on_massign(*args); end

  def on_method_add_arg(*args); end

  def on_method_add_block(*args); end

  def on_mlhs_add(*args); end

  def on_mlhs_add_post(*args); end

  def on_mlhs_add_star(*args); end

  def on_mlhs_new(*args); end

  def on_mlhs_paren(*args); end

  def on_module(*args); end

  def on_mrhs_add(*args); end

  def on_mrhs_add_star(*args); end

  def on_mrhs_new(*args); end

  def on_mrhs_new_from_args(*args); end

  def on_next(*args); end

  def on_nl(tok); end

  def on_nokw_param(*args); end

  def on_op(tok); end

  def on_opassign(*args); end

  def on_operator_ambiguous(*args); end

  def on_param_error(*args); end

  def on_params(*args); end

  def on_paren(*args); end

  def on_period(tok); end

  def on_program(*args); end

  def on_qsymbols_add(*args); end

  def on_qsymbols_beg(tok); end

  def on_qsymbols_new(*args); end

  def on_qwords_add(*args); end

  def on_qwords_beg(tok); end

  def on_qwords_new(*args); end

  def on_rational(tok); end

  def on_rbrace(tok); end

  def on_rbracket(tok); end

  def on_redo(*args); end

  def on_regexp_add(*args); end

  def on_regexp_beg(tok); end

  def on_regexp_end(tok); end

  def on_regexp_literal(*args); end

  def on_regexp_new(*args); end

  def on_rescue(*args); end

  def on_rescue_mod(*args); end

  def on_rest_param(*args); end

  def on_retry(*args); end

  def on_return(*args); end

  def on_return0(*args); end

  def on_rparen(tok); end

  def on_sclass(*args); end

  def on_semicolon(tok); end

  def on_sp(tok); end

  def on_stmts_add(*args); end

  def on_stmts_new(*args); end

  def on_string_add(*args); end

  def on_string_concat(*args); end

  def on_string_content(*args); end

  def on_string_dvar(*args); end

  def on_string_embexpr(*args); end

  def on_string_literal(*args); end

  def on_super(*args); end

  def on_symbeg(tok); end

  def on_symbol(*args); end

  def on_symbol_literal(*args); end

  def on_symbols_add(*args); end

  def on_symbols_beg(tok); end

  def on_symbols_new(*args); end

  def on_tlambda(tok); end

  def on_tlambeg(tok); end

  def on_top_const_field(*args); end

  def on_top_const_ref(*args); end

  def on_tstring_beg(tok); end

  def on_tstring_content(tok); end

  def on_tstring_end(tok); end

  def on_unary(*args); end

  def on_undef(*args); end

  def on_unless(*args); end

  def on_unless_mod(*args); end

  def on_until(*args); end

  def on_until_mod(*args); end

  def on_var_alias(*args); end

  def on_var_field(*args); end

  def on_var_ref(*args); end

  def on_vcall(*args); end

  def on_void_stmt(*args); end

  def on_when(*args); end

  def on_while(*args); end

  def on_while_mod(*args); end

  def on_word_add(*args); end

  def on_word_new(*args); end

  def on_words_add(*args); end

  def on_words_beg(tok); end

  def on_words_new(*args); end

  def on_words_sep(tok); end

  def on_xstring_add(*args); end

  def on_xstring_literal(*args); end

  def on_xstring_new(*args); end

  def on_yield(*args); end

  def on_yield0(*args); end

  def on_zsuper(*args); end
end

class Ripper::TokenPattern
  def initialize(pattern); end

  def match(str); end

  def match_list(tokens); end
  MAP = ::T.let(nil, ::T.untyped)
end

class Ripper::TokenPattern::CompileError
end

class Ripper::TokenPattern::CompileError
end

class Ripper::TokenPattern::Error
end

class Ripper::TokenPattern::Error
end

class Ripper::TokenPattern::MatchData
  def initialize(tokens, match); end

  def string(n=T.unsafe(nil)); end
end

class Ripper::TokenPattern::MatchData
end

class Ripper::TokenPattern::MatchError
end

class Ripper::TokenPattern::MatchError
end

class Ripper::TokenPattern
  def self.compile(*arg, **arg1); end
end

class Ripper
  def self.dedent_string(arg, arg1); end

  def self.lex_state_name(arg); end

  def self.token_match(src, pattern); end
end

module RuboCop::AST::CollectionNode
  def forgiving(*args, **arg, &block); end

  def forgiving!(*args, **arg, &block); end

  def forgiving?(*args, **arg, &block); end

  def ignore_extra_values(*args, **arg, &block); end

  def ignore_extra_values!(*args, **arg, &block); end

  def ordered(*args, **arg, &block); end

  def ordered!(*args, **arg, &block); end

  def ordered?(*args, **arg, &block); end

  def reject_extra_values(*args, **arg, &block); end

  def reject_extra_values!(*args, **arg, &block); end

  def strict(*args, **arg, &block); end

  def strict!(*args, **arg, &block); end

  def strict?(*args, **arg, &block); end

  def to_csv(*args, **arg, &block); end

  def unordered(*args, **arg, &block); end

  def unordered!(*args, **arg, &block); end

  def unordered?(*args, **arg, &block); end
end

RubyLex = IRB::RubyLex

class RubyVM::AbstractSyntaxTree::Node
  def all_tokens(); end

  def node_id(); end

  def pretty_print_children(q, names=T.unsafe(nil)); end

  def script_lines(); end

  def source(); end

  def tokens(); end
end

module RubyVM::AbstractSyntaxTree
  def self.node_id_for_backtrace_location(backtrace_location); end
end

class RubyVM::InstructionSequence
  def script_lines(); end
end

class RubyVM::InstructionSequence
  def self.compile_file_prism(*arg); end

  def self.compile_prism(*arg); end
end

module RubyVM::RJIT
end

module RubyVM::RJIT
  def self.enable(); end

  def self.enabled?(); end
end

class RubyVM
  def self.keep_script_lines(); end

  def self.keep_script_lines=(keep_script_lines); end
end

module SassC::Script::Functions
  include ::Sprockets::SassProcessor::Functions
end

module SassListen
  VERSION = ::T.let(nil, ::T.untyped)
end

module SassListen::Adapter
  OPTIMIZED_ADAPTERS = ::T.let(nil, ::T.untyped)
  POLLING_FALLBACK_MESSAGE = ::T.let(nil, ::T.untyped)
end

class SassListen::Adapter::BSD
  BUNDLER_DECLARE_GEM = ::T.let(nil, ::T.untyped)
  DEFAULTS = ::T.let(nil, ::T.untyped)
  OS_REGEXP = ::T.let(nil, ::T.untyped)
end

class SassListen::Adapter::BSD
end

class SassListen::Adapter::Base
  def config(); end

  def configure(); end

  def initialize(config); end

  def options(); end

  def start(); end

  def started?(); end

  def stop(); end
  DEFAULTS = ::T.let(nil, ::T.untyped)
end

class SassListen::Adapter::Base
  def self._log(*args, &block); end

  def self.usable?(); end
end

class SassListen::Adapter::Config
  def adapter_options(); end

  def directories(); end

  def initialize(directories, queue, silencer, adapter_options); end

  def queue(); end

  def silencer(); end
end

class SassListen::Adapter::Config
end

class SassListen::Adapter::Darwin
  DEFAULTS = ::T.let(nil, ::T.untyped)
  INCOMPATIBLE_GEM_VERSION = ::T.let(nil, ::T.untyped)
  OS_REGEXP = ::T.let(nil, ::T.untyped)
end

class SassListen::Adapter::Darwin
end

class SassListen::Adapter::Linux
  DEFAULTS = ::T.let(nil, ::T.untyped)
  INOTIFY_LIMIT_MESSAGE = ::T.let(nil, ::T.untyped)
  OS_REGEXP = ::T.let(nil, ::T.untyped)
  WIKI_URL = ::T.let(nil, ::T.untyped)
end

class SassListen::Adapter::Linux
end

class SassListen::Adapter::Polling
  DEFAULTS = ::T.let(nil, ::T.untyped)
  OS_REGEXP = ::T.let(nil, ::T.untyped)
end

class SassListen::Adapter::Polling
end

class SassListen::Adapter::Windows
  BUNDLER_DECLARE_GEM = ::T.let(nil, ::T.untyped)
  OS_REGEXP = ::T.let(nil, ::T.untyped)
end

class SassListen::Adapter::Windows
end

module SassListen::Adapter
  def self._log(type, message); end

  def self._usable_adapter_class(); end

  def self._warn_polling_fallback(options); end

  def self.select(options=T.unsafe(nil)); end
end

class SassListen::Backend
  def initialize(directories, queue, silencer, config); end

  def min_delay_between_events(); end

  def start(); end

  def stop(); end
end

class SassListen::Backend
end

class SassListen::Change
  def initialize(config, record); end

  def invalidate(type, rel_path, options); end

  def record(); end
end

class SassListen::Change::Config
  def initialize(queue, silencer); end

  def queue(*args); end

  def silenced?(path, type); end
end

class SassListen::Change::Config
end

class SassListen::Change
end

class SassListen::Directory
end

class SassListen::Directory
  def self._async_changes(snapshot, path, previous, options); end

  def self._change(snapshot, type, path, options); end

  def self._children(path); end

  def self.scan(snapshot, rel_path, options); end
end

module SassListen::Event
end

class SassListen::Event::Config
  def call(*args); end

  def callable?(); end

  def event_queue(); end

  def initialize(listener, event_queue, queue_optimizer, wait_for_delay, &block); end

  def min_delay_between_events(); end

  def optimize_changes(changes); end

  def paused?(); end

  def sleep(*args); end

  def stopped?(); end

  def timestamp(); end
end

class SassListen::Event::Config
end

class SassListen::Event::Loop
  def initialize(config); end

  def pause(); end

  def paused?(); end

  def processing?(); end

  def resume(); end

  def setup(); end

  def stopped?(); end

  def teardown(); end

  def wakeup_on_event(); end
end

class SassListen::Event::Loop::Error
end

class SassListen::Event::Loop::Error::NotStarted
end

class SassListen::Event::Loop::Error::NotStarted
end

class SassListen::Event::Loop::Error
end

class SassListen::Event::Loop
end

class SassListen::Event::Processor
  def initialize(config, reasons); end

  def loop_for(latency); end
end

class SassListen::Event::Processor::Stopped
end

class SassListen::Event::Processor::Stopped
end

class SassListen::Event::Processor
end

class SassListen::Event::Queue
  def <<(args); end

  def empty?(); end

  def initialize(config, &block); end

  def pop(); end
end

class SassListen::Event::Queue::Config
  def initialize(relative); end

  def relative?(); end
end

class SassListen::Event::Queue::Config
end

class SassListen::Event::Queue
end

module SassListen::Event
end

module SassListen::FSM
  def current_state(); end

  def current_state_name(); end

  def default_state(); end

  def initialize(); end

  def state(); end

  def states(); end

  def transition(state_name); end

  def transition!(state_name); end

  def transition_with_callbacks!(state_name); end

  def validate_and_sanitize_new_state(state_name); end
  DEFAULT_STATE = ::T.let(nil, ::T.untyped)
end

module SassListen::FSM::ClassMethods
  def default_state(new_default=T.unsafe(nil)); end

  def state(*args, &block); end

  def states(); end
end

module SassListen::FSM::ClassMethods
end

class SassListen::FSM::State
  def call(obj); end

  def initialize(name, transitions=T.unsafe(nil), &block); end

  def name(); end

  def transitions(); end

  def valid_transition?(new_state); end
end

class SassListen::FSM::State
end

module SassListen::FSM
  def self.included(klass); end
end

class SassListen::File
end

class SassListen::File
  def self.change(record, rel_path); end

  def self.inaccurate_mac_time?(stat); end
end

module SassListen::Internals
end

module SassListen::Internals::ThreadPool
end

module SassListen::Internals::ThreadPool
  def self.add(&block); end

  def self.stop(); end
end

module SassListen::Internals
end

class SassListen::Listener
  include ::SassListen::FSM
  def ignore(regexps); end

  def ignore!(regexps); end

  def initialize(*dirs, &block); end

  def only(regexps); end

  def pause(); end

  def paused?(); end

  def processing?(); end

  def start(); end

  def stop(); end
end

class SassListen::Listener::Config
  def adapter_instance_options(klass); end

  def adapter_select_options(); end

  def initialize(opts); end

  def min_delay_between_events(); end

  def relative?(); end

  def silencer_rules(); end
  DEFAULTS = ::T.let(nil, ::T.untyped)
end

class SassListen::Listener::Config
end

class SassListen::Listener
  extend ::SassListen::FSM::ClassMethods
end

class SassListen::Logger
end

class SassListen::Logger
  def self.debug(*args, &block); end

  def self.error(*args, &block); end

  def self.fatal(*args, &block); end

  def self.info(*args, &block); end

  def self.warn(*args, &block); end
end

class SassListen::Options
  def initialize(opts, defaults); end

  def method_missing(name, *_); end
end

class SassListen::Options
end

class SassListen::QueueOptimizer
  def initialize(config); end

  def smoosh_changes(changes); end
end

class SassListen::QueueOptimizer::Config
  def debug(*args, &block); end

  def exist?(path); end

  def initialize(adapter_class, silencer); end

  def silenced?(path, type); end
end

class SassListen::QueueOptimizer::Config
end

class SassListen::QueueOptimizer
end

class SassListen::Record
  def add_dir(rel_path); end

  def build(); end

  def dir_entries(rel_path); end

  def file_data(rel_path); end

  def initialize(directory); end

  def root(); end

  def unset_path(rel_path); end

  def update_file(rel_path, data); end
end

class SassListen::Record::Entry
  def children(); end

  def initialize(root, relative, name=T.unsafe(nil)); end

  def meta(); end

  def name(); end

  def real_path(); end

  def record_dir_key(); end

  def relative(); end

  def root(); end

  def sys_path(); end
end

class SassListen::Record::Entry
end

class SassListen::Record::SymlinkDetector
  def verify_unwatched!(entry); end
  SYMLINK_LOOP_ERROR = ::T.let(nil, ::T.untyped)
  WIKI = ::T.let(nil, ::T.untyped)
end

class SassListen::Record::SymlinkDetector::Error
end

class SassListen::Record::SymlinkDetector::Error
end

class SassListen::Record::SymlinkDetector
end

class SassListen::Record
end

class SassListen::Silencer
  def configure(options); end

  def ignore_patterns(); end

  def ignore_patterns=(ignore_patterns); end

  def only_patterns(); end

  def only_patterns=(only_patterns); end

  def silenced?(relative_path, type); end
  DEFAULT_IGNORED_DIRECTORIES = ::T.let(nil, ::T.untyped)
  DEFAULT_IGNORED_EXTENSIONS = ::T.let(nil, ::T.untyped)
end

class SassListen::Silencer::Controller
  def append_ignores(*regexps); end

  def initialize(silencer, default_options); end

  def replace_with_bang_ignores(regexps); end

  def replace_with_only(regexps); end
end

class SassListen::Silencer::Controller
end

class SassListen::Silencer
end

module SassListen
  def self.logger(); end

  def self.logger=(logger); end

  def self.setup_default_logger_if_unset(); end

  def self.stop(); end

  def self.to(*args, &block); end
end

ScanError = StringScanner::Error

class Seahorse::Client::NetHttp::ConnectionPool::ExtendedSession
  RUBYGEMS_ACTIVATION_MONITOR = ::T.let(nil, ::T.untyped)
end

class Seahorse::Client::Response
  RUBYGEMS_ACTIVATION_MONITOR = ::T.let(nil, ::T.untyped)
end

module Sentry::Rails::ActionCableExtensions
end

module Sentry::Rails::ActionCableExtensions::Channel
end

module Sentry::Rails::ActionCableExtensions::Channel::Actions
end

module Sentry::Rails::ActionCableExtensions::Channel::Actions
end

module Sentry::Rails::ActionCableExtensions::Channel::Subscriptions
end

module Sentry::Rails::ActionCableExtensions::Channel::Subscriptions
  def self.included(base); end
end

module Sentry::Rails::ActionCableExtensions::Channel
end

module Sentry::Rails::ActionCableExtensions::Connection
end

module Sentry::Rails::ActionCableExtensions::Connection
end

class Sentry::Rails::ActionCableExtensions::ErrorHandler
  OP_NAME = ::T.let(nil, ::T.untyped)
  SPAN_ORIGIN = ::T.let(nil, ::T.untyped)
end

class Sentry::Rails::ActionCableExtensions::ErrorHandler
  def self.capture(connection, transaction_name:, extra_context: T.unsafe(nil), &block); end

  def self.finish_transaction(transaction, status_code); end

  def self.start_transaction(env, scope); end
end

module Sentry::Rails::ActionCableExtensions
end

module Sentry::Rails::ActiveJobExtensions
  def already_supported_by_sentry_integration?(); end

  def perform_now(); end
end

module Sentry::Rails::ActiveJobExtensions
end

module Sentry::Rails::Breadcrumb
end

module Sentry::Rails::Breadcrumb::ActiveSupportLogger
end

module Sentry::Rails::Breadcrumb::ActiveSupportLogger
  def self.add(name, started, _finished, _unique_id, data); end

  def self.detach(); end

  def self.inject(allowed_keys); end
end

module Sentry::Rails::Breadcrumb
end

module Sentry::Rails::ControllerMethods
  def capture_exception(exception, options=T.unsafe(nil)); end

  def capture_message(message, options=T.unsafe(nil)); end
end

module Sentry::Rails::ControllerMethods
end

module Sentry::Rails::ControllerTransaction
  SPAN_ORIGIN = ::T.let(nil, ::T.untyped)
end

module Sentry::Rails::ControllerTransaction
  def self.included(base); end
end

module Sentry::Rails::Overrides
end

module Sentry::Rails::Overrides::OldStreamingReporter
  def log_error_with_raven(exception); end
end

module Sentry::Rails::Overrides::OldStreamingReporter
  def self.included(base); end
end

module Sentry::Rails::Overrides::StreamingReporter
  def log_error(exception); end
end

module Sentry::Rails::Overrides::StreamingReporter
end

module Sentry::Rails::Overrides
end

class Server
  include ::Geocoder::Store::ActiveRecord
  include ::Geocoder::Store::Base
  def autosave_associated_records_for_current_reservations(*args); end

  def autosave_associated_records_for_group_servers(*args); end

  def autosave_associated_records_for_groups(*args); end

  def autosave_associated_records_for_location(*args); end

  def autosave_associated_records_for_ratings(*args); end

  def autosave_associated_records_for_recent_server_statistics(*args); end

  def autosave_associated_records_for_reservations(*args); end

  def autosave_associated_records_for_server_statistics(*args); end

  def validate_associated_records_for_current_reservations(*args); end

  def validate_associated_records_for_group_servers(*args); end

  def validate_associated_records_for_groups(*args); end

  def validate_associated_records_for_ratings(*args); end

  def validate_associated_records_for_recent_server_statistics(*args); end

  def validate_associated_records_for_reservations(*args); end

  def validate_associated_records_for_server_statistics(*args); end
end

module Server::GeneratedAssociationMethods
  def rating_ids(); end

  def rating_ids=(ids); end

  def ratings(); end

  def ratings=(value); end
end

class Server
  extend ::Geocoder::Store::ActiveRecord::ClassMethods
  extend ::T::Private::Methods::MethodHooks
  extend ::T::Private::Methods::SingletonMethodHooks
  def self.geocoded(*args, **arg); end

  def self.near(*args, **arg); end

  def self.not_geocoded(*args, **arg); end

  def self.not_reverse_geocoded(*args, **arg); end

  def self.within_bounding_box(*args, **arg); end
end

class ServerConfig
  def autosave_associated_records_for_reservations(*args); end

  def validate_associated_records_for_reservations(*args); end
end

class ServerConfig
  extend ::T::Private::Methods::MethodHooks
  extend ::T::Private::Methods::SingletonMethodHooks
end

class ServerDecorator
  include ::Draper::AutomaticDelegation
  def server(); end
end

class ServerDecorator
  extend ::Draper::AutomaticDelegation::ClassMethods
end

class ServerInfo
  def condenser(*arg, **arg1, &arg2); end
end

class ServerInfo
  extend ::T::Private::Methods::MethodHooks
  extend ::T::Private::Methods::SingletonMethodHooks
end

class ServerNotification
  include ::ServerNotification::GeneratedAssociationMethods
end

module ServerNotification::GeneratedAssociationMethods
end

module ServerNotification::GeneratedAssociationMethods
end

class ServerNotification
  extend ::T::Private::Methods::MethodHooks
  extend ::T::Private::Methods::SingletonMethodHooks
end

class ServerNotificationWorker
  def sidekiq_options_hash(); end

  def sidekiq_options_hash=(sidekiq_options_hash); end

  def sidekiq_retries_exhausted_block(); end

  def sidekiq_retries_exhausted_block=(sidekiq_retries_exhausted_block); end

  def sidekiq_retry_in_block(); end

  def sidekiq_retry_in_block=(sidekiq_retry_in_block); end
end

class ServerNotificationWorker
  def self.__synchronized_sidekiq_options_hash(); end

  def self.sidekiq_options_hash(); end

  def self.sidekiq_options_hash=(val); end

  def self.sidekiq_retries_exhausted_block(); end

  def self.sidekiq_retries_exhausted_block=(val); end

  def self.sidekiq_retry_in_block(); end

  def self.sidekiq_retry_in_block=(val); end
end

class ServerStatistic
  def autosave_associated_records_for_reservation(*args); end

  def autosave_associated_records_for_server(*args); end
end

class ServerStatisticDecorator
  include ::Draper::AutomaticDelegation
  def server_statistic(); end
end

class ServerStatisticDecorator
  extend ::Draper::AutomaticDelegation::ClassMethods
end

class ServerUpdateWorker
  def sidekiq_options_hash(); end

  def sidekiq_options_hash=(sidekiq_options_hash); end

  def sidekiq_retries_exhausted_block(); end

  def sidekiq_retries_exhausted_block=(sidekiq_retries_exhausted_block); end

  def sidekiq_retry_in_block(); end

  def sidekiq_retry_in_block=(sidekiq_retry_in_block); end
end

class ServerUpdateWorker
  def self.__synchronized_sidekiq_options_hash(); end

  def self.sidekiq_options_hash(); end

  def self.sidekiq_options_hash=(val); end

  def self.sidekiq_retries_exhausted_block(); end

  def self.sidekiq_retries_exhausted_block=(val); end

  def self.sidekiq_retry_in_block(); end

  def self.sidekiq_retry_in_block=(val); end
end

class ServerUpload
  def autosave_associated_records_for_file_upload(*args); end

  def autosave_associated_records_for_server(*args); end
end

class ServerUpload
  extend ::T::Private::Methods::MethodHooks
  extend ::T::Private::Methods::SingletonMethodHooks
end

class ServerVersionWorker
  def sidekiq_options_hash(); end

  def sidekiq_options_hash=(sidekiq_options_hash); end

  def sidekiq_retries_exhausted_block(); end

  def sidekiq_retries_exhausted_block=(sidekiq_retries_exhausted_block); end

  def sidekiq_retry_in_block(); end

  def sidekiq_retry_in_block=(sidekiq_retry_in_block); end
end

class ServerVersionWorker
  def self.__synchronized_sidekiq_options_hash(); end

  def self.sidekiq_options_hash(); end

  def self.sidekiq_options_hash=(val); end

  def self.sidekiq_retries_exhausted_block(); end

  def self.sidekiq_retries_exhausted_block=(val); end

  def self.sidekiq_retry_in_block(); end

  def self.sidekiq_retry_in_block=(val); end
end

class ServersNotificationWorker
  def sidekiq_options_hash(); end

  def sidekiq_options_hash=(sidekiq_options_hash); end

  def sidekiq_retries_exhausted_block(); end

  def sidekiq_retries_exhausted_block=(sidekiq_retries_exhausted_block); end

  def sidekiq_retry_in_block(); end

  def sidekiq_retry_in_block=(sidekiq_retry_in_block); end
end

class ServersNotificationWorker
  def self.sidekiq_options_hash(); end

  def self.sidekiq_options_hash=(val); end

  def self.sidekiq_retries_exhausted_block(); end

  def self.sidekiq_retries_exhausted_block=(val); end

  def self.sidekiq_retry_in_block(); end

  def self.sidekiq_retry_in_block=(val); end
end

class Set
  def ==(other); end

  def ===(o); end

  def divide(&func); end

  def eql?(o); end

  def flatten_merge(set, seen=T.unsafe(nil)); end

  def pretty_print(pp); end

  def pretty_print_cycle(pp); end

  def reset(); end
  InspectKey = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

module Shellwords
  VERSION = ::T.let(nil, ::T.untyped)
end

class Shoulda::Matchers::ActiveRecord::AssociationMatchers::ModelReflection
  RUBYGEMS_ACTIVATION_MONITOR = ::T.let(nil, ::T.untyped)
end

class Shoulda::Matchers::ActiveRecord::HaveDbColumnMatcher::DecoratedColumn
  RUBYGEMS_ACTIVATION_MONITOR = ::T.let(nil, ::T.untyped)
end

class Sidekiq::Client
  include ::Sidekiq::TestingClient
end

module Sidekiq::Cron::WebExtension
end

module Sidekiq::Cron::WebExtension
  def self.registered(app); end
end

class Sidekiq::DeadSet
  def initialize(); end

  def kill(message, opts=T.unsafe(nil)); end

  def retry_all(); end
end

class Sidekiq::EmptyQueueError
end

class Sidekiq::EmptyQueueError
end

module Sidekiq::Job
  def self.clear_all(); end

  def self.drain_all(); end

  def self.jobs(); end
end

class Sidekiq::JobRecord
  def [](name); end

  def args(); end

  def bid(); end

  def created_at(); end

  def delete(); end

  def display_args(); end

  def display_class(); end

  def enqueued_at(); end

  def error_backtrace(); end

  def initialize(item, queue_name=T.unsafe(nil)); end

  def item(); end

  def jid(); end

  def klass(); end

  def latency(); end

  def parse(item); end

  def queue(); end

  def tags(); end

  def value(); end
  ACTIVE_JOB_PREFIX = ::T.let(nil, ::T.untyped)
  GLOBALID_KEY = ::T.let(nil, ::T.untyped)
end

class Sidekiq::JobRecord
end

class Sidekiq::JobSet
  def delete(score, jid); end

  def delete_by_jid(score, jid); end

  def delete_by_value(name, value); end

  def each(&blk); end

  def fetch(score, jid=T.unsafe(nil)); end

  def find_job(jid); end

  def schedule(timestamp, job); end
end

module Sidekiq::Metrics
end

Sidekiq::Metrics::Counter = Concurrent::AtomicFixnum

class Sidekiq::Metrics::Histogram
  include ::Enumerable
  def buckets(); end

  def each(&blk); end

  def fetch(conn, now=T.unsafe(nil)); end

  def initialize(klass); end

  def label(idx); end

  def persist(conn, now=T.unsafe(nil)); end

  def record_time(ms); end
  BUCKET_INTERVALS = ::T.let(nil, ::T.untyped)
  FETCH = ::T.let(nil, ::T.untyped)
  HISTOGRAM_TTL = ::T.let(nil, ::T.untyped)
  LABELS = ::T.let(nil, ::T.untyped)
end

class Sidekiq::Metrics::Histogram
end

class Sidekiq::Metrics::Query
  def for_job(klass, minutes: T.unsafe(nil)); end

  def initialize(pool: T.unsafe(nil), now: T.unsafe(nil)); end

  def top_jobs(class_filter: T.unsafe(nil), minutes: T.unsafe(nil)); end
end

class Sidekiq::Metrics::Query::JobResult
  def add_hist(time, hist_result); end

  def add_metric(metric, time, value); end

  def initialize(); end

  def series_avg(metric=T.unsafe(nil)); end

  def total_avg(metric=T.unsafe(nil)); end
end

class Sidekiq::Metrics::Query::JobResult
end

class Sidekiq::Metrics::Query::MarkResult
  def bucket(); end
end

class Sidekiq::Metrics::Query::MarkResult
end

class Sidekiq::Metrics::Query::Result
  def initialize(); end

  def prepend_bucket(time); end
end

class Sidekiq::Metrics::Query::Result
end

class Sidekiq::Metrics::Query
end

module Sidekiq::Metrics
end

module Sidekiq::Paginator
  def page(key, pageidx=T.unsafe(nil), page_size=T.unsafe(nil), opts=T.unsafe(nil)); end

  def page_items(items, pageidx=T.unsafe(nil), page_size=T.unsafe(nil)); end
end

module Sidekiq::Paginator
end

class Sidekiq::Process
  def [](key); end

  def dump_threads(); end

  def embedded?(); end

  def identity(); end

  def initialize(hash); end

  def labels(); end

  def queues(); end

  def quiet!(); end

  def stop!(); end

  def stopping?(); end

  def tag(); end

  def version(); end

  def weights(); end
end

class Sidekiq::Process
end

class Sidekiq::ProcessSet
  include ::Enumerable
  def cleanup(); end

  def each(&blk); end

  def initialize(clean_plz=T.unsafe(nil)); end

  def leader(); end

  def size(); end

  def total_concurrency(); end

  def total_rss(); end

  def total_rss_in_kb(); end
end

class Sidekiq::ProcessSet
  def self.[](identity); end
end

class Sidekiq::Queue
  include ::Enumerable
  def clear(); end

  def each(&blk); end

  def find_job(jid); end

  def initialize(name=T.unsafe(nil)); end

  def latency(); end

  def name(); end
end

class Sidekiq::Queue
  def self.all(); end
end

module Sidekiq::Queues
end

module Sidekiq::Queues
  def self.[](queue); end

  def self.clear_all(); end

  def self.clear_for(queue, klass); end

  def self.delete_for(jid, queue, klass); end

  def self.jobs_by_class(); end

  def self.jobs_by_queue(); end

  def self.jobs_by_worker(); end

  def self.push(queue, klass, job); end
end

class Sidekiq::RetrySet
  def initialize(); end

  def kill_all(); end

  def retry_all(); end
end

class Sidekiq::ScheduledSet
  def initialize(); end
end

class Sidekiq::SortedEntry
  def add_to_queue(); end

  def at(); end

  def error?(); end

  def initialize(parent, score, item); end

  def kill(); end

  def parent(); end

  def reschedule(at); end

  def retry(); end

  def score(); end
end

class Sidekiq::SortedEntry
end

class Sidekiq::Stats
  def dead_size(); end

  def default_queue_latency(); end

  def enqueued(); end

  def failed(); end

  def fetch_stats!(); end

  def fetch_stats_fast!(); end

  def fetch_stats_slow!(); end

  def processed(); end

  def processes_size(); end

  def queues(); end

  def reset(*stats); end

  def retry_size(); end

  def scheduled_size(); end

  def workers_size(); end
end

class Sidekiq::Stats::History
  def failed(); end

  def initialize(days_previous, start_date=T.unsafe(nil), pool: T.unsafe(nil)); end

  def processed(); end
end

class Sidekiq::Stats::History
end

class Sidekiq::Stats
end

class Sidekiq::Testing
end

class Sidekiq::Testing::TestModeAlreadySetError
end

class Sidekiq::Testing::TestModeAlreadySetError
end

class Sidekiq::Testing
  def self.__global_test_mode(); end

  def self.__global_test_mode=(__global_test_mode); end

  def self.__local_test_mode(); end

  def self.__local_test_mode=(value); end

  def self.__set_test_mode(mode); end

  def self.__test_mode(); end

  def self.disable!(&block); end

  def self.disabled?(); end

  def self.enabled?(); end

  def self.fake!(&block); end

  def self.fake?(); end

  def self.inline!(&block); end

  def self.inline?(); end

  def self.server_middleware(); end
end

module Sidekiq::TestingClient
  def atomic_push(conn, payloads); end
end

module Sidekiq::TestingClient
end

module Sidekiq::TestingExtensions
  def jobs_for(klass); end
end

module Sidekiq::TestingExtensions
end

class Sidekiq::Web
  def app(); end

  def call(env); end

  def disable(*opts); end

  def enable(*opts); end

  def middlewares(); end

  def set(attribute, value); end

  def settings(); end

  def use(*args, &block); end
  ASSETS = ::T.let(nil, ::T.untyped)
  CONTENT_LANGUAGE = ::T.let(nil, ::T.untyped)
  CONTENT_SECURITY_POLICY = ::T.let(nil, ::T.untyped)
  DEFAULT_TABS = ::T.let(nil, ::T.untyped)
  LAYOUT = ::T.let(nil, ::T.untyped)
  LOCALES = ::T.let(nil, ::T.untyped)
  LOCATION = ::T.let(nil, ::T.untyped)
  ROOT = ::T.let(nil, ::T.untyped)
  VIEWS = ::T.let(nil, ::T.untyped)
  X_CASCADE = ::T.let(nil, ::T.untyped)
  X_CONTENT_TYPE_OPTIONS = ::T.let(nil, ::T.untyped)
end

class Sidekiq::Web::CsrfProtection
  def call(env); end

  def initialize(app, options=T.unsafe(nil)); end
  TOKEN_LENGTH = ::T.let(nil, ::T.untyped)
end

class Sidekiq::Web::CsrfProtection
end

class Sidekiq::Web
  def self.app_url(); end

  def self.app_url=(app_url); end

  def self.call(env); end

  def self.custom_job_info_rows(); end

  def self.custom_tabs(); end

  def self.default_tabs(); end

  def self.disable(*opts); end

  def self.enable(*opts); end

  def self.inherited(child); end

  def self.locales(); end

  def self.locales=(locales); end

  def self.middlewares(); end

  def self.redis_pool(); end

  def self.redis_pool=(redis_pool); end

  def self.register(extension, name: T.unsafe(nil), tab: T.unsafe(nil), index: T.unsafe(nil), root_dir: T.unsafe(nil), cache_for: T.unsafe(nil), asset_paths: T.unsafe(nil)); end

  def self.set(attribute, value); end

  def self.settings(); end

  def self.tabs(); end

  def self.use(*args, &block); end

  def self.views(); end

  def self.views=(views); end
end

class Sidekiq::WebAction
  include ::Sidekiq::WebHelpers
  include ::Sidekiq::Paginator
  def _render(); end

  def block(); end

  def block=(block); end

  def env(); end

  def env=(env); end

  def erb(content, options=T.unsafe(nil)); end

  def halt(res); end

  def initialize(env, block); end

  def json(payload); end

  def params(); end

  def redirect(location); end

  def reload_page(); end

  def render(engine, content, options=T.unsafe(nil)); end

  def request(); end

  def route_params(); end

  def session(); end

  def settings(); end

  def type(); end

  def type=(type); end
  RACK_SESSION = ::T.let(nil, ::T.untyped)
end

class Sidekiq::WebAction
end

class Sidekiq::WebApplication
  def call(env); end

  def initialize(klass); end

  def process_csp(env, input); end

  def settings(); end
  CSP_HEADER_TEMPLATE = ::T.let(nil, ::T.untyped)
  METRICS_PERIODS = ::T.let(nil, ::T.untyped)
  QUEUE_NAME = ::T.let(nil, ::T.untyped)
  REDIS_KEYS = ::T.let(nil, ::T.untyped)
end

class Sidekiq::WebApplication
  extend ::Sidekiq::WebRouter
  def self.after(path=T.unsafe(nil), &block); end

  def self.afters(); end

  def self.before(path=T.unsafe(nil), &block); end

  def self.befores(); end

  def self.helpers(mod=T.unsafe(nil), &block); end

  def self.run_afters(app, action); end

  def self.run_befores(app, action); end

  def self.run_hooks(hooks, app, action); end

  def self.set(key, val); end

  def self.settings(); end

  def self.tabs(); end
end

module Sidekiq::WebHelpers
  def add_to_head(); end

  def available_locales(); end

  def busy_weights(capsule_weights); end

  def clear_caches(); end

  def csp_nonce(); end

  def csrf_tag(); end

  def current_path(); end

  def current_status(); end

  def delete_or_add_queue(job, params); end

  def display_args(args, truncate_after_chars=T.unsafe(nil)); end

  def display_custom_head(); end

  def display_tags(job, within=T.unsafe(nil)); end

  def environment_title_prefix(); end

  def filter_link(jid, within=T.unsafe(nil)); end

  def filtering(which); end

  def find_locale_files(lang); end

  def format_memory(rss_kb); end

  def get_locale(); end

  def h(text); end

  def job_params(job, score); end

  def locale(); end

  def locale_files(); end

  def number_with_delimiter(number, options=T.unsafe(nil)); end

  def parse_params(params); end

  def pollable?(); end

  def processes(); end

  def product_version(); end

  def qparams(options); end

  def redirect_with_query(url); end

  def redis_info(); end

  def redis_url(); end

  def relative_time(time); end

  def retry_extra_items(retry_job); end

  def retry_or_delete_or_kill(job, params); end

  def root_path(); end

  def rtl?(); end

  def script_tag(location, **kwargs); end

  def search(jobset, substr); end

  def server_utc_time(); end

  def singularize(str, count); end

  def sort_direction_label(); end

  def sorted_processes(); end

  def stats(); end

  def strings(lang); end

  def style_tag(location, **kwargs); end

  def t(msg, options=T.unsafe(nil)); end

  def text_direction(); end

  def to_display(arg); end

  def to_json(x); end

  def to_query_string(params); end

  def truncate(text, truncate_after_chars=T.unsafe(nil)); end

  def unfiltered?(); end

  def user_preferred_languages(); end

  def workset(); end
  RETRY_JOB_KEYS = ::T.let(nil, ::T.untyped)
  SAFE_QPARAMS = ::T.let(nil, ::T.untyped)
end

module Sidekiq::WebHelpers
end

class Sidekiq::WebRoute
  def block(); end

  def block=(block); end

  def compile(); end

  def initialize(request_method, pattern, block); end

  def match(request_method, path); end

  def matcher(); end

  def name(); end

  def name=(name); end

  def pattern(); end

  def pattern=(pattern); end

  def request_method(); end

  def request_method=(request_method); end
  NAMED_SEGMENTS_PATTERN = ::T.let(nil, ::T.untyped)
end

class Sidekiq::WebRoute
end

module Sidekiq::WebRouter
  def delete(path, &block); end

  def get(path, &block); end

  def head(path, &block); end

  def match(env); end

  def patch(path, &block); end

  def post(path, &block); end

  def put(path, &block); end

  def route(method, path, &block); end
  DELETE = ::T.let(nil, ::T.untyped)
  GET = ::T.let(nil, ::T.untyped)
  HEAD = ::T.let(nil, ::T.untyped)
  PATCH = ::T.let(nil, ::T.untyped)
  PATH_INFO = ::T.let(nil, ::T.untyped)
  POST = ::T.let(nil, ::T.untyped)
  PUT = ::T.let(nil, ::T.untyped)
  REQUEST_METHOD = ::T.let(nil, ::T.untyped)
  ROUTE_PARAMS = ::T.let(nil, ::T.untyped)
end

module Sidekiq::WebRouter
end

class Sidekiq::Work
  def [](key); end

  def initialize(pid, tid, hsh); end

  def job(); end

  def method_missing(*all); end

  def payload(); end

  def process_id(); end

  def queue(); end

  def raw(name); end

  def run_at(); end

  def thread_id(); end
end

class Sidekiq::Work
end

class Sidekiq::WorkSet
  include ::Enumerable
  def each(&block); end

  def find_work_by_jid(jid); end

  def size(); end
end

Sidekiq::Workers = Sidekiq::WorkSet

module SimpleCov
  VERSION = ::T.let(nil, ::T.untyped)
end

class SimpleCov::ArrayFilter
  def matches?(source_files_list); end
end

class SimpleCov::ArrayFilter
end

class SimpleCov::BlockFilter
  def matches?(source_file); end
end

class SimpleCov::BlockFilter
end

module SimpleCov::CommandGuesser
end

module SimpleCov::CommandGuesser
  def self.guess(); end

  def self.original_run_command(); end

  def self.original_run_command=(original_run_command); end
end

module SimpleCov::Configuration
  def adapters(); end

  def add_filter(filter_argument=T.unsafe(nil), &filter_proc); end

  def add_group(group_name, filter_argument=T.unsafe(nil), &filter_proc); end

  def at_exit(&block); end

  def command_name(name=T.unsafe(nil)); end

  def configure(&block); end

  def coverage_dir(dir=T.unsafe(nil)); end

  def coverage_path(); end

  def filters(); end

  def filters=(filters); end

  def formatter(formatter=T.unsafe(nil)); end

  def formatter=(formatter); end

  def formatters(); end

  def formatters=(formatters); end

  def groups(); end

  def groups=(groups); end

  def maximum_coverage_drop(coverage_drop=T.unsafe(nil)); end

  def merge_timeout(seconds=T.unsafe(nil)); end

  def minimum_coverage(coverage=T.unsafe(nil)); end

  def minimum_coverage_by_file(coverage=T.unsafe(nil)); end

  def nocov_token(nocov_token=T.unsafe(nil)); end

  def profiles(); end

  def project_name(new_name=T.unsafe(nil)); end

  def refuse_coverage_drop(); end

  def root(root=T.unsafe(nil)); end

  def skip_token(nocov_token=T.unsafe(nil)); end

  def track_files(glob); end

  def tracked_files(); end

  def use_merging(use=T.unsafe(nil)); end
end

module SimpleCov::Configuration
end

module SimpleCov::ExitCodes
  EXCEPTION = ::T.let(nil, ::T.untyped)
  MAXIMUM_COVERAGE_DROP = ::T.let(nil, ::T.untyped)
  MINIMUM_COVERAGE = ::T.let(nil, ::T.untyped)
  SUCCESS = ::T.let(nil, ::T.untyped)
end

module SimpleCov::ExitCodes
end

class SimpleCov::FileList
  def covered_lines(); end

  def covered_percent(); end

  def covered_percentages(); end

  def covered_strength(); end

  def least_covered_file(); end

  def lines_of_code(); end

  def missed_lines(); end

  def never_lines(); end

  def skipped_lines(); end
end

class SimpleCov::FileList
end

class SimpleCov::Filter
  def filter_argument(); end

  def initialize(filter_argument); end

  def matches?(_); end

  def passes?(source_file); end
end

class SimpleCov::Filter
  def self.build_filter(filter_argument); end

  def self.class_for_argument(filter_argument); end
end

module SimpleCov::Formatter
end

class SimpleCov::Formatter::HTMLFormatter
  def format(result); end

  def output_message(result); end
  VERSION = ::T.let(nil, ::T.untyped)
end

class SimpleCov::Formatter::HTMLFormatter
end

class SimpleCov::Formatter::MultiFormatter
end

module SimpleCov::Formatter::MultiFormatter::InstanceMethods
  def format(result); end
end

module SimpleCov::Formatter::MultiFormatter::InstanceMethods
end

class SimpleCov::Formatter::MultiFormatter
  def self.[](*args); end

  def self.new(formatters=T.unsafe(nil)); end
end

class SimpleCov::Formatter::SimpleFormatter
  def format(result); end
end

class SimpleCov::Formatter::SimpleFormatter
end

module SimpleCov::Formatter
end

module SimpleCov::LastRun
end

module SimpleCov::LastRun
  def self.last_run_path(); end

  def self.read(); end

  def self.write(json); end
end

class SimpleCov::LinesClassifier
  def classify(lines); end
  COMMENT_LINE = ::T.let(nil, ::T.untyped)
  NOT_RELEVANT = ::T.let(nil, ::T.untyped)
  RELEVANT = ::T.let(nil, ::T.untyped)
  WHITESPACE_LINE = ::T.let(nil, ::T.untyped)
  WHITESPACE_OR_COMMENT_LINE = ::T.let(nil, ::T.untyped)
end

class SimpleCov::LinesClassifier
  def self.no_cov_line(); end

  def self.no_cov_line?(line); end

  def self.whitespace_line?(line); end
end

class SimpleCov::Profiles
  def define(name, &blk); end

  def load(name); end
end

class SimpleCov::Profiles
end

class SimpleCov::Railtie
end

class SimpleCov::Railtie
end

module SimpleCov::RawCoverage
end

module SimpleCov::RawCoverage
  def self.merge_file_coverage(file1, file2); end

  def self.merge_line_coverage(count1, count2); end

  def self.merge_results(*results); end

  def self.merge_resultsets(result1, result2); end
end

class SimpleCov::RegexFilter
  def matches?(source_file); end
end

class SimpleCov::RegexFilter
end

class SimpleCov::Result
  def command_name(); end

  def command_name=(command_name); end

  def covered_lines(*args, **arg, &block); end

  def covered_percent(*args, **arg, &block); end

  def covered_percentages(*args, **arg, &block); end

  def covered_strength(*args, **arg, &block); end

  def created_at(); end

  def created_at=(created_at); end

  def filenames(); end

  def files(); end

  def format!(); end

  def groups(); end

  def initialize(original_result); end

  def least_covered_file(*args, **arg, &block); end

  def missed_lines(*args, **arg, &block); end

  def original_result(); end

  def source_files(); end

  def to_hash(); end

  def total_lines(*args, **arg, &block); end
end

class SimpleCov::Result
  extend ::Forwardable
  def self.from_hash(hash); end
end

module SimpleCov::ResultMerger
end

module SimpleCov::ResultMerger
  def self.clear_resultset(); end

  def self.merge_results(*results); end

  def self.merged_result(); end

  def self.results(); end

  def self.resultset(); end

  def self.resultset_path(); end

  def self.resultset_writelock(); end

  def self.store_result(result); end

  def self.stored_data(); end

  def self.synchronize_resultset(); end
end

class SimpleCov::SourceFile
  def build_lines(); end

  def coverage(); end

  def coverage_exceeding_source_warn(); end

  def covered_lines(); end

  def covered_percent(); end

  def covered_strength(); end

  def filename(); end

  def initialize(filename, coverage); end

  def line(number); end

  def lines(); end

  def lines_of_code(); end

  def lines_strength(); end

  def missed_lines(); end

  def never_lines(); end

  def no_lines?(); end

  def process_skipped_lines(lines); end

  def project_filename(); end

  def relevant_lines(); end

  def skipped_lines(); end

  def source(); end

  def source_lines(); end

  def src(); end
end

class SimpleCov::SourceFile::Line
  def coverage(); end

  def covered?(); end

  def initialize(src, line_number, coverage); end

  def line(); end

  def line_number(); end

  def missed?(); end

  def never?(); end

  def number(); end

  def skipped(); end

  def skipped!(); end

  def skipped?(); end

  def source(); end

  def src(); end

  def status(); end
end

class SimpleCov::SourceFile::Line
end

class SimpleCov::SourceFile
end

class SimpleCov::StringFilter
  def matches?(source_file); end
end

class SimpleCov::StringFilter
end

module SimpleCov
  extend ::SimpleCov::Configuration
  def self.add_not_loaded_files(result); end

  def self.clear_result(); end

  def self.exit_exception(); end

  def self.exit_status_from_exception(); end

  def self.filtered(files); end

  def self.grouped(files); end

  def self.load_adapter(name); end

  def self.load_profile(name); end

  def self.pid(); end

  def self.pid=(pid); end

  def self.process_result(result, exit_status); end

  def self.result(); end

  def self.result?(); end

  def self.result_exit_status(result, covered_percent); end

  def self.run_exit_tasks!(); end

  def self.running(); end

  def self.running=(running); end

  def self.set_exit_exception(); end

  def self.start(profile=T.unsafe(nil), &block); end

  def self.usable?(); end

  def self.write_last_run(covered_percent); end
end

class SimpleDelegator
  RUBYGEMS_ACTIVATION_MONITOR = ::T.let(nil, ::T.untyped)
end

module Singleton
  def _dump(depth=T.unsafe(nil)); end

  def clone(); end

  def dup(); end
  VERSION = ::T.let(nil, ::T.untyped)
end

module Singleton::SingletonClassMethods
  def _load(str); end

  def clone(); end
end

module Singleton
  def self.__init__(klass); end
end

class Socket
  AF_ALG = ::T.let(nil, ::T.untyped)
  AF_BLUETOOTH = ::T.let(nil, ::T.untyped)
  AF_CAN = ::T.let(nil, ::T.untyped)
  AF_DECnet = ::T.let(nil, ::T.untyped)
  AF_IB = ::T.let(nil, ::T.untyped)
  AF_KCM = ::T.let(nil, ::T.untyped)
  AF_KEY = ::T.let(nil, ::T.untyped)
  AF_LLC = ::T.let(nil, ::T.untyped)
  AF_MPLS = ::T.let(nil, ::T.untyped)
  AF_NETLINK = ::T.let(nil, ::T.untyped)
  AF_PPPOX = ::T.let(nil, ::T.untyped)
  AF_RDS = ::T.let(nil, ::T.untyped)
  AF_TIPC = ::T.let(nil, ::T.untyped)
  AF_VSOCK = ::T.let(nil, ::T.untyped)
  AF_XDP = ::T.let(nil, ::T.untyped)
  IPV6_DONTFRAG = ::T.let(nil, ::T.untyped)
  IPV6_PATHMTU = ::T.let(nil, ::T.untyped)
  IPV6_RECVPATHMTU = ::T.let(nil, ::T.untyped)
  PF_ALG = ::T.let(nil, ::T.untyped)
  PF_BLUETOOTH = ::T.let(nil, ::T.untyped)
  PF_CAN = ::T.let(nil, ::T.untyped)
  PF_DECnet = ::T.let(nil, ::T.untyped)
  PF_IB = ::T.let(nil, ::T.untyped)
  PF_KCM = ::T.let(nil, ::T.untyped)
  PF_LLC = ::T.let(nil, ::T.untyped)
  PF_MPLS = ::T.let(nil, ::T.untyped)
  PF_NETLINK = ::T.let(nil, ::T.untyped)
  PF_PPPOX = ::T.let(nil, ::T.untyped)
  PF_RDS = ::T.let(nil, ::T.untyped)
  PF_TIPC = ::T.let(nil, ::T.untyped)
  PF_VSOCK = ::T.let(nil, ::T.untyped)
  PF_XDP = ::T.let(nil, ::T.untyped)
  SOCK_CLOEXEC = ::T.let(nil, ::T.untyped)
  SOCK_NONBLOCK = ::T.let(nil, ::T.untyped)
  SO_BPF_EXTENSIONS = ::T.let(nil, ::T.untyped)
  SO_INCOMING_CPU = ::T.let(nil, ::T.untyped)
  SO_INCOMING_NAPI_ID = ::T.let(nil, ::T.untyped)
end

module Socket::Constants
  AF_ALG = ::T.let(nil, ::T.untyped)
  AF_BLUETOOTH = ::T.let(nil, ::T.untyped)
  AF_CAN = ::T.let(nil, ::T.untyped)
  AF_DECnet = ::T.let(nil, ::T.untyped)
  AF_IB = ::T.let(nil, ::T.untyped)
  AF_KCM = ::T.let(nil, ::T.untyped)
  AF_KEY = ::T.let(nil, ::T.untyped)
  AF_LLC = ::T.let(nil, ::T.untyped)
  AF_MPLS = ::T.let(nil, ::T.untyped)
  AF_NETLINK = ::T.let(nil, ::T.untyped)
  AF_PPPOX = ::T.let(nil, ::T.untyped)
  AF_RDS = ::T.let(nil, ::T.untyped)
  AF_TIPC = ::T.let(nil, ::T.untyped)
  AF_VSOCK = ::T.let(nil, ::T.untyped)
  AF_XDP = ::T.let(nil, ::T.untyped)
  IPV6_DONTFRAG = ::T.let(nil, ::T.untyped)
  IPV6_PATHMTU = ::T.let(nil, ::T.untyped)
  IPV6_RECVPATHMTU = ::T.let(nil, ::T.untyped)
  PF_ALG = ::T.let(nil, ::T.untyped)
  PF_BLUETOOTH = ::T.let(nil, ::T.untyped)
  PF_CAN = ::T.let(nil, ::T.untyped)
  PF_DECnet = ::T.let(nil, ::T.untyped)
  PF_IB = ::T.let(nil, ::T.untyped)
  PF_KCM = ::T.let(nil, ::T.untyped)
  PF_LLC = ::T.let(nil, ::T.untyped)
  PF_MPLS = ::T.let(nil, ::T.untyped)
  PF_NETLINK = ::T.let(nil, ::T.untyped)
  PF_PPPOX = ::T.let(nil, ::T.untyped)
  PF_RDS = ::T.let(nil, ::T.untyped)
  PF_TIPC = ::T.let(nil, ::T.untyped)
  PF_VSOCK = ::T.let(nil, ::T.untyped)
  PF_XDP = ::T.let(nil, ::T.untyped)
  SOCK_CLOEXEC = ::T.let(nil, ::T.untyped)
  SOCK_NONBLOCK = ::T.let(nil, ::T.untyped)
  SO_BPF_EXTENSIONS = ::T.let(nil, ::T.untyped)
  SO_INCOMING_CPU = ::T.let(nil, ::T.untyped)
  SO_INCOMING_NAPI_ID = ::T.let(nil, ::T.untyped)
end

class Socket::ResolutionError
  def error_code(); end
end

class Socket::ResolutionError
end

class Sprockets::Context::ENVProxy
  RUBYGEMS_ACTIVATION_MONITOR = ::T.let(nil, ::T.untyped)
end

class SquasherClean::SchemaMigration
  include ::SquasherClean::SchemaMigration::GeneratedAttributeMethods
  include ::SquasherClean::SchemaMigration::GeneratedAssociationMethods
end

module SquasherClean::SchemaMigration::GeneratedAssociationMethods
end

module SquasherClean::SchemaMigration::GeneratedAssociationMethods
end

module SquasherClean::SchemaMigration::GeneratedAttributeMethods
end

module SquasherClean::SchemaMigration::GeneratedAttributeMethods
end

class SshServerDecorator
  def ssh_server(); end
end

class StacLog
  def autosave_associated_records_for_reservation(*args); end
end

class StacLogsController
  include ::ActionView::Layouts::ClassMethods::LayoutConditions
end

class StacLogsDownloaderWorker
  def sidekiq_options_hash(); end

  def sidekiq_options_hash=(sidekiq_options_hash); end

  def sidekiq_retries_exhausted_block(); end

  def sidekiq_retries_exhausted_block=(sidekiq_retries_exhausted_block); end

  def sidekiq_retry_in_block(); end

  def sidekiq_retry_in_block=(sidekiq_retry_in_block); end
end

class StacLogsDownloaderWorker
  def self.sidekiq_options_hash(); end

  def self.sidekiq_options_hash=(val); end

  def self.sidekiq_retries_exhausted_block(); end

  def self.sidekiq_retries_exhausted_block=(val); end

  def self.sidekiq_retry_in_block(); end

  def self.sidekiq_retry_in_block=(val); end
end

class String
  def dedup(); end
end

class String
  def self.new(*arg); end
end

class StringIO
  def pread(*arg); end

  def set_encoding_by_bom(); end
  VERSION = ::T.let(nil, ::T.untyped)
end

class StringIO
  def self.new(*arg); end
end

class StringScanner
  def bol?(); end

  def fixed_anchor?(); end

  def initialize(*arg); end

  def named_captures(); end
  Id = ::T.let(nil, ::T.untyped)
  Version = ::T.let(nil, ::T.untyped)
end

class Struct
  def deconstruct(); end

  def deconstruct_keys(arg); end

  def filter(*arg); end
end

class Struct::AwsEmptyStructure
end

class Struct::AwsEmptyStructure
  def self.[](*arg); end

  def self.keyword_init?(); end

  def self.members(); end
end

class Struct::HTMLElementDescription
  def attrs_depr(); end

  def attrs_depr=(_); end

  def attrs_opt(); end

  def attrs_opt=(_); end

  def attrs_req(); end

  def attrs_req=(_); end

  def defaultsubelt(); end

  def defaultsubelt=(_); end

  def depr(); end

  def depr=(_); end

  def desc(); end

  def desc=(_); end

  def dtd(); end

  def dtd=(_); end

  def empty(); end

  def empty=(_); end

  def endTag(); end

  def endTag=(_); end

  def isinline(); end

  def isinline=(_); end

  def name(); end

  def name=(_); end

  def saveEndTag(); end

  def saveEndTag=(_); end

  def startTag(); end

  def startTag=(_); end

  def subelts(); end

  def subelts=(_); end
end

class Struct::HTMLElementDescription
  def self.[](*arg); end

  def self.keyword_init?(); end

  def self.members(); end
end

class Struct::UnameStruct
  def domainname(); end

  def domainname=(_); end

  def machine(); end

  def machine=(_); end

  def nodename(); end

  def nodename=(_); end

  def release(); end

  def release=(_); end

  def sysname(); end

  def sysname=(_); end

  def version(); end

  def version=(_); end
end

class Struct::UnameStruct
  def self.[](*arg); end

  def self.keyword_init?(); end

  def self.members(); end
end

class Struct
  def self.new(*arg); end
end

class Symbol
  def to_msgpack_ext(); end
end

class SyntaxError
  def path(); end
end

module SyntaxSuggest
end

class SyntaxSuggest::MiniStringIO
  def initialize(isatty: T.unsafe(nil)); end

  def isatty(); end

  def puts(value=T.unsafe(nil), **arg); end

  def string(); end
end

class SyntaxSuggest::MiniStringIO
end

module SyntaxSuggest
  def self.module_for_detailed_message(); end
end

module TSort
  VERSION = ::T.let(nil, ::T.untyped)
end

class Tempfile
  def _close(); end

  def finalizer_obj(); end

  def mode(); end

  def opts(); end

  def unlinked(); end
  RUBYGEMS_ACTIVATION_MONITOR = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

class Tempfile::Closer
  def call(*args); end

  def initialize(tmpfile); end
end

class Tempfile::Closer
end

class Tempfile::Remover
  def call(*args); end

  def initialize(path); end
end

class Tempfile::Remover
end

class Thread::Backtrace
  def self.limit(); end
end

class Thread
  def self.ignore_deadlock(); end

  def self.ignore_deadlock=(ignore_deadlock); end

  def self.new(*arg); end
end

class Time
  def compare_without_coercion(arg); end

  def deconstruct_keys(arg); end

  def eql_without_coercion(arg); end

  def minus_without_duration(arg); end

  def plus_without_duration(arg); end
end

class Time
  def self.at_without_coercion(time, subsec=T.unsafe(nil), unit=T.unsafe(nil), in: T.unsafe(nil)); end

  def self.now_without_delorean(in: T.unsafe(nil)); end
end

class TracePoint
  def eval_script(); end

  def instruction_sequence(); end

  def parameters(); end
end

class TracePoint
  def self.allow_reentry(); end

  def self.new(*events); end
end

class TragicServerDecorator
  def tragic_server(); end
end

class TypeError
  include ::ErrorHighlight::CoreExt
end

module URI
  include ::URI::RFC2396_REGEXP
  TBLENCURICOMP_ = ::T.let(nil, ::T.untyped)
end

class URI::FTP
  def buffer_open(buf, proxy, options); end
end

class URI::FTP
  def self.new2(user, password, host, port, path, typecode=T.unsafe(nil), arg_check=T.unsafe(nil)); end
end

class URI::File
  def check_password(user); end

  def check_user(user); end

  def check_userinfo(user); end

  def set_userinfo(v); end
  COMPONENT = ::T.let(nil, ::T.untyped)
  DEFAULT_PORT = ::T.let(nil, ::T.untyped)
end

class URI::Generic
  def decoded_password(); end

  def decoded_user(); end
end

class URI::HTTP
  def authority(); end

  def buffer_open(buf, proxy, options); end

  def origin(); end
end

class URI::LDAP
  def attributes(); end

  def attributes=(val); end

  def dn(); end

  def dn=(val); end

  def extensions(); end

  def extensions=(val); end

  def filter(); end

  def filter=(val); end

  def initialize(*arg); end

  def scope(); end

  def scope=(val); end

  def set_attributes(val); end

  def set_dn(val); end

  def set_extensions(val); end

  def set_filter(val); end

  def set_scope(val); end
end

class URI::MailTo
  def initialize(*arg); end
end

class URI::RFC2396_Parser
  def initialize(opts=T.unsafe(nil)); end
end

class URI::RFC3986_Parser
  def join(*uris); end

  def parse(uri); end

  def regexp(); end

  def split(uri); end
  FRAGMENT = ::T.let(nil, ::T.untyped)
  HOST = ::T.let(nil, ::T.untyped)
  RFC3986_relative_ref = ::T.let(nil, ::T.untyped)
  SCHEME = ::T.let(nil, ::T.untyped)
  SEG = ::T.let(nil, ::T.untyped)
  SEG_NC = ::T.let(nil, ::T.untyped)
  USERINFO = ::T.let(nil, ::T.untyped)
end

module URI::Util
  def self.make_components_hash(klass, array_hash); end
end

class URI::WSS
  DEFAULT_PORT = ::T.let(nil, ::T.untyped)
end

class URI::WSS
end

module URI
  def self.decode_uri_component(str, enc=T.unsafe(nil)); end

  def self.for(scheme, *arguments, default: T.unsafe(nil)); end

  def self.get_encoding(label); end

  def self.open(name, *rest, **arg, &block); end

  def self.register_scheme(scheme, klass); end
end

module UnicodeNormalize
end

module UnicodeNormalize
end

class UpdateServerPageWorker
  def sidekiq_options_hash(); end

  def sidekiq_options_hash=(sidekiq_options_hash); end

  def sidekiq_retries_exhausted_block(); end

  def sidekiq_retries_exhausted_block=(sidekiq_retries_exhausted_block); end

  def sidekiq_retry_in_block(); end

  def sidekiq_retry_in_block=(sidekiq_retry_in_block); end
end

class UpdateServerPageWorker
  def self.__synchronized_sidekiq_options_hash(); end

  def self.sidekiq_options_hash(); end

  def self.sidekiq_options_hash=(val); end

  def self.sidekiq_retries_exhausted_block(); end

  def self.sidekiq_retries_exhausted_block=(val); end

  def self.sidekiq_retry_in_block(); end

  def self.sidekiq_retry_in_block=(val); end
end

class UpdateSteamNicknameWorker
  def sidekiq_options_hash(); end

  def sidekiq_options_hash=(sidekiq_options_hash); end

  def sidekiq_retries_exhausted_block(); end

  def sidekiq_retries_exhausted_block=(sidekiq_retries_exhausted_block); end

  def sidekiq_retry_in_block(); end

  def sidekiq_retry_in_block=(sidekiq_retry_in_block); end
end

class UpdateSteamNicknameWorker
  def self.__synchronized_sidekiq_options_hash(); end

  def self.sidekiq_options_hash(); end

  def self.sidekiq_options_hash=(val); end

  def self.sidekiq_retries_exhausted_block(); end

  def self.sidekiq_retries_exhausted_block=(val); end

  def self.sidekiq_retry_in_block(); end

  def self.sidekiq_retry_in_block=(val); end
end

class UploadFilesToServerWorker
  def sidekiq_options_hash(); end

  def sidekiq_options_hash=(sidekiq_options_hash); end

  def sidekiq_retries_exhausted_block(); end

  def sidekiq_retries_exhausted_block=(sidekiq_retries_exhausted_block); end

  def sidekiq_retry_in_block(); end

  def sidekiq_retry_in_block=(sidekiq_retry_in_block); end
end

class UploadFilesToServerWorker
  def self.sidekiq_options_hash(); end

  def self.sidekiq_options_hash=(val); end

  def self.sidekiq_retries_exhausted_block(); end

  def self.sidekiq_retries_exhausted_block=(val); end

  def self.sidekiq_retry_in_block(); end

  def self.sidekiq_retry_in_block=(val); end
end

class UploadFilesToServersWorker
  def sidekiq_options_hash(); end

  def sidekiq_options_hash=(sidekiq_options_hash); end

  def sidekiq_retries_exhausted_block(); end

  def sidekiq_retries_exhausted_block=(sidekiq_retries_exhausted_block); end

  def sidekiq_retry_in_block(); end

  def sidekiq_retry_in_block=(sidekiq_retry_in_block); end
end

class UploadFilesToServersWorker
  def self.sidekiq_options_hash(); end

  def self.sidekiq_options_hash=(val); end

  def self.sidekiq_retries_exhausted_block(); end

  def self.sidekiq_retries_exhausted_block=(val); end

  def self.sidekiq_retry_in_block(); end

  def self.sidekiq_retry_in_block=(val); end
end

class User
  include ::Devise::Orm
  include ::Devise::Orm::DirtyTrackingNewMethods
  include ::Devise::Models::Authenticatable
  include ::ActiveSupport::Deprecation::DeprecatedConstantAccessor
  include ::Devise::Models::Rememberable
  include ::Devise::Models::Omniauthable
  include ::Devise::Models::Trackable
  include ::Geocoder::Store::ActiveRecord
  include ::Geocoder::Store::Base
  def autosave_associated_records_for_group_users(*args); end

  def autosave_associated_records_for_groups(*args); end

  def autosave_associated_records_for_log_uploads(*args); end

  def autosave_associated_records_for_orders(*args); end

  def autosave_associated_records_for_paypal_orders(*args); end

  def autosave_associated_records_for_player_statistics(*args); end

  def autosave_associated_records_for_reservation_players(*args); end

  def autosave_associated_records_for_reservations(*args); end

  def autosave_associated_records_for_servers(*args); end

  def autosave_associated_records_for_stripe_orders(*args); end

  def autosave_associated_records_for_vouchers(*args); end

  def devise_modules(); end

  def devise_modules?(); end

  def validate_associated_records_for_group_users(*args); end

  def validate_associated_records_for_groups(*args); end

  def validate_associated_records_for_log_uploads(*args); end

  def validate_associated_records_for_orders(*args); end

  def validate_associated_records_for_paypal_orders(*args); end

  def validate_associated_records_for_player_statistics(*args); end

  def validate_associated_records_for_reservation_players(*args); end

  def validate_associated_records_for_reservations(*args); end

  def validate_associated_records_for_servers(*args); end

  def validate_associated_records_for_stripe_orders(*args); end

  def validate_associated_records_for_vouchers(*args); end
end

class User
  extend ::Devise::Models::Authenticatable::ClassMethods
  extend ::Devise::Models::Rememberable::ClassMethods
  extend ::Devise::Models::Omniauthable::ClassMethods
  extend ::Geocoder::Store::ActiveRecord::ClassMethods
  extend ::T::Private::Methods::MethodHooks
  extend ::T::Private::Methods::SingletonMethodHooks
  def self.devise_modules(); end

  def self.devise_modules=(value); end

  def self.devise_modules?(); end

  def self.geocoded(*args, **arg); end

  def self.near(*args, **arg); end

  def self.not_geocoded(*args, **arg); end

  def self.not_reverse_geocoded(*args, **arg); end

  def self.within_bounding_box(*args, **arg); end
end

class UserDecorator
  include ::Draper::AutomaticDelegation
  def user(); end
end

class UserDecorator
  extend ::Draper::AutomaticDelegation::ClassMethods
end

class VCR::HTTPInteraction::HookAware
  RUBYGEMS_ACTIVATION_MONITOR = ::T.let(nil, ::T.untyped)
end

module VCR::LibraryHooks::Faraday
end

module VCR::LibraryHooks::Faraday::BuilderClassExtension
  def new(*args); end
end

module VCR::LibraryHooks::Faraday::BuilderClassExtension
end

module VCR::LibraryHooks::Faraday::BuilderInstanceExtension
  def lock!(*args); end
end

module VCR::LibraryHooks::Faraday::BuilderInstanceExtension
end

module VCR::LibraryHooks::Faraday
end

module VCR::LibraryHooks::WebMock
  def global_hook_disabled?(request); end

  def global_hook_disabled_requests(); end

  def with_global_hook_disabled(request); end
end

module VCR::LibraryHooks::WebMock::Helpers
  def request_headers_for(webmock_request); end

  def typed_request_for(webmock_request, remove=T.unsafe(nil)); end

  def vcr_request_for(webmock_request); end

  def vcr_response_for(webmock_response); end
end

module VCR::LibraryHooks::WebMock::Helpers
end

class VCR::LibraryHooks::WebMock::RequestHandler
  include ::VCR::LibraryHooks::WebMock::Helpers
  def initialize(request); end

  def request(); end
end

class VCR::LibraryHooks::WebMock::RequestHandler
end

module VCR::LibraryHooks::WebMock
  extend ::VCR::LibraryHooks::WebMock
  extend ::VCR::LibraryHooks::WebMock::Helpers
end

class VCR::LinkedCassette
  RUBYGEMS_ACTIVATION_MONITOR = ::T.let(nil, ::T.untyped)
end

class VCR::Request::FiberAware
  RUBYGEMS_ACTIVATION_MONITOR = ::T.let(nil, ::T.untyped)
end

class VCR::Request::Typed
  RUBYGEMS_ACTIVATION_MONITOR = ::T.let(nil, ::T.untyped)
end

class Voucher
  def autosave_associated_records_for_claimed_by(*args); end

  def autosave_associated_records_for_created_by(*args); end

  def autosave_associated_records_for_order(*args); end

  def autosave_associated_records_for_product(*args); end
end

class Warden::SessionSerializer
  def user_deserialize(args); end

  def user_serialize(record); end
end

module Warden
  extend ::Warden::Test::WardenHelpers
end

module Warning
  extend ::Warning
end

class WeakRef
  def initialize(orig); end
  RUBYGEMS_ACTIVATION_MONITOR = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

module WebMock
  def self.net_connect_allowed_with_vcr?(*args); end

  def self.net_connect_allowed_without_vcr?(uri=T.unsafe(nil)); end
end

class Whitelist
  def autosave_associated_records_for_reservations(*args); end

  def validate_associated_records_for_reservations(*args); end
end

class WhitelistTf
  include ::WhitelistTf::GeneratedAssociationMethods
end

module WhitelistTf::GeneratedAssociationMethods
end

module WhitelistTf::GeneratedAssociationMethods
end

module WillPaginate::ActiveRecord
end

module WillPaginate::ActiveRecord::BaseMethods
  def paginate_by_sql(sql, options); end
end

module WillPaginate::ActiveRecord::BaseMethods
end

module WillPaginate::ActiveRecord::Pagination
  def page(num); end

  def paginate(options); end
end

module WillPaginate::ActiveRecord::Pagination
end

module WillPaginate::ActiveRecord::RelationMethods
  include ::WillPaginate::CollectionMethods
  def clone(); end

  def count(*args); end

  def current_page(); end

  def current_page=(current_page); end

  def empty?(); end

  def find_last(*args); end

  def first(*args); end

  def limit(num); end

  def offset(value=T.unsafe(nil)); end

  def per_page(value=T.unsafe(nil)); end

  def scoped(options=T.unsafe(nil)); end

  def size(); end

  def to_a(); end

  def total_entries(); end

  def total_entries=(total_entries); end
end

module WillPaginate::ActiveRecord::RelationMethods
end

module WillPaginate::ActiveRecord
end

class XmlSimple
  include ::REXML
  def initialize(defaults=T.unsafe(nil)); end

  def xml_in(string=T.unsafe(nil), options=T.unsafe(nil)); end

  def xml_out(ref, options=T.unsafe(nil)); end
  DEF_ANONYMOUS_TAG = ::T.let(nil, ::T.untyped)
  DEF_ATTR_TO_SYMBOL = ::T.let(nil, ::T.untyped)
  DEF_CONTENT_KEY = ::T.let(nil, ::T.untyped)
  DEF_FORCE_ARRAY = ::T.let(nil, ::T.untyped)
  DEF_INDENTATION = ::T.let(nil, ::T.untyped)
  DEF_KEBAB_TO_SNAKE = ::T.let(nil, ::T.untyped)
  DEF_KEY_ATTRIBUTES = ::T.let(nil, ::T.untyped)
  DEF_KEY_TO_SYMBOL = ::T.let(nil, ::T.untyped)
  DEF_ROOT_NAME = ::T.let(nil, ::T.untyped)
  DEF_XML_DECLARATION = ::T.let(nil, ::T.untyped)
  KNOWN_OPTIONS = ::T.let(nil, ::T.untyped)
end

class XmlSimple::Cache
  def restore_mem_copy(filename); end

  def restore_mem_share(filename); end

  def restore_storable(filename); end

  def save_mem_copy(data, filename); end

  def save_mem_share(data, filename); end

  def save_storable(data, filename); end
end

class XmlSimple::Cache
end

class XmlSimple
  def self.xml_in(string=T.unsafe(nil), options=T.unsafe(nil)); end

  def self.xml_out(hash, options=T.unsafe(nil)); end
end

class Zip::File
  include ::Zip::FileSystem
end

module Zip::FileSystem
  def dir(); end

  def file(); end

  def initialize(); end
end

class Zip::FileSystem::ZipFileNameMapper
  include ::Enumerable
  def each(&blk); end

  def expand_path(path); end

  def find_entry(filename); end

  def get_entry(filename); end

  def get_input_stream(filename, &a_proc); end

  def get_output_stream(filename, permissions=T.unsafe(nil), &a_proc); end

  def glob(pattern, *flags, &block); end

  def initialize(zip_file); end

  def mkdir(filename, permissions=T.unsafe(nil)); end

  def pwd(); end

  def pwd=(pwd); end

  def read(filename); end

  def remove(filename); end

  def rename(filename, new_name, &continue_on_exists_proc); end
end

class Zip::FileSystem::ZipFileNameMapper
end

class Zip::FileSystem::ZipFsDir
  def chdir(directory_name); end

  def chroot(*_args); end

  def delete(entry_name); end

  def entries(directory_name); end

  def file=(file); end

  def foreach(directory_name); end

  def getwd(); end

  def glob(*args, &block); end

  def initialize(mapped_zip); end

  def mkdir(entry_name, permissions=T.unsafe(nil)); end

  def new(directory_name); end

  def open(directory_name); end

  def pwd(); end

  def rmdir(entry_name); end

  def unlink(entry_name); end
end

class Zip::FileSystem::ZipFsDir
end

class Zip::FileSystem::ZipFsDirIterator
  include ::Enumerable
  def close(); end

  def each(&a_proc); end

  def initialize(filenames); end

  def read(); end

  def rewind(); end

  def seek(position); end

  def tell(); end
end

class Zip::FileSystem::ZipFsDirIterator
end

class Zip::FileSystem::ZipFsFile
  def atime(filename); end

  def basename(filename); end

  def blockdev?(_filename); end

  def chardev?(_filename); end

  def chmod(mode, *filenames); end

  def chown(owner, group, *filenames); end

  def ctime(filename); end

  def delete(*args); end

  def dir=(dir); end

  def directory?(filename); end

  def dirname(filename); end

  def executable?(filename); end

  def executable_real?(filename); end

  def exist?(filename); end

  def exists?(filename); end

  def expand_path(path); end

  def file?(filename); end

  def foreach(filename, sep=T.unsafe(nil), &a_proc); end

  def ftype(filename); end

  def grpowned?(filename); end

  def initialize(mapped_zip); end

  def join(*fragments); end

  def link(_filename, _symlink_name); end

  def lstat(filename); end

  def mtime(filename); end

  def new(filename, mode=T.unsafe(nil)); end

  def open(filename, mode=T.unsafe(nil), permissions=T.unsafe(nil), &block); end

  def owned?(filename); end

  def pipe(); end

  def pipe?(_filename); end

  def popen(*args, &a_proc); end

  def read(filename); end

  def readable?(filename); end

  def readable_real?(filename); end

  def readlines(filename); end

  def readlink(_filename); end

  def rename(file_to_rename, new_name); end

  def setgid?(filename); end

  def setuid?(filename); end

  def size(filename); end

  def size?(filename); end

  def socket?(_filename); end

  def split(filename); end

  def stat(filename); end

  def sticky?(filename); end

  def symlink(_filename, _symlink_name); end

  def symlink?(_filename); end

  def truncate(_filename, _len); end

  def umask(*args); end

  def unlink(*args); end

  def utime(modified_time, *filenames); end

  def writable?(filename); end

  def writable_real?(filename); end

  def zero?(filename); end
end

class Zip::FileSystem::ZipFsFile::ZipFsStat
  def atime(); end

  def blksize(); end

  def blockdev?(); end

  def blocks(); end

  def chardev?(); end

  def ctime(); end

  def dev(); end

  def directory?(); end

  def executable?(); end

  def executable_real?(); end

  def file?(); end

  def ftype(); end

  def gid(); end

  def grpowned?(); end

  def initialize(zip_fs_file, entry_name); end

  def ino(); end

  def kind_of?(type); end

  def mode(); end

  def mtime(); end

  def nlink(); end

  def owned?(); end

  def pipe?(); end

  def rdev(); end

  def rdev_major(); end

  def rdev_minor(); end

  def readable?(); end

  def readable_real?(); end

  def setgid?(); end

  def setuid?(); end

  def size(); end

  def size?(); end

  def socket?(); end

  def sticky?(); end

  def symlink?(); end

  def uid(); end

  def writable?(); end

  def writable_real?(); end

  def zero?(); end
end

class Zip::FileSystem::ZipFsFile::ZipFsStat
  def self.delegate_to_fs_file(*methods); end
end

class Zip::FileSystem::ZipFsFile
end

module Zip::FileSystem
end

class Zip::StreamableStream
  RUBYGEMS_ACTIVATION_MONITOR = ::T.let(nil, ::T.untyped)
end

class Zlib::Deflate
  def initialize(*arg); end
end

class Zlib::GzipReader
  def initialize(*arg); end
end

class Zlib::GzipReader
  def self.zcat(*arg); end
end

class Zlib::GzipWriter
  def initialize(*arg); end
end

class Zlib::InProgressError
end

class Zlib::InProgressError
end

class Zlib::Inflate
  def initialize(*arg); end
end
